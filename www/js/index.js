(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/assert/assert.js","/../node_modules/assert")
},{"buffer":11,"pBGvAp":74,"util/":133}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// base-x encoding
// Forked from https://github.com/cryptocoinjs/bs58
// Originally written by Mike Hearn for BitcoinJ
// Copyright (c) 2011 Google Inc
// Ported to JavaScript by Stefan Thomas
// Merged Buffer refactorings from base58-native by Stephen Pair
// Copyright (c) 2013 BitPay Inc

module.exports = function base (ALPHABET) {
  var ALPHABET_MAP = {}
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)

  // pre-compute lookup table
  for (var i = 0; i < ALPHABET.length; i++) {
    ALPHABET_MAP[ALPHABET.charAt(i)] = i
  }

  function encode (source) {
    if (source.length === 0) return ''

    var digits = [0]
    for (var i = 0; i < source.length; ++i) {
      for (var j = 0, carry = source[i]; j < digits.length; ++j) {
        carry += digits[j] << 8
        digits[j] = carry % BASE
        carry = (carry / BASE) | 0
      }

      while (carry > 0) {
        digits.push(carry % BASE)
        carry = (carry / BASE) | 0
      }
    }

    // deal with leading zeros
    for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) {
      digits.push(0)
    }

    // convert digits to a string
    for (var ii = 0, jj = digits.length - 1; ii <= jj; ++ii, --jj) {
      var tmp = ALPHABET[digits[ii]]
      digits[ii] = ALPHABET[digits[jj]]
      digits[jj] = tmp
    }

    return digits.join('')
  }

  function decode (string) {
    if (string.length === 0) return []

    var bytes = [0]
    for (var i = 0; i < string.length; i++) {
      var value = ALPHABET_MAP[string[i]]
      if (value === undefined) throw new Error('Non-base' + BASE + ' character')

      for (var j = 0, carry = value; j < bytes.length; ++j) {
        carry += bytes[j] * BASE
        bytes[j] = carry & 0xff
        carry >>= 8
      }

      while (carry > 0) {
        bytes.push(carry & 0xff)
        carry >>= 8
      }
    }

    // deal with leading zeros
    for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
      bytes.push(0)
    }

    return bytes.reverse()
  }

  return {
    encode: encode,
    decode: decode
  }
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/base-x/index.js","/../node_modules/base-x")
},{"buffer":11,"pBGvAp":74}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/base64-js/lib/b64.js","/../node_modules/base64-js/lib")
},{"buffer":11,"pBGvAp":74}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// (public) Constructor
function BigInteger(a, b, c) {
  if (!(this instanceof BigInteger))
    return new BigInteger(a, b, c)

  if (a != null) {
    if ("number" == typeof a) this.fromNumber(a, b, c)
    else if (b == null && "string" != typeof a) this.fromString(a, 256)
    else this.fromString(a, b)
  }
}

var proto = BigInteger.prototype

// duck-typed isBigInteger
proto.__bigi = require('../package.json').version
BigInteger.isBigInteger = function (obj, check_ver) {
  return obj && obj.__bigi && (!check_ver || obj.__bigi === proto.__bigi)
}

// Bits per digit
var dbits

// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.

// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i, x, w, j, c, n) {
  while (--n >= 0) {
    var v = x * this[i++] + w[j] + c
    c = Math.floor(v / 0x4000000)
    w[j++] = v & 0x3ffffff
  }
  return c
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i, x, w, j, c, n) {
  var xl = x & 0x7fff,
    xh = x >> 15
  while (--n >= 0) {
    var l = this[i] & 0x7fff
    var h = this[i++] >> 15
    var m = xh * l + h * xl
    l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff)
    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30)
    w[j++] = l & 0x3fffffff
  }
  return c
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i, x, w, j, c, n) {
  var xl = x & 0x3fff,
    xh = x >> 14
  while (--n >= 0) {
    var l = this[i] & 0x3fff
    var h = this[i++] >> 14
    var m = xh * l + h * xl
    l = xl * l + ((m & 0x3fff) << 14) + w[j] + c
    c = (l >> 28) + (m >> 14) + xh * h
    w[j++] = l & 0xfffffff
  }
  return c
}

// wtf?
BigInteger.prototype.am = am1
dbits = 26

BigInteger.prototype.DB = dbits
BigInteger.prototype.DM = ((1 << dbits) - 1)
var DV = BigInteger.prototype.DV = (1 << dbits)

var BI_FP = 52
BigInteger.prototype.FV = Math.pow(2, BI_FP)
BigInteger.prototype.F1 = BI_FP - dbits
BigInteger.prototype.F2 = 2 * dbits - BI_FP

// Digit conversions
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"
var BI_RC = new Array()
var rr, vv
rr = "0".charCodeAt(0)
for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv
rr = "a".charCodeAt(0)
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv
rr = "A".charCodeAt(0)
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv

function int2char(n) {
  return BI_RM.charAt(n)
}

function intAt(s, i) {
  var c = BI_RC[s.charCodeAt(i)]
  return (c == null) ? -1 : c
}

// (protected) copy this to r
function bnpCopyTo(r) {
  for (var i = this.t - 1; i >= 0; --i) r[i] = this[i]
  r.t = this.t
  r.s = this.s
}

// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x) {
  this.t = 1
  this.s = (x < 0) ? -1 : 0
  if (x > 0) this[0] = x
  else if (x < -1) this[0] = x + DV
  else this.t = 0
}

// return bigint initialized to value
function nbv(i) {
  var r = new BigInteger()
  r.fromInt(i)
  return r
}

// (protected) set from string and radix
function bnpFromString(s, b) {
  var self = this

  var k
  if (b == 16) k = 4
  else if (b == 8) k = 3
  else if (b == 256) k = 8; // byte array
  else if (b == 2) k = 1
  else if (b == 32) k = 5
  else if (b == 4) k = 2
  else {
    self.fromRadix(s, b)
    return
  }
  self.t = 0
  self.s = 0
  var i = s.length,
    mi = false,
    sh = 0
  while (--i >= 0) {
    var x = (k == 8) ? s[i] & 0xff : intAt(s, i)
    if (x < 0) {
      if (s.charAt(i) == "-") mi = true
      continue
    }
    mi = false
    if (sh == 0)
      self[self.t++] = x
    else if (sh + k > self.DB) {
      self[self.t - 1] |= (x & ((1 << (self.DB - sh)) - 1)) << sh
      self[self.t++] = (x >> (self.DB - sh))
    } else
      self[self.t - 1] |= x << sh
    sh += k
    if (sh >= self.DB) sh -= self.DB
  }
  if (k == 8 && (s[0] & 0x80) != 0) {
    self.s = -1
    if (sh > 0) self[self.t - 1] |= ((1 << (self.DB - sh)) - 1) << sh
  }
  self.clamp()
  if (mi) BigInteger.ZERO.subTo(self, self)
}

// (protected) clamp off excess high words
function bnpClamp() {
  var c = this.s & this.DM
  while (this.t > 0 && this[this.t - 1] == c)--this.t
}

// (public) return string representation in given radix
function bnToString(b) {
  var self = this
  if (self.s < 0) return "-" + self.negate()
    .toString(b)
  var k
  if (b == 16) k = 4
  else if (b == 8) k = 3
  else if (b == 2) k = 1
  else if (b == 32) k = 5
  else if (b == 4) k = 2
  else return self.toRadix(b)
  var km = (1 << k) - 1,
    d, m = false,
    r = "",
    i = self.t
  var p = self.DB - (i * self.DB) % k
  if (i-- > 0) {
    if (p < self.DB && (d = self[i] >> p) > 0) {
      m = true
      r = int2char(d)
    }
    while (i >= 0) {
      if (p < k) {
        d = (self[i] & ((1 << p) - 1)) << (k - p)
        d |= self[--i] >> (p += self.DB - k)
      } else {
        d = (self[i] >> (p -= k)) & km
        if (p <= 0) {
          p += self.DB
          --i
        }
      }
      if (d > 0) m = true
      if (m) r += int2char(d)
    }
  }
  return m ? r : "0"
}

// (public) -this
function bnNegate() {
  var r = new BigInteger()
  BigInteger.ZERO.subTo(this, r)
  return r
}

// (public) |this|
function bnAbs() {
  return (this.s < 0) ? this.negate() : this
}

// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a) {
  var r = this.s - a.s
  if (r != 0) return r
  var i = this.t
  r = i - a.t
  if (r != 0) return (this.s < 0) ? -r : r
  while (--i >= 0)
    if ((r = this[i] - a[i]) != 0) return r
  return 0
}

// returns bit length of the integer x
function nbits(x) {
  var r = 1,
    t
  if ((t = x >>> 16) != 0) {
    x = t
    r += 16
  }
  if ((t = x >> 8) != 0) {
    x = t
    r += 8
  }
  if ((t = x >> 4) != 0) {
    x = t
    r += 4
  }
  if ((t = x >> 2) != 0) {
    x = t
    r += 2
  }
  if ((t = x >> 1) != 0) {
    x = t
    r += 1
  }
  return r
}

// (public) return the number of bits in "this"
function bnBitLength() {
  if (this.t <= 0) return 0
  return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM))
}

// (public) return the number of bytes in "this"
function bnByteLength() {
  return this.bitLength() >> 3
}

// (protected) r = this << n*DB
function bnpDLShiftTo(n, r) {
  var i
  for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i]
  for (i = n - 1; i >= 0; --i) r[i] = 0
  r.t = this.t + n
  r.s = this.s
}

// (protected) r = this >> n*DB
function bnpDRShiftTo(n, r) {
  for (var i = n; i < this.t; ++i) r[i - n] = this[i]
  r.t = Math.max(this.t - n, 0)
  r.s = this.s
}

// (protected) r = this << n
function bnpLShiftTo(n, r) {
  var self = this
  var bs = n % self.DB
  var cbs = self.DB - bs
  var bm = (1 << cbs) - 1
  var ds = Math.floor(n / self.DB),
    c = (self.s << bs) & self.DM,
    i
  for (i = self.t - 1; i >= 0; --i) {
    r[i + ds + 1] = (self[i] >> cbs) | c
    c = (self[i] & bm) << bs
  }
  for (i = ds - 1; i >= 0; --i) r[i] = 0
  r[ds] = c
  r.t = self.t + ds + 1
  r.s = self.s
  r.clamp()
}

// (protected) r = this >> n
function bnpRShiftTo(n, r) {
  var self = this
  r.s = self.s
  var ds = Math.floor(n / self.DB)
  if (ds >= self.t) {
    r.t = 0
    return
  }
  var bs = n % self.DB
  var cbs = self.DB - bs
  var bm = (1 << bs) - 1
  r[0] = self[ds] >> bs
  for (var i = ds + 1; i < self.t; ++i) {
    r[i - ds - 1] |= (self[i] & bm) << cbs
    r[i - ds] = self[i] >> bs
  }
  if (bs > 0) r[self.t - ds - 1] |= (self.s & bm) << cbs
  r.t = self.t - ds
  r.clamp()
}

// (protected) r = this - a
function bnpSubTo(a, r) {
  var self = this
  var i = 0,
    c = 0,
    m = Math.min(a.t, self.t)
  while (i < m) {
    c += self[i] - a[i]
    r[i++] = c & self.DM
    c >>= self.DB
  }
  if (a.t < self.t) {
    c -= a.s
    while (i < self.t) {
      c += self[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c += self.s
  } else {
    c += self.s
    while (i < a.t) {
      c -= a[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c -= a.s
  }
  r.s = (c < 0) ? -1 : 0
  if (c < -1) r[i++] = self.DV + c
  else if (c > 0) r[i++] = c
  r.t = i
  r.clamp()
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a, r) {
  var x = this.abs(),
    y = a.abs()
  var i = x.t
  r.t = i + y.t
  while (--i >= 0) r[i] = 0
  for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t)
  r.s = 0
  r.clamp()
  if (this.s != a.s) BigInteger.ZERO.subTo(r, r)
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
  var x = this.abs()
  var i = r.t = 2 * x.t
  while (--i >= 0) r[i] = 0
  for (i = 0; i < x.t - 1; ++i) {
    var c = x.am(i, x[i], r, 2 * i, 0, 1)
    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
      r[i + x.t] -= x.DV
      r[i + x.t + 1] = 1
    }
  }
  if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1)
  r.s = 0
  r.clamp()
}

// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m, q, r) {
  var self = this
  var pm = m.abs()
  if (pm.t <= 0) return
  var pt = self.abs()
  if (pt.t < pm.t) {
    if (q != null) q.fromInt(0)
    if (r != null) self.copyTo(r)
    return
  }
  if (r == null) r = new BigInteger()
  var y = new BigInteger(),
    ts = self.s,
    ms = m.s
  var nsh = self.DB - nbits(pm[pm.t - 1]); // normalize modulus
  if (nsh > 0) {
    pm.lShiftTo(nsh, y)
    pt.lShiftTo(nsh, r)
  } else {
    pm.copyTo(y)
    pt.copyTo(r)
  }
  var ys = y.t
  var y0 = y[ys - 1]
  if (y0 == 0) return
  var yt = y0 * (1 << self.F1) + ((ys > 1) ? y[ys - 2] >> self.F2 : 0)
  var d1 = self.FV / yt,
    d2 = (1 << self.F1) / yt,
    e = 1 << self.F2
  var i = r.t,
    j = i - ys,
    t = (q == null) ? new BigInteger() : q
  y.dlShiftTo(j, t)
  if (r.compareTo(t) >= 0) {
    r[r.t++] = 1
    r.subTo(t, r)
  }
  BigInteger.ONE.dlShiftTo(ys, t)
  t.subTo(y, y); // "negative" y so we can replace sub with am later
  while (y.t < ys) y[y.t++] = 0
  while (--j >= 0) {
    // Estimate quotient digit
    var qd = (r[--i] == y0) ? self.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2)
    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) { // Try it out
      y.dlShiftTo(j, t)
      r.subTo(t, r)
      while (r[i] < --qd) r.subTo(t, r)
    }
  }
  if (q != null) {
    r.drShiftTo(ys, q)
    if (ts != ms) BigInteger.ZERO.subTo(q, q)
  }
  r.t = ys
  r.clamp()
  if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder
  if (ts < 0) BigInteger.ZERO.subTo(r, r)
}

// (public) this mod a
function bnMod(a) {
  var r = new BigInteger()
  this.abs()
    .divRemTo(a, null, r)
  if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r)
  return r
}

// Modular reduction using "classic" algorithm
function Classic(m) {
  this.m = m
}

function cConvert(x) {
  if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m)
  else return x
}

function cRevert(x) {
  return x
}

function cReduce(x) {
  x.divRemTo(this.m, null, x)
}

function cMulTo(x, y, r) {
  x.multiplyTo(y, r)
  this.reduce(r)
}

function cSqrTo(x, r) {
  x.squareTo(r)
  this.reduce(r)
}

Classic.prototype.convert = cConvert
Classic.prototype.revert = cRevert
Classic.prototype.reduce = cReduce
Classic.prototype.mulTo = cMulTo
Classic.prototype.sqrTo = cSqrTo

// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit() {
  if (this.t < 1) return 0
  var x = this[0]
  if ((x & 1) == 0) return 0
  var y = x & 3; // y == 1/x mod 2^2
  y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
  y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
  y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
  // last step - calculate inverse mod DV directly
  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
  y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits
  // we really want the negative inverse, and -DV < y < DV
  return (y > 0) ? this.DV - y : -y
}

// Montgomery reduction
function Montgomery(m) {
  this.m = m
  this.mp = m.invDigit()
  this.mpl = this.mp & 0x7fff
  this.mph = this.mp >> 15
  this.um = (1 << (m.DB - 15)) - 1
  this.mt2 = 2 * m.t
}

// xR mod m
function montConvert(x) {
  var r = new BigInteger()
  x.abs()
    .dlShiftTo(this.m.t, r)
  r.divRemTo(this.m, null, r)
  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r)
  return r
}

// x/R mod m
function montRevert(x) {
  var r = new BigInteger()
  x.copyTo(r)
  this.reduce(r)
  return r
}

// x = x/R mod m (HAC 14.32)
function montReduce(x) {
  while (x.t <= this.mt2) // pad x so am has enough room later
    x[x.t++] = 0
  for (var i = 0; i < this.m.t; ++i) {
    // faster way of calculating u0 = x[i]*mp mod DV
    var j = x[i] & 0x7fff
    var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM
    // use am to combine the multiply-shift-add into one call
    j = i + this.m.t
    x[j] += this.m.am(0, u0, x, i, 0, this.m.t)
    // propagate carry
    while (x[j] >= x.DV) {
      x[j] -= x.DV
      x[++j]++
    }
  }
  x.clamp()
  x.drShiftTo(this.m.t, x)
  if (x.compareTo(this.m) >= 0) x.subTo(this.m, x)
}

// r = "x^2/R mod m"; x != r
function montSqrTo(x, r) {
  x.squareTo(r)
  this.reduce(r)
}

// r = "xy/R mod m"; x,y != r
function montMulTo(x, y, r) {
  x.multiplyTo(y, r)
  this.reduce(r)
}

Montgomery.prototype.convert = montConvert
Montgomery.prototype.revert = montRevert
Montgomery.prototype.reduce = montReduce
Montgomery.prototype.mulTo = montMulTo
Montgomery.prototype.sqrTo = montSqrTo

// (protected) true iff this is even
function bnpIsEven() {
  return ((this.t > 0) ? (this[0] & 1) : this.s) == 0
}

// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e, z) {
  if (e > 0xffffffff || e < 1) return BigInteger.ONE
  var r = new BigInteger(),
    r2 = new BigInteger(),
    g = z.convert(this),
    i = nbits(e) - 1
  g.copyTo(r)
  while (--i >= 0) {
    z.sqrTo(r, r2)
    if ((e & (1 << i)) > 0) z.mulTo(r2, g, r)
    else {
      var t = r
      r = r2
      r2 = t
    }
  }
  return z.revert(r)
}

// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e, m) {
  var z
  if (e < 256 || m.isEven()) z = new Classic(m)
  else z = new Montgomery(m)
  return this.exp(e, z)
}

// protected
proto.copyTo = bnpCopyTo
proto.fromInt = bnpFromInt
proto.fromString = bnpFromString
proto.clamp = bnpClamp
proto.dlShiftTo = bnpDLShiftTo
proto.drShiftTo = bnpDRShiftTo
proto.lShiftTo = bnpLShiftTo
proto.rShiftTo = bnpRShiftTo
proto.subTo = bnpSubTo
proto.multiplyTo = bnpMultiplyTo
proto.squareTo = bnpSquareTo
proto.divRemTo = bnpDivRemTo
proto.invDigit = bnpInvDigit
proto.isEven = bnpIsEven
proto.exp = bnpExp

// public
proto.toString = bnToString
proto.negate = bnNegate
proto.abs = bnAbs
proto.compareTo = bnCompareTo
proto.bitLength = bnBitLength
proto.byteLength = bnByteLength
proto.mod = bnMod
proto.modPowInt = bnModPowInt

// (public)
function bnClone() {
  var r = new BigInteger()
  this.copyTo(r)
  return r
}

// (public) return value as integer
function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1) return this[0] - this.DV
    else if (this.t == 0) return -1
  } else if (this.t == 1) return this[0]
  else if (this.t == 0) return 0
  // assumes 16 < DB < 32
  return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0]
}

// (public) return value as byte
function bnByteValue() {
  return (this.t == 0) ? this.s : (this[0] << 24) >> 24
}

// (public) return value as short (assumes DB>=16)
function bnShortValue() {
  return (this.t == 0) ? this.s : (this[0] << 16) >> 16
}

// (protected) return x s.t. r^x < DV
function bnpChunkSize(r) {
  return Math.floor(Math.LN2 * this.DB / Math.log(r))
}

// (public) 0 if this == 0, 1 if this > 0
function bnSigNum() {
  if (this.s < 0) return -1
  else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0
  else return 1
}

// (protected) convert to radix string
function bnpToRadix(b) {
  if (b == null) b = 10
  if (this.signum() == 0 || b < 2 || b > 36) return "0"
  var cs = this.chunkSize(b)
  var a = Math.pow(b, cs)
  var d = nbv(a),
    y = new BigInteger(),
    z = new BigInteger(),
    r = ""
  this.divRemTo(d, y, z)
  while (y.signum() > 0) {
    r = (a + z.intValue())
      .toString(b)
      .substr(1) + r
    y.divRemTo(d, y, z)
  }
  return z.intValue()
    .toString(b) + r
}

// (protected) convert from radix string
function bnpFromRadix(s, b) {
  var self = this
  self.fromInt(0)
  if (b == null) b = 10
  var cs = self.chunkSize(b)
  var d = Math.pow(b, cs),
    mi = false,
    j = 0,
    w = 0
  for (var i = 0; i < s.length; ++i) {
    var x = intAt(s, i)
    if (x < 0) {
      if (s.charAt(i) == "-" && self.signum() == 0) mi = true
      continue
    }
    w = b * w + x
    if (++j >= cs) {
      self.dMultiply(d)
      self.dAddOffset(w, 0)
      j = 0
      w = 0
    }
  }
  if (j > 0) {
    self.dMultiply(Math.pow(b, j))
    self.dAddOffset(w, 0)
  }
  if (mi) BigInteger.ZERO.subTo(self, self)
}

// (protected) alternate constructor
function bnpFromNumber(a, b, c) {
  var self = this
  if ("number" == typeof b) {
    // new BigInteger(int,int,RNG)
    if (a < 2) self.fromInt(1)
    else {
      self.fromNumber(a, c)
      if (!self.testBit(a - 1)) // force MSB set
        self.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, self)
      if (self.isEven()) self.dAddOffset(1, 0); // force odd
      while (!self.isProbablePrime(b)) {
        self.dAddOffset(2, 0)
        if (self.bitLength() > a) self.subTo(BigInteger.ONE.shiftLeft(a - 1), self)
      }
    }
  } else {
    // new BigInteger(int,RNG)
    var x = new Array(),
      t = a & 7
    x.length = (a >> 3) + 1
    b.nextBytes(x)
    if (t > 0) x[0] &= ((1 << t) - 1)
    else x[0] = 0
    self.fromString(x, 256)
  }
}

// (public) convert to bigendian byte array
function bnToByteArray() {
  var self = this
  var i = self.t,
    r = new Array()
  r[0] = self.s
  var p = self.DB - (i * self.DB) % 8,
    d, k = 0
  if (i-- > 0) {
    if (p < self.DB && (d = self[i] >> p) != (self.s & self.DM) >> p)
      r[k++] = d | (self.s << (self.DB - p))
    while (i >= 0) {
      if (p < 8) {
        d = (self[i] & ((1 << p) - 1)) << (8 - p)
        d |= self[--i] >> (p += self.DB - 8)
      } else {
        d = (self[i] >> (p -= 8)) & 0xff
        if (p <= 0) {
          p += self.DB
          --i
        }
      }
      if ((d & 0x80) != 0) d |= -256
      if (k === 0 && (self.s & 0x80) != (d & 0x80))++k
      if (k > 0 || d != self.s) r[k++] = d
    }
  }
  return r
}

function bnEquals(a) {
  return (this.compareTo(a) == 0)
}

function bnMin(a) {
  return (this.compareTo(a) < 0) ? this : a
}

function bnMax(a) {
  return (this.compareTo(a) > 0) ? this : a
}

// (protected) r = this op a (bitwise)
function bnpBitwiseTo(a, op, r) {
  var self = this
  var i, f, m = Math.min(a.t, self.t)
  for (i = 0; i < m; ++i) r[i] = op(self[i], a[i])
  if (a.t < self.t) {
    f = a.s & self.DM
    for (i = m; i < self.t; ++i) r[i] = op(self[i], f)
    r.t = self.t
  } else {
    f = self.s & self.DM
    for (i = m; i < a.t; ++i) r[i] = op(f, a[i])
    r.t = a.t
  }
  r.s = op(self.s, a.s)
  r.clamp()
}

// (public) this & a
function op_and(x, y) {
  return x & y
}

function bnAnd(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_and, r)
  return r
}

// (public) this | a
function op_or(x, y) {
  return x | y
}

function bnOr(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_or, r)
  return r
}

// (public) this ^ a
function op_xor(x, y) {
  return x ^ y
}

function bnXor(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_xor, r)
  return r
}

// (public) this & ~a
function op_andnot(x, y) {
  return x & ~y
}

function bnAndNot(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_andnot, r)
  return r
}

// (public) ~this
function bnNot() {
  var r = new BigInteger()
  for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i]
  r.t = this.t
  r.s = ~this.s
  return r
}

// (public) this << n
function bnShiftLeft(n) {
  var r = new BigInteger()
  if (n < 0) this.rShiftTo(-n, r)
  else this.lShiftTo(n, r)
  return r
}

// (public) this >> n
function bnShiftRight(n) {
  var r = new BigInteger()
  if (n < 0) this.lShiftTo(-n, r)
  else this.rShiftTo(n, r)
  return r
}

// return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
  if (x == 0) return -1
  var r = 0
  if ((x & 0xffff) == 0) {
    x >>= 16
    r += 16
  }
  if ((x & 0xff) == 0) {
    x >>= 8
    r += 8
  }
  if ((x & 0xf) == 0) {
    x >>= 4
    r += 4
  }
  if ((x & 3) == 0) {
    x >>= 2
    r += 2
  }
  if ((x & 1) == 0)++r
  return r
}

// (public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit() {
  for (var i = 0; i < this.t; ++i)
    if (this[i] != 0) return i * this.DB + lbit(this[i])
  if (this.s < 0) return this.t * this.DB
  return -1
}

// return number of 1 bits in x
function cbit(x) {
  var r = 0
  while (x != 0) {
    x &= x - 1
    ++r
  }
  return r
}

// (public) return number of set bits
function bnBitCount() {
  var r = 0,
    x = this.s & this.DM
  for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x)
  return r
}

// (public) true iff nth bit is set
function bnTestBit(n) {
  var j = Math.floor(n / this.DB)
  if (j >= this.t) return (this.s != 0)
  return ((this[j] & (1 << (n % this.DB))) != 0)
}

// (protected) this op (1<<n)
function bnpChangeBit(n, op) {
  var r = BigInteger.ONE.shiftLeft(n)
  this.bitwiseTo(r, op, r)
  return r
}

// (public) this | (1<<n)
function bnSetBit(n) {
  return this.changeBit(n, op_or)
}

// (public) this & ~(1<<n)
function bnClearBit(n) {
  return this.changeBit(n, op_andnot)
}

// (public) this ^ (1<<n)
function bnFlipBit(n) {
  return this.changeBit(n, op_xor)
}

// (protected) r = this + a
function bnpAddTo(a, r) {
  var self = this

  var i = 0,
    c = 0,
    m = Math.min(a.t, self.t)
  while (i < m) {
    c += self[i] + a[i]
    r[i++] = c & self.DM
    c >>= self.DB
  }
  if (a.t < self.t) {
    c += a.s
    while (i < self.t) {
      c += self[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c += self.s
  } else {
    c += self.s
    while (i < a.t) {
      c += a[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c += a.s
  }
  r.s = (c < 0) ? -1 : 0
  if (c > 0) r[i++] = c
  else if (c < -1) r[i++] = self.DV + c
  r.t = i
  r.clamp()
}

// (public) this + a
function bnAdd(a) {
  var r = new BigInteger()
  this.addTo(a, r)
  return r
}

// (public) this - a
function bnSubtract(a) {
  var r = new BigInteger()
  this.subTo(a, r)
  return r
}

// (public) this * a
function bnMultiply(a) {
  var r = new BigInteger()
  this.multiplyTo(a, r)
  return r
}

// (public) this^2
function bnSquare() {
  var r = new BigInteger()
  this.squareTo(r)
  return r
}

// (public) this / a
function bnDivide(a) {
  var r = new BigInteger()
  this.divRemTo(a, r, null)
  return r
}

// (public) this % a
function bnRemainder(a) {
  var r = new BigInteger()
  this.divRemTo(a, null, r)
  return r
}

// (public) [this/a,this%a]
function bnDivideAndRemainder(a) {
  var q = new BigInteger(),
    r = new BigInteger()
  this.divRemTo(a, q, r)
  return new Array(q, r)
}

// (protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n) {
  this[this.t] = this.am(0, n - 1, this, 0, 0, this.t)
  ++this.t
  this.clamp()
}

// (protected) this += n << w words, this >= 0
function bnpDAddOffset(n, w) {
  if (n == 0) return
  while (this.t <= w) this[this.t++] = 0
  this[w] += n
  while (this[w] >= this.DV) {
    this[w] -= this.DV
    if (++w >= this.t) this[this.t++] = 0
    ++this[w]
  }
}

// A "null" reducer
function NullExp() {}

function nNop(x) {
  return x
}

function nMulTo(x, y, r) {
  x.multiplyTo(y, r)
}

function nSqrTo(x, r) {
  x.squareTo(r)
}

NullExp.prototype.convert = nNop
NullExp.prototype.revert = nNop
NullExp.prototype.mulTo = nMulTo
NullExp.prototype.sqrTo = nSqrTo

// (public) this^e
function bnPow(e) {
  return this.exp(e, new NullExp())
}

// (protected) r = lower n words of "this * a", a.t <= n
// "this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a, n, r) {
  var i = Math.min(this.t + a.t, n)
  r.s = 0; // assumes a,this >= 0
  r.t = i
  while (i > 0) r[--i] = 0
  var j
  for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t)
  for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i)
  r.clamp()
}

// (protected) r = "this * a" without lower n words, n > 0
// "this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a, n, r) {
  --n
  var i = r.t = this.t + a.t - n
  r.s = 0; // assumes a,this >= 0
  while (--i >= 0) r[i] = 0
  for (i = Math.max(n - this.t, 0); i < a.t; ++i)
    r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n)
  r.clamp()
  r.drShiftTo(1, r)
}

// Barrett modular reduction
function Barrett(m) {
  // setup Barrett
  this.r2 = new BigInteger()
  this.q3 = new BigInteger()
  BigInteger.ONE.dlShiftTo(2 * m.t, this.r2)
  this.mu = this.r2.divide(m)
  this.m = m
}

function barrettConvert(x) {
  if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m)
  else if (x.compareTo(this.m) < 0) return x
  else {
    var r = new BigInteger()
    x.copyTo(r)
    this.reduce(r)
    return r
  }
}

function barrettRevert(x) {
  return x
}

// x = x mod m (HAC 14.42)
function barrettReduce(x) {
  var self = this
  x.drShiftTo(self.m.t - 1, self.r2)
  if (x.t > self.m.t + 1) {
    x.t = self.m.t + 1
    x.clamp()
  }
  self.mu.multiplyUpperTo(self.r2, self.m.t + 1, self.q3)
  self.m.multiplyLowerTo(self.q3, self.m.t + 1, self.r2)
  while (x.compareTo(self.r2) < 0) x.dAddOffset(1, self.m.t + 1)
  x.subTo(self.r2, x)
  while (x.compareTo(self.m) >= 0) x.subTo(self.m, x)
}

// r = x^2 mod m; x != r
function barrettSqrTo(x, r) {
  x.squareTo(r)
  this.reduce(r)
}

// r = x*y mod m; x,y != r
function barrettMulTo(x, y, r) {
  x.multiplyTo(y, r)
  this.reduce(r)
}

Barrett.prototype.convert = barrettConvert
Barrett.prototype.revert = barrettRevert
Barrett.prototype.reduce = barrettReduce
Barrett.prototype.mulTo = barrettMulTo
Barrett.prototype.sqrTo = barrettSqrTo

// (public) this^e % m (HAC 14.85)
function bnModPow(e, m) {
  var i = e.bitLength(),
    k, r = nbv(1),
    z
  if (i <= 0) return r
  else if (i < 18) k = 1
  else if (i < 48) k = 3
  else if (i < 144) k = 4
  else if (i < 768) k = 5
  else k = 6
  if (i < 8)
    z = new Classic(m)
  else if (m.isEven())
    z = new Barrett(m)
  else
    z = new Montgomery(m)

  // precomputation
  var g = new Array(),
    n = 3,
    k1 = k - 1,
    km = (1 << k) - 1
  g[1] = z.convert(this)
  if (k > 1) {
    var g2 = new BigInteger()
    z.sqrTo(g[1], g2)
    while (n <= km) {
      g[n] = new BigInteger()
      z.mulTo(g2, g[n - 2], g[n])
      n += 2
    }
  }

  var j = e.t - 1,
    w, is1 = true,
    r2 = new BigInteger(),
    t
  i = nbits(e[j]) - 1
  while (j >= 0) {
    if (i >= k1) w = (e[j] >> (i - k1)) & km
    else {
      w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i)
      if (j > 0) w |= e[j - 1] >> (this.DB + i - k1)
    }

    n = k
    while ((w & 1) == 0) {
      w >>= 1
      --n
    }
    if ((i -= n) < 0) {
      i += this.DB
      --j
    }
    if (is1) { // ret == 1, don't bother squaring or multiplying it
      g[w].copyTo(r)
      is1 = false
    } else {
      while (n > 1) {
        z.sqrTo(r, r2)
        z.sqrTo(r2, r)
        n -= 2
      }
      if (n > 0) z.sqrTo(r, r2)
      else {
        t = r
        r = r2
        r2 = t
      }
      z.mulTo(r2, g[w], r)
    }

    while (j >= 0 && (e[j] & (1 << i)) == 0) {
      z.sqrTo(r, r2)
      t = r
      r = r2
      r2 = t
      if (--i < 0) {
        i = this.DB - 1
        --j
      }
    }
  }
  return z.revert(r)
}

// (public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
  var x = (this.s < 0) ? this.negate() : this.clone()
  var y = (a.s < 0) ? a.negate() : a.clone()
  if (x.compareTo(y) < 0) {
    var t = x
    x = y
    y = t
  }
  var i = x.getLowestSetBit(),
    g = y.getLowestSetBit()
  if (g < 0) return x
  if (i < g) g = i
  if (g > 0) {
    x.rShiftTo(g, x)
    y.rShiftTo(g, y)
  }
  while (x.signum() > 0) {
    if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x)
    if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y)
    if (x.compareTo(y) >= 0) {
      x.subTo(y, x)
      x.rShiftTo(1, x)
    } else {
      y.subTo(x, y)
      y.rShiftTo(1, y)
    }
  }
  if (g > 0) y.lShiftTo(g, y)
  return y
}

// (protected) this % n, n < 2^26
function bnpModInt(n) {
  if (n <= 0) return 0
  var d = this.DV % n,
    r = (this.s < 0) ? n - 1 : 0
  if (this.t > 0)
    if (d == 0) r = this[0] % n
    else
      for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n
  return r
}

// (public) 1/this % m (HAC 14.61)
function bnModInverse(m) {
  var ac = m.isEven()
  if (this.signum() === 0) throw new Error('division by zero')
  if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO
  var u = m.clone(),
    v = this.clone()
  var a = nbv(1),
    b = nbv(0),
    c = nbv(0),
    d = nbv(1)
  while (u.signum() != 0) {
    while (u.isEven()) {
      u.rShiftTo(1, u)
      if (ac) {
        if (!a.isEven() || !b.isEven()) {
          a.addTo(this, a)
          b.subTo(m, b)
        }
        a.rShiftTo(1, a)
      } else if (!b.isEven()) b.subTo(m, b)
      b.rShiftTo(1, b)
    }
    while (v.isEven()) {
      v.rShiftTo(1, v)
      if (ac) {
        if (!c.isEven() || !d.isEven()) {
          c.addTo(this, c)
          d.subTo(m, d)
        }
        c.rShiftTo(1, c)
      } else if (!d.isEven()) d.subTo(m, d)
      d.rShiftTo(1, d)
    }
    if (u.compareTo(v) >= 0) {
      u.subTo(v, u)
      if (ac) a.subTo(c, a)
      b.subTo(d, b)
    } else {
      v.subTo(u, v)
      if (ac) c.subTo(a, c)
      d.subTo(b, d)
    }
  }
  if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO
  while (d.compareTo(m) >= 0) d.subTo(m, d)
  while (d.signum() < 0) d.addTo(m, d)
  return d
}

var lowprimes = [
  2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
  73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,
  157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
  239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317,
  331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,
  421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,
  509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,
  613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,
  709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,
  821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,
  919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997
]

var lplim = (1 << 26) / lowprimes[lowprimes.length - 1]

// (public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t) {
  var i, x = this.abs()
  if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
    for (i = 0; i < lowprimes.length; ++i)
      if (x[0] == lowprimes[i]) return true
    return false
  }
  if (x.isEven()) return false
  i = 1
  while (i < lowprimes.length) {
    var m = lowprimes[i],
      j = i + 1
    while (j < lowprimes.length && m < lplim) m *= lowprimes[j++]
    m = x.modInt(m)
    while (i < j) if (m % lowprimes[i++] == 0) return false
  }
  return x.millerRabin(t)
}

// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
  var n1 = this.subtract(BigInteger.ONE)
  var k = n1.getLowestSetBit()
  if (k <= 0) return false
  var r = n1.shiftRight(k)
  t = (t + 1) >> 1
  if (t > lowprimes.length) t = lowprimes.length
  var a = new BigInteger(null)
  var j, bases = []
  for (var i = 0; i < t; ++i) {
    for (;;) {
      j = lowprimes[Math.floor(Math.random() * lowprimes.length)]
      if (bases.indexOf(j) == -1) break
    }
    bases.push(j)
    a.fromInt(j)
    var y = a.modPow(r, this)
    if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
      var j = 1
      while (j++ < k && y.compareTo(n1) != 0) {
        y = y.modPowInt(2, this)
        if (y.compareTo(BigInteger.ONE) == 0) return false
      }
      if (y.compareTo(n1) != 0) return false
    }
  }
  return true
}

// protected
proto.chunkSize = bnpChunkSize
proto.toRadix = bnpToRadix
proto.fromRadix = bnpFromRadix
proto.fromNumber = bnpFromNumber
proto.bitwiseTo = bnpBitwiseTo
proto.changeBit = bnpChangeBit
proto.addTo = bnpAddTo
proto.dMultiply = bnpDMultiply
proto.dAddOffset = bnpDAddOffset
proto.multiplyLowerTo = bnpMultiplyLowerTo
proto.multiplyUpperTo = bnpMultiplyUpperTo
proto.modInt = bnpModInt
proto.millerRabin = bnpMillerRabin

// public
proto.clone = bnClone
proto.intValue = bnIntValue
proto.byteValue = bnByteValue
proto.shortValue = bnShortValue
proto.signum = bnSigNum
proto.toByteArray = bnToByteArray
proto.equals = bnEquals
proto.min = bnMin
proto.max = bnMax
proto.and = bnAnd
proto.or = bnOr
proto.xor = bnXor
proto.andNot = bnAndNot
proto.not = bnNot
proto.shiftLeft = bnShiftLeft
proto.shiftRight = bnShiftRight
proto.getLowestSetBit = bnGetLowestSetBit
proto.bitCount = bnBitCount
proto.testBit = bnTestBit
proto.setBit = bnSetBit
proto.clearBit = bnClearBit
proto.flipBit = bnFlipBit
proto.add = bnAdd
proto.subtract = bnSubtract
proto.multiply = bnMultiply
proto.divide = bnDivide
proto.remainder = bnRemainder
proto.divideAndRemainder = bnDivideAndRemainder
proto.modPow = bnModPow
proto.modInverse = bnModInverse
proto.pow = bnPow
proto.gcd = bnGCD
proto.isProbablePrime = bnIsProbablePrime

// JSBN-specific extension
proto.square = bnSquare

// constants
BigInteger.ZERO = nbv(0)
BigInteger.ONE = nbv(1)
BigInteger.valueOf = nbv

module.exports = BigInteger

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/bigi/lib/bigi.js","/../node_modules/bigi/lib")
},{"../package.json":7,"buffer":11,"pBGvAp":74}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// FIXME: Kind of a weird way to throw exceptions, consider removing
var assert = require('assert')
var BigInteger = require('./bigi')

/**
 * Turns a byte array into a big integer.
 *
 * This function will interpret a byte array as a big integer in big
 * endian notation.
 */
BigInteger.fromByteArrayUnsigned = function(byteArray) {
  // BigInteger expects a DER integer conformant byte array
  if (byteArray[0] & 0x80) {
    return new BigInteger([0].concat(byteArray))
  }

  return new BigInteger(byteArray)
}

/**
 * Returns a byte array representation of the big integer.
 *
 * This returns the absolute of the contained value in big endian
 * form. A value of zero results in an empty array.
 */
BigInteger.prototype.toByteArrayUnsigned = function() {
  var byteArray = this.toByteArray()
  return byteArray[0] === 0 ? byteArray.slice(1) : byteArray
}

BigInteger.fromDERInteger = function(byteArray) {
  return new BigInteger(byteArray)
}

/*
 * Converts BigInteger to a DER integer representation.
 *
 * The format for this value uses the most significant bit as a sign
 * bit.  If the most significant bit is already set and the integer is
 * positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
*/
BigInteger.prototype.toDERInteger = BigInteger.prototype.toByteArray

BigInteger.fromBuffer = function(buffer) {
  // BigInteger expects a DER integer conformant byte array
  if (buffer[0] & 0x80) {
    var byteArray = Array.prototype.slice.call(buffer)

    return new BigInteger([0].concat(byteArray))
  }

  return new BigInteger(buffer)
}

BigInteger.fromHex = function(hex) {
  if (hex === '') return BigInteger.ZERO

  assert.equal(hex, hex.match(/^[A-Fa-f0-9]+/), 'Invalid hex string')
  assert.equal(hex.length % 2, 0, 'Incomplete hex')
  return new BigInteger(hex, 16)
}

BigInteger.prototype.toBuffer = function(size) {
  var byteArray = this.toByteArrayUnsigned()
  var zeros = []

  var padding = size - byteArray.length
  while (zeros.length < padding) zeros.push(0)

  return new Buffer(zeros.concat(byteArray))
}

BigInteger.prototype.toHex = function(size) {
  return this.toBuffer(size).toString('hex')
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/bigi/lib/convert.js","/../node_modules/bigi/lib")
},{"./bigi":4,"assert":1,"buffer":11,"pBGvAp":74}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var BigInteger = require('./bigi')

//addons
require('./convert')

module.exports = BigInteger
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/bigi/lib/index.js","/../node_modules/bigi/lib")
},{"./bigi":4,"./convert":5,"buffer":11,"pBGvAp":74}],7:[function(require,module,exports){
module.exports={
  "_args": [
    [
      {
        "raw": "bigi@^1.4.2",
        "scope": null,
        "escapedName": "bigi",
        "name": "bigi",
        "rawSpec": "^1.4.2",
        "spec": ">=1.4.2 <2.0.0",
        "type": "range"
      },
      "/Users/m/p/esteem/node_modules/steemauth"
    ]
  ],
  "_from": "bigi@>=1.4.2 <2.0.0",
  "_id": "bigi@1.4.2",
  "_inCache": true,
  "_installable": true,
  "_location": "/bigi",
  "_nodeVersion": "6.1.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/bigi-1.4.2.tgz_1469584192413_0.6801238611806184"
  },
  "_npmUser": {
    "name": "jprichardson",
    "email": "jprichardson@gmail.com"
  },
  "_npmVersion": "3.8.6",
  "_phantomChildren": {},
  "_requested": {
    "raw": "bigi@^1.4.2",
    "scope": null,
    "escapedName": "bigi",
    "name": "bigi",
    "rawSpec": "^1.4.2",
    "spec": ">=1.4.2 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/ecurve",
    "/steemauth"
  ],
  "_resolved": "https://registry.npmjs.org/bigi/-/bigi-1.4.2.tgz",
  "_shasum": "9c665a95f88b8b08fc05cfd731f561859d725825",
  "_shrinkwrap": null,
  "_spec": "bigi@^1.4.2",
  "_where": "/Users/m/p/esteem/node_modules/steemauth",
  "bugs": {
    "url": "https://github.com/cryptocoinjs/bigi/issues"
  },
  "dependencies": {},
  "description": "Big integers.",
  "devDependencies": {
    "coveralls": "^2.11.2",
    "istanbul": "^0.3.5",
    "jshint": "^2.5.1",
    "mocha": "^2.1.0",
    "mochify": "^2.1.0"
  },
  "directories": {},
  "dist": {
    "shasum": "9c665a95f88b8b08fc05cfd731f561859d725825",
    "tarball": "https://registry.npmjs.org/bigi/-/bigi-1.4.2.tgz"
  },
  "gitHead": "c25308081c896ff84702303722bf5ecd8b3f78e3",
  "homepage": "https://github.com/cryptocoinjs/bigi#readme",
  "keywords": [
    "cryptography",
    "math",
    "bitcoin",
    "arbitrary",
    "precision",
    "arithmetic",
    "big",
    "integer",
    "int",
    "number",
    "biginteger",
    "bigint",
    "bignumber",
    "decimal",
    "float"
  ],
  "main": "./lib/index.js",
  "maintainers": [
    {
      "name": "midnightlightning",
      "email": "boydb@midnightdesign.ws"
    },
    {
      "name": "sidazhang",
      "email": "sidazhang89@gmail.com"
    },
    {
      "name": "nadav",
      "email": "npm@shesek.info"
    },
    {
      "name": "jprichardson",
      "email": "jprichardson@gmail.com"
    }
  ],
  "name": "bigi",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "url": "git+https://github.com/cryptocoinjs/bigi.git",
    "type": "git"
  },
  "scripts": {
    "browser-test": "mochify --wd -R spec",
    "coverage": "istanbul cover ./node_modules/.bin/_mocha -- --reporter list test/*.js",
    "coveralls": "npm run-script coverage && node ./node_modules/.bin/coveralls < coverage/lcov.info",
    "jshint": "jshint --config jshint.json lib/*.js ; true",
    "test": "_mocha -- test/*.js",
    "unit": "mocha"
  },
  "testling": {
    "files": "test/*.js",
    "harness": "mocha",
    "browsers": [
      "ie/9..latest",
      "firefox/latest",
      "chrome/latest",
      "safari/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  },
  "version": "1.4.2"
}

},{}],8:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/browser-resolve/empty.js","/../node_modules/browser-resolve")
},{"buffer":11,"pBGvAp":74}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

function assertEncoding(encoding) {
  if (encoding && !Buffer.isEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  this.charBuffer = new Buffer(6);
  this.charReceived = 0;
  this.charLength = 0;
};


StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  var offset = 0;

  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var i = (buffer.length >= this.charLength - this.charReceived) ?
                this.charLength - this.charReceived :
                buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, offset, i);
    this.charReceived += (i - offset);
    offset = i;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (i == buffer.length) return charStr;

    // otherwise cut off the characters end from the beginning of this buffer
    buffer = buffer.slice(i, buffer.length);
    break;
  }

  var lenIncomplete = this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);
    this.charReceived = lenIncomplete;
    end -= lenIncomplete;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }

  return i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 2;
  this.charLength = incomplete ? 2 : 0;
  return incomplete;
}

function base64DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 3;
  this.charLength = incomplete ? 3 : 0;
  return incomplete;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/browserify/node_modules/string_decoder/index.js","/../node_modules/browserify/node_modules/string_decoder")
},{"buffer":11,"pBGvAp":74}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var basex = require('base-x')
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
var base58 = basex(ALPHABET)

module.exports = {
  encode: base58.encode,
  decode: base58.decode
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/bs58/index.js","/../node_modules/bs58")
},{"base-x":2,"buffer":11,"pBGvAp":74}],11:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++)
      target[i + target_start] = this[i + start]
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/buffer/index.js","/../node_modules/buffer")
},{"base64-js":3,"buffer":11,"ieee754":70,"pBGvAp":74}],12:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
 Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>
 * Backing buffer: ArrayBuffer, Accessor: Uint8Array
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/bytebuffer.js for details
 */
(function(global, factory) {

    /* AMD */ if (typeof define === 'function' && define["amd"])
        define(["long"], factory);
    /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"])
        module['exports'] = (function() {
            var Long; try { Long = require("long"); } catch (e) {}
            return factory(Long);
        })();
    /* Global */ else
        (global["dcodeIO"] = global["dcodeIO"] || {})["ByteBuffer"] = factory(global["dcodeIO"]["Long"]);

})(this, function(Long) {
    "use strict";

    /**
     * Constructs a new ByteBuffer.
     * @class The swiss army knife for binary data in JavaScript.
     * @exports ByteBuffer
     * @constructor
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @expose
     */
    var ByteBuffer = function(capacity, littleEndian, noAssert) {
        if (typeof capacity === 'undefined')
            capacity = ByteBuffer.DEFAULT_CAPACITY;
        if (typeof littleEndian === 'undefined')
            littleEndian = ByteBuffer.DEFAULT_ENDIAN;
        if (typeof noAssert === 'undefined')
            noAssert = ByteBuffer.DEFAULT_NOASSERT;
        if (!noAssert) {
            capacity = capacity | 0;
            if (capacity < 0)
                throw RangeError("Illegal capacity");
            littleEndian = !!littleEndian;
            noAssert = !!noAssert;
        }

        /**
         * Backing ArrayBuffer.
         * @type {!ArrayBuffer}
         * @expose
         */
        this.buffer = capacity === 0 ? EMPTY_BUFFER : new ArrayBuffer(capacity);

        /**
         * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`.
         * @type {?Uint8Array}
         * @expose
         */
        this.view = capacity === 0 ? null : new Uint8Array(this.buffer);

        /**
         * Absolute read/write offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.offset = 0;

        /**
         * Marked offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#mark
         * @see ByteBuffer#reset
         */
        this.markedOffset = -1;

        /**
         * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.limit = capacity;

        /**
         * Whether to use little endian byte order, defaults to `false` for big endian.
         * @type {boolean}
         * @expose
         */
        this.littleEndian = littleEndian;

        /**
         * Whether to skip assertions of offsets and values, defaults to `false`.
         * @type {boolean}
         * @expose
         */
        this.noAssert = noAssert;
    };

    /**
     * ByteBuffer version.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.VERSION = "5.0.1";

    /**
     * Little endian constant that can be used instead of its boolean value. Evaluates to `true`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.LITTLE_ENDIAN = true;

    /**
     * Big endian constant that can be used instead of its boolean value. Evaluates to `false`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.BIG_ENDIAN = false;

    /**
     * Default initial capacity of `16`.
     * @type {number}
     * @expose
     */
    ByteBuffer.DEFAULT_CAPACITY = 16;

    /**
     * Default endianess of `false` for big endian.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;

    /**
     * Default no assertions flag of `false`.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_NOASSERT = false;

    /**
     * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded
     *  and int64 support is not available.
     * @type {?Long}
     * @const
     * @see https://github.com/dcodeIO/long.js
     * @expose
     */
    ByteBuffer.Long = Long || null;

    /**
     * @alias ByteBuffer.prototype
     * @inner
     */
    var ByteBufferPrototype = ByteBuffer.prototype;

    /**
     * An indicator used to reliably determine if an object is a ByteBuffer or not.
     * @type {boolean}
     * @const
     * @expose
     * @private
     */
    ByteBufferPrototype.__isByteBuffer__;

    Object.defineProperty(ByteBufferPrototype, "__isByteBuffer__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    // helpers

    /**
     * @type {!ArrayBuffer}
     * @inner
     */
    var EMPTY_BUFFER = new ArrayBuffer(0);

    /**
     * String.fromCharCode reference for compile-time renaming.
     * @type {function(...number):string}
     * @inner
     */
    var stringFromCharCode = String.fromCharCode;

    /**
     * Creates a source function for a string.
     * @param {string} s String to read from
     * @returns {function():number|null} Source function returning the next char code respectively `null` if there are
     *  no more characters left.
     * @throws {TypeError} If the argument is invalid
     * @inner
     */
    function stringSource(s) {
        var i=0; return function() {
            return i < s.length ? s.charCodeAt(i++) : null;
        };
    }

    /**
     * Creates a destination function for a string.
     * @returns {function(number=):undefined|string} Destination function successively called with the next char code.
     *  Returns the final string when called without arguments.
     * @inner
     */
    function stringDestination() {
        var cs = [], ps = []; return function() {
            if (arguments.length === 0)
                return ps.join('')+stringFromCharCode.apply(String, cs);
            if (cs.length + arguments.length > 1024)
                ps.push(stringFromCharCode.apply(String, cs)),
                    cs.length = 0;
            Array.prototype.push.apply(cs, arguments);
        };
    }

    /**
     * Gets the accessor type.
     * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)
     * @expose
     */
    ByteBuffer.accessor = function() {
        return Uint8Array;
    };
    /**
     * Allocates a new ByteBuffer backed by a buffer of the specified capacity.
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBuffer.allocate = function(capacity, littleEndian, noAssert) {
        return new ByteBuffer(capacity, littleEndian, noAssert);
    };

    /**
     * Concatenates multiple ByteBuffers into one.
     * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate
     * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string ("base64", "hex", "binary",
     *  defaults to "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults
     *  to {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} Concatenated ByteBuffer
     * @expose
     */
    ByteBuffer.concat = function(buffers, encoding, littleEndian, noAssert) {
        if (typeof encoding === 'boolean' || typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        var capacity = 0;
        for (var i=0, k=buffers.length, length; i<k; ++i) {
            if (!ByteBuffer.isByteBuffer(buffers[i]))
                buffers[i] = ByteBuffer.wrap(buffers[i], encoding);
            length = buffers[i].limit - buffers[i].offset;
            if (length > 0) capacity += length;
        }
        if (capacity === 0)
            return new ByteBuffer(0, littleEndian, noAssert);
        var bb = new ByteBuffer(capacity, littleEndian, noAssert),
            bi;
        i=0; while (i<k) {
            bi = buffers[i++];
            length = bi.limit - bi.offset;
            if (length <= 0) continue;
            bb.view.set(bi.view.subarray(bi.offset, bi.limit), bb.offset);
            bb.offset += length;
        }
        bb.limit = bb.offset;
        bb.offset = 0;
        return bb;
    };

    /**
     * Tests if the specified type is a ByteBuffer.
     * @param {*} bb ByteBuffer to test
     * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`
     * @expose
     */
    ByteBuffer.isByteBuffer = function(bb) {
        return (bb && bb["__isByteBuffer__"]) === true;
    };
    /**
     * Gets the backing buffer type.
     * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)
     * @expose
     */
    ByteBuffer.type = function() {
        return ArrayBuffer;
    };
    /**
     * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its
     *  {@link ByteBuffer#limit} to the length of the wrapped data.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped
     * @param {(string|boolean)=} encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to
     *  "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`
     * @expose
     */
    ByteBuffer.wrap = function(buffer, encoding, littleEndian, noAssert) {
        if (typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        if (typeof buffer === 'string') {
            if (typeof encoding === 'undefined')
                encoding = "utf8";
            switch (encoding) {
                case "base64":
                    return ByteBuffer.fromBase64(buffer, littleEndian);
                case "hex":
                    return ByteBuffer.fromHex(buffer, littleEndian);
                case "binary":
                    return ByteBuffer.fromBinary(buffer, littleEndian);
                case "utf8":
                    return ByteBuffer.fromUTF8(buffer, littleEndian);
                case "debug":
                    return ByteBuffer.fromDebug(buffer, littleEndian);
                default:
                    throw Error("Unsupported encoding: "+encoding);
            }
        }
        if (buffer === null || typeof buffer !== 'object')
            throw TypeError("Illegal buffer");
        var bb;
        if (ByteBuffer.isByteBuffer(buffer)) {
            bb = ByteBufferPrototype.clone.call(buffer);
            bb.markedOffset = -1;
            return bb;
        }
        if (buffer instanceof Uint8Array) { // Extract ArrayBuffer from Uint8Array
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.length > 0) { // Avoid references to more than one EMPTY_BUFFER
                bb.buffer = buffer.buffer;
                bb.offset = buffer.byteOffset;
                bb.limit = buffer.byteOffset + buffer.byteLength;
                bb.view = new Uint8Array(buffer.buffer);
            }
        } else if (buffer instanceof ArrayBuffer) { // Reuse ArrayBuffer
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.byteLength > 0) {
                bb.buffer = buffer;
                bb.offset = 0;
                bb.limit = buffer.byteLength;
                bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null;
            }
        } else if (Object.prototype.toString.call(buffer) === "[object Array]") { // Create from octets
            bb = new ByteBuffer(buffer.length, littleEndian, noAssert);
            bb.limit = buffer.length;
            for (var i=0; i<buffer.length; ++i)
                bb.view[i] = buffer[i];
        } else
            throw TypeError("Illegal buffer"); // Otherwise fail
        return bb;
    };

    /**
     * Writes the array as a bitset.
     * @param {Array<boolean>} value Array of booleans to write
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.writeBitSet = function(value, offset) {
      var relative = typeof offset === 'undefined';
      if (relative) offset = this.offset;
      if (!this.noAssert) {
        if (!(value instanceof Array))
          throw TypeError("Illegal BitSet: Not an array");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset >>>= 0;
        if (offset < 0 || offset + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
      }

      var start = offset,
          bits = value.length,
          bytes = (bits >> 3),
          bit = 0,
          k;

      offset += this.writeVarint32(bits,offset);

      while(bytes--) {
        k = (!!value[bit++] & 1) |
            ((!!value[bit++] & 1) << 1) |
            ((!!value[bit++] & 1) << 2) |
            ((!!value[bit++] & 1) << 3) |
            ((!!value[bit++] & 1) << 4) |
            ((!!value[bit++] & 1) << 5) |
            ((!!value[bit++] & 1) << 6) |
            ((!!value[bit++] & 1) << 7);
        this.writeByte(k,offset++);
      }

      if(bit < bits) {
        var m = 0; k = 0;
        while(bit < bits) k = k | ((!!value[bit++] & 1) << (m++));
        this.writeByte(k,offset++);
      }

      if (relative) {
        this.offset = offset;
        return this;
      }
      return offset - start;
    }

    /**
     * Reads a BitSet as an array of booleans.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {Array<boolean>
     * @expose
     */
    ByteBufferPrototype.readBitSet = function(offset) {
      var relative = typeof offset === 'undefined';
      if (relative) offset = this.offset;

      var ret = this.readVarint32(offset),
          bits = ret.value,
          bytes = (bits >> 3),
          bit = 0,
          value = [],
          k;

      offset += ret.length;

      while(bytes--) {
        k = this.readByte(offset++);
        value[bit++] = !!(k & 0x01);
        value[bit++] = !!(k & 0x02);
        value[bit++] = !!(k & 0x04);
        value[bit++] = !!(k & 0x08);
        value[bit++] = !!(k & 0x10);
        value[bit++] = !!(k & 0x20);
        value[bit++] = !!(k & 0x40);
        value[bit++] = !!(k & 0x80);
      }

      if(bit < bits) {
        var m = 0;
        k = this.readByte(offset++);
        while(bit < bits) value[bit++] = !!((k >> (m++)) & 1);
      }

      if (relative) {
        this.offset = offset;
      }
      return value;
    }
    /**
     * Reads the specified number of bytes.
     * @param {number} length Number of bytes to read
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.readBytes = function(length, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + length > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
        }
        var slice = this.slice(offset, offset + length);
        if (relative) this.offset += length;
        return slice;
    };

    /**
     * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.
     * @function
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeBytes = ByteBufferPrototype.append;

    // types/ints/int8

    /**
     * Writes an 8bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeInt8 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 1;
        var capacity0 = this.buffer.byteLength;
        if (offset > capacity0)
            this.resize((capacity0 *= 2) > offset ? capacity0 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8;

    /**
     * Reads an 8bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt8 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var value = this.view[offset];
        if ((value & 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8;

    /**
     * Writes an 8bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUint8 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 1;
        var capacity1 = this.buffer.byteLength;
        if (offset > capacity1)
            this.resize((capacity1 *= 2) > offset ? capacity1 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8;

    /**
     * Reads an 8bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint8 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var value = this.view[offset];
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8;

    // types/ints/int16

    /**
     * Writes a 16bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeInt16 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 2;
        var capacity2 = this.buffer.byteLength;
        if (offset > capacity2)
            this.resize((capacity2 *= 2) > offset ? capacity2 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset+1] = (value & 0xFF00) >>> 8;
            this.view[offset  ] =  value & 0x00FF;
        } else {
            this.view[offset]   = (value & 0xFF00) >>> 8;
            this.view[offset+1] =  value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16;

    /**
     * Reads a 16bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readInt16 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset  ];
            value |= this.view[offset+1] << 8;
        } else {
            value  = this.view[offset  ] << 8;
            value |= this.view[offset+1];
        }
        if ((value & 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16;

    /**
     * Writes a 16bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUint16 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 2;
        var capacity3 = this.buffer.byteLength;
        if (offset > capacity3)
            this.resize((capacity3 *= 2) > offset ? capacity3 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset+1] = (value & 0xFF00) >>> 8;
            this.view[offset  ] =  value & 0x00FF;
        } else {
            this.view[offset]   = (value & 0xFF00) >>> 8;
            this.view[offset+1] =  value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16;

    /**
     * Reads a 16bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUint16 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset  ];
            value |= this.view[offset+1] << 8;
        } else {
            value  = this.view[offset  ] << 8;
            value |= this.view[offset+1];
        }
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16;

    // types/ints/int32

    /**
     * Writes a 32bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity4 = this.buffer.byteLength;
        if (offset > capacity4)
            this.resize((capacity4 *= 2) > offset ? capacity4 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset+3] = (value >>> 24) & 0xFF;
            this.view[offset+2] = (value >>> 16) & 0xFF;
            this.view[offset+1] = (value >>>  8) & 0xFF;
            this.view[offset  ] =  value         & 0xFF;
        } else {
            this.view[offset  ] = (value >>> 24) & 0xFF;
            this.view[offset+1] = (value >>> 16) & 0xFF;
            this.view[offset+2] = (value >>>  8) & 0xFF;
            this.view[offset+3] =  value         & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32;

    /**
     * Reads a 32bit signed integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset+2] << 16;
            value |= this.view[offset+1] <<  8;
            value |= this.view[offset  ];
            value += this.view[offset+3] << 24 >>> 0;
        } else {
            value  = this.view[offset+1] << 16;
            value |= this.view[offset+2] <<  8;
            value |= this.view[offset+3];
            value += this.view[offset  ] << 24 >>> 0;
        }
        value |= 0; // Cast to signed
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32;

    /**
     * Writes a 32bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUint32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity5 = this.buffer.byteLength;
        if (offset > capacity5)
            this.resize((capacity5 *= 2) > offset ? capacity5 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset+3] = (value >>> 24) & 0xFF;
            this.view[offset+2] = (value >>> 16) & 0xFF;
            this.view[offset+1] = (value >>>  8) & 0xFF;
            this.view[offset  ] =  value         & 0xFF;
        } else {
            this.view[offset  ] = (value >>> 24) & 0xFF;
            this.view[offset+1] = (value >>> 16) & 0xFF;
            this.view[offset+2] = (value >>>  8) & 0xFF;
            this.view[offset+3] =  value         & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32;

    /**
     * Reads a 32bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset+2] << 16;
            value |= this.view[offset+1] <<  8;
            value |= this.view[offset  ];
            value += this.view[offset+3] << 24 >>> 0;
        } else {
            value  = this.view[offset+1] << 16;
            value |= this.view[offset+2] <<  8;
            value |= this.view[offset+3];
            value += this.view[offset  ] << 24 >>> 0;
        }
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32;

    // types/ints/int64

    if (Long) {

        /**
         * Writes a 64bit signed integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeInt64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            offset += 8;
            var capacity6 = this.buffer.byteLength;
            if (offset > capacity6)
                this.resize((capacity6 *= 2) > offset ? capacity6 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset+3] = (lo >>> 24) & 0xFF;
                this.view[offset+2] = (lo >>> 16) & 0xFF;
                this.view[offset+1] = (lo >>>  8) & 0xFF;
                this.view[offset  ] =  lo         & 0xFF;
                offset += 4;
                this.view[offset+3] = (hi >>> 24) & 0xFF;
                this.view[offset+2] = (hi >>> 16) & 0xFF;
                this.view[offset+1] = (hi >>>  8) & 0xFF;
                this.view[offset  ] =  hi         & 0xFF;
            } else {
                this.view[offset  ] = (hi >>> 24) & 0xFF;
                this.view[offset+1] = (hi >>> 16) & 0xFF;
                this.view[offset+2] = (hi >>>  8) & 0xFF;
                this.view[offset+3] =  hi         & 0xFF;
                offset += 4;
                this.view[offset  ] = (lo >>> 24) & 0xFF;
                this.view[offset+1] = (lo >>> 16) & 0xFF;
                this.view[offset+2] = (lo >>>  8) & 0xFF;
                this.view[offset+3] =  lo         & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64;

        /**
         * Reads a 64bit signed integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readInt64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo  = this.view[offset+2] << 16;
                lo |= this.view[offset+1] <<  8;
                lo |= this.view[offset  ];
                lo += this.view[offset+3] << 24 >>> 0;
                offset += 4;
                hi  = this.view[offset+2] << 16;
                hi |= this.view[offset+1] <<  8;
                hi |= this.view[offset  ];
                hi += this.view[offset+3] << 24 >>> 0;
            } else {
                hi  = this.view[offset+1] << 16;
                hi |= this.view[offset+2] <<  8;
                hi |= this.view[offset+3];
                hi += this.view[offset  ] << 24 >>> 0;
                offset += 4;
                lo  = this.view[offset+1] << 16;
                lo |= this.view[offset+2] <<  8;
                lo |= this.view[offset+3];
                lo += this.view[offset  ] << 24 >>> 0;
            }
            var value = new Long(lo, hi, false);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64;

        /**
         * Writes a 64bit unsigned integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUint64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            offset += 8;
            var capacity7 = this.buffer.byteLength;
            if (offset > capacity7)
                this.resize((capacity7 *= 2) > offset ? capacity7 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset+3] = (lo >>> 24) & 0xFF;
                this.view[offset+2] = (lo >>> 16) & 0xFF;
                this.view[offset+1] = (lo >>>  8) & 0xFF;
                this.view[offset  ] =  lo         & 0xFF;
                offset += 4;
                this.view[offset+3] = (hi >>> 24) & 0xFF;
                this.view[offset+2] = (hi >>> 16) & 0xFF;
                this.view[offset+1] = (hi >>>  8) & 0xFF;
                this.view[offset  ] =  hi         & 0xFF;
            } else {
                this.view[offset  ] = (hi >>> 24) & 0xFF;
                this.view[offset+1] = (hi >>> 16) & 0xFF;
                this.view[offset+2] = (hi >>>  8) & 0xFF;
                this.view[offset+3] =  hi         & 0xFF;
                offset += 4;
                this.view[offset  ] = (lo >>> 24) & 0xFF;
                this.view[offset+1] = (lo >>> 16) & 0xFF;
                this.view[offset+2] = (lo >>>  8) & 0xFF;
                this.view[offset+3] =  lo         & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.
         * @function
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64;

        /**
         * Reads a 64bit unsigned integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUint64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo  = this.view[offset+2] << 16;
                lo |= this.view[offset+1] <<  8;
                lo |= this.view[offset  ];
                lo += this.view[offset+3] << 24 >>> 0;
                offset += 4;
                hi  = this.view[offset+2] << 16;
                hi |= this.view[offset+1] <<  8;
                hi |= this.view[offset  ];
                hi += this.view[offset+3] << 24 >>> 0;
            } else {
                hi  = this.view[offset+1] << 16;
                hi |= this.view[offset+2] <<  8;
                hi |= this.view[offset+3];
                hi += this.view[offset  ] << 24 >>> 0;
                offset += 4;
                lo  = this.view[offset+1] << 16;
                lo |= this.view[offset+2] <<  8;
                lo |= this.view[offset+3];
                lo += this.view[offset  ] << 24 >>> 0;
            }
            var value = new Long(lo, hi, true);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.
         * @function
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64;

    } // Long


    // types/floats/float32

    /*
     ieee754 - https://github.com/feross/ieee754

     The MIT License (MIT)

     Copyright (c) Feross Aboukhadijeh

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE.
    */

    /**
     * Reads an IEEE754 float from a byte array.
     * @param {!Array} buffer
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @returns {number}
     * @inner
     */
    function ieee754_read(buffer, offset, isLE, mLen, nBytes) {
        var e, m,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            nBits = -7,
            i = isLE ? (nBytes - 1) : 0,
            d = isLE ? -1 : 1,
            s = buffer[offset + i];

        i += d;

        e = s & ((1 << (-nBits)) - 1);
        s >>= (-nBits);
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & ((1 << (-nBits)) - 1);
        e >>= (-nBits);
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
            e = 1 - eBias;
        } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity);
        } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    }

    /**
     * Writes an IEEE754 float to a byte array.
     * @param {!Array} buffer
     * @param {number} value
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @inner
     */
    function ieee754_write(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
            i = isLE ? 0 : (nBytes - 1),
            d = isLE ? 1 : -1,
            s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
        } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
            }
            if (e + eBias >= 1) {
                value += rt / c;
            } else {
                value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
                e++;
                c /= 2;
            }

            if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
            }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

        e = (e << mLen) | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128;
    }

    /**
     * Writes a 32bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number')
                throw TypeError("Illegal value: "+value+" (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity8 = this.buffer.byteLength;
        if (offset > capacity8)
            this.resize((capacity8 *= 2) > offset ? capacity8 : offset);
        offset -= 4;
        ieee754_write(this.view, value, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32;

    /**
     * Reads a 32bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32;

    // types/floats/float64

    /**
     * Writes a 64bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat64 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number')
                throw TypeError("Illegal value: "+value+" (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 8;
        var capacity9 = this.buffer.byteLength;
        if (offset > capacity9)
            this.resize((capacity9 *= 2) > offset ? capacity9 : offset);
        offset -= 8;
        ieee754_write(this.view, value, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return this;
    };

    /**
     * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64;

    /**
     * Reads a 64bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat64 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 8 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return value;
    };

    /**
     * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64;


    // types/varints/varint32

    /**
     * Maximum number of bytes required to store a 32bit base 128 variable-length integer.
     * @type {number}
     * @const
     * @expose
     */
    ByteBuffer.MAX_VARINT32_BYTES = 5;

    /**
     * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
     * @param {number} value Value to encode
     * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}
     * @expose
     */
    ByteBuffer.calculateVarint32 = function(value) {
        // ref: src/google/protobuf/io/coded_stream.cc
        value = value >>> 0;
             if (value < 1 << 7 ) return 1;
        else if (value < 1 << 14) return 2;
        else if (value < 1 << 21) return 3;
        else if (value < 1 << 28) return 4;
        else                      return 5;
    };

    /**
     * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
     * @param {number} n Signed 32bit integer
     * @returns {number} Unsigned zigzag encoded 32bit integer
     * @expose
     */
    ByteBuffer.zigZagEncode32 = function(n) {
        return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Decodes a zigzag encoded signed 32bit integer.
     * @param {number} n Unsigned zigzag encoded 32bit integer
     * @returns {number} Signed 32bit integer
     * @expose
     */
    ByteBuffer.zigZagDecode32 = function(n) {
        return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Writes a 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var size = ByteBuffer.calculateVarint32(value),
            b;
        offset += size;
        var capacity10 = this.buffer.byteLength;
        if (offset > capacity10)
            this.resize((capacity10 *= 2) > offset ? capacity10 : offset);
        offset -= size;
        value >>>= 0;
        while (value >= 0x80) {
            b = (value & 0x7f) | 0x80;
            this.view[offset++] = b;
            value >>>= 7;
        }
        this.view[offset++] = value;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return size;
    };

    /**
     * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32ZigZag = function(value, offset) {
        return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);
    };

    /**
     * Reads a 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available
     *  to fully decode the varint.
     * @expose
     */
    ByteBufferPrototype.readVarint32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var c = 0,
            value = 0 >>> 0,
            b;
        do {
            if (!this.noAssert && offset > this.limit) {
                var err = Error("Truncated");
                err['truncated'] = true;
                throw err;
            }
            b = this.view[offset++];
            if (c < 5)
                value |= (b & 0x7f) << (7*c);
            ++c;
        } while ((b & 0x80) !== 0);
        value |= 0;
        if (relative) {
            this.offset = offset;
            return value;
        }
        return {
            "value": value,
            "length": c
        };
    };

    /**
     * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint
     * @expose
     */
    ByteBufferPrototype.readVarint32ZigZag = function(offset) {
        var val = this.readVarint32(offset);
        if (typeof val === 'object')
            val["value"] = ByteBuffer.zigZagDecode32(val["value"]);
        else
            val = ByteBuffer.zigZagDecode32(val);
        return val;
    };

    // types/varints/varint64

    if (Long) {

        /**
         * Maximum number of bytes required to store a 64bit base 128 variable-length integer.
         * @type {number}
         * @const
         * @expose
         */
        ByteBuffer.MAX_VARINT64_BYTES = 10;

        /**
         * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
         * @param {number|!Long} value Value to encode
         * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}
         * @expose
         */
        ByteBuffer.calculateVarint64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            // ref: src/google/protobuf/io/coded_stream.cc
            var part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            if (part2 == 0) {
                if (part1 == 0) {
                    if (part0 < 1 << 14)
                        return part0 < 1 << 7 ? 1 : 2;
                    else
                        return part0 < 1 << 21 ? 3 : 4;
                } else {
                    if (part1 < 1 << 14)
                        return part1 < 1 << 7 ? 5 : 6;
                    else
                        return part1 < 1 << 21 ? 7 : 8;
                }
            } else
                return part2 < 1 << 7 ? 9 : 10;
        };

        /**
         * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
         * @param {number|!Long} value Signed long
         * @returns {!Long} Unsigned zigzag encoded long
         * @expose
         */
        ByteBuffer.zigZagEncode64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();
        };

        /**
         * Decodes a zigzag encoded signed 64bit integer.
         * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number
         * @returns {!Long} Signed long
         * @expose
         */
        ByteBuffer.zigZagDecode64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();
        };

        /**
         * Writes a 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            var size = ByteBuffer.calculateVarint64(value),
                part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            offset += size;
            var capacity11 = this.buffer.byteLength;
            if (offset > capacity11)
                this.resize((capacity11 *= 2) > offset ? capacity11 : offset);
            offset -= size;
            switch (size) {
                case 10: this.view[offset+9] = (part2 >>>  7) & 0x01;
                case 9 : this.view[offset+8] = size !== 9 ? (part2       ) | 0x80 : (part2       ) & 0x7F;
                case 8 : this.view[offset+7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
                case 7 : this.view[offset+6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
                case 6 : this.view[offset+5] = size !== 6 ? (part1 >>>  7) | 0x80 : (part1 >>>  7) & 0x7F;
                case 5 : this.view[offset+4] = size !== 5 ? (part1       ) | 0x80 : (part1       ) & 0x7F;
                case 4 : this.view[offset+3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
                case 3 : this.view[offset+2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
                case 2 : this.view[offset+1] = size !== 2 ? (part0 >>>  7) | 0x80 : (part0 >>>  7) & 0x7F;
                case 1 : this.view[offset  ] = size !== 1 ? (part0       ) | 0x80 : (part0       ) & 0x7F;
            }
            if (relative) {
                this.offset += size;
                return this;
            } else {
                return size;
            }
        };

        /**
         * Writes a zig-zag encoded 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64ZigZag = function(value, offset) {
            return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);
        };

        /**
         * Reads a 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 1 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
            }
            // ref: src/google/protobuf/io/coded_stream.cc
            var start = offset,
                part0 = 0,
                part1 = 0,
                part2 = 0,
                b  = 0;
            b = this.view[offset++]; part0  = (b & 0x7F)      ; if ( b & 0x80                                                   ) {
            b = this.view[offset++]; part0 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            throw Error("Buffer overrun"); }}}}}}}}}}
            var value = Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, false);
            if (relative) {
                this.offset = offset;
                return value;
            } else {
                return {
                    'value': value,
                    'length': offset-start
                };
            }
        };

        /**
         * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64ZigZag = function(offset) {
            var val = this.readVarint64(offset);
            if (val && val['value'] instanceof Long)
                val["value"] = ByteBuffer.zigZagDecode64(val["value"]);
            else
                val = ByteBuffer.zigZagDecode64(val);
            return val;
        };

    } // Long


    // types/strings/cstring

    /**
     * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL
     *  characters itself.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  contained in `str` + 1 if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeCString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        var i,
            k = str.length;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            for (i=0; i<k; ++i) {
                if (str.charCodeAt(i) === 0)
                    throw RangeError("Illegal str: Contains NULL-characters");
            }
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        // UTF8 strings do not contain zero bytes in between except for the zero character, so:
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k+1;
        var capacity12 = this.buffer.byteLength;
        if (offset > capacity12)
            this.resize((capacity12 *= 2) > offset ? capacity12 : offset);
        offset -= k+1;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        this.view[offset++] = 0;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return k;
    };

    /**
     * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters
     *  itself.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readCString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            temp;
        // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:
        var sd, b = -1;
        utfx.decodeUTF8toUTF16(function() {
            if (b === 0) return null;
            if (offset >= this.limit)
                throw RangeError("Illegal range: Truncated data, "+offset+" < "+this.limit);
            b = this.view[offset++];
            return b === 0 ? null : b;
        }.bind(this), sd = stringDestination(), true);
        if (relative) {
            this.offset = offset;
            return sd();
        } else {
            return {
                "string": sd(),
                "length": offset - start
            };
        }
    };

    // types/strings/istring

    /**
     * Writes a length as uint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeIString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            k;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        offset += 4+k;
        var capacity13 = this.buffer.byteLength;
        if (offset > capacity13)
            this.resize((capacity13 *= 2) > offset ? capacity13 : offset);
        offset -= 4+k;
        if (this.littleEndian) {
            this.view[offset+3] = (k >>> 24) & 0xFF;
            this.view[offset+2] = (k >>> 16) & 0xFF;
            this.view[offset+1] = (k >>>  8) & 0xFF;
            this.view[offset  ] =  k         & 0xFF;
        } else {
            this.view[offset  ] = (k >>> 24) & 0xFF;
            this.view[offset+1] = (k >>> 16) & 0xFF;
            this.view[offset+2] = (k >>>  8) & 0xFF;
            this.view[offset+3] =  k         & 0xFF;
        }
        offset += 4;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start + 4 + k)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+4+k));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as uint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readIString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var start = offset;
        var len = this.readUint32(offset);
        var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);
        offset += str['length'];
        if (relative) {
            this.offset = offset;
            return str['string'];
        } else {
            return {
                'string': str['string'],
                'length': offset - start
            };
        }
    };

    // types/strings/utf8string

    /**
     * Metrics representing number of UTF8 characters. Evaluates to `c`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_CHARS = 'c';

    /**
     * Metrics representing number of bytes. Evaluates to `b`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_BYTES = 'b';

    /**
     * Writes an UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeUTF8String = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var k;
        var start = offset;
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k;
        var capacity14 = this.buffer.byteLength;
        if (offset > capacity14)
            this.resize((capacity14 *= 2) > offset ? capacity14 : offset);
        offset -= k;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.
     * @function
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;

    /**
     * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's
     *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 characters
     * @expose
     */
    ByteBuffer.calculateUTF8Chars = function(str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[0];
    };

    /**
     * Calculates the number of UTF8 bytes of a string.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateUTF8Bytes = function(str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[1];
    };

    /**
     * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.
     * @function
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;

    /**
     * Reads an UTF8 encoded string.
     * @param {number} length Number of characters or bytes to read.
     * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readUTF8String = function(length, metrics, offset) {
        if (typeof metrics === 'number') {
            offset = metrics;
            metrics = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0)
                throw TypeError("Illegal length: "+length+" (not an integer)");
            length |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var i = 0,
            start = offset,
            sd;
        if (metrics === ByteBuffer.METRICS_CHARS) { // The same for node and the browser
            sd = stringDestination();
            utfx.decodeUTF8(function() {
                return i < length && offset < this.limit ? this.view[offset++] : null;
            }.bind(this), function(cp) {
                ++i; utfx.UTF8toUTF16(cp, sd);
            });
            if (i !== length)
                throw RangeError("Illegal range: Truncated data, "+i+" == "+length);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    "string": sd(),
                    "length": offset - start
                };
            }
        } else if (metrics === ByteBuffer.METRICS_BYTES) {
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + length > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
            }
            var k = offset + length;
            utfx.decodeUTF8toUTF16(function() {
                return offset < k ? this.view[offset++] : null;
            }.bind(this), sd = stringDestination(), this.noAssert);
            if (offset !== k)
                throw RangeError("Illegal range: Truncated data, "+offset+" == "+k);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    'string': sd(),
                    'length': offset - start
                };
            }
        } else
            throw TypeError("Unsupported metrics: "+metrics);
    };

    /**
     * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.
     * @function
     * @param {number} length Number of characters or bytes to read
     * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String;

    // types/strings/vstring

    /**
     * Writes a length as varint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeVString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            k, l;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        l = ByteBuffer.calculateVarint32(k);
        offset += l+k;
        var capacity15 = this.buffer.byteLength;
        if (offset > capacity15)
            this.resize((capacity15 *= 2) > offset ? capacity15 : offset);
        offset -= l+k;
        offset += this.writeVarint32(k, offset);
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start+k+l)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+k+l));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as varint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readVString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var start = offset;
        var len = this.readVarint32(offset);
        var str = this.readUTF8String(len['value'], ByteBuffer.METRICS_BYTES, offset += len['length']);
        offset += str['length'];
        if (relative) {
            this.offset = offset;
            return str['string'];
        } else {
            return {
                'string': str['string'],
                'length': offset - start
            };
        }
    };


    /**
     * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended
     *  data's length.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`
     * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`
     */
    ByteBufferPrototype.append = function(source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer))
            source = ByteBuffer.wrap(source, encoding);
        var length = source.limit - source.offset;
        if (length <= 0) return this; // Nothing to append
        offset += length;
        var capacity16 = this.buffer.byteLength;
        if (offset > capacity16)
            this.resize((capacity16 *= 2) > offset ? capacity16 : offset);
        offset -= length;
        this.view.set(source.view.subarray(source.offset, source.limit), offset);
        source.offset += length;
        if (relative) this.offset += length;
        return this;
    };

    /**
     * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the
        specified offset up to the length of this ByteBuffer's data.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#append
     */
    ByteBufferPrototype.appendTo = function(target, offset) {
        target.append(this, offset);
        return this;
    };

    /**
     * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to
     *  disable them if your code already makes sure that everything is valid.
     * @param {boolean} assert `true` to enable assertions, otherwise `false`
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.assert = function(assert) {
        this.noAssert = !assert;
        return this;
    };

    /**
     * Gets the capacity of this ByteBuffer's backing buffer.
     * @returns {number} Capacity of the backing buffer
     * @expose
     */
    ByteBufferPrototype.capacity = function() {
        return this.buffer.byteLength;
    };
    /**
     * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the
     *  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.clear = function() {
        this.offset = 0;
        this.limit = this.buffer.byteLength;
        this.markedOffset = -1;
        return this;
    };

    /**
     * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},
     *  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.
     * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`
     * @returns {!ByteBuffer} Cloned instance
     * @expose
     */
    ByteBufferPrototype.clone = function(copy) {
        var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);
        if (copy) {
            bb.buffer = new ArrayBuffer(this.buffer.byteLength);
            bb.view = new Uint8Array(bb.buffer);
        } else {
            bb.buffer = this.buffer;
            bb.view = this.view;
        }
        bb.offset = this.offset;
        bb.markedOffset = this.markedOffset;
        bb.limit = this.limit;
        return bb;
    };

    /**
     * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes
     *  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and
     *  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.compact = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === 0 && end === this.buffer.byteLength)
            return this; // Already compacted
        var len = end - begin;
        if (len === 0) {
            this.buffer = EMPTY_BUFFER;
            this.view = null;
            if (this.markedOffset >= 0) this.markedOffset -= begin;
            this.offset = 0;
            this.limit = 0;
            return this;
        }
        var buffer = new ArrayBuffer(len);
        var view = new Uint8Array(buffer);
        view.set(this.view.subarray(begin, end));
        this.buffer = buffer;
        this.view = view;
        if (this.markedOffset >= 0) this.markedOffset -= begin;
        this.offset = 0;
        this.limit = len;
        return this;
    };

    /**
     * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Copy
     * @expose
     */
    ByteBufferPrototype.copy = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === end)
            return new ByteBuffer(0, this.littleEndian, this.noAssert);
        var capacity = end - begin,
            bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);
        bb.offset = 0;
        bb.limit = capacity;
        if (bb.markedOffset >= 0) bb.markedOffset -= begin;
        this.copyTo(bb, 0, begin, end);
        return bb;
    };

    /**
     * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}
     *  by the number of bytes copied if omitted.
     * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the
     *  number of bytes copied if omitted.
     * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.copyTo = function(target, targetOffset, sourceOffset, sourceLimit) {
        var relative,
            targetRelative;
        if (!this.noAssert) {
            if (!ByteBuffer.isByteBuffer(target))
                throw TypeError("Illegal target: Not a ByteBuffer");
        }
        targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0;
        sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0;
        sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0;

        if (targetOffset < 0 || targetOffset > target.buffer.byteLength)
            throw RangeError("Illegal target range: 0 <= "+targetOffset+" <= "+target.buffer.byteLength);
        if (sourceOffset < 0 || sourceLimit > this.buffer.byteLength)
            throw RangeError("Illegal source range: 0 <= "+sourceOffset+" <= "+this.buffer.byteLength);

        var len = sourceLimit - sourceOffset;
        if (len === 0)
            return target; // Nothing to copy

        target.ensureCapacity(targetOffset + len);

        target.view.set(this.view.subarray(sourceOffset, sourceLimit), targetOffset);

        if (relative) this.offset += len;
        if (targetRelative) target.offset += len;

        return this;
    };

    /**
     * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the
     *  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,
     *  the required capacity will be used instead.
     * @param {number} capacity Required capacity
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.ensureCapacity = function(capacity) {
        var current = this.buffer.byteLength;
        if (current < capacity)
            return this.resize((current *= 2) > capacity ? current : capacity);
        return this;
    };

    /**
     * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {number|string} value Byte value to fill with. If given as a string, the first character is used.
     * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted. defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} this
     * @expose
     * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes
     */
    ByteBufferPrototype.fill = function(value, begin, end) {
        var relative = typeof begin === 'undefined';
        if (relative) begin = this.offset;
        if (typeof value === 'string' && value.length > 0)
            value = value.charCodeAt(0);
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin >= end)
            return this; // Nothing to fill
        while (begin < end) this.view[begin++] = value;
        if (relative) this.offset = begin;
        return this;
    };

    /**
     * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and
     *  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.flip = function() {
        this.limit = this.offset;
        this.offset = 0;
        return this;
    };
    /**
     * Marks an offset on this ByteBuffer to be used later.
     * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @see ByteBuffer#reset
     * @expose
     */
    ByteBufferPrototype.mark = function(offset) {
        offset = typeof offset === 'undefined' ? this.offset : offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        this.markedOffset = offset;
        return this;
    };
    /**
     * Sets the byte order.
     * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.order = function(littleEndian) {
        if (!this.noAssert) {
            if (typeof littleEndian !== 'boolean')
                throw TypeError("Illegal littleEndian: Not a boolean");
        }
        this.littleEndian = !!littleEndian;
        return this;
    };

    /**
     * Switches (to) little endian byte order.
     * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.LE = function(littleEndian) {
        this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true;
        return this;
    };

    /**
     * Switches (to) big endian byte order.
     * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.BE = function(bigEndian) {
        this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false;
        return this;
    };
    /**
     * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be
     *  modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`
     * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`
     */
    ByteBufferPrototype.prepend = function(source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer))
            source = ByteBuffer.wrap(source, encoding);
        var len = source.limit - source.offset;
        if (len <= 0) return this; // Nothing to prepend
        var diff = len - offset;
        if (diff > 0) { // Not enough space before offset, so resize + move
            var buffer = new ArrayBuffer(this.buffer.byteLength + diff);
            var view = new Uint8Array(buffer);
            view.set(this.view.subarray(offset, this.buffer.byteLength), len);
            this.buffer = buffer;
            this.view = view;
            this.offset += diff;
            if (this.markedOffset >= 0) this.markedOffset += diff;
            this.limit += diff;
            offset += diff;
        } else {
            var arrayView = new Uint8Array(this.buffer);
        }
        this.view.set(source.view.subarray(source.offset, source.limit), offset - len);

        source.offset = source.limit;
        if (relative)
            this.offset -= len;
        return this;
    };

    /**
     * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#prepend
     */
    ByteBufferPrototype.prependTo = function(target, offset) {
        target.prepend(this, offset);
        return this;
    };
    /**
     * Prints debug information about this ByteBuffer's contents.
     * @param {function(string)=} out Output function to call, defaults to console.log
     * @expose
     */
    ByteBufferPrototype.printDebug = function(out) {
        if (typeof out !== 'function') out = console.log.bind(console);
        out(
            this.toString()+"\n"+
            "-------------------------------------------------------------------\n"+
            this.toDebug(/* columns */ true)
        );
    };

    /**
     * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}, so this returns `limit - offset`.
     * @returns {number} Remaining readable bytes. May be negative if `offset > limit`.
     * @expose
     */
    ByteBufferPrototype.remaining = function() {
        return this.limit - this.offset;
    };
    /**
     * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}
     *  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been
     *  marked, sets `offset = 0`.
     * @returns {!ByteBuffer} this
     * @see ByteBuffer#mark
     * @expose
     */
    ByteBufferPrototype.reset = function() {
        if (this.markedOffset >= 0) {
            this.offset = this.markedOffset;
            this.markedOffset = -1;
        } else {
            this.offset = 0;
        }
        return this;
    };
    /**
     * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that
     *  large or larger.
     * @param {number} capacity Capacity required
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `capacity` is not a number
     * @throws {RangeError} If `capacity < 0`
     * @expose
     */
    ByteBufferPrototype.resize = function(capacity) {
        if (!this.noAssert) {
            if (typeof capacity !== 'number' || capacity % 1 !== 0)
                throw TypeError("Illegal capacity: "+capacity+" (not an integer)");
            capacity |= 0;
            if (capacity < 0)
                throw RangeError("Illegal capacity: 0 <= "+capacity);
        }
        if (this.buffer.byteLength < capacity) {
            var buffer = new ArrayBuffer(capacity);
            var view = new Uint8Array(buffer);
            view.set(this.view);
            this.buffer = buffer;
            this.view = view;
        }
        return this;
    };
    /**
     * Reverses this ByteBuffer's contents.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.reverse = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === end)
            return this; // Nothing to reverse
        Array.prototype.reverse.call(this.view.subarray(begin, end));
        return this;
    };
    /**
     * Skips the next `length` bytes. This will just advance
     * @param {number} length Number of bytes to skip. May also be negative to move the offset back.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.skip = function(length) {
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0)
                throw TypeError("Illegal length: "+length+" (not an integer)");
            length |= 0;
        }
        var offset = this.offset + length;
        if (!this.noAssert) {
            if (offset < 0 || offset > this.buffer.byteLength)
                throw RangeError("Illegal length: 0 <= "+this.offset+" + "+length+" <= "+this.buffer.byteLength);
        }
        this.offset = offset;
        return this;
    };

    /**
     * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}
     * @expose
     */
    ByteBufferPrototype.slice = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var bb = this.clone();
        bb.offset = begin;
        bb.limit = end;
        return bb;
    };
    /**
     * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if
     *  possible. Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toBuffer = function(forceCopy) {
        var offset = this.offset,
            limit = this.limit;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: Not an integer");
            offset >>>= 0;
            if (typeof limit !== 'number' || limit % 1 !== 0)
                throw TypeError("Illegal limit: Not an integer");
            limit >>>= 0;
            if (offset < 0 || offset > limit || limit > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+offset+" <= "+limit+" <= "+this.buffer.byteLength);
        }
        // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is
        // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:
        if (!forceCopy && offset === 0 && limit === this.buffer.byteLength)
            return this.buffer;
        if (offset === limit)
            return EMPTY_BUFFER;
        var buffer = new ArrayBuffer(limit - offset);
        new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0);
        return buffer;
    };

    /**
     * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}.
     * @function
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.
     *  Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer;

    /**
     * Converts the ByteBuffer's contents to a string.
     * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows
     *  direct conversion to "utf8", "hex", "base64" and "binary" encoding. "debug" returns a hex representation with
     *  highlighted offsets.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {string} String representation
     * @throws {Error} If `encoding` is invalid
     * @expose
     */
    ByteBufferPrototype.toString = function(encoding, begin, end) {
        if (typeof encoding === 'undefined')
            return "ByteBufferAB(offset="+this.offset+",markedOffset="+this.markedOffset+",limit="+this.limit+",capacity="+this.capacity()+")";
        if (typeof encoding === 'number')
            encoding = "utf8",
            begin = encoding,
            end = begin;
        switch (encoding) {
            case "utf8":
                return this.toUTF8(begin, end);
            case "base64":
                return this.toBase64(begin, end);
            case "hex":
                return this.toHex(begin, end);
            case "binary":
                return this.toBinary(begin, end);
            case "debug":
                return this.toDebug();
            case "columns":
                return this.toColumns();
            default:
                throw Error("Unsupported encoding: "+encoding);
        }
    };

    // lxiv-embeddable

    /**
     * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/lxiv for details
     */
    var lxiv = function() {
        "use strict";

        /**
         * lxiv namespace.
         * @type {!Object.<string,*>}
         * @exports lxiv
         */
        var lxiv = {};

        /**
         * Character codes for output.
         * @type {!Array.<number>}
         * @inner
         */
        var aout = [
            65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
            81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102,
            103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
            119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47
        ];

        /**
         * Character codes for input.
         * @type {!Array.<number>}
         * @inner
         */
        var ain = [];
        for (var i=0, k=aout.length; i<k; ++i)
            ain[aout[i]] = i;

        /**
         * Encodes bytes to base64 char codes.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if
         *  there are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each encoded char
         *  code.
         */
        lxiv.encode = function(src, dst) {
            var b, t;
            while ((b = src()) !== null) {
                dst(aout[(b>>2)&0x3f]);
                t = (b&0x3)<<4;
                if ((b = src()) !== null) {
                    t |= (b>>4)&0xf;
                    dst(aout[(t|((b>>4)&0xf))&0x3f]);
                    t = (b&0xf)<<2;
                    if ((b = src()) !== null)
                        dst(aout[(t|((b>>6)&0x3))&0x3f]),
                        dst(aout[b&0x3f]);
                    else
                        dst(aout[t&0x3f]),
                        dst(61);
                } else
                    dst(aout[t&0x3f]),
                    dst(61),
                    dst(61);
            }
        };

        /**
         * Decodes base64 char codes to bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         * @throws {Error} If a character code is invalid
         */
        lxiv.decode = function(src, dst) {
            var c, t1, t2;
            function fail(c) {
                throw Error("Illegal character code: "+c);
            }
            while ((c = src()) !== null) {
                t1 = ain[c];
                if (typeof t1 === 'undefined') fail(c);
                if ((c = src()) !== null) {
                    t2 = ain[c];
                    if (typeof t2 === 'undefined') fail(c);
                    dst((t1<<2)>>>0|(t2&0x30)>>4);
                    if ((c = src()) !== null) {
                        t1 = ain[c];
                        if (typeof t1 === 'undefined')
                            if (c === 61) break; else fail(c);
                        dst(((t2&0xf)<<4)>>>0|(t1&0x3c)>>2);
                        if ((c = src()) !== null) {
                            t2 = ain[c];
                            if (typeof t2 === 'undefined')
                                if (c === 61) break; else fail(c);
                            dst(((t1&0x3)<<6)>>>0|t2);
                        }
                    }
                }
            }
        };

        /**
         * Tests if a string is valid base64.
         * @param {string} str String to test
         * @returns {boolean} `true` if valid, otherwise `false`
         */
        lxiv.test = function(str) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);
        };

        return lxiv;
    }();

    // encodings/base64

    /**
     * Encodes this ByteBuffer's contents to a base64 encoded string.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.
     * @returns {string} Base64 encoded string
     * @throws {RangeError} If `begin` or `end` is out of bounds
     * @expose
     */
    ByteBufferPrototype.toBase64 = function(begin, end) {
        if (typeof begin === 'undefined')
            begin = this.offset;
        if (typeof end === 'undefined')
            end = this.limit;
        begin = begin | 0; end = end | 0;
        if (begin < 0 || end > this.capacity || begin > end)
            throw RangeError("begin, end");
        var sd; lxiv.encode(function() {
            return begin < end ? this.view[begin++] : null;
        }.bind(this), sd = stringDestination());
        return sd();
    };

    /**
     * Decodes a base64 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBase64 = function(str, littleEndian) {
        if (typeof str !== 'string')
            throw TypeError("str");
        var bb = new ByteBuffer(str.length/4*3, littleEndian),
            i = 0;
        lxiv.decode(stringSource(str), function(b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    /**
     * Encodes a binary string to base64 like `window.btoa` does.
     * @param {string} str Binary string
     * @returns {string} Base64 encoded string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
     * @expose
     */
    ByteBuffer.btoa = function(str) {
        return ByteBuffer.fromBinary(str).toBase64();
    };

    /**
     * Decodes a base64 encoded string to binary like `window.atob` does.
     * @param {string} b64 Base64 encoded string
     * @returns {string} Binary string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob
     * @expose
     */
    ByteBuffer.atob = function(b64) {
        return ByteBuffer.fromBase64(b64).toBinary();
    };

    // encodings/binary

    /**
     * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Binary encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toBinary = function(begin, end) {
        if (typeof begin === 'undefined')
            begin = this.offset;
        if (typeof end === 'undefined')
            end = this.limit;
        begin |= 0; end |= 0;
        if (begin < 0 || end > this.capacity() || begin > end)
            throw RangeError("begin, end");
        if (begin === end)
            return "";
        var chars = [],
            parts = [];
        while (begin < end) {
            chars.push(this.view[begin++]);
            if (chars.length >= 1024)
                parts.push(String.fromCharCode.apply(String, chars)),
                chars = [];
        }
        return parts.join('') + String.fromCharCode.apply(String, chars);
    };

    /**
     * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBinary = function(str, littleEndian) {
        if (typeof str !== 'string')
            throw TypeError("str");
        var i = 0,
            k = str.length,
            charCode,
            bb = new ByteBuffer(k, littleEndian);
        while (i<k) {
            charCode = str.charCodeAt(i);
            if (charCode > 0xff)
                throw RangeError("illegal char code: "+charCode);
            bb.view[i++] = charCode;
        }
        bb.limit = k;
        return bb;
    };

    // encodings/debug

    /**
     * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
     * * `<` : offset,
     * * `'` : markedOffset,
     * * `>` : limit,
     * * `|` : offset and limit,
     * * `[` : offset and markedOffset,
     * * `]` : markedOffset and limit,
     * * `!` : offset, markedOffset and limit
     * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`
     * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`
     * @expose
     * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`
     * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`
     * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`
     * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`
     */
    ByteBufferPrototype.toDebug = function(columns) {
        var i = -1,
            k = this.buffer.byteLength,
            b,
            hex = "",
            asc = "",
            out = "";
        while (i<k) {
            if (i !== -1) {
                b = this.view[i];
                if (b < 0x10) hex += "0"+b.toString(16).toUpperCase();
                else hex += b.toString(16).toUpperCase();
                if (columns)
                    asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.';
            }
            ++i;
            if (columns) {
                if (i > 0 && i % 16 === 0 && i !== k) {
                    while (hex.length < 3*16+3) hex += " ";
                    out += hex+asc+"\n";
                    hex = asc = "";
                }
            }
            if (i === this.offset && i === this.limit)
                hex += i === this.markedOffset ? "!" : "|";
            else if (i === this.offset)
                hex += i === this.markedOffset ? "[" : "<";
            else if (i === this.limit)
                hex += i === this.markedOffset ? "]" : ">";
            else
                hex += i === this.markedOffset ? "'" : (columns || (i !== 0 && i !== k) ? " " : "");
        }
        if (columns && hex !== " ") {
            while (hex.length < 3*16+3)
                hex += " ";
            out += hex + asc + "\n";
        }
        return columns ? out : hex;
    };

    /**
     * Decodes a hex encoded string with marked offsets to a ByteBuffer.
     * @param {string} str Debug string to decode (not be generated with `columns = true`)
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     * @see ByteBuffer#toDebug
     */
    ByteBuffer.fromDebug = function(str, littleEndian, noAssert) {
        var k = str.length,
            bb = new ByteBuffer(((k+1)/3)|0, littleEndian, noAssert);
        var i = 0, j = 0, ch, b,
            rs = false, // Require symbol next
            ho = false, hm = false, hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)?
            fail = false;
        while (i<k) {
            switch (ch = str.charAt(i++)) {
                case '!':
                    if (!noAssert) {
                        if (ho || hm || hl) {
                            fail = true;
                            break;
                        }
                        ho = hm = hl = true;
                    }
                    bb.offset = bb.markedOffset = bb.limit = j;
                    rs = false;
                    break;
                case '|':
                    if (!noAssert) {
                        if (ho || hl) {
                            fail = true;
                            break;
                        }
                        ho = hl = true;
                    }
                    bb.offset = bb.limit = j;
                    rs = false;
                    break;
                case '[':
                    if (!noAssert) {
                        if (ho || hm) {
                            fail = true;
                            break;
                        }
                        ho = hm = true;
                    }
                    bb.offset = bb.markedOffset = j;
                    rs = false;
                    break;
                case '<':
                    if (!noAssert) {
                        if (ho) {
                            fail = true;
                            break;
                        }
                        ho = true;
                    }
                    bb.offset = j;
                    rs = false;
                    break;
                case ']':
                    if (!noAssert) {
                        if (hl || hm) {
                            fail = true;
                            break;
                        }
                        hl = hm = true;
                    }
                    bb.limit = bb.markedOffset = j;
                    rs = false;
                    break;
                case '>':
                    if (!noAssert) {
                        if (hl) {
                            fail = true;
                            break;
                        }
                        hl = true;
                    }
                    bb.limit = j;
                    rs = false;
                    break;
                case "'":
                    if (!noAssert) {
                        if (hm) {
                            fail = true;
                            break;
                        }
                        hm = true;
                    }
                    bb.markedOffset = j;
                    rs = false;
                    break;
                case ' ':
                    rs = false;
                    break;
                default:
                    if (!noAssert) {
                        if (rs) {
                            fail = true;
                            break;
                        }
                    }
                    b = parseInt(ch+str.charAt(i++), 16);
                    if (!noAssert) {
                        if (isNaN(b) || b < 0 || b > 255)
                            throw TypeError("Illegal str: Not a debug encoded string");
                    }
                    bb.view[j++] = b;
                    rs = true;
            }
            if (fail)
                throw TypeError("Illegal str: Invalid symbol at "+i);
        }
        if (!noAssert) {
            if (!ho || !hl)
                throw TypeError("Illegal str: Missing offset or limit");
            if (j<bb.buffer.byteLength)
                throw TypeError("Illegal str: Not a debug encoded string (is it hex?) "+j+" < "+k);
        }
        return bb;
    };

    // encodings/hex

    /**
     * Encodes this ByteBuffer's contents to a hex encoded string.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Hex encoded string
     * @expose
     */
    ByteBufferPrototype.toHex = function(begin, end) {
        begin = typeof begin === 'undefined' ? this.offset : begin;
        end = typeof end === 'undefined' ? this.limit : end;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var out = new Array(end - begin),
            b;
        while (begin < end) {
            b = this.view[begin++];
            if (b < 0x10)
                out.push("0", b.toString(16));
            else out.push(b.toString(16));
        }
        return out.join('');
    };

    /**
     * Decodes a hex encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromHex = function(str, littleEndian, noAssert) {
        if (!noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (str.length % 2 !== 0)
                throw TypeError("Illegal str: Length not a multiple of 2");
        }
        var k = str.length,
            bb = new ByteBuffer((k / 2) | 0, littleEndian),
            b;
        for (var i=0, j=0; i<k; i+=2) {
            b = parseInt(str.substring(i, i+2), 16);
            if (!noAssert)
                if (!isFinite(b) || b < 0 || b > 255)
                    throw TypeError("Illegal str: Contains non-hex characters");
            bb.view[j++] = b;
        }
        bb.limit = j;
        return bb;
    };

    // utfx-embeddable

    /**
     * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/utfx for details
     */
    var utfx = function() {
        "use strict";

        /**
         * utfx namespace.
         * @inner
         * @type {!Object.<string,*>}
         */
        var utfx = {};

        /**
         * Maximum valid code point.
         * @type {number}
         * @const
         */
        utfx.MAX_CODEPOINT = 0x10FFFF;

        /**
         * Encodes UTF8 code points to UTF8 bytes.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte
         */
        utfx.encodeUTF8 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src,
                src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp < 0x80)
                    dst(cp&0x7F);
                else if (cp < 0x800)
                    dst(((cp>>6)&0x1F)|0xC0),
                    dst((cp&0x3F)|0x80);
                else if (cp < 0x10000)
                    dst(((cp>>12)&0x0F)|0xE0),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                else
                    dst(((cp>>18)&0x07)|0xF0),
                    dst(((cp>>12)&0x3F)|0x80),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                cp = null;
            }
        };

        /**
         * Decodes UTF8 bytes to UTF8 code points.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the
         *  remaining bytes.
         */
        utfx.decodeUTF8 = function(src, dst) {
            var a, b, c, d, fail = function(b) {
                b = b.slice(0, b.indexOf(null));
                var err = Error(b.toString());
                err.name = "TruncatedError";
                err['bytes'] = b;
                throw err;
            };
            while ((a = src()) !== null) {
                if ((a&0x80) === 0)
                    dst(a);
                else if ((a&0xE0) === 0xC0)
                    ((b = src()) === null) && fail([a, b]),
                    dst(((a&0x1F)<<6) | (b&0x3F));
                else if ((a&0xF0) === 0xE0)
                    ((b=src()) === null || (c=src()) === null) && fail([a, b, c]),
                    dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F));
                else if ((a&0xF8) === 0xF0)
                    ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]),
                    dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F));
                else throw RangeError("Illegal starting byte: "+a);
            }
        };

        /**
         * Converts UTF16 characters to UTF8 code points.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Code points destination as a function successively called with each converted code
         *  point.
         */
        utfx.UTF16toUTF8 = function(src, dst) {
            var c1, c2 = null;
            while (true) {
                if ((c1 = c2 !== null ? c2 : src()) === null)
                    break;
                if (c1 >= 0xD800 && c1 <= 0xDFFF) {
                    if ((c2 = src()) !== null) {
                        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {
                            dst((c1-0xD800)*0x400+c2-0xDC00+0x10000);
                            c2 = null; continue;
                        }
                    }
                }
                dst(c1);
            }
            if (c2 !== null) dst(c2);
        };

        /**
         * Converts UTF8 code points to UTF16 characters.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a code point is out of range
         */
        utfx.UTF8toUTF16 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src, src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp <= 0xFFFF)
                    dst(cp);
                else
                    cp -= 0x10000,
                    dst((cp>>10)+0xD800),
                    dst((cp%0x400)+0xDC00);
                cp = null;
            }
        };

        /**
         * Converts and encodes UTF16 characters to UTF8 bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
         *  if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         */
        utfx.encodeUTF16toUTF8 = function(src, dst) {
            utfx.UTF16toUTF8(src, function(cp) {
                utfx.encodeUTF8(cp, dst);
            });
        };

        /**
         * Decodes and converts UTF8 bytes to UTF16 characters.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
         */
        utfx.decodeUTF8toUTF16 = function(src, dst) {
            utfx.decodeUTF8(src, function(cp) {
                utfx.UTF8toUTF16(cp, dst);
            });
        };

        /**
         * Calculates the byte length of an UTF8 code point.
         * @param {number} cp UTF8 code point
         * @returns {number} Byte length
         */
        utfx.calculateCodePoint = function(cp) {
            return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
        };

        /**
         * Calculates the number of UTF8 bytes required to store UTF8 code points.
         * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
         *  `null` if there are no more code points left.
         * @returns {number} The number of UTF8 bytes required
         */
        utfx.calculateUTF8 = function(src) {
            var cp, l=0;
            while ((cp = src()) !== null)
                l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            return l;
        };

        /**
         * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.
         * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
         */
        utfx.calculateUTF16asUTF8 = function(src) {
            var n=0, l=0;
            utfx.UTF16toUTF8(src, function(cp) {
                ++n; l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            });
            return [n,l];
        };

        return utfx;
    }();

    // encodings/utf8

    /**
     * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded
     *  string.
     * @returns {string} Hex encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toUTF8 = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var sd; try {
            utfx.decodeUTF8toUTF16(function() {
                return begin < end ? this.view[begin++] : null;
            }.bind(this), sd = stringDestination());
        } catch (e) {
            if (begin !== end)
                throw RangeError("Illegal range: Truncated data, "+begin+" != "+end);
        }
        return sd();
    };

    /**
     * Decodes an UTF8 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromUTF8 = function(str, littleEndian, noAssert) {
        if (!noAssert)
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
        var bb = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(str), true)[1], littleEndian, noAssert),
            i = 0;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    return ByteBuffer;
});

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/bytebuffer/dist/bytebuffer.js","/../node_modules/bytebuffer/dist")
},{"buffer":11,"long":72,"pBGvAp":74}],13:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var Transform = require('stream').Transform
var inherits = require('inherits')
var StringDecoder = require('string_decoder').StringDecoder
module.exports = CipherBase
inherits(CipherBase, Transform)
function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  this._decoder = null
  this._encoding = null
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc)
  }
  var outData = this._update(data)
  if (this.hashMode) {
    return this
  }
  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }
  return outData
}

CipherBase.prototype.setAutoPadding = function () {}

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this._final())
  } catch (e) {
    err = e
  } finally {
    done(err)
  }
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this._final() || new Buffer('')
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }
  if (this._encoding !== enc) {
    throw new Error('can\'t switch encodings')
  }
  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }
  return out
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/cipher-base/index.js","/../node_modules/cipher-base")
},{"buffer":11,"inherits":71,"pBGvAp":74,"stream":125,"string_decoder":9}],14:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var inherits = require('inherits')
var md5 = require('./md5')
var rmd160 = require('ripemd160')
var sha = require('sha.js')

var Base = require('cipher-base')

function HashNoConstructor(hash) {
  Base.call(this, 'digest')

  this._hash = hash
  this.buffers = []
}

inherits(HashNoConstructor, Base)

HashNoConstructor.prototype._update = function (data) {
  this.buffers.push(data)
}

HashNoConstructor.prototype._final = function () {
  var buf = Buffer.concat(this.buffers)
  var r = this._hash(buf)
  this.buffers = null

  return r
}

function Hash(hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if ('md5' === alg) return new HashNoConstructor(md5)
  if ('rmd160' === alg || 'ripemd160' === alg) return new HashNoConstructor(rmd160)

  return new Hash(sha(alg))
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/create-hash/browser.js","/../node_modules/create-hash")
},{"./md5":16,"buffer":11,"cipher-base":13,"inherits":71,"pBGvAp":74,"ripemd160":75,"sha.js":78}],15:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}
exports.hash = hash;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/create-hash/helpers.js","/../node_modules/create-hash")
},{"buffer":11,"pBGvAp":74}],16:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/create-hash/md5.js","/../node_modules/create-hash")
},{"./helpers":15,"buffer":11,"pBGvAp":74}],17:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var createHash = require('create-hash/browser');
var inherits = require('inherits')

var Transform = require('stream').Transform

var ZEROS = new Buffer(128)
ZEROS.fill(0)

function Hmac(alg, key) {
  Transform.call(this)
  alg = alg.toLowerCase()
  if (typeof key === 'string') {
    key = new Buffer(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = createHash(alg).update(key).digest()

  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = new Buffer(blocksize)
  var opad = this._opad = new Buffer(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = createHash(alg).update(ipad)
}

inherits(Hmac, Transform)

Hmac.prototype.update = function (data, enc) {
  this._hash.update(data, enc)

  return this
}

Hmac.prototype._transform = function (data, _, next) {
  this._hash.update(data)

  next()
}

Hmac.prototype._flush = function (next) {
  this.push(this.digest())

  next()
}

Hmac.prototype.digest = function (enc) {
  var h = this._hash.digest()

  return createHash(this._alg).update(this._opad).update(h).digest(enc)
}

module.exports = function createHmac(alg, key) {
  return new Hmac(alg, key)
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/create-hmac/browser.js","/../node_modules/create-hmac")
},{"buffer":11,"create-hash/browser":14,"inherits":71,"pBGvAp":74,"stream":125}],18:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/aes.js","/../node_modules/crypto-js")
},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":25,"buffer":11,"pBGvAp":74}],19:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                var block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                var block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                var modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                var modeCreator = mode.createDecryptor;

	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }
	            this._mode = modeCreator.call(mode, this, iv && iv.words);
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                var wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                var salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/cipher-core.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],20:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {
	        function F() {}

	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                F.prototype = this;
	                var subtype = new F();

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init')) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/core.js","/../node_modules/crypto-js")
},{"buffer":11,"pBGvAp":74}],21:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex != -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            var words = [];
	            var nBytes = 0;
	            for (var i = 0; i < base64StrLength; i++) {
	                if (i % 4) {
	                    var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
	                    var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
	                    var bitsCombined = bits1 | bits2;
	                    words[nBytes >>> 2] |= (bitsCombined) << (24 - (nBytes % 4) * 8);
	                    nBytes++;
	                }
	            }

	            return WordArray.create(words, nBytes);
	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };
	}());


	return CryptoJS.enc.Base64;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/enc-base64.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],22:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Hex;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/enc-hex.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],23:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                var block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/evpkdf.js","/../node_modules/crypto-js")
},{"./core":20,"./hmac":24,"./sha1":26,"buffer":11,"pBGvAp":74}],24:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/hmac.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],25:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/md5.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],26:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/sha1.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],27:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var currencySymbolMap = require('./map');

var symbolCurrencyMap = {};
Object.keys(currencySymbolMap).forEach(function (key) {
  symbolCurrencyMap[currencySymbolMap[key]] = key
})

function getSymbolFromCurrency(currencyCode) {
  if (typeof currencyCode !== 'string') return undefined
  var code = currencyCode.toUpperCase();
  if (!currencySymbolMap.hasOwnProperty(code)) return undefined
  return currencySymbolMap[code];
}

function getCurrencyFromSymbol(symbol) {
  if (!symbolCurrencyMap.hasOwnProperty(symbol)) return undefined
  return symbolCurrencyMap[symbol]
}

function getSymbol(currencyCode) {
  if (typeof currencyCode !== 'string') return '?'
  var symbol = getSymbolFromCurrency(currencyCode.toUpperCase())
  return symbol !== undefined ? symbol : '?'
}

module.exports = getSymbol
module.exports.getSymbolFromCurrency = getSymbolFromCurrency
module.exports.getCurrencyFromSymbol = getCurrencyFromSymbol
module.exports.symbolCurrencyMap = symbolCurrencyMap
module.exports.currencySymbolMap = currencySymbolMap

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/currency-symbol-map/currency-symbol-map.js","/../node_modules/currency-symbol-map")
},{"./map":28,"buffer":11,"pBGvAp":74}],28:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports =
{ "ALL": "L"
, "AFN": "؋"
, "ARS": "$"
, "AWG": "ƒ"
, "AUD": "$"
, "AZN": "₼"
, "BSD": "$"
, "BBD": "$"
, "BYR": "p."
, "BZD": "BZ$"
, "BMD": "$"
, "BOB": "Bs."
, "BAM": "KM"
, "BWP": "P"
, "BGN": "лв"
, "BRL": "R$"
, "BND": "$"
, "BTC": "Ƀ"
, "KHR": "៛"
, "CAD": "$"
, "KYD": "$"
, "CLP": "$"
, "CNY": "¥"
, "COP": "$"
, "CRC": "₡"
, "HRK": "kn"
, "CUP": "₱"
, "CZK": "Kč"
, "DKK": "kr"
, "DOP": "RD$"
, "XCD": "$"
, "EGP": "£"
, "SVC": "$"
, "EEK": "kr"
, "EUR": "€"
, "FKP": "£"
, "FJD": "$"
, "GHC": "₵"
, "GIP": "£"
, "GTQ": "Q"
, "GGP": "£"
, "GYD": "$"
, "HNL": "L"
, "HKD": "$"
, "HUF": "Ft"
, "ISK": "kr"
, "INR": "₹"
, "IDR": "Rp"
, "IRR": "﷼"
, "IMP": "£"
, "ILS": "₪"
, "JMD": "J$"
, "JPY": "¥"
, "JEP": "£"
, "KES": "KSh"
, "KZT": "лв"
, "KPW": "₩"
, "KRW": "₩"
, "KGS": "лв"
, "LAK": "₭"
, "LVL": "Ls"
, "LBP": "£"
, "LRD": "$"
, "LTL": "Lt"
, "MKD": "ден"
, "MYR": "RM"
, "MUR": "₨"
, "MXN": "$"
, "MNT": "₮"
, "MZN": "MT"
, "NAD": "$"
, "NPR": "₨"
, "ANG": "ƒ"
, "NZD": "$"
, "NIO": "C$"
, "NGN": "₦"
, "NOK": "kr"
, "OMR": "﷼"
, "PKR": "₨"
, "PAB": "B/."
, "PYG": "Gs"
, "PEN": "S/."
, "PHP": "₱"
, "PLN": "zł"
, "QAR": "﷼"
, "RON": "lei"
, "RUB": "₽"
, "RMB": "￥"
, "SHP": "£"
, "SAR": "﷼"
, "RSD": "Дин."
, "SCR": "₨"
, "SGD": "$"
, "SBD": "$"
, "SOS": "S"
, "ZAR": "R"
, "LKR": "₨"
, "SEK": "kr"
, "CHF": "CHF"
, "SRD": "$"
, "SYP": "£"
, "TZS": "TSh"
, "TWD": "NT$"
, "THB": "฿"
, "TTD": "TT$"
, "TRY": "₺"
, "TRL": "₤"
, "TVD": "$"
, "UGX": "USh"
, "UAH": "₴"
, "GBP": "£"
, "USD": "$"
, "UYU": "$U"
, "UZS": "лв"
, "VEF": "Bs"
, "VND": "₫"
, "YER": "﷼"
, "ZWD": "Z$"
, "GEL": "₾"
, "KZT": "₸"
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/currency-symbol-map/map.js","/../node_modules/currency-symbol-map")
},{"buffer":11,"pBGvAp":74}],29:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict'

/**
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
function diff_match_patch() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close do
  // the contents have to be to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  // The number of bits in an int.
  this.Match_MaxBits = 32;
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

/** @typedef {{0: number, 1: string}} */
diff_match_patch.Diff;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff.
 * @param {number} opt_deadline Optional time when the diff should be complete
 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
 *     instead.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
    opt_deadline) {
  // Set a deadline by which time the diff must be complete.
  if (typeof opt_deadline == 'undefined') {
    if (this.Diff_Timeout <= 0) {
      opt_deadline = Number.MAX_VALUE;
    } else {
      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
    }
  }
  var deadline = opt_deadline;

  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute_(text1, text2, checklines, deadline);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
    deadline) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  if (checklines && text1.length > 100 && text2.length > 100) {
    return this.diff_lineMode_(text1, text2, deadline);
  }

  return this.diff_bisect_(text1, text2, deadline);
};


/**
 * Do a quick line-level diff on both strings, then rediff the parts for
 * greater accuracy.
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
  // Scan the text on a line-by-line basis first.
  var a = this.diff_linesToChars_(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  var linearray = a.lineArray;

  var diffs = this.diff_main(text1, text2, false, deadline);

  // Convert the diff back to original text.
  this.diff_charsToLines_(diffs, linearray);
  // Eliminate freak matches (e.g. blank lines)
  this.diff_cleanupSemantic(diffs);

  // Rediff any replacement blocks, this time character-by-character.
  // Add a dummy entry at the end.
  diffs.push([DIFF_EQUAL, '']);
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete >= 1 && count_insert >= 1) {
          // Delete the offending records and add the merged ones.
          diffs.splice(pointer - count_delete - count_insert,
                       count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          var a = this.diff_main(text_delete, text_insert, false, deadline);
          for (var j = a.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, a[j]);
          }
          pointer = pointer + a.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
    pointer++;
  }
  diffs.pop();  // Remove the dummy entry at the end.

  return diffs;
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Bail out if deadline is reached.
    if ((new Date()).getTime() > deadline) {
      break;
    }

    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
    deadline) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = this.diff_main(text1a, text2a, false, deadline);
  var diffsb = this.diff_main(text1b, text2b, false, deadline);

  return diffs.concat(diffsb);
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
 *     An object containing the encoded text1, the encoded text2 and
 *     the array of unique strings.
 *     The zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge_(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);
      lineStart = lineEnd + 1;

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
    }
    return chars;
  }

  var chars1 = diff_linesToCharsMunge_(text1);
  var chars2 = diff_linesToCharsMunge_(text2);
  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {!Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
  for (var x = 0; x < diffs.length; x++) {
    var chars = diffs[x][1];
    var text = [];
    for (var y = 0; y < chars.length; y++) {
      text[y] = lineArray[chars.charCodeAt(y)];
    }
    diffs[x][1] = text.join('');
  }
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine if the suffix of one string is the prefix of another.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of the first
 *     string and the start of the second string.
 * @private
 */
diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  // Eliminate the null case.
  if (text1_length == 0 || text2_length == 0) {
    return 0;
  }
  // Truncate the longer string.
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  var text_length = Math.min(text1_length, text2_length);
  // Quick check for the worst case.
  if (text1 == text2) {
    return text_length;
  }

  // Start by looking for a single character match
  // and increase length until no match is found.
  // Performance analysis: http://neil.fraser.name/news/2010/11/04/
  var best = 0;
  var length = 1;
  while (true) {
    var pattern = text1.substring(text_length - length);
    var found = text2.indexOf(pattern);
    if (found == -1) {
      return best;
    }
    length += found;
    if (found == 0 || text1.substring(text_length - length) ==
        text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 * @private
 */
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
  if (this.Diff_Timeout <= 0) {
    // Don't risk returning a non-optimal diff if we have unlimited time.
    return null;
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  // Number of characters that changed after the equality.
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastequality = diffs[pointer][1];
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_INSERT) {
        length_insertions2 += diffs[pointer][1].length;
      } else {
        length_deletions2 += diffs[pointer][1].length;
      }
      // Eliminate an equality that is smaller or equal to the edits on both
      // sides of it.
      if (lastequality && (lastequality.length <=
          Math.max(length_insertions1, length_deletions1)) &&
          (lastequality.length <= Math.max(length_insertions2,
                                           length_deletions2))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;  // Reset the counters.
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastequality = null;
        changes = true;
      }
    }
    pointer++;
  }

  // Normalize the diff.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);

  // Find any overlaps between deletions and insertions.
  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
  //   -> <del>abc</del>xxx<ins>def</ins>
  // e.g: <del>xxxabc</del><ins>defxxx</ins>
  //   -> <ins>def</ins>xxx<del>abc</del>
  // Only extract an overlap if it is as big as the edit ahead or behind it.
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] == DIFF_DELETE &&
        diffs[pointer][0] == DIFF_INSERT) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 ||
            overlap_length1 >= insertion.length / 2) {
          // Overlap found.  Insert an equality and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);
          diffs[pointer - 1][1] =
              deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 ||
            overlap_length2 >= insertion.length / 2) {
          // Reverse overlap found.
          // Insert an equality and swap and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] =
              insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] =
              deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 6 (best) to 0 (worst).
   * Closure, but does not reference any external variables.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   * @private
   */
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 6;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var char1 = one.charAt(one.length - 1);
    var char2 = two.charAt(0);
    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
    var whitespace1 = nonAlphaNumeric1 &&
        char1.match(diff_match_patch.whitespaceRegex_);
    var whitespace2 = nonAlphaNumeric2 &&
        char2.match(diff_match_patch.whitespaceRegex_);
    var lineBreak1 = whitespace1 &&
        char1.match(diff_match_patch.linebreakRegex_);
    var lineBreak2 = whitespace2 &&
        char2.match(diff_match_patch.linebreakRegex_);
    var blankLine1 = lineBreak1 &&
        one.match(diff_match_patch.blanklineEndRegex_);
    var blankLine2 = lineBreak2 &&
        two.match(diff_match_patch.blanklineStartRegex_);

    if (blankLine1 || blankLine2) {
      // Five points for blank lines.
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      // Four points for line breaks.
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      // Three points for end of sentences.
      return 3;
    } else if (whitespace1 || whitespace2) {
      // Two points for whitespace.
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      // One point for non-alphanumeric.
      return 1;
    }
    return 0;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
          diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore_(equality1, edit) +
            diff_cleanupSemanticScore_(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};

// Define some regex patterns for matching boundaries.
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastequality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastequality = null;
      }
      post_ins = post_del = false;
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
                           ((lastequality.length < this.Diff_EditCost / 2) &&
                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastequality = null;
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality.
          pointer = equalitiesLength > 0 ?
              equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var pattern_amp = /&/g;
  var pattern_lt = /</g;
  var pattern_gt = />/g;
  var pattern_para = /\n/g;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];    // Operation (insert, delete, equal)
    var data = diffs[x][1];  // Text of change.
    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
        break;
      case DIFF_DELETE:
        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
        break;
      case DIFF_EQUAL:
        html[x] = '<span>' + text + '</span>';
        break;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  return text.join('\t').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = [DIFF_EQUAL, text];
        } else {
          diffs[diffsLength++] = [DIFF_DELETE, text];
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap_(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet_(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore_(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore_(0, best_loc), score_threshold);
    }
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = -1;

  var bin_min, bin_mid;
  var bin_max = pattern.length + text.length;
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (var j = finish; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following line generates
      // warnings.
      var charMatch = s[text.charAt(j - 1)];
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore_(d, j - 1);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore_(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {!Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
                              patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push([DIFF_EQUAL, suffix]);
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples
 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof opt_b == 'string' &&
      typeof opt_c == 'undefined') {
    // Method 1: text1, text2
    // Compute diffs from text1 and text2.
    text1 = /** @type {string} */(a);
    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
      typeof opt_c == 'undefined') {
    // Method 2: diffs
    // Compute text1 from diffs.
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
      typeof opt_c == 'undefined') {
    // Method 3: text1, diffs
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
      opt_c && typeof opt_c == 'object') {
    // Method 4: text1, text2, diffs
    // text2 is not used.
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new diff_match_patch.patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
  // text2 (postpatch_text).  We recreate the patches one by one to determine
  // context info.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext_(patch, prepatch_text);
            patches.push(patch);
            patch = new diff_match_patch.patch_obj();
            patchDiffLength = 0;
            // Unlike Unidiff, our patch lists have a rolling context.
            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
            // Update prepatch text & pos to reflect the application of the
            // just completed patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext_(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making deep copies is hard in JavaScript.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new diff_match_patch.patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] = patch.diffs[y].slice();
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @param {string} text Old text.
 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find valid trailing context.  Drop this patch.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[x] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[x].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {  // Insertion
              text = text.substring(0, start_loc + index2) + mod[1] +
                     text.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {  // Deletion
              text = text.substring(0, start_loc + index2) +
                     text.substring(start_loc + this.diff_xIndex(diffs,
                         index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  var patch_size = this.Match_MaxBits;
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patch_size) {
      continue;
    }
    var bigpatch = patches[x];
    // Remove the big old patch.
    patches.splice(x--, 1);
    var start1 = bigpatch.start1;
    var start2 = bigpatch.start2;
    var precontext = '';
    while (bigpatch.diffs.length !== 0) {
      // Create one of several smaller patches.
      var patch = new diff_match_patch.patch_obj();
      var empty = true;
      patch.start1 = start1 - precontext.length;
      patch.start2 = start2 - precontext.length;
      if (precontext !== '') {
        patch.length1 = patch.length2 = precontext.length;
        patch.diffs.push([DIFF_EQUAL, precontext]);
      }
      while (bigpatch.diffs.length !== 0 &&
             patch.length1 < patch_size - this.Patch_Margin) {
        var diff_type = bigpatch.diffs[0][0];
        var diff_text = bigpatch.diffs[0][1];
        if (diff_type === DIFF_INSERT) {
          // Insertions are harmless.
          patch.length2 += diff_text.length;
          start2 += diff_text.length;
          patch.diffs.push(bigpatch.diffs.shift());
          empty = false;
        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                   patch.diffs[0][0] == DIFF_EQUAL &&
                   diff_text.length > 2 * patch_size) {
          // This is a large deletion.  Let it pass in one chunk.
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          empty = false;
          patch.diffs.push([diff_type, diff_text]);
          bigpatch.diffs.shift();
        } else {
          // Deletion or equality.  Only take as much as we can stomach.
          diff_text = diff_text.substring(0,
              patch_size - patch.length1 - this.Patch_Margin);
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          if (diff_type === DIFF_EQUAL) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
          } else {
            empty = false;
          }
          patch.diffs.push([diff_type, diff_text]);
          if (diff_text == bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] =
                bigpatch.diffs[0][1].substring(diff_text.length);
          }
        }
      }
      // Compute the head context for the next patch.
      precontext = this.diff_text2(patch.diffs);
      precontext =
          precontext.substring(precontext.length - this.Patch_Margin);
      // Append the end context for this patch.
      var postcontext = this.diff_text1(bigpatch.diffs)
                            .substring(0, this.Patch_Margin);
      if (postcontext !== '') {
        patch.length1 += postcontext.length;
        patch.length2 += postcontext.length;
        if (patch.diffs.length !== 0 &&
            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
          patch.diffs[patch.diffs.length - 1][1] += postcontext;
        } else {
          patch.diffs.push([DIFF_EQUAL, postcontext]);
        }
      }
      if (!empty) {
        patches.splice(++x, 0, patch);
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of Patch objects.
 * @param {string} textline Text representation of patches.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  var text = textline.split('\n');
  var textPointer = 0;
  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
  while (textPointer < text.length) {
    var m = text[textPointer].match(patchHeader);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new diff_match_patch.patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push([DIFF_DELETE, line]);
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push([DIFF_INSERT, line]);
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push([DIFF_EQUAL, line]);
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
diff_match_patch.patch_obj = function() {
  /** @type {!Array.<!diff_match_patch.Diff>} */
  this.diffs = [];
  /** @type {?number} */
  this.start1 = null;
  /** @type {?number} */
  this.start2 = null;
  /** @type {number} */
  this.length1 = 0;
  /** @type {number} */
  this.length2 = 0;
};


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
diff_match_patch.patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  return text.join('').replace(/%20/g, ' ');
};


// The following export code was added by @ForbesLindesay
module.exports = diff_match_patch;
module.exports['diff_match_patch'] = diff_match_patch;
module.exports['DIFF_DELETE'] = DIFF_DELETE;
module.exports['DIFF_INSERT'] = DIFF_INSERT;
module.exports['DIFF_EQUAL'] = DIFF_EQUAL;

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/diff-match-patch/index.js","/../node_modules/diff-match-patch")
},{"buffer":11,"pBGvAp":74}],30:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var assert = require('assert')
var BigInteger = require('bigi')

var Point = require('./point')

function Curve (p, a, b, Gx, Gy, n, h) {
  this.p = p
  this.a = a
  this.b = b
  this.G = Point.fromAffine(this, Gx, Gy)
  this.n = n
  this.h = h

  this.infinity = new Point(this, null, null, BigInteger.ZERO)

  // result caching
  this.pOverFour = p.add(BigInteger.ONE).shiftRight(2)
}

Curve.prototype.pointFromX = function (isOdd, x) {
  var alpha = x.pow(3).add(this.a.multiply(x)).add(this.b).mod(this.p)
  var beta = alpha.modPow(this.pOverFour, this.p) // XXX: not compatible with all curves

  var y = beta
  if (beta.isEven() ^ !isOdd) {
    y = this.p.subtract(y) // -y % p
  }

  return Point.fromAffine(this, x, y)
}

Curve.prototype.isInfinity = function (Q) {
  if (Q === this.infinity) return true

  return Q.z.signum() === 0 && Q.y.signum() !== 0
}

Curve.prototype.isOnCurve = function (Q) {
  if (this.isInfinity(Q)) return true

  var x = Q.affineX
  var y = Q.affineY
  var a = this.a
  var b = this.b
  var p = this.p

  // Check that xQ and yQ are integers in the interval [0, p - 1]
  if (x.signum() < 0 || x.compareTo(p) >= 0) return false
  if (y.signum() < 0 || y.compareTo(p) >= 0) return false

  // and check that y^2 = x^3 + ax + b (mod p)
  var lhs = y.square().mod(p)
  var rhs = x.pow(3).add(a.multiply(x)).add(b).mod(p)
  return lhs.equals(rhs)
}

/**
 * Validate an elliptic curve point.
 *
 * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive
 */
Curve.prototype.validate = function (Q) {
  // Check Q != O
  assert(!this.isInfinity(Q), 'Point is at infinity')
  assert(this.isOnCurve(Q), 'Point is not on the curve')

  // Check nQ = O (where Q is a scalar multiple of G)
  var nQ = Q.multiply(this.n)
  assert(this.isInfinity(nQ), 'Point is not a scalar multiple of G')

  return true
}

module.exports = Curve

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ecurve/lib/curve.js","/../node_modules/ecurve/lib")
},{"./point":34,"assert":1,"bigi":6,"buffer":11,"pBGvAp":74}],31:[function(require,module,exports){
module.exports={
  "secp128r1": {
    "p": "fffffffdffffffffffffffffffffffff",
    "a": "fffffffdfffffffffffffffffffffffc",
    "b": "e87579c11079f43dd824993c2cee5ed3",
    "n": "fffffffe0000000075a30d1b9038a115",
    "h": "01",
    "Gx": "161ff7528b899b2d0c28607ca52c5b86",
    "Gy": "cf5ac8395bafeb13c02da292dded7a83"
  },
  "secp160k1": {
    "p": "fffffffffffffffffffffffffffffffeffffac73",
    "a": "00",
    "b": "07",
    "n": "0100000000000000000001b8fa16dfab9aca16b6b3",
    "h": "01",
    "Gx": "3b4c382ce37aa192a4019e763036f4f5dd4d7ebb",
    "Gy": "938cf935318fdced6bc28286531733c3f03c4fee"
  },
  "secp160r1": {
    "p": "ffffffffffffffffffffffffffffffff7fffffff",
    "a": "ffffffffffffffffffffffffffffffff7ffffffc",
    "b": "1c97befc54bd7a8b65acf89f81d4d4adc565fa45",
    "n": "0100000000000000000001f4c8f927aed3ca752257",
    "h": "01",
    "Gx": "4a96b5688ef573284664698968c38bb913cbfc82",
    "Gy": "23a628553168947d59dcc912042351377ac5fb32"
  },
  "secp192k1": {
    "p": "fffffffffffffffffffffffffffffffffffffffeffffee37",
    "a": "00",
    "b": "03",
    "n": "fffffffffffffffffffffffe26f2fc170f69466a74defd8d",
    "h": "01",
    "Gx": "db4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d",
    "Gy": "9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d"
  },
  "secp192r1": {
    "p": "fffffffffffffffffffffffffffffffeffffffffffffffff",
    "a": "fffffffffffffffffffffffffffffffefffffffffffffffc",
    "b": "64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1",
    "n": "ffffffffffffffffffffffff99def836146bc9b1b4d22831",
    "h": "01",
    "Gx": "188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012",
    "Gy": "07192b95ffc8da78631011ed6b24cdd573f977a11e794811"
  },
  "secp256k1": {
    "p": "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    "a": "00",
    "b": "07",
    "n": "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
    "h": "01",
    "Gx": "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    "Gy": "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
  },
  "secp256r1": {
    "p": "ffffffff00000001000000000000000000000000ffffffffffffffffffffffff",
    "a": "ffffffff00000001000000000000000000000000fffffffffffffffffffffffc",
    "b": "5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b",
    "n": "ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551",
    "h": "01",
    "Gx": "6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296",
    "Gy": "4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
  }
}

},{}],32:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var Point = require('./point')
var Curve = require('./curve')

var getCurveByName = require('./names')

module.exports = {
  Curve: Curve,
  Point: Point,
  getCurveByName: getCurveByName
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ecurve/lib/index.js","/../node_modules/ecurve/lib")
},{"./curve":30,"./names":33,"./point":34,"buffer":11,"pBGvAp":74}],33:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var BigInteger = require('bigi')

var curves = require('./curves.json')
var Curve = require('./curve')

function getCurveByName (name) {
  var curve = curves[name]
  if (!curve) return null

  var p = new BigInteger(curve.p, 16)
  var a = new BigInteger(curve.a, 16)
  var b = new BigInteger(curve.b, 16)
  var n = new BigInteger(curve.n, 16)
  var h = new BigInteger(curve.h, 16)
  var Gx = new BigInteger(curve.Gx, 16)
  var Gy = new BigInteger(curve.Gy, 16)

  return new Curve(p, a, b, Gx, Gy, n, h)
}

module.exports = getCurveByName

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ecurve/lib/names.js","/../node_modules/ecurve/lib")
},{"./curve":30,"./curves.json":31,"bigi":6,"buffer":11,"pBGvAp":74}],34:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var assert = require('assert')
var BigInteger = require('bigi')

var THREE = BigInteger.valueOf(3)

function Point (curve, x, y, z) {
  assert.notStrictEqual(z, undefined, 'Missing Z coordinate')

  this.curve = curve
  this.x = x
  this.y = y
  this.z = z
  this._zInv = null

  this.compressed = true
}

Object.defineProperty(Point.prototype, 'zInv', {
  get: function () {
    if (this._zInv === null) {
      this._zInv = this.z.modInverse(this.curve.p)
    }

    return this._zInv
  }
})

Object.defineProperty(Point.prototype, 'affineX', {
  get: function () {
    return this.x.multiply(this.zInv).mod(this.curve.p)
  }
})

Object.defineProperty(Point.prototype, 'affineY', {
  get: function () {
    return this.y.multiply(this.zInv).mod(this.curve.p)
  }
})

Point.fromAffine = function (curve, x, y) {
  return new Point(curve, x, y, BigInteger.ONE)
}

Point.prototype.equals = function (other) {
  if (other === this) return true
  if (this.curve.isInfinity(this)) return this.curve.isInfinity(other)
  if (this.curve.isInfinity(other)) return this.curve.isInfinity(this)

  // u = Y2 * Z1 - Y1 * Z2
  var u = other.y.multiply(this.z).subtract(this.y.multiply(other.z)).mod(this.curve.p)

  if (u.signum() !== 0) return false

  // v = X2 * Z1 - X1 * Z2
  var v = other.x.multiply(this.z).subtract(this.x.multiply(other.z)).mod(this.curve.p)

  return v.signum() === 0
}

Point.prototype.negate = function () {
  var y = this.curve.p.subtract(this.y)

  return new Point(this.curve, this.x, y, this.z)
}

Point.prototype.add = function (b) {
  if (this.curve.isInfinity(this)) return b
  if (this.curve.isInfinity(b)) return this

  var x1 = this.x
  var y1 = this.y
  var x2 = b.x
  var y2 = b.y

  // u = Y2 * Z1 - Y1 * Z2
  var u = y2.multiply(this.z).subtract(y1.multiply(b.z)).mod(this.curve.p)
  // v = X2 * Z1 - X1 * Z2
  var v = x2.multiply(this.z).subtract(x1.multiply(b.z)).mod(this.curve.p)

  if (v.signum() === 0) {
    if (u.signum() === 0) {
      return this.twice() // this == b, so double
    }

    return this.curve.infinity // this = -b, so infinity
  }

  var v2 = v.square()
  var v3 = v2.multiply(v)
  var x1v2 = x1.multiply(v2)
  var zu2 = u.square().multiply(this.z)

  // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
  var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.p)
  // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
  var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.p)
  // z3 = v^3 * z1 * z2
  var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.p)

  return new Point(this.curve, x3, y3, z3)
}

Point.prototype.twice = function () {
  if (this.curve.isInfinity(this)) return this
  if (this.y.signum() === 0) return this.curve.infinity

  var x1 = this.x
  var y1 = this.y

  var y1z1 = y1.multiply(this.z)
  var y1sqz1 = y1z1.multiply(y1).mod(this.curve.p)
  var a = this.curve.a

  // w = 3 * x1^2 + a * z1^2
  var w = x1.square().multiply(THREE)

  if (a.signum() !== 0) {
    w = w.add(this.z.square().multiply(a))
  }

  w = w.mod(this.curve.p)
  // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
  var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.p)
  // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
  var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.pow(3)).mod(this.curve.p)
  // z3 = 8 * (y1 * z1)^3
  var z3 = y1z1.pow(3).shiftLeft(3).mod(this.curve.p)

  return new Point(this.curve, x3, y3, z3)
}

// Simple NAF (Non-Adjacent Form) multiplication algorithm
// TODO: modularize the multiplication algorithm
Point.prototype.multiply = function (k) {
  if (this.curve.isInfinity(this)) return this
  if (k.signum() === 0) return this.curve.infinity

  var e = k
  var h = e.multiply(THREE)

  var neg = this.negate()
  var R = this

  for (var i = h.bitLength() - 2; i > 0; --i) {
    var hBit = h.testBit(i)
    var eBit = e.testBit(i)

    R = R.twice()

    if (hBit !== eBit) {
      R = R.add(hBit ? this : neg)
    }
  }

  return R
}

// Compute this*j + x*k (simultaneous multiplication)
Point.prototype.multiplyTwo = function (j, x, k) {
  var i = Math.max(j.bitLength(), k.bitLength()) - 1
  var R = this.curve.infinity
  var both = this.add(x)

  while (i >= 0) {
    var jBit = j.testBit(i)
    var kBit = k.testBit(i)

    R = R.twice()

    if (jBit) {
      if (kBit) {
        R = R.add(both)
      } else {
        R = R.add(this)
      }
    } else if (kBit) {
      R = R.add(x)
    }
    --i
  }

  return R
}

Point.prototype.getEncoded = function (compressed) {
  if (compressed == null) compressed = this.compressed
  if (this.curve.isInfinity(this)) return new Buffer('00', 'hex') // Infinity point encoded is simply '00'

  var x = this.affineX
  var y = this.affineY

  var buffer

  // Determine size of q in bytes
  var byteLength = Math.floor((this.curve.p.bitLength() + 7) / 8)

  // 0x02/0x03 | X
  if (compressed) {
    buffer = new Buffer(1 + byteLength)
    buffer.writeUInt8(y.isEven() ? 0x02 : 0x03, 0)

  // 0x04 | X | Y
  } else {
    buffer = new Buffer(1 + byteLength + byteLength)
    buffer.writeUInt8(0x04, 0)

    y.toBuffer(byteLength).copy(buffer, 1 + byteLength)
  }

  x.toBuffer(byteLength).copy(buffer, 1)

  return buffer
}

Point.decodeFrom = function (curve, buffer) {
  var type = buffer.readUInt8(0)
  var compressed = (type !== 4)

  var byteLength = Math.floor((curve.p.bitLength() + 7) / 8)
  var x = BigInteger.fromBuffer(buffer.slice(1, 1 + byteLength))

  var Q
  if (compressed) {
    assert.equal(buffer.length, byteLength + 1, 'Invalid sequence length')
    assert(type === 0x02 || type === 0x03, 'Invalid sequence tag')

    var isOdd = (type === 0x03)
    Q = curve.pointFromX(isOdd, x)
  } else {
    assert.equal(buffer.length, 1 + byteLength + byteLength, 'Invalid sequence length')

    var y = BigInteger.fromBuffer(buffer.slice(1 + byteLength))
    Q = Point.fromAffine(curve, x, y)
  }

  Q.compressed = compressed
  return Q
}

Point.prototype.toString = function () {
  if (this.curve.isInfinity(this)) return '(INFINITY)'

  return '(' + this.affineX.toString() + ',' + this.affineY.toString() + ')'
}

module.exports = Point

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ecurve/lib/point.js","/../node_modules/ecurve/lib")
},{"assert":1,"bigi":6,"buffer":11,"pBGvAp":74}],35:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/events/events.js","/../node_modules/events")
},{"buffer":11,"pBGvAp":74}],36:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var TransactionBuilder = require("./src/TransactionBuilder");

module.exports = {
    TransactionBuilder: TransactionBuilder,

    ChainTypes: require("./src/ChainTypes"),
    ObjectId: require("./src/ObjectId"),
    NumberUtils: require("./src/NumberUtils"),
    TransactionHelper: require("./src/TransactionHelper"),
    ChainValidation: require("./src/ChainValidation"),
    Login: require("./src/AccountLogin")
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/chain/index.js","/../node_modules/golosjs-lib/dist/chain")
},{"./src/AccountLogin":37,"./src/ChainTypes":39,"./src/ChainValidation":40,"./src/NumberUtils":41,"./src/ObjectId":42,"./src/TransactionBuilder":43,"./src/TransactionHelper":44,"buffer":11,"pBGvAp":74}],37:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PrivateKey = require("../../ecc/src/PrivateKey");
var key = require("../../ecc/src/KeyUtils");

var KeyCache = function () {
    function KeyCache() {
        _classCallCheck(this, KeyCache);

        this._keyCachePriv = new Map();
        this._keyCachePub = new Map();
        this._myKeys = new Map();
    }

    _createClass(KeyCache, [{
        key: "setPrivKey",
        value: function setPrivKey(key, privKey) {
            this._keyCachePriv.set(key, privKey);
        }
    }, {
        key: "hasPrivKey",
        value: function hasPrivKey(key) {
            return this._keyCachePriv.has(key);
        }
    }, {
        key: "getPrivKey",
        value: function getPrivKey(key) {
            return this._keyCachePriv.get(key);
        }
    }, {
        key: "setPubKey",
        value: function setPubKey(key, pubKey) {
            this._keyCachePub.set(key, pubKey);
        }
    }, {
        key: "hasPubKey",
        value: function hasPubKey(key) {
            return this._keyCachePub.has(key);
        }
    }, {
        key: "getPubKey",
        value: function getPubKey(key) {
            return this._keyCachePub.get(key);;
        }
    }, {
        key: "setMyKey",
        value: function setMyKey(key, privKey) {
            this._myKeys.set(key, privKey);
        }
    }, {
        key: "getMyKey",
        value: function getMyKey(key) {
            return this._myKeys.get(key);
        }
    }]);

    return KeyCache;
}();

var AccountLogin = function () {
    function AccountLogin() {
        _classCallCheck(this, AccountLogin);

        this.reset();
        this.keyCache = new KeyCache();
    }

    _createClass(AccountLogin, [{
        key: "reset",
        value: function reset() {
            this.state = { loggedIn: false, roles: ["active", "owner", "posting", "memo"] };

            this.subs = {};
        }
    }, {
        key: "addSubscription",
        value: function addSubscription(cb) {
            this.subs[cb] = cb;
        }
    }, {
        key: "setRoles",
        value: function setRoles(roles) {
            this.state.roles = roles;
        }
    }, {
        key: "getRoles",
        value: function getRoles() {
            return this.state.roles;
        }
    }, {
        key: "generateKeys",
        value: function generateKeys(accountName, password, roles, prefix) {
            var _this = this;

            if (!accountName || !password) {
                throw new Error("Account name or password required");
            }
            if (password.length < 12) {
                throw new Error("Password must have at least 12 characters");
            }

            var privKeys = {};
            var pubKeys = {};

            (roles || this.state.roles).forEach(function (role) {
                var seed = accountName + role + password;
                var pkey = _this.keyCache.hasPrivKey(role) ? _this.keyCache.getPrivKey(role) : PrivateKey.fromSeed(key.normalize_brainKey(seed));
                _this.keyCache.setPrivKey(role, pkey);

                privKeys[role] = pkey;
                pubKeys[role] = _this.keyCache.getPubKey(role) ? _this.keyCache.getPubKey(role) : pkey.toPublicKey().toString(prefix);

                _this.keyCache.setPubKey(role, pubKeys[role]);
            });

            return { privKeys: privKeys, pubKeys: pubKeys };
        }
    }, {
        key: "fromPrivKey",
        value: function fromPrivKey(accountName, privateKey, roles, prefix) {
            var _this2 = this;

            if (!privateKey) {
                return null;
            }
            var privKeys = {};
            var pubKeys = {};

            (roles || this.state.roles).forEach(function (role) {

                var pkey = _this2.keyCache.hasPrivKey(role) ? _this2.keyCache.getPrivKey(role) : PrivateKey.fromWif(privateKey);
                _this2.keyCache.setPrivKey(role, pkey);

                privKeys[role] = pkey;
                pubKeys[role] = _this2.keyCache.getPubKey(role) ? _this2.keyCache.getPubKey(role) : pkey.toPublicKey().toString(prefix);

                _this2.keyCache.setPubKey(role, pubKeys[role]);
            });

            return { privKeys: privKeys, pubKeys: pubKeys };
        }
    }, {
        key: "getPubKeys",
        value: function getPubKeys() {
            var _this3 = this;

            return this.state.roles.map(function (role) {
                return _this3.keyCache.getPubKey(role);
            });
        }
    }, {
        key: "checkKeys",
        value: function checkKeys(_ref) {
            var _this4 = this;

            var accountName = _ref.accountName;
            var password = _ref.password;
            var auths = _ref.auths;
            var _ref$privateKey = _ref.privateKey;
            var privateKey = _ref$privateKey === undefined ? null : _ref$privateKey;

            if (!accountName || !password && !privateKey || !auths) {
                throw new Error("checkKeys: Missing inputs");
            }
            var hasKey = false;

            var _loop = function _loop(role) {
                var keys = void 0;
                if (password) {
                    keys = _this4.generateKeys(accountName, password, [role]);
                } else if (privateKey) {
                    keys = _this4.fromPrivKey(accountName, privateKey, [role]);
                }

                if (keys && Object.keys(keys).length) {
                    (function () {
                        var _keys = keys;
                        var privKeys = _keys.privKeys;
                        var pubKeys = _keys.pubKeys;

                        auths[role].forEach(function (key) {
                            if (key[0] === pubKeys[role]) {
                                hasKey = true;
                                _this4.keyCache.setMyKey(role, { priv: privKeys[role], pub: pubKeys[role] });
                            }
                        });
                    })();
                }
            };

            for (var role in auths) {
                _loop(role);
            };

            if (hasKey) {
                this.name = accountName;
            }

            this.state.loggedIn = hasKey;

            return hasKey;
        }
    }, {
        key: "signTransaction",
        value: function signTransaction(tr) {
            var _this5 = this;

            var signerPubkeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var requiredPubkeys = arguments[2];


            var myKeys = {};
            var hasKey = false;

            this.state.roles.forEach(function (role) {
                var myKey = _this5.keyCache.getMyKey(role);
                if (myKey) {
                    if (signerPubkeys[myKey.pub]) {
                        hasKey = true;
                        return;
                    }
                    hasKey = true;
                    signerPubkeys[myKey.pub] = true;
                    if (requiredPubkeys && requiredPubkeys.indexOf(myKey.pub) !== -1) {
                        tr.add_signer(myKey.priv, myKey.pub);
                    } else if (!requiredPubkeys) {
                        tr.add_signer(myKey.priv, myKey.pub);
                    }
                }
            });

            if (!hasKey) {
                console.error("You do not have any private keys to sign this transaction");
                throw new Error("You do not have any private keys to sign this transaction");
            }
        }
    }]);

    return AccountLogin;
}();

module.exports = AccountLogin;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/chain/src/AccountLogin.js","/../node_modules/golosjs-lib/dist/chain/src")
},{"../../ecc/src/KeyUtils":47,"../../ecc/src/PrivateKey":48,"buffer":11,"pBGvAp":74}],38:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _this;

var ecc_config = {
    address_prefix: "GLS"
};

module.exports = _this = {
    core_asset: "GOLOS",
    vest_asset: "GESTS",
    dollar_asset: "GBG",
    address_prefix: "GLS",
    expire_in_secs: 15,
    expire_in_secs_proposal: 24 * 60 * 60,
    networks: {
        Steem: {
            core_asset: "GOLOS",
            address_prefix: "GLS",
            chain_id: "782a3039b478c839e4cb0c941ff4eaeb7df40bdd68bd441afd444b9da763de12"
        }
    },
    /** Set a few properties for known chain IDs. */
    setChainId: function setChainId(chain_id) {

        var i, len, network, network_name, ref;
        ref = Object.keys(_this.networks);

        for (i = 0, len = ref.length; i < len; i++) {

            network_name = ref[i];
            network = _this.networks[network_name];

            if (network.chain_id === chain_id) {

                _this.network_name = network_name;

                if (network.address_prefix) {
                    _this.address_prefix = network.address_prefix;
                    ecc_config.address_prefix = network.address_prefix;
                }

                // console.log("INFO    Configured for", network_name, ":", network.core_asset, "\n");

                return {
                    network_name: network_name,
                    network: network
                };
            }
        }

        if (!_this.network_name) {
            console.log("Unknown chain id (this may be a testnet)", chain_id);
        }
    },

    reset: function reset() {
        _this.core_asset = "GOLOS";
        _this.address_prefix = "GLS";
        ecc_config.address_prefix = "GLS";
        _this.expire_in_secs = 15;
        _this.expire_in_secs_proposal = 24 * 60 * 60;

        console.log("Chain config reset");
    },

    setPrefix: function setPrefix() {
        var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "GLS";

        _this.address_prefix = prefix;
        ecc_config.address_prefix = prefix;
    }
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/chain/src/ChainConfig.js","/../node_modules/golosjs-lib/dist/chain/src")
},{"buffer":11,"pBGvAp":74}],39:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var ChainTypes = {};

ChainTypes.operations = {
    vote: 0,
    comment: 1,
    transfer: 2,
    transfer_to_vesting: 3,
    withdraw_vesting: 4,
    limit_order_create: 5,
    limit_order_cancel: 6,
    feed_publish: 7,
    convert: 8,
    account_create: 9,
    account_update: 10,
    witness_update: 11,
    account_witness_vote: 12,
    account_witness_proxy: 13,
    pow: 14,
    custom: 15,
    report_over_production: 16,
    delete_comment: 17,
    custom_json: 18,
    comment_options: 19,
    set_withdraw_vesting_route: 20,
    fill_convert_request: 21,
    author_reward: 22,
    curation_reward: 23,
    liquidity_reward: 24,
    interest: 25,
    fill_vesting_withdraw: 26,
    fill_order: 27,
    comment_payout: 28,
    escrow_transfer: 29,
    escrow_approve: 30,
    escrow_dispute: 31,
    escrow_release: 32
};

module.exports = ChainTypes;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/chain/src/ChainTypes.js","/../node_modules/golosjs-lib/dist/chain/src")
},{"buffer":11,"pBGvAp":74}],40:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

/**
    Account names may contain one or more names separated by a dot.
    Each name needs to start with a letter and may contain
    numbers, or well placed dashes.
    @see is_valid_name graphene/libraries/chain/protocol/account.cpp
*/
var id_regex = /\b\d+\.\d+\.(\d+)\b/;

var chainValidation = {
    is_account_name: function is_account_name(value) {
        var allow_too_short = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var i, label, len, length, ref;

        if (this.is_empty(value)) {
            return false;
        }

        length = value.length;

        if (!allow_too_short && length < 3 || length > 63) {
            return false;
        }

        ref = value.split('.');

        for (i = 0, len = ref.length; i < len; i++) {

            label = ref[i];

            if (!(/^[a-z][a-z0-9-]*$/.test(label) && !/--/.test(label) && /[a-z0-9]$/.test(label))) {
                return false;
            }
        }
        return true;
    },

    is_object_id: function is_object_id(obj_id) {
        if ('string' != typeof obj_id) return false;

        var match = id_regex.exec(obj_id);
        return match !== null && obj_id.split(".").length === 3;
    },

    is_empty: function is_empty(value) {
        return value == null || value.length === 0;
    },

    is_account_name_error: function is_account_name_error(value, allow_too_short) {
        var i, label, len, length, ref, suffix;
        if (allow_too_short == null) {
            allow_too_short = false;
        }
        suffix = "Account name should ";
        if (this.is_empty(value)) {
            return suffix + "not be empty.";
        }
        length = value.length;
        if (!allow_too_short && length < 3) {
            return suffix + "be longer.";
        }
        if (length > 63) {
            return suffix + "be shorter.";
        }
        if (/\./.test(value)) {
            suffix = "Each account segment should ";
        }
        ref = value.split('.');
        for (i = 0, len = ref.length; i < len; i++) {
            label = ref[i];
            if (!/^[~a-z]/.test(label)) {
                return suffix + "start with a letter.";
            }
            if (!/^[~a-z0-9-]*$/.test(label)) {
                return suffix + "have only letters, digits, or dashes.";
            }
            if (/--/.test(label)) {
                return suffix + "have only one dash in a row.";
            }
            if (!/[a-z0-9]$/.test(label)) {
                return suffix + "end with a letter or digit.";
            }
            if (!(label.length >= 3)) {
                return suffix + "be longer";
            }
        }
        return null;
    },

    is_cheap_name: function is_cheap_name(account_name) {
        return (/[0-9-]/.test(account_name) || !/[aeiouy]/.test(account_name)
        );
    },

    is_empty_user_input: function is_empty_user_input(value) {
        if (this.is_empty(value)) {
            return true;
        }
        if ((value + "").trim() === "") {
            return true;
        }
        return false;
    },

    required: function required(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (this.is_empty(value)) {
            throw new Error("value required for " + field_name + ": " + value);
        }
        return value;
    },

    /** @see is_valid_symbol graphene/libraries/chain/protocol/asset_ops.cpp */
    is_valid_symbol_error: function is_valid_symbol_error(value) {
        var suffix = "Asset name should ";
        if (this.is_empty(value)) {
            return suffix + "not be empty.";
        }
        if (value.split('.').length > 2) {
            return suffix + "have only one dot.";
        }
        if (value.length < 3) {
            return suffix + "be longer.";
        }
        if (value.length > 16) {
            return suffix + "be shorter.";
        }
        if (!/^[A-Z]/.test(value)) {
            return suffix + "start with a letter";
        }
        if (!/[A-Z]$/.test(value)) {
            return suffix + "end with a letter";
        }
        if (/^[A-Z0-9\.]$/.test(value)) {
            return suffix + "contain only letters numbers and perhaps a dot.";
        }
        return null;
    }
};

module.exports = chainValidation;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/chain/src/ChainValidation.js","/../node_modules/golosjs-lib/dist/chain/src")
},{"buffer":11,"pBGvAp":74}],41:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var assert = require("assert");

/**
    Convert 12.34 with a precision of 3 into 12340
    
    @arg {number|string} number - Use strings for large numbers.  This may contain one decimal but no sign
    @arg {number} precision - number of implied decimal places (usually causes right zero padding)
    @return {string} -
*/
module.exports = {
    toImpliedDecimal: function toImpliedDecimal(number, precision) {

        if (typeof number === "number") {
            assert(number <= 9007199254740991, "overflow");
            number = "" + number;
        } else if (number.toString) number = number.toString();

        assert(typeof number === "string", "number should be an actual number or string: " + (typeof number === "undefined" ? "undefined" : _typeof(number)));
        number = number.trim();
        assert(/^[0-9]*\.?[0-9]*$/.test(number), "Invalid decimal number " + number);

        var _number$split = number.split(".");

        var _number$split2 = _slicedToArray(_number$split, 2);

        var _number$split2$ = _number$split2[0];
        var whole = _number$split2$ === undefined ? "" : _number$split2$;
        var _number$split2$2 = _number$split2[1];
        var decimal = _number$split2$2 === undefined ? "" : _number$split2$2;


        var padding = precision - decimal.length;
        assert(padding >= 0, "Too many decimal digits in " + number + " to create an implied decimal of " + precision);

        for (var i = 0; i < padding; i++) {
            decimal += "0";
        }while (whole.charAt(0) === "0") {
            whole = whole.substring(1);
        }return whole + decimal;
    }
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/chain/src/NumberUtils.js","/../node_modules/golosjs-lib/dist/chain/src")
},{"assert":1,"buffer":11,"pBGvAp":74}],42:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('bytebuffer');

var Long = _require.Long;


var v = require('../../serializer/src/SerializerValidation');

var DB_MAX_INSTANCE_ID = Long.fromNumber(Math.pow(2, 48) - 1);

var ObjectId = function () {
    function ObjectId(space, type, instance) {
        _classCallCheck(this, ObjectId);

        this.space = space;
        this.type = type;
        this.instance = instance;
        var instance_string = this.instance.toString();
        var _ObjectId = this.space + '.' + this.type + '.' + instance_string;
        if (!v.is_digits(instance_string)) {
            throw new ('Invalid object id ' + _ObjectId)();
        }
    }

    _createClass(ObjectId, [{
        key: 'toLong',
        value: function toLong() {
            return Long.fromNumber(this.space).shiftLeft(56).or(Long.fromNumber(this.type).shiftLeft(48).or(this.instance));
        }
    }, {
        key: 'appendByteBuffer',
        value: function appendByteBuffer(b) {
            return b.writeUint64(this.toLong());
        }
    }, {
        key: 'toString',
        value: function toString() {
            return this.space + '.' + this.type + '.' + this.instance.toString();
        }
    }], [{
        key: 'fromString',
        value: function fromString(value) {
            if (value.space !== undefined && value.type !== undefined && value.instance !== undefined) {
                return value;
            }

            var params = v.require_match(/^([0-9]+)\.([0-9]+)\.([0-9]+)$/, v.required(value, "ObjectId"), "ObjectId");
            return new ObjectId(parseInt(params[1]), parseInt(params[2]), Long.fromString(params[3]));
        }
    }, {
        key: 'fromLong',
        value: function fromLong(long) {
            var space = long.shiftRight(56).toInt();
            var type = long.shiftRight(48).toInt() & 0x00ff;
            var instance = long.and(DB_MAX_INSTANCE_ID);
            return new ObjectId(space, type, instance);
        }
    }, {
        key: 'fromByteBuffer',
        value: function fromByteBuffer(b) {
            return ObjectId.fromLong(b.readUint64());
        }
    }]);

    return ObjectId;
}();

module.exports = ObjectId;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/chain/src/ObjectId.js","/../node_modules/golosjs-lib/dist/chain/src")
},{"../../serializer/src/SerializerValidation":60,"buffer":11,"bytebuffer":12,"pBGvAp":74}],43:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assert = require("assert");

var _require = require("../../ecc");

var Signature = _require.Signature;
var PublicKey = _require.PublicKey;
var hash = _require.hash;

var _require2 = require("../../serializer");

var ops = _require2.ops;

var ChainConfig = require("../../chain/src/ChainConfig");

var _require3 = require('steem-rpc');

var Client = _require3.Client;

var Api = Client.get();

var _require4 = require('bytebuffer');

var Long = _require4.Long;


var ChainTypes = require('./ChainTypes');

var head_block_time_string;

var TransactionBuilder = function () {
    function TransactionBuilder() {
        _classCallCheck(this, TransactionBuilder);

        this.ref_block_num = 0;
        this.ref_block_prefix = 0;
        this.expiration = 0;
        this.operations = [];
        this.signatures = [];
        this.signer_private_keys = [];

        // semi-private method bindings
        this._broadcast = _broadcast.bind(this);
    }

    /**
        @arg {string} name - like "transfer"
        @arg {object} operation - JSON matchching the operation's format
    */


    _createClass(TransactionBuilder, [{
        key: "add_type_operation",
        value: function add_type_operation(name, operation) {
            this.add_operation(this.get_type_operation(name, operation));
            return;
        }

        /**
            This does it all: set fees, finalize, sign, and broadcast (if wanted).
             @arg {ConfidentialWallet} cwallet - must be unlocked, used to gather signing keys
             @arg {array<string>} [signer_pubkeys = null] - Optional ["GPHAbc9Def0...", ...].  These are additional signing keys.  Some balance claims require propritary address formats, the witness node can't tell us which ones are needed so they must be passed in.  If the witness node can figure out a signing key (mostly all other transactions), it should not be passed in here.
             @arg {boolean} [broadcast = false]
        */

    }, {
        key: "process_transaction",
        value: function process_transaction(accountLogin) {
            var _this = this;

            var signer_pubkeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var broadcast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;


            // let wallet_object = cwallet.wallet.wallet_object
            // if(Api.chain_id !== wallet_object.get("chain_id"))
            //     return Promise.reject("Mismatched chain_id; expecting " +
            //         wallet_object.get("chain_id") + ", but got " +
            //         Api.chain_id)

            var signer_pubkeys_added = {};
            // if(signer_pubkeys) {
            //
            //     // Balance claims are by address, only the private
            //     // key holder can know about these additional
            //     // potential keys.
            //     var pubkeys = accountLogin.getPubKeys()
            //     if( ! pubkeys.length)
            //         throw new Error("Missing signing key")
            //
            //     for(let pubkey_string of pubkeys) {
            //         var private_key = cwallet.getPrivateKey(pubkey_string)
            //         this.add_signer(private_key, pubkey_string)
            //         signer_pubkeys_added[pubkey_string] = true
            //     }
            // }

            // return this.get_potential_signatures().then( (pubkeys)=> {
            var my_pubkeys = accountLogin.getPubKeys();

            //{//Testing only, don't send All public keys!
            //    var pubkeys_all = PrivateKeyStore.getPubkeys() // All public keys
            //    this.get_required_signatures(pubkeys_all).then( required_pubkey_strings =>
            //        console.log('get_required_signatures all\t',required_pubkey_strings.sort(), pubkeys_all))
            //    this.get_required_signatures(my_pubkeys).then( required_pubkey_strings =>
            //        console.log('get_required_signatures normal\t',required_pubkey_strings.sort(), pubkeys))
            //}


            return this.get_required_signatures(my_pubkeys).then(function (required_pubkeys) {
                // console.log("required_pubkeys", required_pubkeys);
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = my_pubkeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var pubkey_string = _step.value;

                        // console.log("pubkey_string", pubkey_string);

                        if (signer_pubkeys_added[pubkey_string]) continue;

                        accountLogin.signTransaction(_this, signer_pubkeys_added, required_pubkeys);
                        // var private_key = cwallet.getPrivateKey(pubkey_string)
                        // if( ! private_key)
                        //     // This should not happen, get_required_signatures will only
                        //     // returned keys from my_pubkeys
                        //     throw new Error("Missing signing key for " + pubkey_string)
                        // this.add_signer(private_key, pubkey_string)
                    }

                    // console.log("signer_pubkeys_added", signer_pubkeys_added);
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }).then(function () {
                if (broadcast) {
                    return _this.broadcast();
                } else {
                    return _this.serialize();
                }
            });
        }

        /** Typically this is called automatically just prior to signing.  Once finalized this transaction can not be changed. */

    }, {
        key: "finalize",
        value: function finalize() {
            var _this2 = this;

            // console.log("Try to finalize", "expiration:", this.expiration);
            return new Promise(function (resolve, reject) {

                if (_this2.tr_buffer) {
                    throw new Error("already finalized");
                }

                resolve(Api.database_api().exec("get_dynamic_global_properties", []).then(function (r) {
                    head_block_time_string = r.time;
                    if (_this2.expiration === 0) _this2.expiration = base_expiration_sec() + ChainConfig.expire_in_secs;
                    // console.log("new expiration:", this.expiration);
                    _this2.ref_block_num = r.head_block_number & 0xFFFF;
                    _this2.ref_block_prefix = new Buffer(r.head_block_id, 'hex').readUInt32LE(4);
                    //DEBUG console.log("ref_block",@ref_block_num,@ref_block_prefix,r)

                    var iterable = _this2.operations;
                    for (var i = 0, op; i < iterable.length; i++) {
                        op = iterable[i];
                        if (op[1]["finalize"]) {
                            op[1].finalize();
                        }
                    }
                    _this2.tr_buffer = ops.transaction.toBuffer(_this2);
                }).catch(function (err) {
                    console.log("get_dynamic_global_properties err:", err);
                }));
            });
        }

        /** @return {string} hex transaction ID */

    }, {
        key: "id",
        value: function id() {
            if (!this.tr_buffer) {
                throw new Error("not finalized");
            }
            return hash.sha256(this.tr_buffer).toString('hex').substring(0, 40);
        }

        /**
            Typically one will use {@link this.add_type_operation} instead.
            @arg {array} operation - [operation_id, operation]
        */

    }, {
        key: "add_operation",
        value: function add_operation(operation) {
            if (this.tr_buffer) {
                throw new Error("already finalized");
            }
            assert(operation, "operation");
            if (!Array.isArray(operation)) {
                throw new Error("Expecting array [operation_id, operation]");
            }
            this.operations.push(operation);
            return;
        }
    }, {
        key: "get_type_operation",
        value: function get_type_operation(name, operation) {
            if (this.tr_buffer) {
                throw new Error("already finalized");
            }
            assert(name, "name");
            assert(operation, "operation");
            var _type = ops[name];
            assert(_type, "Unknown operation " + name);
            var operation_id = ChainTypes.operations[_type.operation_name];
            if (operation_id === undefined) {
                throw new Error("unknown operation: " + _type.operation_name);
            }
            if (!operation.fee) {
                operation.fee = { amount: 0, asset_id: 0 };
            }
            if (name === 'proposal_create') {
                operation.expiration_time || (operation.expiration_time = base_expiration_sec() + ChainConfig.expire_in_secs_proposal);
            }
            var operation_instance = _type.fromObject(operation);
            return [operation_id, operation_instance];
        }

        /** optional: there is a deafult expiration */

    }, {
        key: "set_expire_seconds",
        value: function set_expire_seconds(sec) {
            if (this.tr_buffer) {
                throw new Error("already finalized");
            }
            return this.expiration = base_expiration_sec() + sec;
        }

        /* Wraps this transaction in a proposal_create transaction */

    }, {
        key: "propose",
        value: function propose(proposal_create_options) {
            if (this.tr_buffer) {
                throw new Error("already finalized");
            }
            if (!this.operations.length) {
                throw new Error("add operation first");
            }

            assert(proposal_create_options, "proposal_create_options");
            assert(proposal_create_options.fee_paying_account, "proposal_create_options.fee_paying_account");

            var proposed_ops = this.operations.map(function (op) {
                return { op: op };
            });

            this.operations = [];
            this.signatures = [];
            this.signer_private_keys = [];
            proposal_create_options.proposed_ops = proposed_ops;
            this.add_type_operation("proposal_create", proposal_create_options);
            return this;
        }
    }, {
        key: "has_proposed_operation",
        value: function has_proposed_operation() {
            var hasProposed = false;
            for (var i = 0; i < this.operations.length; i++) {
                if ("proposed_ops" in this.operations[i][1]) {
                    hasProposed = true;
                    break;
                }
            }

            return hasProposed;
        }
    }, {
        key: "get_potential_signatures",
        value: function get_potential_signatures() {
            var tr_object = ops.signed_transaction.toObject(this);
            return Api.database_api().exec("get_potential_signatures", [tr_object]).then(function (pubkeys) {
                return { pubkeys: pubkeys };
            });
        }
    }, {
        key: "get_required_signatures",
        value: function get_required_signatures(available_keys) {

            if (!available_keys.length) {
                return Promise.resolve([]);
            }
            var tr_object = ops.signed_transaction.toObject(this);
            // console.log('... tr_object',tr_object)
            //DEBUG console.log('... tr_object',tr_object)
            return Api.database_api().exec("get_required_signatures", [tr_object, available_keys]).then(function (required_public_keys) {
                // DEBUG console.log('... get_required_signatures',required_public_keys)
                return required_public_keys;
            });
        }
    }, {
        key: "add_signer",
        value: function add_signer(private_key) {
            var public_key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : private_key.toPublicKey();


            assert(private_key.d, "required PrivateKey object");

            if (this.signed) {
                throw new Error("already signed");
            }
            if (!public_key.Q) {
                public_key = PublicKey.fromPublicKeyString(public_key);
            }
            // prevent duplicates
            var spHex = private_key.toHex();
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = this.signer_private_keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var sp = _step2.value;

                    if (sp[0].toHex() === spHex) return;
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            this.signer_private_keys.push([private_key, public_key]);
        }
    }, {
        key: "sign",
        value: function sign() {
            var chain_id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ChainConfig.networks.Steem.chain_id;

            if (!this.tr_buffer) {
                throw new Error("not finalized");
            }
            if (this.signed) {
                throw new Error("already signed");
            }
            var end = this.signer_private_keys.length;
            for (var i = 0; 0 < end ? i < end : i > end; 0 < end ? i++ : i++) {
                var _signer_private_keys$ = _slicedToArray(this.signer_private_keys[i], 2);

                var private_key = _signer_private_keys$[0];
                var public_key = _signer_private_keys$[1];

                var sig = Signature.signBuffer(Buffer.concat([new Buffer(chain_id, 'hex'), this.tr_buffer]), private_key, public_key);
                this.signatures.push(sig.toBuffer());
            }
            this.signer_private_keys = [];
            this.signed = true;
            return;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            return ops.signed_transaction.toObject(this);
        }
    }, {
        key: "toObject",
        value: function toObject() {
            return ops.signed_transaction.toObject(this);
        }
    }, {
        key: "broadcast",
        value: function broadcast(was_broadcast_callback) {
            var _this3 = this;

            if (this.tr_buffer) {
                return this._broadcast(was_broadcast_callback);
            } else {
                return this.finalize().then(function () {
                    return _this3._broadcast(was_broadcast_callback);
                });
            }
        }
    }]);

    return TransactionBuilder;
}();

var base_expiration_sec = function base_expiration_sec() {
    var head_block_sec = Math.ceil(getHeadBlockDate().getTime() / 1000);
    var now_sec = Math.ceil(Date.now() / 1000);
    // The head block time should be updated every 3 seconds.  If it isn't
    // then help the transaction to expire (use head_block_sec)
    if (now_sec - head_block_sec > 30) {
        return head_block_sec;
    }
    // If the user's clock is very far behind, use the head block time.
    return Math.max(now_sec, head_block_sec);
};

function _broadcast(was_broadcast_callback) {
    var _this4 = this;

    return new Promise(function (resolve, reject) {
        if (!_this4.signed) {
            _this4.sign();
        }
        if (!_this4.tr_buffer) {
            reject(new Error("not finalized"));
        }
        if (!_this4.signatures.length) {
            reject(new Error("not signed"));
        }
        if (!_this4.operations.length) {
            reject(new Error("no operations"));
        }

        if (!("network_broadcast_api" in Api)) {
            reject(new Error("Api does not include network_broadcast_api"));
        }
        var tr_object = ops.signed_transaction.toObject(_this4);

        return Api.network_broadcast_api().exec("broadcast_transaction_with_callback", [{ reject: reject, resolve: resolve }, tr_object]).then(function () {
            // console.log('... broadcast success, waiting for callback')
            if (was_broadcast_callback) was_broadcast_callback();
            return;
        }).catch(function (error) {
            // console.log may be redundant for network errors, other errors could occur
            // console.log(error);
            var message = error.message;
            if (!message) {
                message = "";
            }
            reject(new Error(message + "\n" + 'graphene-crypto ' + ' digest ' + hash.sha256(_this4.tr_buffer).toString('hex') + ' transaction ' + _this4.tr_buffer.toString('hex') + ' ' + JSON.stringify(tr_object)));
        });
    });
}

function getHeadBlockDate() {
    return timeStringToDate(head_block_time_string);
}

function timeStringToDate(time_string) {
    if (!time_string) return new Date("1970-01-01T00:00:00.000Z");
    if (!/Z$/.test(time_string)) //does not end in Z
        // https://github.com/cryptonomex/graphene/issues/368
        time_string = time_string + "Z";
    return new Date(time_string);
}

module.exports = TransactionBuilder;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/chain/src/TransactionBuilder.js","/../node_modules/golosjs-lib/dist/chain/src")
},{"../../chain/src/ChainConfig":38,"../../ecc":45,"../../serializer":58,"./ChainTypes":39,"assert":1,"buffer":11,"bytebuffer":12,"pBGvAp":74,"steem-rpc":88}],44:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var helper;
module.exports = helper = {};

var secureRandom = require('secure-random');

//Promise = require '../common/Promise'

var _require = require('bytebuffer');

var Long = _require.Long;

var _require2 = require("../../ecc");

var Signature = _require2.Signature;

var _require3 = require("../../serializer");

var ops = _require3.ops;


helper.unique_nonce_entropy = null;
helper.unique_nonce_uint64 = function () {
    var entropy = helper.unique_nonce_entropy = function () {

        if (helper.unique_nonce_entropy === null) {
            //console.log('... secureRandom.randomUint8Array(1)[0]',secureRandom.randomUint8Array(1)[0])
            return parseInt(secureRandom.randomUint8Array(1)[0]);
        } else {
            return ++helper.unique_nonce_entropy % 256;
        }
    }();
    var long = Long.fromNumber(Date.now());
    //console.log('unique_nonce_uint64 date\t',ByteBuffer.allocate(8).writeUint64(long).toHex(0))
    //console.log('unique_nonce_uint64 entropy\t',ByteBuffer.allocate(8).writeUint64(Long.fromNumber(entropy)).toHex(0))
    long = long.shiftLeft(8).or(Long.fromNumber(entropy));
    //console.log('unique_nonce_uint64 shift8\t',ByteBuffer.allocate(8).writeUint64(long).toHex(0))
    return long.toString();
};

/* Todo, set fees */
helper.to_json = function (tr) {
    var broadcast = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    return function (tr, broadcast) {
        var tr_object = ops.signed_transaction.toObject(tr);
        if (broadcast) {
            var net = Apis.instance().network_api();
            console.log('... tr_object', JSON.stringify(tr_object));
            return net.exec("broadcast_transaction", [tr_object]);
        } else {
            return tr_object;
        }
    }(tr, broadcast);
};

helper.signed_tr_json = function (tr, private_keys) {
    var tr_buffer = ops.transaction.toBuffer(tr);
    tr = ops.transaction.toObject(tr);
    tr.signatures = function () {
        var result = [];
        for (var i = 0; 0 < private_keys.length ? i < private_keys.length : i > private_keys.length; 0 < private_keys.length ? i++ : i++) {
            var private_key = private_keys[i];
            result.push(Signature.signBuffer(tr_buffer, private_key).toHex());
        }
        return result;
    }();
    return tr;
};

helper.expire_in_min = function (min) {
    return Math.round(Date.now() / 1000) + min * 60;
};

helper.seconds_from_now = function (timeout_sec) {
    return Math.round(Date.now() / 1000) + timeout_sec;
};

/**
    Print to the console a JSON representation of any object in
    @graphene/serializer { types }
*/
helper.template = function (serializer_operation_type_name) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { use_default: true, annotate: true };

    var so = type[serializer_operation_type_name];
    if (!so) {
        throw new Error('unknown serializer_operation_type ' + serializer_operation_type_name);
    }
    return so.toObject(undefined, debug);
};

helper.new_operation = function (serializer_operation_type_name) {
    var so = type[serializer_operation_type_name];
    if (!so) {
        throw new Error('unknown serializer_operation_type ' + serializer_operation_type_name);
    }
    var object = so.toObject(undefined, { use_default: true, annotate: true });
    return so.fromObject(object);
};

helper.instance = function (ObjectId) {
    return ObjectId.substring("0.0.".length);
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/chain/src/TransactionHelper.js","/../node_modules/golosjs-lib/dist/chain/src")
},{"../../ecc":45,"../../serializer":58,"buffer":11,"bytebuffer":12,"pBGvAp":74,"secure-random":76}],45:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = {
    Address: require("./src/address"),
    Aes: require("./src/aes"),
    PrivateKey: require("./src/PrivateKey"),
    PublicKey: require("./src/PublicKey"),
    Signature: require("./src/signature"),
    brainKey: require("./src/BrainKey"),
    hash: require("./src/hash"),
    key: require("./src/KeyUtils")
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/ecc/index.js","/../node_modules/golosjs-lib/dist/ecc")
},{"./src/BrainKey":46,"./src/KeyUtils":47,"./src/PrivateKey":48,"./src/PublicKey":49,"./src/address":50,"./src/aes":51,"./src/hash":55,"./src/signature":56,"buffer":11,"pBGvAp":74}],46:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

module.exports = function normalize(brainKey) {
    if (typeof brainKey !== 'string') {
        throw new Error("string required for brainKey");
    }
    brainKey = brainKey.trim();
    return brainKey.split(/[\t\n\v\f\r ]+/).join(' ');
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/ecc/src/BrainKey.js","/../node_modules/golosjs-lib/dist/ecc/src")
},{"buffer":11,"pBGvAp":74}],47:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var key;
var PrivateKey = require('./PrivateKey');
var PublicKey = require('./PublicKey');
var Address = require('./address');
var Aes = require('./aes');

var hash = require('./hash');
// var dictionary = require('./dictionary_en');
var secureRandom = require('secure-random');
var ChainConfig = require("../../chain/src/ChainConfig");

// hash for .25 second
var HASH_POWER_MILLS = 250;

module.exports = key = {

    /** Uses 1 second of hashing power to create a key/password checksum.  An
    implementation can re-call this method with the same password to re-match
    the strength of the CPU (either after moving from a desktop to a mobile,
    mobile to desktop, or N years from now when CPUs are presumably stronger).
     A salt is used for all the normal reasons...
     @return object {
        aes_private: Aes,
        checksum: "{hash_iteration_count},{salt},{checksum}"
    }
    */
    aes_checksum: function aes_checksum(password) {
        if (!(typeof password === "string")) {
            throw new "password string required"();
        }
        var salt = secureRandom.randomBuffer(4).toString('hex');
        var iterations = 0;
        var secret = salt + password;
        // hash for .1 second
        var start_t = Date.now();
        while (Date.now() - start_t < HASH_POWER_MILLS) {
            secret = hash.sha256(secret);
            iterations += 1;
        }

        var checksum = hash.sha256(secret);
        var checksum_string = [iterations, salt.toString('hex'), checksum.slice(0, 4).toString('hex')].join(',');

        return { aes_private: Aes.fromSeed(secret),
            checksum: checksum_string
        };
    },


    /** Provide a matching password and key_checksum.  A "wrong password"
    error is thrown if the password does not match.  If this method takes
    much more or less than 1 second to return, one should consider updating
    all encyrpted fields using a new key.key_checksum.
    */
    aes_private: function aes_private(password, key_checksum) {
        var _key_checksum$split = key_checksum.split(',');

        var _key_checksum$split2 = _slicedToArray(_key_checksum$split, 3);

        var iterations = _key_checksum$split2[0];
        var salt = _key_checksum$split2[1];
        var checksum = _key_checksum$split2[2];

        var secret = salt + password;
        for (var i = 0; 0 < iterations ? i < iterations : i > iterations; 0 < iterations ? i++ : i++) {
            secret = hash.sha256(secret);
        }
        var new_checksum = hash.sha256(secret);
        if (!(new_checksum.slice(0, 4).toString('hex') === checksum)) {
            throw new Error("wrong password");
        }
        return Aes.fromSeed(secret);
    },


    /**
        A week random number generator can run out of entropy.  This should ensure even the worst random number implementation will be reasonably safe.
         @param1 string entropy of at least 32 bytes
    */
    random32ByteBuffer: function random32ByteBuffer() {
        var entropy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.browserEntropy();


        if (!(typeof entropy === 'string')) {
            throw new Error("string required for entropy");
        }

        if (entropy.length < 32) {
            throw new Error("expecting at least 32 bytes of entropy");
        }

        var start_t = Date.now();

        while (Date.now() - start_t < HASH_POWER_MILLS) {
            entropy = hash.sha256(entropy);
        }var hash_array = [];
        hash_array.push(entropy);

        // Hashing for 1 second may helps the computer is not low on entropy (this method may be called back-to-back).
        hash_array.push(secureRandom.randomBuffer(32));

        return hash.sha256(Buffer.concat(hash_array));
    },


    suggest_brain_key: function suggest_brain_key() {
        var dictionary = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ",";
        var entropy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.browserEntropy();


        var randomBuffer = this.random32ByteBuffer(entropy);

        var word_count = 16;
        var dictionary_lines = dictionary.split(',');

        if (!(dictionary_lines.length === 49744)) {
            throw new Error('expecting ' + 49744 + ' but got ' + dictionary_lines.length + ' dictionary words');
        }

        var brainkey = [];
        var end = word_count * 2;

        for (var i = 0; i < end; i += 2) {

            // randomBuffer has 256 bits / 16 bits per word == 16 words
            var num = (randomBuffer[i] << 8) + randomBuffer[i + 1];

            // convert into a number between 0 and 1 (inclusive)
            var rndMultiplier = num / Math.pow(2, 16);
            var wordIndex = Math.round(dictionary_lines.length * rndMultiplier);

            brainkey.push(dictionary_lines[wordIndex]);
        }
        return this.normalize_brainKey(brainkey.join(' '));
    },

    get_random_key: function get_random_key(entropy) {
        return PrivateKey.fromBuffer(this.random32ByteBuffer(entropy));
    },
    get_brainPrivateKey: function get_brainPrivateKey(brainKey) {
        var sequence = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (sequence < 0) {
            throw new Error("invalid sequence");
        }
        brainKey = key.normalize_brainKey(brainKey);
        return PrivateKey.fromBuffer(hash.sha256(hash.sha512(brainKey + " " + sequence)));
    },


    // Turn invisible space like characters into a single space
    normalize_brainKey: function normalize_brainKey(brainKey) {
        if (!(typeof brainKey === 'string')) {
            throw new Error("string required for brainKey");
        }

        brainKey = brainKey.trim();
        return brainKey.split(/[\t\n\v\f\r ]+/).join(' ');
    },
    browserEntropy: function browserEntropy() {

        var entropyStr = "";
        try {
            entropyStr = new Date().toString() + " " + window.screen.height + " " + window.screen.width + " " + window.screen.colorDepth + " " + " " + window.screen.availHeight + " " + window.screen.availWidth + " " + window.screen.pixelDepth + navigator.language + " " + window.location + " " + window.history.length;

            for (var i = 0, mimeType; i < navigator.mimeTypes.length; i++) {
                mimeType = navigator.mimeTypes[i];
                entropyStr += mimeType.description + " " + mimeType.type + " " + mimeType.suffixes + " ";
            }
            console.log("INFO\tbrowserEntropy gathered");
        } catch (error) {
            //nodejs:ReferenceError: window is not defined
            entropyStr = hash.sha256(new Date().toString());
        }

        var b = new Buffer(entropyStr);
        entropyStr += b.toString('binary') + " " + new Date().toString();
        return entropyStr;
    },


    // @return array of 5 legacy addresses for a pubkey string parameter.
    addresses: function addresses(pubkey) {
        var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ChainConfig.address_prefix;

        var public_key = PublicKey.fromPublicKeyString(pubkey, address_prefix);
        // S L O W
        var address_string = [Address.fromPublic(public_key, false, 0).toString(address_prefix), // btc_uncompressed
        Address.fromPublic(public_key, true, 0).toString(address_prefix), // btc_compressed
        Address.fromPublic(public_key, false, 56).toString(address_prefix), // pts_uncompressed
        Address.fromPublic(public_key, true, 56).toString(address_prefix), // pts_compressed
        public_key.toAddressString(address_prefix) // bts_short, most recent format
        ];
        return address_string;
    }
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/ecc/src/KeyUtils.js","/../node_modules/golosjs-lib/dist/ecc/src")
},{"../../chain/src/ChainConfig":38,"./PrivateKey":48,"./PublicKey":49,"./address":50,"./aes":51,"./hash":55,"buffer":11,"pBGvAp":74,"secure-random":76}],48:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ecurve = require('ecurve');

var _require = require('ecurve');

var Point = _require.Point;
var getCurveByName = _require.getCurveByName;

var secp256k1 = getCurveByName('secp256k1');
var BigInteger = require('bigi');

var _require2 = require('bs58');

var encode = _require2.encode;
var decode = _require2.decode;

var assert = require('assert');
var hash = require('./hash');
var PublicKey = require('./PublicKey');
var deepEqual = require("deep-equal");

var G = secp256k1.G;
var n = secp256k1.n;

var PrivateKey = function () {

    /**
        @private see static functions
        @param {BigInteger}
    */
    function PrivateKey(d) {
        _classCallCheck(this, PrivateKey);

        this.d = d;
    }

    _createClass(PrivateKey, [{
        key: 'toWif',
        value: function toWif() {
            var private_key = this.toBuffer();
            // checksum includes the version
            private_key = Buffer.concat([new Buffer([0x80]), private_key]);
            var checksum = hash.sha256(private_key);
            checksum = hash.sha256(checksum);
            checksum = checksum.slice(0, 4);
            var private_wif = Buffer.concat([private_key, checksum]);
            return encode(private_wif);
        }

        /**
            @return {Point}
        */

    }, {
        key: 'toPublicKeyPoint',
        value: function toPublicKeyPoint() {
            var Q;
            return Q = secp256k1.G.multiply(this.d);
        }
    }, {
        key: 'toPublicKey',
        value: function toPublicKey() {
            if (this.public_key) {
                return this.public_key;
            }
            return this.public_key = PublicKey.fromPoint(this.toPublicKeyPoint());
        }
    }, {
        key: 'toBuffer',
        value: function toBuffer() {
            return this.d.toBuffer(32);
        }

        /** ECIES */

    }, {
        key: 'get_shared_secret',
        value: function get_shared_secret(public_key) {
            var legacy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            public_key = toPublic(public_key);
            var KB = public_key.toUncompressed().toBuffer();
            var KBP = Point.fromAffine(secp256k1, BigInteger.fromBuffer(KB.slice(1, 33)), // x
            BigInteger.fromBuffer(KB.slice(33, 65)) // y
            );
            var r = this.toBuffer();
            var P = KBP.multiply(BigInteger.fromBuffer(r));
            var S = P.affineX.toBuffer({ size: 32 });
            /*
            the input to sha512 must be exactly 32-bytes, to match the c++ implementation
            of get_shared_secret.  Right now S will be shorter if the most significant
            byte(s) is zero.  Pad it back to the full 32-bytes
            */
            if (!legacy && S.length < 32) {
                pad = new Buffer(32 - S.length).fill(0);
                S = Buffer.concat([pad, S]);
            }

            // SHA512 used in ECIES
            return hash.sha512(S);
        }

        // /** ECIES (does not always match the Point.fromAffine version above) */
        // get_shared_secret(public_key){
        //     public_key = toPublic(public_key)
        //     var P = public_key.Q.multiply( this.d );
        //     var S = P.affineX.toBuffer({size: 32});
        //     // ECIES, adds an extra sha512
        //     return hash.sha512(S);
        // }

        /** @throws {Error} - overflow of the key could not be derived */

    }, {
        key: 'child',
        value: function child(offset) {
            offset = Buffer.concat([this.toPublicKey().toBuffer(), offset]);
            offset = hash.sha256(offset);
            var c = BigInteger.fromBuffer(offset);

            if (c.compareTo(n) >= 0) throw new Error("Child offset went out of bounds, try again");

            var derived = this.d.add(c); //.mod(n)

            if (derived.signum() === 0) throw new Error("Child offset derived to an invalid key, try again");

            return new PrivateKey(derived);
        }

        /* <helper_functions> */

    }, {
        key: 'toByteBuffer',
        value: function toByteBuffer() {
            var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            this.appendByteBuffer(b);
            return b.copy(0, b.offset);
        }
    }, {
        key: 'toHex',
        value: function toHex() {
            return this.toBuffer().toString('hex');
        }

        /* </helper_functions> */

    }], [{
        key: 'fromBuffer',
        value: function fromBuffer(buf) {
            if (!Buffer.isBuffer(buf)) {
                throw new Error("Expecting paramter to be a Buffer type");
            }
            if (32 !== buf.length) {
                console.log('WARN: Expecting 32 bytes, instead got ' + buf.length + ', stack trace:', new Error().stack);
            }
            if (buf.length === 0) {
                throw new Error("Empty buffer");
            }
            return new PrivateKey(BigInteger.fromBuffer(buf));
        }

        /** @arg {string} seed - any length string.  This is private, the same seed produces the same private key every time.  */

    }, {
        key: 'fromSeed',
        value: function fromSeed(seed) {
            // generate_private_key
            if (!(typeof seed === 'string')) {
                throw new Error('seed must be of type string');
            }
            return PrivateKey.fromBuffer(hash.sha256(seed));
        }

        /** @return {string} Wallet Import Format (still a secret, Not encrypted) */

    }, {
        key: 'fromWif',
        value: function fromWif(_private_wif) {
            var private_wif = new Buffer(decode(_private_wif));
            var version = private_wif.readUInt8(0);
            assert.equal(0x80, version, 'Expected version ' + 0x80 + ', instead got ' + version);
            // checksum includes the version
            var private_key = private_wif.slice(0, -4);
            var checksum = private_wif.slice(-4);
            var new_checksum = hash.sha256(private_key);
            new_checksum = hash.sha256(new_checksum);
            new_checksum = new_checksum.slice(0, 4);
            var isEqual = deepEqual(checksum, new_checksum); //, 'Invalid checksum'
            if (!isEqual) {
                throw new Error("Checksum did not match");
            }
            private_key = private_key.slice(1);
            return PrivateKey.fromBuffer(private_key);
        }
    }, {
        key: 'fromHex',
        value: function fromHex(hex) {
            return PrivateKey.fromBuffer(new Buffer(hex, 'hex'));
        }
    }]);

    return PrivateKey;
}();

module.exports = PrivateKey;

var toPublic = function toPublic(data) {
    return data == null ? data : data.Q ? data : PublicKey.fromStringOrThrow(data);
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/ecc/src/PrivateKey.js","/../node_modules/golosjs-lib/dist/ecc/src")
},{"./PublicKey":49,"./hash":55,"assert":1,"bigi":6,"bs58":10,"buffer":11,"deep-equal":67,"ecurve":32,"pBGvAp":74}],49:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BigInteger = require('bigi');

var _require = require('ecurve');

var Point = _require.Point;
var getCurveByName = _require.getCurveByName;

var secp256k1 = getCurveByName('secp256k1');

var _require2 = require('bs58');

var encode = _require2.encode;
var decode = _require2.decode;

var hash = require('./hash');
var ChainConfig = require("../../chain/src/ChainConfig");
var assert = require('assert');
var deepEqual = require("deep-equal");

var G = secp256k1.G;
var n = secp256k1.n;

var PublicKey = function () {

    /** @param {Point} public key */
    function PublicKey(Q) {
        _classCallCheck(this, PublicKey);

        this.Q = Q;
    }

    _createClass(PublicKey, [{
        key: 'toBuffer',
        value: function toBuffer() {
            var compressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.Q ? this.Q.compressed : null;

            if (this.Q === null) return new Buffer('000000000000000000000000000000000000000000000000000000000000000000', 'hex');
            return this.Q.getEncoded(compressed);
        }
    }, {
        key: 'toUncompressed',
        value: function toUncompressed() {
            var buf = this.Q.getEncoded(false);
            var point = Point.decodeFrom(secp256k1, buf);
            return PublicKey.fromPoint(point);
        }

        /** bts::blockchain::address (unique but not a full public key) */

    }, {
        key: 'toBlockchainAddress',
        value: function toBlockchainAddress() {
            var pub_buf = this.toBuffer();
            var pub_sha = hash.sha512(pub_buf);
            return hash.ripemd160(pub_sha);
        }

        /** Alias for {@link toPublicKeyString} */

    }, {
        key: 'toString',
        value: function toString() {
            var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ChainConfig.address_prefix;

            return this.toPublicKeyString(address_prefix);
        }

        /**
            Full public key
            {return} string
        */

    }, {
        key: 'toPublicKeyString',
        value: function toPublicKeyString() {
            var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ChainConfig.address_prefix;

            var pub_buf = this.toBuffer();
            var checksum = hash.ripemd160(pub_buf);
            var addy = Buffer.concat([pub_buf, checksum.slice(0, 4)]);
            return address_prefix + encode(addy);
        }

        /**
            @arg {string} public_key - like GPHXyz...
            @arg {string} address_prefix - like GPH
            @return PublicKey or `null` (if the public_key string is invalid)
        */

    }, {
        key: 'toAddressString',
        value: function toAddressString() {
            var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ChainConfig.address_prefix;

            var pub_buf = this.toBuffer();
            var pub_sha = hash.sha512(pub_buf);
            var addy = hash.ripemd160(pub_sha);
            var checksum = hash.ripemd160(addy);
            addy = Buffer.concat([addy, checksum.slice(0, 4)]);
            return address_prefix + encode(addy);
        }
    }, {
        key: 'toPtsAddy',
        value: function toPtsAddy() {
            var pub_buf = this.toBuffer();
            var pub_sha = hash.sha256(pub_buf);
            var addy = hash.ripemd160(pub_sha);
            addy = Buffer.concat([new Buffer([0x38]), addy]); //version 56(decimal)

            var checksum = hash.sha256(addy);
            checksum = hash.sha256(checksum);

            addy = Buffer.concat([addy, checksum.slice(0, 4)]);
            return encode(addy);
        }
    }, {
        key: 'child',
        value: function child(offset) {

            assert(Buffer.isBuffer(offset), "Buffer required: offset");
            assert.equal(offset.length, 32, "offset length");

            offset = Buffer.concat([this.toBuffer(), offset]);
            offset = hash.sha256(offset);

            var c = BigInteger.fromBuffer(offset);

            if (c.compareTo(n) >= 0) throw new Error("Child offset went out of bounds, try again");

            var cG = G.multiply(c);
            var Qprime = this.Q.add(cG);

            if (secp256k1.isInfinity(Qprime)) throw new Error("Child offset derived to an invalid key, try again");

            return PublicKey.fromPoint(Qprime);
        }

        /* <HEX> */

    }, {
        key: 'toByteBuffer',
        value: function toByteBuffer() {
            var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            this.appendByteBuffer(b);
            return b.copy(0, b.offset);
        }
    }, {
        key: 'toHex',
        value: function toHex() {
            return this.toBuffer().toString('hex');
        }
    }], [{
        key: 'fromBinary',
        value: function fromBinary(bin) {
            return PublicKey.fromBuffer(new Buffer(bin, 'binary'));
        }
    }, {
        key: 'fromBuffer',
        value: function fromBuffer(buffer) {
            if (buffer.toString('hex') === '000000000000000000000000000000000000000000000000000000000000000000') return new PublicKey(null);
            return new PublicKey(Point.decodeFrom(secp256k1, buffer));
        }
    }, {
        key: 'fromPoint',
        value: function fromPoint(point) {
            return new PublicKey(point);
        }
    }, {
        key: 'fromPublicKeyString',
        value: function fromPublicKeyString(public_key) {
            var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ChainConfig.address_prefix;

            try {
                return PublicKey.fromStringOrThrow(public_key, address_prefix);
            } catch (e) {
                return null;
            }
        }

        /**
            @arg {string} public_key - like GPHXyz...
            @arg {string} address_prefix - like GPH
            @throws {Error} if public key is invalid
            @return PublicKey
        */

    }, {
        key: 'fromStringOrThrow',
        value: function fromStringOrThrow(public_key) {
            var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ChainConfig.address_prefix;

            var prefix = public_key.slice(0, address_prefix.length);
            assert.equal(address_prefix, prefix, 'Expecting key to begin with ' + address_prefix + ', instead got ' + prefix);
            public_key = public_key.slice(address_prefix.length);

            public_key = new Buffer(decode(public_key), 'binary');
            var checksum = public_key.slice(-4);
            public_key = public_key.slice(0, -4);
            var new_checksum = hash.ripemd160(public_key);
            new_checksum = new_checksum.slice(0, 4);
            var isEqual = deepEqual(checksum, new_checksum); //, 'Invalid checksum'
            if (!isEqual) {
                throw new Error("Checksum did not match");
            }
            return PublicKey.fromBuffer(public_key);
        }
    }, {
        key: 'fromHex',
        value: function fromHex(hex) {
            return PublicKey.fromBuffer(new Buffer(hex, 'hex'));
        }
    }, {
        key: 'fromPublicKeyStringHex',
        value: function fromPublicKeyStringHex(hex) {
            return PublicKey.fromPublicKeyString(new Buffer(hex, 'hex'));
        }

        /* </HEX> */

    }]);

    return PublicKey;
}();

module.exports = PublicKey;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/ecc/src/PublicKey.js","/../node_modules/golosjs-lib/dist/ecc/src")
},{"../../chain/src/ChainConfig":38,"./hash":55,"assert":1,"bigi":6,"bs58":10,"buffer":11,"deep-equal":67,"ecurve":32,"pBGvAp":74}],50:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assert = require('assert');
var ChainConfig = require("../../chain/src/ChainConfig");
var hash = require('./hash');

var _require = require('bs58');

var encode = _require.encode;
var decode = _require.decode;

var deepEqual = require("deep-equal");

/** Addresses are shortened non-reversable hashes of a public key.  The full PublicKey is preferred.
    @deprecated
*/

var Address = function () {
    function Address(addy) {
        _classCallCheck(this, Address);

        this.addy = addy;
    }

    _createClass(Address, [{
        key: 'toBuffer',
        value: function toBuffer() {
            return this.addy;
        }
    }, {
        key: 'toString',
        value: function toString() {
            var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ChainConfig.address_prefix;

            var checksum = hash.ripemd160(this.addy);
            var addy = Buffer.concat([this.addy, checksum.slice(0, 4)]);
            return address_prefix + encode(addy);
        }
    }], [{
        key: 'fromBuffer',
        value: function fromBuffer(buffer) {
            var _hash = hash.sha512(buffer);
            var addy = hash.ripemd160(_hash);
            return new Address(addy);
        }
    }, {
        key: 'fromString',
        value: function fromString(string) {
            var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ChainConfig.address_prefix;

            var prefix = string.slice(0, address_prefix.length);
            assert.equal(address_prefix, prefix, 'Expecting key to begin with ' + address_prefix + ', instead got ' + prefix);
            var addy = string.slice(address_prefix.length);
            addy = new Buffer(decode(addy), 'binary');
            var checksum = addy.slice(-4);
            addy = addy.slice(0, -4);
            var new_checksum = hash.ripemd160(addy);
            new_checksum = new_checksum.slice(0, 4);
            var isEqual = deepEqual(checksum, new_checksum); //, 'Invalid checksum'
            if (!isEqual) {
                throw new Error("Checksum did not match");
            }
            return new Address(addy);
        }
    }, {
        key: 'fromPublic',


        /** @return Address - Compressed PTS format (by default) */
        value: function fromPublic(public_key) {
            var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 56;

            var sha2 = hash.sha256(public_key.toBuffer(compressed));
            var rep = hash.ripemd160(sha2);
            var versionBuffer = new Buffer(1);
            versionBuffer.writeUInt8(0xFF & version, 0);
            var addr = Buffer.concat([versionBuffer, rep]);
            var check = hash.sha256(addr);
            check = hash.sha256(check);
            var buffer = Buffer.concat([addr, check.slice(0, 4)]);
            return new Address(hash.ripemd160(buffer));
        }
    }]);

    return Address;
}();

module.exports = Address;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/ecc/src/address.js","/../node_modules/golosjs-lib/dist/ecc/src")
},{"../../chain/src/ChainConfig":38,"./hash":55,"assert":1,"bs58":10,"buffer":11,"deep-equal":67,"pBGvAp":74}],51:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// https://code.google.com/p/crypto-js
var AES = require("crypto-js/aes");
var encHex = require("crypto-js/enc-hex");
var encBase64 = require("crypto-js/enc-base64");
var assert = require("assert");

var _require = require("bytebuffer");

var Long = _require.Long;

var hash = require('./hash');

/** Provides symetric encrypt and decrypt via AES. */

var Aes = function () {

    /** @private */
    function Aes(iv, key) {
        _classCallCheck(this, Aes);

        this.iv = iv, this.key = key;
    }

    /** This is an excellent way to ensure that all references to Aes can not operate anymore (example: a wallet becomes locked).  An application should ensure there is only one Aes object instance for a given secret `seed`. */


    _createClass(Aes, [{
        key: "clear",
        value: function clear() {
            return this.iv = this.key = undefined;
        }

        /** @arg {string} seed - secret seed may be used to encrypt or decrypt. */

    }, {
        key: "_decrypt_word_array",


        /** @private */
        value: function _decrypt_word_array(cipher) {
            // https://code.google.com/p/crypto-js/#Custom_Key_and_IV
            // see wallet_records.cpp master_key::decrypt_key
            return AES.decrypt({ ciphertext: cipher, salt: null }, this.key, { iv: this.iv });
        }

        /** @private */

    }, {
        key: "_encrypt_word_array",
        value: function _encrypt_word_array(plaintext) {
            //https://code.google.com/p/crypto-js/issues/detail?id=85
            var cipher = AES.encrypt(plaintext, this.key, { iv: this.iv });
            return encBase64.parse(cipher.toString());
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} ciphertext
            @return {Buffer} binary
        */

    }, {
        key: "decrypt",
        value: function decrypt(ciphertext) {
            if (typeof ciphertext === "string") {
                ciphertext = new Buffer(ciphertext, 'binary');
            }
            if (!Buffer.isBuffer(ciphertext)) {
                throw new Error("buffer required");
            }
            assert(ciphertext, "Missing cipher text");
            // hex is the only common format
            var hex = this.decryptHex(ciphertext.toString('hex'));
            return new Buffer(hex, 'hex');
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} plaintext
            @return {Buffer} binary
        */

    }, {
        key: "encrypt",
        value: function encrypt(plaintext) {
            if (typeof plaintext === "string") {
                plaintext = new Buffer(plaintext, 'binary');
            }
            if (!Buffer.isBuffer(plaintext)) {
                throw new Error("buffer required");
            }
            //assert plaintext, "Missing plain text"
            // hex is the only common format
            var hex = this.encryptHex(plaintext.toString('hex'));
            return new Buffer(hex, 'hex');
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string|Buffer} plaintext
            @return {string} hex
        */

    }, {
        key: "encryptToHex",
        value: function encryptToHex(plaintext) {
            if (typeof plaintext === "string") {
                plaintext = new Buffer(plaintext, 'binary');
            }
            if (!Buffer.isBuffer(plaintext)) {
                throw new Error("buffer required");
            }
            //assert plaintext, "Missing plain text"
            // hex is the only common format
            return this.encryptHex(plaintext.toString('hex'));
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} cipher - hex
            @return {string} binary (could easily be readable text)
        */

    }, {
        key: "decryptHex",
        value: function decryptHex(cipher) {
            assert(cipher, "Missing cipher text");
            // Convert data into word arrays (used by Crypto)
            var cipher_array = encHex.parse(cipher);
            var plainwords = this._decrypt_word_array(cipher_array);
            return encHex.stringify(plainwords);
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} cipher - hex
            @return {Buffer} encoded as specified by the parameter
        */

    }, {
        key: "decryptHexToBuffer",
        value: function decryptHexToBuffer(cipher) {
            assert(cipher, "Missing cipher text");
            // Convert data into word arrays (used by Crypto)
            var cipher_array = encHex.parse(cipher);
            var plainwords = this._decrypt_word_array(cipher_array);
            var plainhex = encHex.stringify(plainwords);
            return new Buffer(plainhex, 'hex');
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} cipher - hex
            @arg {string} [encoding = 'binary'] - a valid Buffer encoding
            @return {String} encoded as specified by the parameter
        */

    }, {
        key: "decryptHexToText",
        value: function decryptHexToText(cipher) {
            var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'binary';

            return this.decryptHexToBuffer(cipher).toString(encoding);
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} plainhex - hex format
            @return {String} hex
        */

    }, {
        key: "encryptHex",
        value: function encryptHex(plainhex) {
            var plain_array = encHex.parse(plainhex);
            var cipher_array = this._encrypt_word_array(plain_array);
            return encHex.stringify(cipher_array);
        }
    }], [{
        key: "fromSeed",
        value: function fromSeed(seed) {
            if (seed === undefined) {
                throw new Error("seed is required");
            }
            var _hash = hash.sha512(seed);
            _hash = _hash.toString('hex');
            // DEBUG console.log('... fromSeed _hash',_hash)
            return Aes.fromSha512(_hash);
        }
    }, {
        key: "fromSha512",


        /** @arg {string} hash - A 128 byte hex string, typically one would call {@link fromSeed} instead. */
        value: function fromSha512(hash) {
            assert.equal(hash.length, 128, "A Sha512 in HEX should be 128 characters long, instead got " + hash.length);
            var iv = encHex.parse(hash.substring(64, 96));
            var key = encHex.parse(hash.substring(0, 64));
            return new Aes(iv, key);
        }
    }, {
        key: "fromBuffer",
        value: function fromBuffer(buf) {
            assert(Buffer.isBuffer(buf), "Expecting Buffer");
            assert.equal(buf.length, 64, "A Sha512 Buffer should be 64 characters long, instead got " + buf.length);
            return Aes.fromSha512(buf.toString("hex"));
        }
        /**
            @throws {Error} - "Invalid Key, ..."
            @arg {PrivateKey} private_key - required and used for decryption
            @arg {PublicKey} public_key - required and used to calcualte the shared secret
            @arg {string} [nonce = ""] optional but should always be provided and be unique when re-using the same private/public keys more than once.  This nonce is not a secret.
            @arg {string|Buffer} message - Encrypted message containing a checksum
            @return {Buffer}
        */

    }, {
        key: "decrypt_with_checksum",
        value: function decrypt_with_checksum(private_key, public_key, nonce, message) {
            var legacy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;


            // Warning: Do not put `nonce = ""` in the arguments, in es6 this will not convert "null" into an emtpy string
            if (nonce == null) // null or undefined
                nonce = "";

            if (!Buffer.isBuffer(message)) {
                message = new Buffer(message, 'hex');
            }

            var S = private_key.get_shared_secret(public_key, legacy);
            // D E B U G
            // console.log('decrypt_with_checksum', {
            //     priv_to_pub: private_key.toPublicKey().toString(),
            //     pub: public_key.toPublicKeyString(),
            //     nonce: nonce,
            //     message: message.length,
            //     S: S.toString('hex')
            // })

            var aes = Aes.fromSeed(Buffer.concat([
            // A null or empty string nonce will not effect the hash
            new Buffer("" + nonce), new Buffer(S.toString('hex'))]));

            var planebuffer = aes.decrypt(message);
            if (!(planebuffer.length >= 4)) {
                throw new Error("Invalid key, could not decrypt message(1)");
            }

            // DEBUG console.log('... planebuffer',planebuffer)
            var checksum = planebuffer.slice(0, 4);
            var plaintext = planebuffer.slice(4);

            // console.log('... checksum',checksum.toString('hex'))
            // console.log('... plaintext',plaintext.toString())

            var new_checksum = hash.sha256(plaintext);
            new_checksum = new_checksum.slice(0, 4);
            new_checksum = new_checksum.toString('hex');

            if (!(checksum.toString('hex') === new_checksum)) {
                throw new Error("Invalid key, could not decrypt message(2)");
            }

            return plaintext;
        }
    }, {
        key: "encrypt_with_checksum",


        /** Identical to {@link decrypt_with_checksum} but used to encrypt.  Should not throw an error.
            @return {Buffer} message - Encrypted message which includes a checksum
        */
        value: function encrypt_with_checksum(private_key, public_key, nonce, message) {

            // Warning: Do not put `nonce = ""` in the arguments, in es6 this will not convert "null" into an emtpy string

            if (nonce == null) // null or undefined
                nonce = "";

            if (!Buffer.isBuffer(message)) {
                message = new Buffer(message, 'binary');
            }

            var S = private_key.get_shared_secret(public_key);

            // D E B U G
            // console.log('encrypt_with_checksum', {
            //     priv_to_pub: private_key.toPublicKey().toString()
            //     pub: public_key.toPublicKeyString()
            //     nonce: nonce
            //     message: message.length
            //     S: S.toString('hex')
            // })

            var aes = Aes.fromSeed(Buffer.concat([
            // A null or empty string nonce will not effect the hash
            new Buffer("" + nonce), new Buffer(S.toString('hex'))]));
            // DEBUG console.log('... S',S.toString('hex'))
            var checksum = hash.sha256(message).slice(0, 4);
            var payload = Buffer.concat([checksum, message]);
            // DEBUG console.log('... payload',payload.toString())
            return aes.encrypt(payload);
        }
    }]);

    return Aes;
}();

module.exports = Aes;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/ecc/src/aes.js","/../node_modules/golosjs-lib/dist/ecc/src")
},{"./hash":55,"assert":1,"buffer":11,"bytebuffer":12,"crypto-js/aes":18,"crypto-js/enc-base64":21,"crypto-js/enc-hex":22,"pBGvAp":74}],52:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var assert = require('assert'); // from github.com/bitcoinjs/bitcoinjs-lib from github.com/cryptocoinjs/ecdsa
var crypto = require('./hash');
var enforceType = require('./enforce_types');

var BigInteger = require('bigi');
var ECSignature = require('./ecsignature');

// https://tools.ietf.org/html/rfc6979#section-3.2
function deterministicGenerateK(curve, hash, d, checkSig, nonce) {

  enforceType('Buffer', hash);
  enforceType(BigInteger, d);

  if (nonce) {
    hash = crypto.sha256(Buffer.concat([hash, new Buffer(nonce)]));
  }

  // sanity check
  assert.equal(hash.length, 32, 'Hash must be 256 bit');

  var x = d.toBuffer(32);
  var k = new Buffer(32);
  var v = new Buffer(32);

  // Step B
  v.fill(1);

  // Step C
  k.fill(0);

  // Step D
  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0]), x, hash]), k);

  // Step E
  v = crypto.HmacSHA256(v, k);

  // Step F
  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([1]), x, hash]), k);

  // Step G
  v = crypto.HmacSHA256(v, k);

  // Step H1/H2a, ignored as tlen === qlen (256 bit)
  // Step H2b
  v = crypto.HmacSHA256(v, k);

  var T = BigInteger.fromBuffer(v);

  // Step H3, repeat until T is within the interval [1, n - 1]
  while (T.signum() <= 0 || T.compareTo(curve.n) >= 0 || !checkSig(T)) {
    k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0])]), k);
    v = crypto.HmacSHA256(v, k);

    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
    // Step H2b again
    v = crypto.HmacSHA256(v, k);

    T = BigInteger.fromBuffer(v);
  }

  return T;
}

function sign(curve, hash, d, nonce) {

  var e = BigInteger.fromBuffer(hash);
  var n = curve.n;
  var G = curve.G;

  var r, s;
  var k = deterministicGenerateK(curve, hash, d, function (k) {
    // find canonically valid signature
    var Q = G.multiply(k);

    if (curve.isInfinity(Q)) return false;

    r = Q.affineX.mod(n);
    if (r.signum() === 0) return false;

    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);
    if (s.signum() === 0) return false;

    return true;
  }, nonce);

  var N_OVER_TWO = n.shiftRight(1);

  // enforce low S values, see bip62: 'low s values in signatures'
  if (s.compareTo(N_OVER_TWO) > 0) {
    s = n.subtract(s);
  }

  return new ECSignature(r, s);
}

function verifyRaw(curve, e, signature, Q) {
  var n = curve.n;
  var G = curve.G;

  var r = signature.r;
  var s = signature.s;

  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]
  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false;
  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false;

  // c = s^-1 mod n
  var c = s.modInverse(n);

  // 1.4.4 Compute u1 = es^−1 mod n
  //               u2 = rs^−1 mod n
  var u1 = e.multiply(c).mod(n);
  var u2 = r.multiply(c).mod(n);

  // 1.4.5 Compute R = (xR, yR) = u1G + u2Q
  var R = G.multiplyTwo(u1, Q, u2);

  // 1.4.5 (cont.) Enforce R is not at infinity
  if (curve.isInfinity(R)) return false;

  // 1.4.6 Convert the field element R.x to an integer
  var xR = R.affineX;

  // 1.4.7 Set v = xR mod n
  var v = xR.mod(n);

  // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"
  return v.equals(r);
}

function verify(curve, hash, signature, Q) {
  // 1.4.2 H = Hash(M), already done by the user
  // 1.4.3 e = H
  var e = BigInteger.fromBuffer(hash);
  return verifyRaw(curve, e, signature, Q);
}

/**
  * Recover a public key from a signature.
  *
  * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, "Public
  * Key Recovery Operation".
  *
  * http://www.secg.org/download/aid-780/sec1-v2.pdf
  */
function recoverPubKey(curve, e, signature, i) {
  assert.strictEqual(i & 3, i, 'Recovery param is more than two bits');

  var n = curve.n;
  var G = curve.G;

  var r = signature.r;
  var s = signature.s;

  assert(r.signum() > 0 && r.compareTo(n) < 0, 'Invalid r value');
  assert(s.signum() > 0 && s.compareTo(n) < 0, 'Invalid s value');

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = i & 1;

  // The more significant bit specifies whether we should use the
  // first or second candidate key.
  var isSecondKey = i >> 1;

  // 1.1 Let x = r + jn
  var x = isSecondKey ? r.add(n) : r;
  var R = curve.pointFromX(isYOdd, x);

  // 1.4 Check that nR is at infinity
  var nR = R.multiply(n);
  assert(curve.isInfinity(nR), 'nR is not a valid curve point');

  // Compute -e from e
  var eNeg = e.negate().mod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  var rInv = r.modInverse(n);

  var Q = R.multiplyTwo(s, G, eNeg).multiply(rInv);
  curve.validate(Q);

  return Q;
}

/**
  * Calculate pubkey extraction parameter.
  *
  * When extracting a pubkey from a signature, we have to
  * distinguish four different cases. Rather than putting this
  * burden on the verifier, Bitcoin includes a 2-bit value with the
  * signature.
  *
  * This function simply tries all four cases and returns the value
  * that resulted in a successful pubkey recovery.
  */
function calcPubKeyRecoveryParam(curve, e, signature, Q) {
  for (var i = 0; i < 4; i++) {
    var Qprime = recoverPubKey(curve, e, signature, i);

    // 1.6.2 Verify Q
    if (Qprime.equals(Q)) {
      return i;
    }
  }

  throw new Error('Unable to find valid recovery factor');
}

module.exports = {
  calcPubKeyRecoveryParam: calcPubKeyRecoveryParam,
  deterministicGenerateK: deterministicGenerateK,
  recoverPubKey: recoverPubKey,
  sign: sign,
  verify: verify,
  verifyRaw: verifyRaw
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/ecc/src/ecdsa.js","/../node_modules/golosjs-lib/dist/ecc/src")
},{"./ecsignature":53,"./enforce_types":54,"./hash":55,"assert":1,"bigi":6,"buffer":11,"pBGvAp":74}],53:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var assert = require('assert'); // from https://github.com/bitcoinjs/bitcoinjs-lib
var enforceType = require('./enforce_types');

var BigInteger = require('bigi');

function ECSignature(r, s) {
  enforceType(BigInteger, r);
  enforceType(BigInteger, s);

  this.r = r;
  this.s = s;
}

// Import operations
ECSignature.parseCompact = function (buffer) {
  assert.equal(buffer.length, 65, 'Invalid signature length');
  var i = buffer.readUInt8(0) - 27;

  // At most 3 bits
  assert.equal(i, i & 7, 'Invalid signature parameter');
  var compressed = !!(i & 4);

  // Recovery param only
  i = i & 3;

  var r = BigInteger.fromBuffer(buffer.slice(1, 33));
  var s = BigInteger.fromBuffer(buffer.slice(33));

  return {
    compressed: compressed,
    i: i,
    signature: new ECSignature(r, s)
  };
};

ECSignature.fromDER = function (buffer) {
  assert.equal(buffer.readUInt8(0), 0x30, 'Not a DER sequence');
  assert.equal(buffer.readUInt8(1), buffer.length - 2, 'Invalid sequence length');
  assert.equal(buffer.readUInt8(2), 0x02, 'Expected a DER integer');

  var rLen = buffer.readUInt8(3);
  assert(rLen > 0, 'R length is zero');

  var offset = 4 + rLen;
  assert.equal(buffer.readUInt8(offset), 0x02, 'Expected a DER integer (2)');

  var sLen = buffer.readUInt8(offset + 1);
  assert(sLen > 0, 'S length is zero');

  var rB = buffer.slice(4, offset);
  var sB = buffer.slice(offset + 2);
  offset += 2 + sLen;

  if (rLen > 1 && rB.readUInt8(0) === 0x00) {
    assert(rB.readUInt8(1) & 0x80, 'R value excessively padded');
  }

  if (sLen > 1 && sB.readUInt8(0) === 0x00) {
    assert(sB.readUInt8(1) & 0x80, 'S value excessively padded');
  }

  assert.equal(offset, buffer.length, 'Invalid DER encoding');
  var r = BigInteger.fromDERInteger(rB);
  var s = BigInteger.fromDERInteger(sB);

  assert(r.signum() >= 0, 'R value is negative');
  assert(s.signum() >= 0, 'S value is negative');

  return new ECSignature(r, s);
};

// FIXME: 0x00, 0x04, 0x80 are SIGHASH_* boundary constants, importing Transaction causes a circular dependency
ECSignature.parseScriptSignature = function (buffer) {
  var hashType = buffer.readUInt8(buffer.length - 1);
  var hashTypeMod = hashType & ~0x80;

  assert(hashTypeMod > 0x00 && hashTypeMod < 0x04, 'Invalid hashType');

  return {
    signature: ECSignature.fromDER(buffer.slice(0, -1)),
    hashType: hashType
  };
};

// Export operations
ECSignature.prototype.toCompact = function (i, compressed) {
  if (compressed) i += 4;
  i += 27;

  var buffer = new Buffer(65);
  buffer.writeUInt8(i, 0);

  this.r.toBuffer(32).copy(buffer, 1);
  this.s.toBuffer(32).copy(buffer, 33);

  return buffer;
};

ECSignature.prototype.toDER = function () {
  var rBa = this.r.toDERInteger();
  var sBa = this.s.toDERInteger();

  var sequence = [];

  // INTEGER
  sequence.push(0x02, rBa.length);
  sequence = sequence.concat(rBa);

  // INTEGER
  sequence.push(0x02, sBa.length);
  sequence = sequence.concat(sBa);

  // SEQUENCE
  sequence.unshift(0x30, sequence.length);

  return new Buffer(sequence);
};

ECSignature.prototype.toScriptSignature = function (hashType) {
  var hashTypeBuffer = new Buffer(1);
  hashTypeBuffer.writeUInt8(hashType, 0);

  return Buffer.concat([this.toDER(), hashTypeBuffer]);
};

module.exports = ECSignature;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/ecc/src/ecsignature.js","/../node_modules/golosjs-lib/dist/ecc/src")
},{"./enforce_types":54,"assert":1,"bigi":6,"buffer":11,"pBGvAp":74}],54:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

module.exports = function enforce(type, value) {
  // Copied from https://github.com/bitcoinjs/bitcoinjs-lib
  switch (type) {
    case 'Array':
      {
        if (Array.isArray(value)) return;
        break;
      }

    case 'Boolean':
      {
        if (typeof value === 'boolean') return;
        break;
      }

    case 'Buffer':
      {
        if (Buffer.isBuffer(value)) return;
        break;
      }

    case 'Number':
      {
        if (typeof value === 'number') return;
        break;
      }

    case 'String':
      {
        if (typeof value === 'string') return;
        break;
      }

    default:
      {
        if (getName(value.constructor) === getName(type)) return;
      }
  }

  throw new TypeError('Expected ' + (getName(type) || type) + ', got ' + value);
};

function getName(fn) {
  // Why not fn.name: https://kangax.github.io/compat-table/es6/#function_name_property
  var match = fn.toString().match(/function (.*?)\(/);
  return match ? match[1] : null;
}
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/ecc/src/enforce_types.js","/../node_modules/golosjs-lib/dist/ecc/src")
},{"buffer":11,"pBGvAp":74}],55:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var createHash = require("create-hash");
var createHmac = require("create-hmac");

/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
function sha1(data, encoding) {
    return createHash('sha1').update(data).digest(encoding);
}

/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
function sha256(data, encoding) {
    return createHash('sha256').update(data).digest(encoding);
}

/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
function sha512(data, encoding) {
    return createHash('sha512').update(data).digest(encoding);
}

function HmacSHA256(buffer, secret) {
    return createHmac('sha256', secret).update(buffer).digest();
}

function ripemd160(data) {
    return createHash('rmd160').update(data).digest();
}

// function hash160(buffer) {
//   return ripemd160(sha256(buffer))
// }
//
// function hash256(buffer) {
//   return sha256(sha256(buffer))
// }

//
// function HmacSHA512(buffer, secret) {
//   return crypto.createHmac('sha512', secret).update(buffer).digest()
// }

module.exports = {
    sha1: sha1,
    sha256: sha256,
    sha512: sha512,
    HmacSHA256: HmacSHA256,
    ripemd160: ripemd160
    // hash160: hash160,
    // hash256: hash256,
    // HmacSHA512: HmacSHA512
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/ecc/src/hash.js","/../node_modules/golosjs-lib/dist/ecc/src")
},{"buffer":11,"create-hash":14,"create-hmac":17,"pBGvAp":74}],56:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ecdsa = require('./ecdsa');
var hash = require('./hash');

var _require = require('ecurve');

var getCurveByName = _require.getCurveByName;

var secp256k1 = getCurveByName('secp256k1');
var assert = require('assert');
var BigInteger = require('bigi');
var PublicKey = require('./PublicKey');

var Signature = function () {
    function Signature(r1, s1, i1) {
        _classCallCheck(this, Signature);

        this.r = r1;
        this.s = s1;
        this.i = i1;
        assert.equal(this.r != null, true, 'Missing parameter');
        assert.equal(this.s != null, true, 'Missing parameter');
        assert.equal(this.i != null, true, 'Missing parameter');
    }

    _createClass(Signature, [{
        key: 'toBuffer',
        value: function toBuffer() {
            var buf;
            buf = new Buffer(65);
            buf.writeUInt8(this.i, 0);
            this.r.toBuffer(32).copy(buf, 1);
            this.s.toBuffer(32).copy(buf, 33);
            return buf;
        }
    }, {
        key: 'recoverPublicKeyFromBuffer',
        value: function recoverPublicKeyFromBuffer(buffer) {
            return this.recoverPublicKey(hash.sha256(buffer));
        }
    }, {
        key: 'recoverPublicKey',


        /**
            @return {PublicKey}
        */
        value: function recoverPublicKey(sha256_buffer) {
            var Q = void 0,
                e = void 0,
                i = void 0;
            e = BigInteger.fromBuffer(sha256_buffer);
            i = this.i;
            i -= 27;
            i = i & 3;
            Q = ecdsa.recoverPubKey(secp256k1, e, this, i);
            return PublicKey.fromPoint(Q);
        }
    }, {
        key: 'verifyBuffer',


        /**
            @param {Buffer} un-hashed
            @param {./PublicKey}
            @return {boolean}
        */
        value: function verifyBuffer(buf, public_key) {
            var _hash = hash.sha256(buf);
            return this.verifyHash(_hash, public_key);
        }
    }, {
        key: 'verifyHash',
        value: function verifyHash(hash, public_key) {
            assert.equal(hash.length, 32, "A SHA 256 should be 32 bytes long, instead got " + hash.length);
            return ecdsa.verify(secp256k1, hash, {
                r: this.r,
                s: this.s
            }, public_key.Q);
        }
    }, {
        key: 'toByteBuffer',


        /* <HEX> */

        value: function toByteBuffer() {
            var b;
            b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            this.appendByteBuffer(b);
            return b.copy(0, b.offset);
        }
    }, {
        key: 'toHex',
        value: function toHex() {
            return this.toBuffer().toString("hex");
        }
    }, {
        key: 'verifyHex',
        value: function verifyHex(hex, public_key) {
            var buf;
            buf = new Buffer(hex, 'hex');
            return this.verifyBuffer(buf, public_key);
        }
    }], [{
        key: 'fromBuffer',
        value: function fromBuffer(buf) {
            var i, r, s;
            assert.equal(buf.length, 65, 'Invalid signature length');
            i = buf.readUInt8(0);
            assert.equal(i - 27, i - 27 & 7, 'Invalid signature parameter');
            r = BigInteger.fromBuffer(buf.slice(1, 33));
            s = BigInteger.fromBuffer(buf.slice(33));
            return new Signature(r, s, i);
        }
    }, {
        key: 'signBuffer',


        /**
            @param {Buffer} buf
            @param {PrivateKey} private_key
            @return {Signature}
        */
        value: function signBuffer(buf, private_key) {
            var _hash = hash.sha256(buf);
            return Signature.signBufferSha256(_hash, private_key);
        }

        /** Sign a buffer of exactally 32 bytes in size (sha256(text))
            @param {Buffer} buf - 32 bytes binary
            @param {PrivateKey} private_key
            @return {Signature}
        */

    }, {
        key: 'signBufferSha256',
        value: function signBufferSha256(buf_sha256, private_key) {
            if (buf_sha256.length !== 32 || !Buffer.isBuffer(buf_sha256)) throw new Error("buf_sha256: 32 byte buffer requred");
            var der, e, ecsignature, i, lenR, lenS, nonce;
            i = null;
            nonce = 0;
            e = BigInteger.fromBuffer(buf_sha256);
            while (true) {
                ecsignature = ecdsa.sign(secp256k1, buf_sha256, private_key.d, nonce++);
                der = ecsignature.toDER();
                lenR = der[3];
                lenS = der[5 + lenR];
                if (lenR === 32 && lenS === 32) {
                    i = ecdsa.calcPubKeyRecoveryParam(secp256k1, e, ecsignature, private_key.toPublicKey().Q);
                    i += 4; // compressed
                    i += 27; // compact  //  24 or 27 :( forcing odd-y 2nd key candidate)
                    break;
                }
                if (nonce % 10 === 0) {
                    console.log("WARN: " + nonce + " attempts to find canonical signature");
                }
            }
            return new Signature(ecsignature.r, ecsignature.s, i);
        }
    }, {
        key: 'sign',
        value: function sign(string, private_key) {
            return Signature.signBuffer(new Buffer(string), private_key);
        }
    }, {
        key: 'fromHex',
        value: function fromHex(hex) {
            return Signature.fromBuffer(new Buffer(hex, "hex"));
        }
    }, {
        key: 'signHex',
        value: function signHex(hex, private_key) {
            var buf;
            buf = new Buffer(hex, 'hex');
            return Signature.signBuffer(buf, private_key);
        }
    }]);

    return Signature;
}();

module.exports = Signature;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/ecc/src/signature.js","/../node_modules/golosjs-lib/dist/ecc/src")
},{"./PublicKey":49,"./ecdsa":52,"./hash":55,"assert":1,"bigi":6,"buffer":11,"ecurve":32,"pBGvAp":74}],57:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = Object.assign(require("./chain"), require("./ecc"), require("./serializer"));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/index.js","/../node_modules/golosjs-lib/dist")
},{"./chain":36,"./ecc":45,"./serializer":58,"buffer":11,"pBGvAp":74}],58:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

module.exports = {

    // Primary class for creating operations
    Serializer: require('./src/serializer'),

    // helper functions for creating operations
    fp: require('./src/FastParser'),

    // Low level types
    types: require('./src/types'),

    // Higher level operations (made out of generic types)
    ops: require('./src/operations'),

    // Utility that generates JSON examples
    template: require('./src/template'),

    // Serializer validation
    SerializerValidation: require('./src/SerializerValidation')
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/serializer/index.js","/../node_modules/golosjs-lib/dist/serializer")
},{"./src/FastParser":59,"./src/SerializerValidation":60,"./src/operations":63,"./src/serializer":64,"./src/template":65,"./src/types":66,"buffer":11,"pBGvAp":74}],59:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PublicKey = require("../../ecc/src/PublicKey");

var FastParser = function () {
    function FastParser() {
        _classCallCheck(this, FastParser);
    }

    _createClass(FastParser, null, [{
        key: 'fixed_data',
        value: function fixed_data(b, len, buffer) {
            if (!b) {
                return;
            }
            if (buffer) {
                var data = buffer.slice(0, len).toString('binary');
                b.append(data, 'binary');
                while (len-- > data.length) {
                    b.writeUint8(0);
                }
            } else {
                var b_copy = b.copy(b.offset, b.offset + len);
                b.skip(len);
                return new Buffer(b_copy.toBinary(), 'binary');
            }
        }
    }, {
        key: 'public_key',
        value: function public_key(b, _public_key) {
            if (!b) {
                return;
            }
            if (_public_key) {
                var buffer = _public_key.toBuffer();
                b.append(buffer.toString('binary'), 'binary');
                return;
            } else {
                buffer = FastParser.fixed_data(b, 33);
                return PublicKey.fromBuffer(buffer);
            }
        }
    }, {
        key: 'ripemd160',
        value: function ripemd160(b, _ripemd) {
            if (!b) {
                return;
            }
            if (_ripemd) {
                FastParser.fixed_data(b, 20, _ripemd);
                return;
            } else {
                return FastParser.fixed_data(b, 20);
            }
        }
    }, {
        key: 'time_point_sec',
        value: function time_point_sec(b, epoch) {
            if (epoch) {
                epoch = Math.ceil(epoch / 1000);
                b.writeInt32(epoch);
                return;
            } else {
                epoch = b.readInt32(); // fc::time_point_sec
                return new Date(epoch * 1000);
            }
        }
    }]);

    return FastParser;
}();

module.exports = FastParser;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/serializer/src/FastParser.js","/../node_modules/golosjs-lib/dist/serializer/src")
},{"../../ecc/src/PublicKey":49,"buffer":11,"pBGvAp":74}],60:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _require = require('bytebuffer');

var Long = _require.Long;

var ChainTypes = require('../../chain/src/ChainTypes');

var MAX_SAFE_INT = 9007199254740991;
var MIN_SAFE_INT = -9007199254740991;

/**
    Most validations are skipped and the value returned unchanged when an empty string, null, or undefined is encountered (except "required").

    Validations support a string format for dealing with large numbers.
*/
var _my = {

    is_empty: function is_empty(value) {
        return value === null || value === undefined;
    },

    required: function required(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (this.is_empty(value)) {
            throw new Error('value required ' + field_name + ' ' + value);
        }
        return value;
    },
    require_long: function require_long(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (!Long.isLong(value)) {
            throw new Error('Long value required ' + field_name + ' ' + value);
        }
        return value;
    },
    string: function string(value) {
        if (this.is_empty(value)) {
            return value;
        }
        if (typeof value !== "string") {
            throw new Error('string required: ' + value);
        }
        return value;
    },
    number: function number(value) {
        if (this.is_empty(value)) {
            return value;
        }
        if (typeof value !== "number") {
            throw new Error('number required: ' + value);
        }
        return value;
    },
    whole_number: function whole_number(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (this.is_empty(value)) {
            return value;
        }
        if (/\./.test(value)) {
            throw new Error('whole number required ' + field_name + ' ' + value);
        }
        return value;
    },
    unsigned: function unsigned(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (this.is_empty(value)) {
            return value;
        }
        if (/-/.test(value)) {
            throw new Error('unsigned required ' + field_name + ' ' + value);
        }
        return value;
    },


    is_digits: function is_digits(value) {
        if (typeof value === "numeric") {
            return true;
        }
        return (/^[0-9]+$/.test(value)
        );
    },

    to_number: function to_number(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (this.is_empty(value)) {
            return value;
        }
        this.no_overflow53(value, field_name);
        var int_value = function () {
            if (typeof value === "number") {
                return value;
            } else {
                return parseInt(value);
            }
        }();
        return int_value;
    },

    to_long: function to_long(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (this.is_empty(value)) {
            return value;
        }
        if (Long.isLong(value)) {
            return value;
        }

        this.no_overflow64(value, field_name);
        if (typeof value === "number") {
            value = "" + value;
        }
        return Long.fromString(value);
    },
    to_string: function to_string(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (this.is_empty(value)) {
            return value;
        }
        if (typeof value === "string") {
            return value;
        }
        if (typeof value === "number") {
            this.no_overflow53(value, field_name);
            return "" + value;
        }
        if (Long.isLong(value)) {
            return value.toString();
        }
        throw 'unsupported type ' + field_name + ': (' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + ') ' + value;
    },
    require_test: function require_test(regex, value) {
        var field_name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

        if (this.is_empty(value)) {
            return value;
        }
        if (!regex.test(value)) {
            throw new Error('unmatched ' + regex + ' ' + field_name + ' ' + value);
        }
        return value;
    },


    require_match: function require_match(regex, value) {
        var field_name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

        if (this.is_empty(value)) {
            return value;
        }
        var match = value.match(regex);
        if (match === null) {
            throw new Error('unmatched ' + regex + ' ' + field_name + ' ' + value);
        }
        return match;
    },

    require_object_id: function require_object_id(value, field_name) {
        return require_match(/^([0-9]+)\.([0-9]+)\.([0-9]+)$/, value, field_name);
    },

    // Does not support over 53 bits
    require_range: function require_range(min, max, value) {
        var field_name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

        if (this.is_empty(value)) {
            return value;
        }
        var number = this.to_number(value);
        if (value < min || value > max) {
            throw new Error('out of range ' + value + ' ' + field_name + ' ' + value);
        }
        return value;
    },


    require_object_type: function require_object_type() {
        var reserved_spaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var type = arguments[1];
        var value = arguments[2];
        var field_name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

        if (this.is_empty(value)) {
            return value;
        }
        var object_type = ChainTypes.object_type[type];
        if (!object_type) {
            throw new Error('Unknown object type ' + type + ' ' + field_name + ' ' + value);
        }
        var re = new RegExp(reserved_spaces + '.' + object_type + '.[0-9]+$');
        if (!re.test(value)) {
            throw new Error('Expecting ' + type + ' in format ' + (reserved_spaces + '.' + object_type + '.[0-9]+ ') + ('instead of ' + value + ' ' + field_name + ' ' + value));
        }
        return value;
    },

    get_instance: function get_instance(reserve_spaces, type, value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        this.require_object_type(reserve_spaces, type, value, field_name);
        return this.to_number(value.split('.')[2]);
    },

    require_relative_type: function require_relative_type(type, value, field_name) {
        this.require_object_type(0, type, value, field_name);
        return value;
    },

    get_relative_instance: function get_relative_instance(type, value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        this.require_object_type(0, type, value, field_name);
        return this.to_number(value.split('.')[2]);
    },

    require_protocol_type: function require_protocol_type(type, value, field_name) {
        this.require_object_type(1, type, value, field_name);
        return value;
    },

    get_protocol_instance: function get_protocol_instance(type, value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        this.require_object_type(1, type, value, field_name);
        return this.to_number(value.split('.')[2]);
    },

    get_protocol_type: function get_protocol_type(value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        this.require_object_id(value, field_name);
        var values = value.split('.');
        return this.to_number(values[1]);
    },

    get_protocol_type_name: function get_protocol_type_name(value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        var type_id = this.get_protocol_type(value, field_name);
        return Object.keys(ChainTypes.object_type)[type_id];
    },


    require_implementation_type: function require_implementation_type(type, value, field_name) {
        this.require_object_type(2, type, value, field_name);
        return value;
    },

    get_implementation_instance: function get_implementation_instance(type, value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        this.require_object_type(2, type, value, field_name);
        return this.to_number(value.split('.')[2]);
    },

    // signed / unsigned decimal
    no_overflow53: function no_overflow53(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (typeof value === "number") {
            if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
                throw new Error('overflow ' + field_name + ' ' + value);
            }
            return;
        }
        if (typeof value === "string") {
            var int = parseInt(value);
            if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
                throw new Error('overflow ' + field_name + ' ' + value);
            }
            return;
        }
        if (Long.isLong(value)) {
            // typeof value.toInt() is 'number'
            this.no_overflow53(value.toInt(), field_name);
            return;
        }
        throw 'unsupported type ' + field_name + ': (' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + ') ' + value;
    },


    // signed / unsigned whole numbers only
    no_overflow64: function no_overflow64(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        // https://github.com/dcodeIO/Long.js/issues/20
        if (Long.isLong(value)) {
            return;
        }

        // BigInteger#isBigInteger https://github.com/cryptocoinjs/bigi/issues/20
        if (value.t !== undefined && value.s !== undefined) {
            this.no_overflow64(value.toString(), field_name);
            return;
        }

        if (typeof value === "string") {
            // remove leading zeros, will cause a false positive
            value = value.replace(/^0+/, '');
            // remove trailing zeros
            while (/0$/.test(value)) {
                value = value.substring(0, value.length - 1);
            }
            if (/\.$/.test(value)) {
                // remove trailing dot
                value = value.substring(0, value.length - 1);
            }
            if (value === "") {
                value = "0";
            }
            var long_string = Long.fromString(value).toString();
            if (long_string !== value.trim()) {
                throw new Error('overflow ' + field_name + ' ' + value);
            }
            return;
        }
        if (typeof value === "number") {
            if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
                throw new Error('overflow ' + field_name + ' ' + value);
            }
            return;
        }

        throw 'unsupported type ' + field_name + ': (' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + ') ' + value;
    }
};

module.exports = _my;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/serializer/src/SerializerValidation.js","/../node_modules/golosjs-lib/dist/serializer/src")
},{"../../chain/src/ChainTypes":39,"buffer":11,"bytebuffer":12,"pBGvAp":74}],61:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** Exception nesting.  */
var ErrorWithCause = function () {
    function ErrorWithCause(message, cause) {
        _classCallCheck(this, ErrorWithCause);

        this.message = message;
        if (typeof cause !== "undefined" && cause !== null ? cause.message : undefined) {
            this.message = "cause\t" + cause.message + "\t" + this.message;
        }

        var stack = ""; //(new Error).stack
        if (typeof cause !== "undefined" && cause !== null ? cause.stack : undefined) {
            stack = "caused by\n\t" + cause.stack + "\t" + stack;
        }

        this.stack = this.message + "\n" + stack;
    }

    _createClass(ErrorWithCause, null, [{
        key: "throw",
        value: function _throw(message, cause) {
            var msg = message;
            if (typeof cause !== "undefined" && cause !== null ? cause.message : undefined) {
                msg += "\t cause: " + cause.message + " ";
            }
            if (typeof cause !== "undefined" && cause !== null ? cause.stack : undefined) {
                msg += "\n stack: " + cause.stack + " ";
            }
            throw new Error(msg);
        }
    }]);

    return ErrorWithCause;
}();

module.exports = ErrorWithCause;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/serializer/src/error_with_cause.js","/../node_modules/golosjs-lib/dist/serializer/src")
},{"buffer":11,"pBGvAp":74}],62:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var assert = require("assert");

/**
    Convert 12.34 with a precision of 3 into 12340

    @arg {number|string} number - Use strings for large numbers.  This may contain one decimal but no sign
    @arg {number} precision - number of implied decimal places (usually causes right zero padding)
    @return {string} -
*/
module.exports = {
    toImpliedDecimal: function toImpliedDecimal(number, precision) {

        if (typeof number === "number") {
            assert(number <= 9007199254740991, "overflow");
            number = "" + number;
        } else if (number.toString) number = number.toString();

        assert(typeof number === "string", "number should be an actual number or string: " + (typeof number === "undefined" ? "undefined" : _typeof(number)));
        number = number.trim();
        assert(/^[0-9]*\.?[0-9]*$/.test(number), "Invalid decimal number " + number);

        var _number$split = number.split(".");

        var _number$split2 = _slicedToArray(_number$split, 2);

        var _number$split2$ = _number$split2[0];
        var whole = _number$split2$ === undefined ? "" : _number$split2$;
        var _number$split2$2 = _number$split2[1];
        var decimal = _number$split2$2 === undefined ? "" : _number$split2$2;


        var padding = precision - decimal.length;
        assert(padding >= 0, "Too many decimal digits in " + number + " to create an implied decimal of " + precision);

        for (var i = 0; i < padding; i++) {
            decimal += "0";
        }while (whole.charAt(0) === "0") {
            whole = whole.substring(1);
        }return whole + decimal;
    },

    fromImpliedDecimal: function fromImpliedDecimal(number, precision) {
        if (typeof number === "number") {
            assert(number <= 9007199254740991, "overflow");
            number = "" + number;
        } else if (number.toString) number = number.toString();

        while (number.length < precision + 1) {
            // 0.123
            number = "0" + number;
        } // 44000 => 44.000
        var dec_string = number.substring(number.length - precision);
        return number.substring(0, number.length - precision) + (dec_string ? "." + dec_string : "");
    }
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/serializer/src/numberUtils.js","/../node_modules/golosjs-lib/dist/serializer/src")
},{"assert":1,"buffer":11,"pBGvAp":74}],63:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var types = require("./types");
var SerializerImpl = require("./serializer");

var int16 = types.int16;
var uint16 = types.uint16;
var uint32 = types.uint32;
var int64 = types.int64;
var uint64 = types.uint64;
var string = types.string;
var bytes = types.bytes;
var bool = types.bool;
var array = types.array;
var fixed_array = types.fixed_array;
var object_id_type = types.object_id_type;
var vote_id = types.vote_id;
var future_extensions = types.future_extensions;
var static_variant = types.static_variant;
var map = types.map;
var set = types.set;
var public_key = types.public_key;
var address = types.address;
var time_point_sec = types.time_point_sec;
var optional = types.optional;
var asset = types.asset;


future_extensions = types.void;

/*
When updating generated code
Replace:  operation = static_variant [
with:     operation.st_operations = [

at the end of this file.

Then, delete this part:
public_key = new Serializer(
    "public_key"
    key_data: bytes 33
)

*/
// Place-holder, their are dependencies on "operation" .. The final list of
// operations is not avialble until the very end of the generated code.
// See: operation.st_operations = ...
var operation = static_variant();
module.exports["operation"] = operation;

// For module.exports
var Serializer = function Serializer(operation_name, serilization_types_object) {
    var s = new SerializerImpl(operation_name, serilization_types_object);
    return module.exports[operation_name] = s;
};

// Custom-types follow Generated code:

// ##  Generated code follows
// # npm i -g decaffeinate
// # programs/js_operation_serializer > ops.coffee && decaffeinate ops.coffee
// # open ops.txt, copy to Chain/ChainTypes and operations.js
// ## -------------------------------
var signed_transaction = new Serializer("signed_transaction", {
    ref_block_num: uint16,
    ref_block_prefix: uint32,
    expiration: time_point_sec,
    operations: array(operation),
    extensions: set(future_extensions),
    signatures: array(bytes(65))
});

var signed_block = new Serializer("signed_block", {
    previous: bytes(20),
    timestamp: time_point_sec,
    witness: string,
    transaction_merkle_root: bytes(20),
    extensions: set(future_extensions),
    witness_signature: bytes(65),
    transactions: array(signed_transaction)
});

var block_header = new Serializer("block_header", {
    previous: bytes(20),
    timestamp: time_point_sec,
    witness: string,
    transaction_merkle_root: bytes(20),
    extensions: set(future_extensions)
});

var signed_block_header = new Serializer("signed_block_header", {
    previous: bytes(20),
    timestamp: time_point_sec,
    witness: string,
    transaction_merkle_root: bytes(20),
    extensions: set(future_extensions),
    witness_signature: bytes(65)
});

var vote = new Serializer("vote", {
    voter: string,
    author: string,
    permlink: string,
    weight: uint16
});

var comment = new Serializer("comment", {
    parent_author: string,
    parent_permlink: string,
    author: string,
    permlink: string,
    title: string,
    body: string,
    json_metadata: string
});

// let asset = new Serializer(
//     "asset",{
//     amount: int64,
//     symbol: string
// }
// );

var transfer = new Serializer("transfer", {
    from: string,
    to: string,
    amount: asset,
    memo: string
});

var transfer_to_vesting = new Serializer("transfer_to_vesting", {
    from: string,
    to: string,
    amount: asset
});

var withdraw_vesting = new Serializer("withdraw_vesting", {
    account: string,
    vesting_shares: asset
});

var limit_order_create = new Serializer("limit_order_create", {
    owner: string,
    orderid: uint32,
    amount_to_sell: asset,
    min_to_receive: asset,
    fill_or_kill: bool,
    expiration: time_point_sec
});

var limit_order_cancel = new Serializer("limit_order_cancel", {
    owner: string,
    orderid: uint32
});

var price = new Serializer("price", {
    base: asset,
    quote: asset
});

var feed_publish = new Serializer("feed_publish", {
    publisher: string,
    exchange_rate: price
});

var convert = new Serializer("convert", {
    owner: string,
    requestid: uint32,
    amount: asset
});

var authority = new Serializer("authority", {
    weight_threshold: uint32,
    account_auths: map(string, uint16),
    key_auths: map(public_key, uint16)
});

var account_create = new Serializer("account_create", {
    fee: asset,
    creator: string,
    new_account_name: string,
    owner: authority,
    active: authority,
    posting: authority,
    memo_key: public_key,
    json_metadata: string
});

var account_update = new Serializer("account_update", {
    account: string,
    owner: optional(authority),
    active: optional(authority),
    posting: optional(authority),
    memo_key: public_key,
    json_metadata: string
});

var chain_properties = new Serializer("chain_properties", {
    account_creation_fee: asset,
    maximum_block_size: uint32,
    sbd_interest_rate: uint16
});

var witness_update = new Serializer("witness_update", {
    owner: string,
    url: string,
    block_signing_key: public_key,
    props: chain_properties,
    fee: asset
});

var account_witness_vote = new Serializer("account_witness_vote", {
    account: string,
    witness: string,
    approve: bool
});

var account_witness_proxy = new Serializer("account_witness_proxy", {
    account: string,
    proxy: string
});

var pow = new Serializer("pow", {
    worker: public_key,
    input: bytes(32),
    signature: bytes(65),
    work: bytes(32)
});

var custom = new Serializer("custom", {
    required_auths: set(string),
    id: uint16,
    data: bytes()
});

var report_over_production = new Serializer("report_over_production", {
    reporter: string,
    first_block: signed_block_header,
    second_block: signed_block_header
});

var delete_comment = new Serializer("delete_comment", {
    author: string,
    permlink: string
});

var custom_json = new Serializer("custom_json", {
    required_auths: set(string),
    required_posting_auths: set(string),
    id: string,
    json: string
});

var comment_options = new Serializer("comment_options", {
    author: string,
    permlink: string,
    max_accepted_payout: asset,
    percent_steem_dollars: uint16,
    allow_votes: bool,
    allow_curation_rewards: bool,
    extensions: set(static_variant([future_extensions]))
});

var set_withdraw_vesting_route = new Serializer("set_withdraw_vesting_route", {
    from_account: string,
    to_account: string,
    percent: uint16,
    auto_vest: bool
});

var fill_convert_request = new Serializer("fill_convert_request", {
    owner: string,
    requestid: uint32,
    amount_in: asset,
    amount_out: asset
});

var comment_reward = new Serializer("comment_reward", {
    author: string,
    permlink: string,
    sbd_payout: asset,
    vesting_payout: asset
});

var curate_reward = new Serializer("curate_reward", {
    curator: string,
    reward: asset,
    comment_author: string,
    comment_permlink: string
});

var liquidity_reward = new Serializer("liquidity_reward", {
    owner: string,
    payout: asset
});

var interest = new Serializer("interest", {
    owner: string,
    interest: asset
});

var fill_vesting_withdraw = new Serializer("fill_vesting_withdraw", {
    from_account: string,
    to_account: string,
    withdrawn: asset,
    deposited: asset
});

var fill_order = new Serializer("fill_order", {
    current_owner: string,
    current_orderid: uint32,
    current_pays: asset,
    open_owner: string,
    open_orderid: uint32,
    open_pays: asset
});

var comment_payout = new Serializer("comment_payout", {
    author: string,
    permlink: string,
    payout: asset
});

var escrow_transfer = new Serializer("escrow_transfer", {
    from: string,
    to: string,
    agent: string,
    escrow_id: uint32,
    sbd_amount: asset,
    steem_amount: asset,
    fee: asset,
    ratification_deadline: time_point_sec,
    escrow_expiration: time_point_sec,
    json_metadata: string
});

var escrow_approve = new Serializer("escrow_approve", {
    from: string,
    to: string,
    agent: string,
    who: string,
    escrow_id: uint32,
    approve: bool
});

var escrow_dispute = new Serializer("escrow_dispute", {
    from: string,
    to: string,
    agent: string,
    who: string,
    escrow_id: uint32
});

var escrow_release = new Serializer("escrow_release", {
    from: string,
    to: string,
    agent: string,
    who: string,
    receiver: string,
    escrow_id: uint32,
    sbd_amount: asset,
    steem_amount: asset
});

operation.st_operations = [vote, comment, transfer, transfer_to_vesting, withdraw_vesting, limit_order_create, limit_order_cancel, feed_publish, convert, account_create, account_update, witness_update, account_witness_vote, account_witness_proxy, pow, custom, report_over_production, delete_comment, custom_json, comment_options, set_withdraw_vesting_route, fill_convert_request, comment_reward, curate_reward, liquidity_reward, interest, fill_vesting_withdraw, fill_order, comment_payout, escrow_transfer, escrow_approve, escrow_dispute, escrow_release];

var transaction = new Serializer("transaction", {
    ref_block_num: uint16,
    ref_block_prefix: uint32,
    expiration: time_point_sec,
    operations: array(operation),
    extensions: set(future_extensions)
});

//# -------------------------------
//#  Generated code end
//# -------------------------------
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/serializer/src/operations.js","/../node_modules/golosjs-lib/dist/serializer/src")
},{"./serializer":64,"./types":66,"buffer":11,"pBGvAp":74}],64:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ByteBuffer = require('bytebuffer');
var EC = require('./error_with_cause');

var HEX_DUMP = process.env.npm_config__graphene_serializer_hex_dump;

var Serializer = function () {
    function Serializer(operation_name, types) {
        _classCallCheck(this, Serializer);

        this.operation_name = operation_name;
        this.types = types;
        if (this.types) this.keys = Object.keys(this.types);

        Serializer.printDebug = true;
    }

    _createClass(Serializer, [{
        key: 'fromByteBuffer',
        value: function fromByteBuffer(b) {
            var object = {};
            var field = null;
            try {
                var iterable = this.keys;
                for (var i = 0, field; i < iterable.length; i++) {
                    field = iterable[i];
                    var type = this.types[field];
                    try {
                        if (HEX_DUMP) {
                            if (type.operation_name) {
                                console.error(type.operation_name);
                            } else {
                                var o1 = b.offset;
                                type.fromByteBuffer(b);
                                var o2 = b.offset;
                                b.offset = o1;
                                //b.reset()
                                var _b = b.copy(o1, o2);
                                console.error(this.operation_name + '.' + field + '\t', _b.toHex());
                            }
                        }
                        object[field] = type.fromByteBuffer(b);
                    } catch (e) {
                        if (Serializer.printDebug) {
                            console.error('Error reading ' + this.operation_name + '.' + field + ' in data:');
                            b.printDebug();
                        }
                        throw e;
                    }
                }
            } catch (error) {
                EC.throw(this.operation_name + '.' + field, error);
            }

            return object;
        }
    }, {
        key: 'appendByteBuffer',
        value: function appendByteBuffer(b, object) {
            var field = null;
            try {
                var iterable = this.keys;
                for (var i = 0, field; i < iterable.length; i++) {
                    field = iterable[i];
                    var type = this.types[field];
                    type.appendByteBuffer(b, object[field]);
                }
            } catch (error) {
                try {
                    EC.throw(this.operation_name + '.' + field + " = " + JSON.stringify(object[field]), error);
                } catch (e) {
                    // circular ref
                    EC.throw(this.operation_name + '.' + field + " = " + object[field], error);
                }
            }
            return;
        }
    }, {
        key: 'fromObject',
        value: function fromObject(serialized_object) {
            var result = {};
            var field = null;
            try {
                var iterable = this.keys;
                for (var i = 0, field; i < iterable.length; i++) {
                    field = iterable[i];
                    var type = this.types[field];
                    var value = serialized_object[field];
                    //DEBUG value = value.resolve if value.resolve
                    //DEBUG console.log('... value',field,value)
                    var object = type.fromObject(value);
                    result[field] = object;
                }
            } catch (error) {
                EC.throw(this.operation_name + '.' + field, error);
            }

            return result;
        }

        /**
            @arg {boolean} [debug.use_default = false] - more template friendly
            @arg {boolean} [debug.annotate = false] - add user-friendly information
        */

    }, {
        key: 'toObject',
        value: function toObject() {
            var serialized_object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { use_default: false, annotate: false };

            var result = {};
            var field = null;
            try {
                if (!this.types) return result;

                var iterable = this.keys;
                for (var i = 0, field; i < iterable.length; i++) {
                    field = iterable[i];
                    var type = this.types[field];
                    var object = type.toObject(typeof serialized_object !== "undefined" && serialized_object !== null ? serialized_object[field] : undefined, debug);
                    result[field] = object;
                    if (HEX_DUMP) {
                        var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
                        type.appendByteBuffer(b, typeof serialized_object !== "undefined" && serialized_object !== null ? serialized_object[field] : undefined);
                        b = b.copy(0, b.offset);
                        console.error(this.operation_name + '.' + field, b.toHex());
                    }
                }
            } catch (error) {
                EC.throw(this.operation_name + '.' + field, error);
            }

            return result;
        }

        /** Sort by the first element in a operation */

    }, {
        key: 'compare',
        value: function compare(a, b) {

            var first_key = this.keys[0];
            var first_type = this.types[first_key];

            var valA = a[first_key];
            var valB = b[first_key];

            if (first_type.compare) return first_type.compare(valA, valB);

            if (typeof valA === "number" && typeof valB === "number") return valA - valB;

            var encoding = void 0;
            if (Buffer.isBuffer(valA) && Buffer.isBuffer(valB)) {
                // A binary string compare does not work.  If localeCompare is well supported that could replace HEX.  Performanance is very good so comparing HEX works.
                encoding = "hex";
            }

            var strA = valA.toString(encoding);
            var strB = valB.toString(encoding);
            return strA > strB ? 1 : strA < strB ? -1 : 0;
        }

        // <helper_functions>

    }, {
        key: 'fromHex',
        value: function fromHex(hex) {
            var b = ByteBuffer.fromHex(hex, ByteBuffer.LITTLE_ENDIAN);
            return this.fromByteBuffer(b);
        }
    }, {
        key: 'fromBuffer',
        value: function fromBuffer(buffer) {
            var b = ByteBuffer.fromBinary(buffer.toString("binary"), ByteBuffer.LITTLE_ENDIAN);
            return this.fromByteBuffer(b);
        }
    }, {
        key: 'toHex',
        value: function toHex(object) {
            // return this.toBuffer(object).toString("hex")
            var b = this.toByteBuffer(object);
            return b.toHex();
        }
    }, {
        key: 'toByteBuffer',
        value: function toByteBuffer(object) {
            var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            this.appendByteBuffer(b, object);
            return b.copy(0, b.offset);
        }
    }, {
        key: 'toBuffer',
        value: function toBuffer(object) {
            return new Buffer(this.toByteBuffer(object).toBinary(), 'binary');
        }
    }]);

    return Serializer;
}();

module.exports = Serializer;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/serializer/src/serializer.js","/../node_modules/golosjs-lib/dist/serializer/src")
},{"./error_with_cause":61,"buffer":11,"bytebuffer":12,"pBGvAp":74}],65:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

/** Console print any transaction object with zero default values. */
module.exports = function template(op) {

    var object = op.toObject(void 0, { use_default: true, annotate: true });

    // visual (with descriptions)
    console.error(JSON.stringify(object, null, 4));

    // usable in a copy-paste

    object = op.toObject(void 0, { use_default: true, annotate: false });

    // copy-paste one-lineer
    console.error(JSON.stringify(object));
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/serializer/src/template.js","/../node_modules/golosjs-lib/dist/serializer/src")
},{"buffer":11,"pBGvAp":74}],66:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Low-level types that make up operations

var v = require('./SerializerValidation');
var fp = require('./FastParser');

var ChainTypes = require("../../chain/src/ChainTypes");
var ObjectId = require("../../chain/src/ObjectId");

var _require = require("../../ecc");

var PublicKey = _require.PublicKey;
var Address = _require.Address;

var ChainConfig = require("../../chain/src/ChainConfig");

var _require2 = require("./numberUtils");

var fromImpliedDecimal = _require2.fromImpliedDecimal;

var Types = {};
module.exports = Types;

var HEX_DUMP = process.env.npm_config__graphene_serializer_hex_dump;

Types.asset = {
    fromByteBuffer: function fromByteBuffer(b) {
        var amount = b.readInt64();
        var precision = b.readUint8();
        var b_copy = b.copy(b.offset, b.offset + 7);
        var symbol = new Buffer(b_copy.toBinary(), "binary").toString().replace(/\x00/g, "");
        b.skip(7);
        // "1.000 STEEM" always written with full precision
        var amount_string = fromImpliedDecimal(amount, precision);
        return amount_string + " " + symbol;
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        object = object.trim();
        if (!/^[0-9]+\.?[0-9]* [A-Za-z0-9]+$/.test(object)) throw new Error("Expecting amount like '99.000 SYMBOL', instead got '" + object + "'");

        var _object$split = object.split(" ");

        var _object$split2 = _slicedToArray(_object$split, 2);

        var amount = _object$split2[0];
        var symbol = _object$split2[1];

        if (symbol.length > 6) throw new Error("Symbols are not longer than 6 characters " + symbol + "-" + symbol.length);

        b.writeInt64(v.to_long(amount.replace(".", "")));
        var dot = amount.indexOf("."); // 0.000
        var precision = dot === -1 ? 0 : amount.length - dot - 1;
        b.writeUint8(precision);
        b.append(symbol.toUpperCase(), 'binary');
        for (var i = 0; i < 7 - symbol.length; i++) {
            b.writeUint8(0);
        }return;
    },
    fromObject: function fromObject(object) {
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0.000 STEEM";
        }
        return object;
    }
};

Types.uint8 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint8();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(0, 0xFF, object, 'uint8 ' + object);
        b.writeUint8(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(0, 0xFF, object, 'uint8 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(0, 0xFF, object, 'uint8 ' + object);
        return parseInt(object);
    }
};

Types.int16 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readInt16();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(0, 0xFFFF, object, 'int16 ' + object);
        b.writeInt16(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(0, 0xFFFF, object, 'int16 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(0, 0xFFFF, object, 'int16 ' + object);
        return parseInt(object);
    }
};

Types.uint16 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint16();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(-0xFFFF, 0xFFFF, object, 'uint16 ' + object);
        b.writeUint16(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(-0xFFFF, 0xFFFF, object, 'uint16 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(-0xFFFF, 0xFFFF, object, 'uint16 ' + object);
        return parseInt(object);
    }
};

Types.uint32 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(0, 0xFFFFFFFF, object, 'uint32 ' + object);
        b.writeUint32(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(0, 0xFFFFFFFF, object, 'uint32 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(0, 0xFFFFFFFF, object, 'uint32 ' + object);
        return parseInt(object);
    }
};

var MIN_SIGNED_32 = -1 * Math.pow(2, 31);
var MAX_SIGNED_32 = Math.pow(2, 31) - 1;

Types.varint32 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readVarint32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, 'uint32 ' + object);
        b.writeVarint32(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, 'uint32 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, 'uint32 ' + object);
        return parseInt(object);
    }
};

Types.int64 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readInt64();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        b.writeInt64(v.to_long(object));
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        return v.to_long(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0";
        }
        v.required(object);
        return v.to_long(object).toString();
    }
};

Types.uint64 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint64();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        b.writeUint64(v.to_long(v.unsigned(object)));
        return;
    },
    fromObject: function fromObject(object) {
        return v.to_long(v.unsigned(object));
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0";
        }
        return v.to_long(object).toString();
    }
};

Types.string = {
    fromByteBuffer: function fromByteBuffer(b) {
        var b_copy;
        var len = b.readVarint32();
        b_copy = b.copy(b.offset, b.offset + len), b.skip(len);
        return new Buffer(b_copy.toBinary(), 'binary');
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        b.writeVarint32(object.length);
        b.append(object.toString('binary'), 'binary');
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        return new Buffer(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "";
        }
        return object.toString();
    }
};

Types.bytes = function (size) {
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            if (size === undefined) {
                var b_copy;
                var len = b.readVarint32();
                b_copy = b.copy(b.offset, b.offset + len), b.skip(len);
                return new Buffer(b_copy.toBinary(), 'binary');
            } else {
                b_copy = b.copy(b.offset, b.offset + size), b.skip(size);
                return new Buffer(b_copy.toBinary(), 'binary');
            }
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            v.required(object);
            if (typeof object === "string") object = new Buffer(object, "hex");

            if (size === undefined) {
                b.writeVarint32(object.length);
            }
            b.append(object.toString('binary'), 'binary');
            return;
        },
        fromObject: function fromObject(object) {
            v.required(object);
            if (Buffer.isBuffer(object)) return object;

            return new Buffer(object, 'hex');
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                var zeros = function zeros(num) {
                    return new Array(num).join("00");
                };
                return zeros(size);
            }
            v.required(object);
            return object.toString('hex');
        }
    };
};

Types.bool = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint8() === 1;
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        // supports boolean or integer
        b.writeUint8(JSON.parse(object) ? 1 : 0);
        return;
    },
    fromObject: function fromObject(object) {
        return JSON.parse(object) ? true : false;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return false;
        }
        return JSON.parse(object) ? true : false;
    }
};

Types.void = {
    fromByteBuffer: function fromByteBuffer(b) {
        throw new Error("(void) undefined type");
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        throw new Error("(void) undefined type");
    },
    fromObject: function fromObject(object) {
        throw new Error("(void) undefined type");
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return undefined;
        }
        throw new Error("(void) undefined type");
    }
};

Types.array = function (st_operation) {
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            var size = b.readVarint32();
            if (HEX_DUMP) {
                console.log("varint32 size = " + size.toString(16));
            }
            var result = [];
            for (var i = 0; 0 < size ? i < size : i > size; 0 < size ? i++ : i++) {
                result.push(st_operation.fromByteBuffer(b));
            }
            return sortOperation(result, st_operation);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            v.required(object);
            object = sortOperation(object, st_operation);
            b.writeVarint32(object.length);
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                st_operation.appendByteBuffer(b, o);
            }
        },
        fromObject: function fromObject(object) {
            v.required(object);
            object = sortOperation(object, st_operation);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push(st_operation.fromObject(o));
            }
            return result;
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [st_operation.toObject(object, debug)];
            }
            v.required(object);
            object = sortOperation(object, st_operation);

            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push(st_operation.toObject(o, debug));
            }
            return result;
        }
    };
};

Types.time_point_sec = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        if (typeof object !== "number") object = Types.time_point_sec.fromObject(object);

        b.writeUint32(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);

        if (typeof object === "number") return object;

        if (object.getTime) return Math.floor(object.getTime() / 1000);

        if (typeof object !== "string") throw new Error("Unknown date type: " + object);

        // if(typeof object === "string" && !/Z$/.test(object))
        //     object = object + "Z"

        return Math.floor(new Date(object).getTime() / 1000);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) return new Date(0).toISOString().split('.')[0];

        v.required(object);

        if (typeof object === "string") return object;

        if (object.getTime) return object.toISOString().split('.')[0];

        var int = parseInt(object);
        v.require_range(0, 0xFFFFFFFF, int, 'uint32 ' + object);
        return new Date(int * 1000).toISOString().split('.')[0];
    }
};

Types.set = function (st_operation) {
    return {
        validate: function validate(array) {
            var dup_map = {};
            for (var i = 0, o; i < array.length; i++) {
                o = array[i];
                var ref;
                if (ref = typeof o === 'undefined' ? 'undefined' : _typeof(o), ['string', 'number'].indexOf(ref) >= 0) {
                    if (dup_map[o] !== undefined) {
                        throw new Error("duplicate (set)");
                    }
                    dup_map[o] = true;
                }
            }
            return sortOperation(array, st_operation);
        },
        fromByteBuffer: function fromByteBuffer(b) {
            var size = b.readVarint32();
            if (HEX_DUMP) {
                console.log("varint32 size = " + size.toString(16));
            }
            return this.validate(function () {
                var result = [];
                for (var i = 0; 0 < size ? i < size : i > size; 0 < size ? i++ : i++) {
                    result.push(st_operation.fromByteBuffer(b));
                }
                return result;
            }());
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            if (!object) {
                object = [];
            }
            b.writeVarint32(object.length);
            var iterable = this.validate(object);
            for (var i = 0, o; i < iterable.length; i++) {
                o = iterable[i];
                st_operation.appendByteBuffer(b, o);
            }
            return;
        },
        fromObject: function fromObject(object) {
            if (!object) {
                object = [];
            }
            return this.validate(function () {
                var result = [];
                for (var i = 0, o; i < object.length; i++) {
                    o = object[i];
                    result.push(st_operation.fromObject(o));
                }
                return result;
            }());
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [st_operation.toObject(object, debug)];
            }
            if (!object) {
                object = [];
            }
            return this.validate(function () {
                var result = [];
                for (var i = 0, o; i < object.length; i++) {
                    o = object[i];
                    result.push(st_operation.toObject(o, debug));
                }
                return result;
            }());
        }
    };
};

// global_parameters_update_operation current_fees
Types.fixed_array = function (count, st_operation) {
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            var i, j, ref, results;
            results = [];
            for (i = j = 0, ref = count; j < ref; i = j += 1) {
                results.push(st_operation.fromByteBuffer(b));
            }
            return sortOperation(results, st_operation);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            var i, j, ref;
            if (count !== 0) {
                v.required(object);
                object = sortOperation(object, st_operation);
            }
            for (i = j = 0, ref = count; j < ref; i = j += 1) {
                st_operation.appendByteBuffer(b, object[i]);
            }
        },
        fromObject: function fromObject(object) {
            var i, j, ref, results;
            if (count !== 0) {
                v.required(object);
            }
            results = [];
            for (i = j = 0, ref = count; j < ref; i = j += 1) {
                results.push(st_operation.fromObject(object[i]));
            }
            return results;
        },
        toObject: function toObject(object, debug) {
            var i, j, k, ref, ref1, results, results1;
            if (debug == null) {
                debug = {};
            }
            if (debug.use_default && object === void 0) {
                results = [];
                for (i = j = 0, ref = count; j < ref; i = j += 1) {
                    results.push(st_operation.toObject(void 0, debug));
                }
                return results;
            }
            if (count !== 0) {
                v.required(object);
            }
            results1 = [];
            for (i = k = 0, ref1 = count; k < ref1; i = k += 1) {
                results1.push(st_operation.toObject(object[i], debug));
            }
            return results1;
        }
    };
};

/* Supports instance numbers (11) or object types (1.2.11).  Object type
Validation is enforced when an object type is used. */
var id_type = function id_type(reserved_spaces, object_type) {
    v.required(reserved_spaces, "reserved_spaces");
    v.required(object_type, "object_type");
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            return b.readVarint32();
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            v.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            // convert 1.2.n into just n
            if (/^[0-9]+\.[0-9]+\.[0-9]+$/.test(object)) {
                object = v.get_instance(reserved_spaces, object_type, object);
            }
            b.writeVarint32(v.to_number(object));
            return;
        },
        fromObject: function fromObject(object) {
            v.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            if (v.is_digits(object)) {
                return v.to_number(object);
            }
            return v.get_instance(reserved_spaces, object_type, object);
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var object_type_id = ChainTypes.object_type[object_type];
            if (debug.use_default && object === undefined) {
                return reserved_spaces + '.' + object_type_id + '.0';
            }
            v.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            if (/^[0-9]+\.[0-9]+\.[0-9]+$/.test(object)) {
                object = v.get_instance(reserved_spaces, object_type, object);
            }

            return reserved_spaces + '.' + object_type_id + '.' + object;
        }
    };
};

Types.object_id_type = {
    fromByteBuffer: function fromByteBuffer(b) {
        return ObjectId.fromByteBuffer(b);
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        object = ObjectId.fromString(object);
        object.appendByteBuffer(b);
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        return ObjectId.fromString(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0.0.0";
        }
        v.required(object);
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        object = ObjectId.fromString(object);
        return object.toString();
    }
};

Types.vote_id = { TYPE: 0x000000FF,
    ID: 0xFFFFFF00,
    fromByteBuffer: function fromByteBuffer(b) {
        var value = b.readUint32();
        return {
            type: value & this.TYPE,
            id: value & this.ID
        };
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        if (object === "string") object = Types.vote_id.fromObject(object);

        var value = object.id << 8 | object.type;
        b.writeUint32(value);
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object, "(type vote_id)");
        if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) === "object") {
            v.required(object.type, "type");
            v.required(object.id, "id");
            return object;
        }
        v.require_test(/^[0-9]+:[0-9]+$/, object, 'vote_id format ' + object);

        var _object$split3 = object.split(':');

        var _object$split4 = _slicedToArray(_object$split3, 2);

        var type = _object$split4[0];
        var id = _object$split4[1];

        v.require_range(0, 0xff, type, 'vote type ' + object);
        v.require_range(0, 0xffffff, id, 'vote id ' + object);
        return { type: type, id: id };
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0:0";
        }
        v.required(object);
        if (typeof object === "string") object = Types.vote_id.fromObject(object);

        return object.type + ":" + object.id;
    },
    compare: function compare(a, b) {
        if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== "object") a = Types.vote_id.fromObject(a);
        if ((typeof b === 'undefined' ? 'undefined' : _typeof(b)) !== "object") b = Types.vote_id.fromObject(b);
        return parseInt(a.id) - parseInt(b.id);
    }
};

Types.optional = function (st_operation) {
    v.required(st_operation, "st_operation");
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            if (!(b.readUint8() === 1)) {
                return undefined;
            }
            return st_operation.fromByteBuffer(b);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            if (object !== null && object !== undefined) {
                b.writeUint8(1);
                st_operation.appendByteBuffer(b, object);
            } else {
                b.writeUint8(0);
            }
            return;
        },
        fromObject: function fromObject(object) {
            if (object === undefined) {
                return undefined;
            }
            return st_operation.fromObject(object);
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            // toObject is only null save if use_default is true
            var result_object = function () {
                if (!debug.use_default && object === undefined) {
                    return undefined;
                } else {
                    return st_operation.toObject(object, debug);
                }
            }();

            if (debug.annotate) {
                if ((typeof result_object === 'undefined' ? 'undefined' : _typeof(result_object)) === "object") {
                    result_object.__optional = "parent is optional";
                } else {
                    result_object = { __optional: result_object };
                }
            }
            return result_object;
        }
    };
};

Types.static_variant = function (_st_operations) {
    return {
        nosort: true,
        st_operations: _st_operations,
        fromByteBuffer: function fromByteBuffer(b) {
            var type_id = b.readVarint32();
            var st_operation = this.st_operations[type_id];
            if (HEX_DUMP) {
                console.error('static_variant id 0x' + type_id.toString(16) + ' (' + type_id + ')');
            }
            v.required(st_operation, 'operation ' + type_id);
            return [type_id, st_operation.fromByteBuffer(b)];
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            v.required(object);
            var type_id = object[0];
            var st_operation = this.st_operations[type_id];
            v.required(st_operation, 'operation ' + type_id);
            b.writeVarint32(type_id);
            st_operation.appendByteBuffer(b, object[1]);
            return;
        },
        fromObject: function fromObject(object) {
            v.required(object);
            var type_id = object[0];
            var st_operation = this.st_operations[type_id];
            v.required(st_operation, 'operation ' + type_id);
            return [type_id, st_operation.fromObject(object[1])];
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [0, this.st_operations[0].toObject(undefined, debug)];
            }
            v.required(object);
            var type_id = object[0];
            var st_operation = this.st_operations[type_id];
            v.required(st_operation, 'operation ' + type_id);
            return [type_id, st_operation.toObject(object[1], debug)];
        }
    };
};

Types.map = function (key_st_operation, value_st_operation) {
    return {
        validate: function validate(array) {
            if (!Array.isArray(array)) {
                throw new Error("expecting array");
            }
            var dup_map = {};
            for (var i = 0, o; i < array.length; i++) {
                o = array[i];
                var ref;
                if (!(o.length === 2)) {
                    throw new Error("expecting two elements");
                }
                if (ref = _typeof(o[0]), ['number', 'string'].indexOf(ref) >= 0) {
                    if (dup_map[o[0]] !== undefined) {
                        throw new Error("duplicate (map)");
                    }
                    dup_map[o[0]] = true;
                }
            }
            return sortOperation(array, key_st_operation);
        },
        fromByteBuffer: function fromByteBuffer(b) {
            var result = [];
            var end = b.readVarint32();
            for (var i = 0; 0 < end ? i < end : i > end; 0 < end ? i++ : i++) {
                result.push([key_st_operation.fromByteBuffer(b), value_st_operation.fromByteBuffer(b)]);
            }
            return this.validate(result);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            this.validate(object);
            b.writeVarint32(object.length);
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                key_st_operation.appendByteBuffer(b, o[0]);
                value_st_operation.appendByteBuffer(b, o[1]);
            }
            return;
        },
        fromObject: function fromObject(object) {
            v.required(object);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push([key_st_operation.fromObject(o[0]), value_st_operation.fromObject(o[1])]);
            }
            return this.validate(result);
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [[key_st_operation.toObject(undefined, debug), value_st_operation.toObject(undefined, debug)]];
            }
            v.required(object);
            object = this.validate(object);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push([key_st_operation.toObject(o[0], debug), value_st_operation.toObject(o[1], debug)]);
            }
            return result;
        }
    };
};

Types.public_key = {
    toPublic: function toPublic(object) {
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        return object == null ? object : object.Q ? object : PublicKey.fromStringOrThrow(object);
    },
    fromByteBuffer: function fromByteBuffer(b) {
        return fp.public_key(b);
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        fp.public_key(b, Types.public_key.toPublic(object));
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        if (object.Q) {
            return object;
        }
        return Types.public_key.toPublic(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return ChainConfig.address_prefix + "859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2HqhToVM";
        }
        v.required(object);
        return object.toString();
    },
    compare: function compare(a, b) {
        return strCmp(a.toString(), b.toString());
    }
};

Types.address = {
    _to_address: function _to_address(object) {
        v.required(object);
        if (object.addy) {
            return object;
        }
        return Address.fromString(object);
    },
    fromByteBuffer: function fromByteBuffer(b) {
        return new Address(fp.ripemd160(b));
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        fp.ripemd160(b, Types.address._to_address(object).toBuffer());
        return;
    },
    fromObject: function fromObject(object) {
        return Types.address._to_address(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return ChainConfig.address_prefix + "664KmHxSuQyDsfwo4WEJvWpzg1QKdg67S";
        }
        return Types.address._to_address(object).toString();
    },
    compare: function compare(a, b) {
        return strCmp(a.toString(), b.toString());
    }
};

var strCmp = function strCmp(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
};
var firstEl = function firstEl(el) {
    return Array.isArray(el) ? el[0] : el;
};
var sortOperation = function sortOperation(array, st_operation) {
    return st_operation.nosort ? array : st_operation.compare ? array.sort(function (a, b) {
        return st_operation.compare(firstEl(a), firstEl(b));
    }) : // custom compare operation
    array.sort(function (a, b) {
        return typeof firstEl(a) === "number" && typeof firstEl(b) === "number" ? firstEl(a) - firstEl(b) :
        // A binary string compare does not work. Performanance is very good so HEX is used..  localeCompare is another option.
        Buffer.isBuffer(firstEl(a)) && Buffer.isBuffer(firstEl(b)) ? strCmp(firstEl(a).toString("hex"), firstEl(b).toString("hex")) : strCmp(firstEl(a).toString(), firstEl(b).toString());
    });
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/dist/serializer/src/types.js","/../node_modules/golosjs-lib/dist/serializer/src")
},{"../../chain/src/ChainConfig":38,"../../chain/src/ChainTypes":39,"../../chain/src/ObjectId":42,"../../ecc":45,"./FastParser":59,"./SerializerValidation":60,"./numberUtils":62,"buffer":11,"pBGvAp":74}],67:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/node_modules/deep-equal/index.js","/../node_modules/golosjs-lib/node_modules/deep-equal")
},{"./lib/is_arguments.js":68,"./lib/keys.js":69,"buffer":11,"pBGvAp":74}],68:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/node_modules/deep-equal/lib/is_arguments.js","/../node_modules/golosjs-lib/node_modules/deep-equal/lib")
},{"buffer":11,"pBGvAp":74}],69:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/golosjs-lib/node_modules/deep-equal/lib/keys.js","/../node_modules/golosjs-lib/node_modules/deep-equal/lib")
},{"buffer":11,"pBGvAp":74}],70:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ieee754/index.js","/../node_modules/ieee754")
},{"buffer":11,"pBGvAp":74}],71:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/inherits/inherits_browser.js","/../node_modules/inherits")
},{"buffer":11,"pBGvAp":74}],72:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/long.js for details
 */
(function(global, factory) {

    /* AMD */ if (typeof define === 'function' && define["amd"])
        define([], factory);
    /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"])
        module["exports"] = factory();
    /* Global */ else
        (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();

})(this, function() {
    "use strict";

    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @constructor
     */
    function Long(low, high, unsigned) {

        /**
         * The low 32 bits as a signed value.
         * @type {number}
         */
        this.low = low | 0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         */
        this.high = high | 0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         */
        this.unsigned = !!unsigned;
    }

    // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.

    /**
     * An indicator used to reliably determine if an object is a Long or not.
     * @type {boolean}
     * @const
     * @private
     */
    Long.prototype.__isLong__;

    Object.defineProperty(Long.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    /**
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @inner
     */
    function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
    }

    /**
     * Tests if the specified object is a Long.
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     */
    Long.isLong = isLong;

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */
    var UINT_CACHE = {};

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
            value >>>= 0;
            if (cache = (0 <= value && value < 256)) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache)
                UINT_CACHE[value] = obj;
            return obj;
        } else {
            value |= 0;
            if (cache = (-128 <= value && value < 128)) {
                cachedObj = INT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache)
                INT_CACHE[value] = obj;
            return obj;
        }
    }

    /**
     * Returns a Long representing the given 32 bit integer value.
     * @function
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromInt = fromInt;

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromNumber(value, unsigned) {
        if (isNaN(value) || !isFinite(value))
            return unsigned ? UZERO : ZERO;
        if (unsigned) {
            if (value < 0)
                return UZERO;
            if (value >= TWO_PWR_64_DBL)
                return MAX_UNSIGNED_VALUE;
        } else {
            if (value <= -TWO_PWR_63_DBL)
                return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL)
                return MAX_VALUE;
        }
        if (value < 0)
            return fromNumber(-value, unsigned).neg();
        return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
    }

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @function
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromNumber = fromNumber;

    /**
     * @param {number} lowBits
     * @param {number} highBits
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    }

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @function
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromBits = fromBits;

    /**
     * @function
     * @param {number} base
     * @param {number} exponent
     * @returns {number}
     * @inner
     */
    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

    /**
     * @param {string} str
     * @param {(boolean|number)=} unsigned
     * @param {number=} radix
     * @returns {!Long}
     * @inner
     */
    function fromString(str, unsigned, radix) {
        if (str.length === 0)
            throw Error('empty string');
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
            return ZERO;
        if (typeof unsigned === 'number') {
            // For goog.math.long compatibility
            radix = unsigned,
            unsigned = false;
        } else {
            unsigned = !! unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');

        var p;
        if ((p = str.indexOf('-')) > 0)
            throw Error('interior hyphen');
        else if (p === 0) {
            return fromString(str.substring(1), unsigned, radix).neg();
        }

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 8));

        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i),
                value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = fromNumber(pow_dbl(radix, size));
                result = result.mul(power).add(fromNumber(value));
            } else {
                result = result.mul(radixToPower);
                result = result.add(fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    }

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @function
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     */
    Long.fromString = fromString;

    /**
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
     * @returns {!Long}
     * @inner
     */
    function fromValue(val) {
        if (val /* is compatible */ instanceof Long)
            return val;
        if (typeof val === 'number')
            return fromNumber(val);
        if (typeof val === 'string')
            return fromString(val);
        // Throws for non-objects, converts non-instanceof Long:
        return fromBits(val.low, val.high, val.unsigned);
    }

    /**
     * Converts the specified value to a Long.
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @returns {!Long}
     */
    Long.fromValue = fromValue;

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     * @const
     * @inner
     */
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

    /**
     * @type {!Long}
     * @inner
     */
    var ZERO = fromInt(0);

    /**
     * Signed zero.
     * @type {!Long}
     */
    Long.ZERO = ZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var UZERO = fromInt(0, true);

    /**
     * Unsigned zero.
     * @type {!Long}
     */
    Long.UZERO = UZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var ONE = fromInt(1);

    /**
     * Signed one.
     * @type {!Long}
     */
    Long.ONE = ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var UONE = fromInt(1, true);

    /**
     * Unsigned one.
     * @type {!Long}
     */
    Long.UONE = UONE;

    /**
     * @type {!Long}
     * @inner
     */
    var NEG_ONE = fromInt(-1);

    /**
     * Signed negative one.
     * @type {!Long}
     */
    Long.NEG_ONE = NEG_ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

    /**
     * Maximum signed value.
     * @type {!Long}
     */
    Long.MAX_VALUE = MAX_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

    /**
     * Maximum unsigned value.
     * @type {!Long}
     */
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MIN_VALUE = fromBits(0, 0x80000000|0, false);

    /**
     * Minimum signed value.
     * @type {!Long}
     */
    Long.MIN_VALUE = MIN_VALUE;

    /**
     * @alias Long.prototype
     * @inner
     */
    var LongPrototype = Long.prototype;

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @returns {number}
     */
    LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     */
    LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * Converts the Long to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     */
    LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');
        if (this.isZero())
            return '0';
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.eq(MIN_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = fromNumber(radix),
                    div = this.div(radixLong),
                    rem1 = div.mul(radixLong).sub(this);
                return div.toString(radix) + rem1.toInt().toString(radix);
            } else
                return '-' + this.neg().toString(radix);
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
            rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower),
                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
                digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
                return digits + result;
            else {
                while (digits.length < 6)
                    digits = '0' + digits;
                result = '' + digits + result;
            }
        }
    };

    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     */
    LongPrototype.getHighBits = function getHighBits() {
        return this.high;
    };

    /**
     * Gets the high 32 bits as an unsigned integer.
     * @returns {number} Unsigned high bits
     */
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
    };

    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     */
    LongPrototype.getLowBits = function getLowBits() {
        return this.low;
    };

    /**
     * Gets the low 32 bits as an unsigned integer.
     * @returns {number} Unsigned low bits
     */
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
    };

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @returns {number}
     */
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative()) // Unsigned Longs are never negative
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
            if ((val & (1 << bit)) != 0)
                break;
        return this.high != 0 ? bit + 33 : bit + 1;
    };

    /**
     * Tests if this Long's value equals zero.
     * @returns {boolean}
     */
    LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
    };

    /**
     * Tests if this Long's value is negative.
     * @returns {boolean}
     */
    LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * Tests if this Long's value is positive.
     * @returns {boolean}
     */
    LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
    };

    /**
     * Tests if this Long's value is odd.
     * @returns {boolean}
     */
    LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
    };

    /**
     * Tests if this Long's value is even.
     * @returns {boolean}
     */
    LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
    };

    /**
     * Tests if this Long's value equals the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.equals = function equals(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
            return false;
        return this.high === other.high && this.low === other.low;
    };

    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.eq = LongPrototype.equals;

    /**
     * Tests if this Long's value differs from the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(/* validates */ other);
    };

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.neq = LongPrototype.notEquals;

    /**
     * Tests if this Long's value is less than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThan = function lessThan(other) {
        return this.comp(/* validates */ other) < 0;
    };

    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lt = LongPrototype.lessThan;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(/* validates */ other) <= 0;
    };

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lte = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is greater than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(/* validates */ other) > 0;
    };

    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gt = LongPrototype.greaterThan;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(/* validates */ other) >= 0;
    };

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;

    /**
     * Compares this Long's value with the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.compare = function compare(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.eq(other))
            return 0;
        var thisNeg = this.isNegative(),
            otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
            return -1;
        if (!thisNeg && otherNeg)
            return 1;
        // At this point the sign bits are the same
        if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
        // Both are positive if at least one is unsigned
        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
    };

    /**
     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.comp = LongPrototype.compare;

    /**
     * Negates this Long's value.
     * @returns {!Long} Negated Long
     */
    LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
            return MIN_VALUE;
        return this.not().add(ONE);
    };

    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     */
    LongPrototype.neg = LongPrototype.negate;

    /**
     * Returns the sum of this and the specified Long.
     * @param {!Long|number|string} addend Addend
     * @returns {!Long} Sum
     */
    LongPrototype.add = function add(addend) {
        if (!isLong(addend))
            addend = fromValue(addend);

        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the specified Long.
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
            subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
    };

    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.sub = LongPrototype.subtract;

    /**
     * Returns the product of this and the specified Long.
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
            return ZERO;
        if (!isLong(multiplier))
            multiplier = fromValue(multiplier);
        if (multiplier.isZero())
            return ZERO;
        if (this.eq(MIN_VALUE))
            return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
            return this.isOdd() ? MIN_VALUE : ZERO;

        if (this.isNegative()) {
            if (multiplier.isNegative())
                return this.neg().mul(multiplier.neg());
            else
                return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();

        // If both longs are small, use float multiplication
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.mul = LongPrototype.multiply;

    /**
     * Returns this Long divided by the specified. The result is signed if this Long is signed or
     *  unsigned if this Long is unsigned.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        if (divisor.isZero())
            throw Error('division by zero');
        if (this.isZero())
            return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
            // This section is only relevant for signed longs and is derived from the
            // closure library as a whole.
            if (this.eq(MIN_VALUE)) {
                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                    return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
                else if (divisor.eq(MIN_VALUE))
                    return ONE;
                else {
                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                    var halfThis = this.shr(1);
                    approx = halfThis.div(divisor).shl(1);
                    if (approx.eq(ZERO)) {
                        return divisor.isNegative() ? ONE : NEG_ONE;
                    } else {
                        rem = this.sub(divisor.mul(approx));
                        res = approx.add(rem.div(divisor));
                        return res;
                    }
                }
            } else if (divisor.eq(MIN_VALUE))
                return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
                if (divisor.isNegative())
                    return this.neg().div(divisor.neg());
                return this.neg().div(divisor).neg();
            } else if (divisor.isNegative())
                return this.div(divisor.neg()).neg();
            res = ZERO;
        } else {
            // The algorithm below has not been made for unsigned longs. It's therefore
            // required to take special care of the MSB prior to running it.
            if (!divisor.unsigned)
                divisor = divisor.toUnsigned();
            if (divisor.gt(this))
                return UZERO;
            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
                return UONE;
            res = UZERO;
        }

        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        rem = this;
        while (rem.gte(divisor)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
                delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
                approxRes = fromNumber(approx),
                approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
                approx -= delta;
                approxRes = fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero())
                approxRes = ONE;

            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.div = LongPrototype.divide;

    /**
     * Returns this Long modulo the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
    };

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.mod = LongPrototype.modulo;

    /**
     * Returns the bitwise NOT of this Long.
     * @returns {!Long}
     */
    LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise AND of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.and = function and(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise OR of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.or = function or(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.xor = function xor(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
        else
            return fromBits(0, this.low << (numBits - 32), this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shl = LongPrototype.shiftLeft;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
        else
            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
    };

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shr = LongPrototype.shiftRight;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
            return this;
        else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
            } else if (numBits === 32)
                return fromBits(high, 0, this.unsigned);
            else
                return fromBits(high >>> (numBits - 32), 0, this.unsigned);
        }
    };

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;

    /**
     * Converts this Long to signed.
     * @returns {!Long} Signed long
     */
    LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
            return this;
        return fromBits(this.low, this.high, false);
    };

    /**
     * Converts this Long to unsigned.
     * @returns {!Long} Unsigned long
     */
    LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
            return this;
        return fromBits(this.low, this.high, true);
    };

    /**
     * Converts this Long to its byte representation.
     * @param {boolean=} le Whether little or big endian, defaults to big endian
     * @returns {!Array.<number>} Byte representation
     */
    LongPrototype.toBytes = function(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
    }

    /**
     * Converts this Long to its little endian byte representation.
     * @returns {!Array.<number>} Little endian byte representation
     */
    LongPrototype.toBytesLE = function() {
        var hi = this.high,
            lo = this.low;
        return [
             lo         & 0xff,
            (lo >>>  8) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>> 24) & 0xff,
             hi         & 0xff,
            (hi >>>  8) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>> 24) & 0xff
        ];
    }

    /**
     * Converts this Long to its big endian byte representation.
     * @returns {!Array.<number>} Big endian byte representation
     */
    LongPrototype.toBytesBE = function() {
        var hi = this.high,
            lo = this.low;
        return [
            (hi >>> 24) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>>  8) & 0xff,
             hi         & 0xff,
            (lo >>> 24) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>>  8) & 0xff,
             lo         & 0xff
        ];
    }

    return Long;
});

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/long/dist/long.js","/../node_modules/long/dist")
},{"buffer":11,"pBGvAp":74}],73:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
/* eslint-disable no-unused-vars */
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (e) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/object-assign/index.js","/../node_modules/object-assign")
},{"buffer":11,"pBGvAp":74}],74:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/process/browser.js","/../node_modules/process")
},{"buffer":11,"pBGvAp":74}],75:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/** @preserve
(c) 2012 by Cédric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// constants table
var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]
var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]

function bytesToWords (bytes) {
  var words = []
  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
    words[b >>> 5] |= bytes[i] << (24 - b % 32)
  }
  return words
}

function wordsToBytes (words) {
  var bytes = []
  for (var b = 0; b < words.length * 32; b += 8) {
    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF)
  }
  return bytes
}

function processBlock (H, M, offset) {
  // swap endian
  for (var i = 0; i < 16; i++) {
    var offset_i = offset + i
    var M_offset_i = M[offset_i]

    // Swap
    M[offset_i] = (
      (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
      (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)
    )
  }

  // Working variables
  var al, bl, cl, dl, el
  var ar, br, cr, dr, er

  ar = al = H[0]
  br = bl = H[1]
  cr = cl = H[2]
  dr = dl = H[3]
  er = el = H[4]

  // computation
  var t
  for (i = 0; i < 80; i += 1) {
    t = (al + M[offset + zl[i]]) | 0
    if (i < 16) {
      t += f1(bl, cl, dl) + hl[0]
    } else if (i < 32) {
      t += f2(bl, cl, dl) + hl[1]
    } else if (i < 48) {
      t += f3(bl, cl, dl) + hl[2]
    } else if (i < 64) {
      t += f4(bl, cl, dl) + hl[3]
    } else {// if (i<80) {
      t += f5(bl, cl, dl) + hl[4]
    }
    t = t | 0
    t = rotl(t, sl[i])
    t = (t + el) | 0
    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = t

    t = (ar + M[offset + zr[i]]) | 0
    if (i < 16) {
      t += f5(br, cr, dr) + hr[0]
    } else if (i < 32) {
      t += f4(br, cr, dr) + hr[1]
    } else if (i < 48) {
      t += f3(br, cr, dr) + hr[2]
    } else if (i < 64) {
      t += f2(br, cr, dr) + hr[3]
    } else {// if (i<80) {
      t += f1(br, cr, dr) + hr[4]
    }

    t = t | 0
    t = rotl(t, sr[i])
    t = (t + er) | 0
    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = t
  }

  // intermediate hash value
  t = (H[1] + cl + dr) | 0
  H[1] = (H[2] + dl + er) | 0
  H[2] = (H[3] + el + ar) | 0
  H[3] = (H[4] + al + br) | 0
  H[4] = (H[0] + bl + cr) | 0
  H[0] = t
}

function f1 (x, y, z) {
  return ((x) ^ (y) ^ (z))
}

function f2 (x, y, z) {
  return (((x) & (y)) | ((~x) & (z)))
}

function f3 (x, y, z) {
  return (((x) | (~(y))) ^ (z))
}

function f4 (x, y, z) {
  return (((x) & (z)) | ((y) & (~(z))))
}

function f5 (x, y, z) {
  return ((x) ^ ((y) | (~(z))))
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function ripemd160 (message) {
  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

  if (typeof message === 'string') {
    message = new Buffer(message, 'utf8')
  }

  var m = bytesToWords(message)

  var nBitsLeft = message.length * 8
  var nBitsTotal = message.length * 8

  // Add padding
  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32)
  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
    (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |
    (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00)
  )

  for (var i = 0; i < m.length; i += 16) {
    processBlock(H, m, i)
  }

  // swap endian
  for (i = 0; i < 5; i++) {
    // shortcut
    var H_i = H[i]

    // Swap
    H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |
      (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00)
  }

  var digestbytes = wordsToBytes(H)
  return new Buffer(digestbytes)
}

module.exports = ripemd160

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ripemd160/lib/ripemd160.js","/../node_modules/ripemd160/lib")
},{"buffer":11,"pBGvAp":74}],76:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
!function(globals){
'use strict'

//*** UMD BEGIN
if (typeof define !== 'undefined' && define.amd) { //require.js / AMD
  define([], function() {
    return secureRandom
  })
} else if (typeof module !== 'undefined' && module.exports) { //CommonJS
  module.exports = secureRandom
} else { //script / browser
  globals.secureRandom = secureRandom
}
//*** UMD END

//options.type is the only valid option
function secureRandom(count, options) {
  options = options || {type: 'Array'}
  //we check for process.pid to prevent browserify from tricking us
  if (typeof process != 'undefined' && typeof process.pid == 'number') {
    return nodeRandom(count, options)
  } else {
    var crypto = window.crypto || window.msCrypto
    if (!crypto) throw new Error("Your browser does not support window.crypto.")
    return browserRandom(count, options)
  }
}

function nodeRandom(count, options) {
  var crypto = require('crypto')
  var buf = crypto.randomBytes(count)

  switch (options.type) {
    case 'Array':
      return [].slice.call(buf)
    case 'Buffer':
      return buf
    case 'Uint8Array':
      var arr = new Uint8Array(count)
      for (var i = 0; i < count; ++i) { arr[i] = buf.readUInt8(i) }
      return arr
    default:
      throw new Error(options.type + " is unsupported.")
  }
}

function browserRandom(count, options) {
  var nativeArr = new Uint8Array(count)
  var crypto = window.crypto || window.msCrypto
  crypto.getRandomValues(nativeArr)

  switch (options.type) {
    case 'Array':
      return [].slice.call(nativeArr)
    case 'Buffer':
      try { var b = new Buffer(1) } catch(e) { throw new Error('Buffer not supported in this environment. Use Node.js or Browserify for browser support.')}
      return new Buffer(nativeArr)
    case 'Uint8Array':
      return nativeArr
    default:
      throw new Error(options.type + " is unsupported.")
  }
}

secureRandom.randomArray = function(byteCount) {
  return secureRandom(byteCount, {type: 'Array'})
}

secureRandom.randomUint8Array = function(byteCount) {
  return secureRandom(byteCount, {type: 'Uint8Array'})
}

secureRandom.randomBuffer = function(byteCount) {
  return secureRandom(byteCount, {type: 'Buffer'})
}


}(this);

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/secure-random/lib/secure-random.js","/../node_modules/secure-random/lib")
},{"buffer":11,"crypto":8,"pBGvAp":74}],77:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = new Buffer(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
  this._s = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = new Buffer(data, enc)
  }

  var l = this._len += data.length
  var s = this._s || 0
  var f = 0
  var buffer = this._block

  while (s < l) {
    var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
    var ch = (t - f)

    for (var i = 0; i < ch; i++) {
      buffer[(s % this._blockSize) + i] = data[i + f]
    }

    s += ch
    f += ch

    if ((s % this._blockSize) === 0) {
      this._update(buffer)
    }
  }
  this._s = s

  return this
}

Hash.prototype.digest = function (enc) {
  // Suppose the length of the message M, in bits, is l
  var l = this._len * 8

  // Append the bit 1 to the end of the message
  this._block[this._len % this._blockSize] = 0x80

  // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
  this._block.fill(0, this._len % this._blockSize + 1)

  if (l % (this._blockSize * 8) >= this._finalSize * 8) {
    this._update(this._block)
    this._block.fill(0)
  }

  // to this append the block which is equal to the number l written in binary
  // TODO: handle case where l is > Math.pow(2, 29)
  this._block.writeInt32BE(l, this._blockSize - 4)

  var hash = this._update(this._block) || this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/hash.js","/../node_modules/sha.js")
},{"buffer":11,"pBGvAp":74}],78:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/index.js","/../node_modules/sha.js")
},{"./sha":79,"./sha1":80,"./sha224":81,"./sha256":82,"./sha384":83,"./sha512":84,"buffer":11,"pBGvAp":74}],79:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha.js","/../node_modules/sha.js")
},{"./hash":77,"buffer":11,"inherits":71,"pBGvAp":74}],80:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha1.js","/../node_modules/sha.js")
},{"./hash":77,"buffer":11,"inherits":71,"pBGvAp":74}],81:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = new Buffer(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha224.js","/../node_modules/sha.js")
},{"./hash":77,"./sha256":82,"buffer":11,"inherits":71,"pBGvAp":74}],82:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = new Buffer(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha256.js","/../node_modules/sha.js")
},{"./hash":77,"buffer":11,"inherits":71,"pBGvAp":74}],83:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = new Buffer(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha384.js","/../node_modules/sha.js")
},{"./hash":77,"./sha512":84,"buffer":11,"inherits":71,"pBGvAp":74}],84:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = new Buffer(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha512.js","/../node_modules/sha.js")
},{"./hash":77,"buffer":11,"inherits":71,"pBGvAp":74}],85:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WsRpc = require("./WebSocketRpc");
var SteemApi = require("./SteemApi");

var defaultOptions = {
    url: "wss://node.steem.ws",
    user: "",
    pass: "",
    debug: false,
    apis: ["database_api", "network_broadcast_api", "follow_api", "market_history_api", "login_api", "private_message_api"]
};

var objectAssign = require('object-assign');

var apiInstance;

module.exports = {

    reset: function reset() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        if (apiInstance) {
            this.close();
        }
        apiInstance = new ApiInstance(options);
        apiInstance.connect();

        return apiInstance;
    },

    get: function get() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
        var connect = arguments[1];

        if (!apiInstance) {
            apiInstance = new ApiInstance(options);
        }

        if (connect) {
            apiInstance.setOptions(options);
            apiInstance.connect();
        }

        return apiInstance;
    },


    close: function close() {
        apiInstance.close();apiInstance = null;
    }
};

var ApiInstance = function () {
    function ApiInstance(options) {
        _classCallCheck(this, ApiInstance);

        this.setOptions(options);
        this.statusCallback = options.statusCallback;
    }

    _createClass(ApiInstance, [{
        key: "setOptions",
        value: function setOptions(options) {
            this.options = objectAssign({}, defaultOptions, options);//Object.assign({}, defaultOptions, options);
            if (this.options.apis.indexOf("database_api") === -1) {
                this.options.apis.unshift("database_api");
            }
        }
    }, {
        key: "connect",
        value: function connect() {
            if (this.wsRpc) {
                return;
            }

            try {
                this.wsRpc = new WsRpc(this.options, this.onReconnect.bind(this), this.onStatusChange.bind(this));
                return this.login();
            } catch (err) {
                console.error("wsRpc open error:", err);
            }
        }
    }, {
        key: "login",
        value: function login() {
            var _this = this;

            return this.initPromise = this.wsRpc.login(this.options.user, this.options.pass).then(function () {
                var apiPromises = [];

                _this.options.apis.forEach(function (api) {
                    _this["_" + api] = new SteemApi(_this.wsRpc, api);
                    _this[api] = function () {
                        return this["_" + api];
                    };
                    apiPromises.push(_this["_" + api].init().then(function () {
                        if (api === "database_api") {
                            return _this[api]().exec("get_config", []).then(function (res) {
                                _this.chainId = res.STEEMIT_CHAIN_ID;
                                return "connected to " + api;
                            });
                        } else {
                            return "connected to " + api;
                        }
                    }));
                });
                return Promise.all(apiPromises);
            }).catch(function (err) {
                // console.error("Unable to connect to", this.options.url);
                throw new Error("Unable to connect to " + _this.options.url);
            });
        }
    }, {
        key: "onReconnect",
        value: function onReconnect() {
            this.login();
        }
    }, {
        key: "onStatusChange",
        value: function onStatusChange(e) {
            if (this.statusCallback) {
                this.statusCallback(e);
            }
        }
    }, {
        key: "close",
        value: function close() {
            if (this.wsRpc) {
                this.wsRpc.close();
                this.wsRpc = null;
            }
        }
    }]);

    return ApiInstance;
}();
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steem-rpc/lib/ApiInstance.js","/../node_modules/steem-rpc/lib")
},{"./SteemApi":86,"./WebSocketRpc":87,"buffer":11,"object-assign":73,"pBGvAp":74}],86:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SteemApi = function () {
	function SteemApi(wsRpc, apiName) {
		_classCallCheck(this, SteemApi);

		this.wsRpc = wsRpc;
		this.apiName = apiName;
	}

	_createClass(SteemApi, [{
		key: "init",
		value: function init() {
			var _this = this;

			return this.wsRpc.getApiByName(this.apiName).then(function (response) {
				_this.apiId = response;
				return _this;
			});
		}
	}, {
		key: "exec",
		value: function exec(method, params) {
			return this.wsRpc.call([this.apiId, method, params]).catch(function (error) {
				console.error("SteemApi error:", method, params, JSON.stringify(error));
				var newErr = new Error("SteemApi error:" + method + params + JSON.stringify(error));
				newErr.original = error;
				localStorage.error = 1;
				localStorage.errormessage = error.message?error.message.split("\n")[1]:'Connection lost, reconnecting...';
				throw newErr;
			});
		}
	}]);

	return SteemApi;
}();

module.exports = SteemApi;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steem-rpc/lib/SteemApi.js","/../node_modules/steem-rpc/lib")
},{"buffer":11,"pBGvAp":74}],87:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RWebSocket = require("./reconnecting-websocket");

var WebSocketRpc = function () {
	function WebSocketRpc(options) {
		var _this = this;

		var rcCallback = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
		var statusCallback = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

		_classCallCheck(this, WebSocketRpc);

		this.rcCallback = rcCallback;
		this.statusCallback = statusCallback;

		if (typeof WebSocket !== "undefined") {
			options.WebSocket = WebSocket;
			options.idleTreshold = "idleTreshold" in options ? options.idleTreshold : 60000; // Only use idle threshold in browsers
		} else {
				options.WebSocket = require("ws");
				options.idleTreshold = 0; // Always reconnect in node.js
			}
		options.reconnectInterval = 1000;
		options.reconnectDecay = 1.2;

		this.ws = new RWebSocket(options);
		this.ws.timeoutInterval = 15000;

		var initialConnect = true;

		this.connectPromise = new Promise(function (resolve, reject) {

			_this.ws.onopen = function () {
				if (_this.statusCallback) _this.statusCallback("open");
				if (initialConnect) {
					initialConnect = false;
					resolve();
				} else {
					if (_this.rcCallback) _this.rcCallback();
				}
			};

			_this.ws.onerror = function (err) {
				if (_this.statusCallback) _this.statusCallback("error");
				reject(err);
			};

			_this.ws.onmessage = function (message) {
				var data = {};
				try {
					data = JSON.parse(message.data);
				} catch (e) {
					console.log("Unable to parse API response:", e);
					data.error = "Unable to parse response " + JSON.stringify(message);
				}
				_this.listener(data);
			};

			_this.ws.onclose = function () {
				// web socket may re-connect
				_this.cbs.forEach(function (value) {
					value.reject('connection closed');
				});

				_this.methodCbs.forEach(function (value) {
					value.reject('connection closed');
				});

				_this.cbs.clear();
				_this.methodCbs.clear();
				_this.cbId = 0;

				if (_this.statusCallback) _this.statusCallback("closed");
			};
		});

		this.cbId = 0;
		this.cbs = new Map();
		this.methodCbs = new Map();

		if (typeof window !== "undefined") {
			window.onbeforeunload = function () {
				_this.close();
			};
		}
	}

	_createClass(WebSocketRpc, [{
		key: "listener",
		value: function listener(message) {
			var callback = this.cbs.get(message.id);
			var methodCallback = this.methodCbs.get(message.id);

			if (methodCallback) {
				this.methodCbs.delete(message.id);
				if ("error" in message && "reject" in methodCallback) {
					methodCallback.reject(message.error);
				} else if ("resolve" in methodCallback) {
					methodCallback.resolve();
				}
			}

			if (callback) {
				this.cbs.delete(message.id);
				if ("error" in message) {
					callback.reject(message.error);
				} else {
					callback.resolve(message.result);
				}
			}
		}
	}, {
		key: "call",
		value: function call(params) {
			var _this2 = this;

			var request = {
				method: "call",
				params: params,
				id: this.cbId++
			};

			return new Promise(function (resolve, reject) {

				_this2.cbs.set(request.id, {
					time: new Date(),
					resolve: resolve,
					reject: reject
				});

				if (request.params[1] === "broadcast_transaction_with_callback" && request.params[2][0]) {
					_this2.methodCbs.set(request.id, request.params[2][0]);
					request.params[2][0] = request.params[2][0].resolve;
				}

				_this2.ws.onerror = function (error) {
					reject(error);
				};

				_this2.ws.send(JSON.stringify(request));
			});
		}
	}, {
		key: "getApiByName",
		value: function getApiByName(api) {
			return this.call([1, "get_api_by_name", [api]]);
		}
	}, {
		key: "login",
		value: function login(user, password) {
			var _this3 = this;

			return this.connectPromise.then(function () {
				return _this3.call([1, "login", [user, password]]);
			});
		}
	}, {
		key: "close",
		value: function close() {
			if (this.ws) {
				this.ws.onclose();
				this.ws.close();
				this.ws = null;
			}
		}
	}]);

	return WebSocketRpc;
}();

module.exports = WebSocketRpc;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steem-rpc/lib/WebSocketRpc.js","/../node_modules/steem-rpc/lib")
},{"./reconnecting-websocket":89,"buffer":11,"pBGvAp":74,"ws":8}],88:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var Client = require("./ApiInstance");

module.exports = {
	Client: Client
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steem-rpc/lib/index.js","/../node_modules/steem-rpc/lib")
},{"./ApiInstance":85,"buffer":11,"pBGvAp":74}],89:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

// MIT License:
//
// Copyright (c) 2010-2012, Joe Walnes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/**
 * This behaves like a WebSocket in every way, except if it fails to connect,
 * or it gets disconnected, it will repeatedly poll until it successfully connects
 * again.
 *
 * It is API compatible, so when you have:
 *   ws = new WebSocket('ws://....');
 * you can replace with:
 *   ws = new ReconnectingWebSocket('ws://....');
 *
 * The event stream will typically look like:
 *  onconnecting
 *  onopen
 *  onmessage
 *  onmessage
 *  onclose // lost connection
 *  onconnecting
 *  onopen  // sometime later...
 *  onmessage
 *  onmessage
 *  etc...
 *
 * It is API compatible with the standard WebSocket API, apart from the following members:
 *
 * - `bufferedAmount`
 * - `extensions`
 * - `binaryType`
 *
 * Latest version: https://github.com/joewalnes/reconnecting-websocket/
 * - Joe Walnes
 *
 * Syntax
 * ======
 * var socket = new ReconnectingWebSocket(url, protocols, options);
 *
 * Parameters
 * ==========
 * url - The url you are connecting to.
 * protocols - Optional string or array of protocols.
 * options - See below
 *
 * Options
 * =======
 * Options can either be passed upon instantiation or set after instantiation:
 *
 * var socket = new ReconnectingWebSocket(url, null, { debug: true, reconnectInterval: 4000 });
 *
 * or
 *
 * var socket = new ReconnectingWebSocket(url);
 * socket.debug = true;
 * socket.reconnectInterval = 4000;
 *
 * debug
 * - Whether this instance should log debug messages. Accepts true or false. Default: false.
 *
 * automaticOpen
 * - Whether or not the websocket should attempt to connect immediately upon instantiation. The socket can be manually opened or closed at any time using ws.open() and ws.close().
 *
 * reconnectInterval
 * - The number of milliseconds to delay before attempting to reconnect. Accepts integer. Default: 1000.
 *
 * maxReconnectInterval
 * - The maximum number of milliseconds to delay a reconnection attempt. Accepts integer. Default: 30000.
 *
 * reconnectDecay
 * - The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. Accepts integer or float. Default: 1.5.
 *
 * timeoutInterval
 * - The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. Accepts integer. Default: 2000.
 *
 */
(function (global, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory();
    } else {
        global.ReconnectingWebSocket = factory();
    }
})(undefined, function () {

    //if (!('WebSocket' in window)) {
    //    return;
    //}

    var WebSocket;

    function ReconnectingWebSocket(options) {

        // Default settings
        var settings = {

            /** Whether this instance should log debug messages. */
            debug: false,

            /** Whether or not the websocket should attempt to connect immediately upon instantiation. */
            automaticOpen: true,

            /** The number of milliseconds to delay before attempting to reconnect. */
            reconnectInterval: 2000,
            /** The maximum number of milliseconds to delay a reconnection attempt. */
            maxReconnectInterval: 300000,
            /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */
            reconnectDecay: 1.5,

            /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */
            timeoutInterval: 2000,

            /** The maximum number of reconnection attempts to make. Unlimited if null. */
            maxReconnectAttempts: 100,

            /** The binary type, possible values 'blob' or 'arraybuffer', default 'blob'. */
            binaryType: 'arraybuffer',

            /** Don't reconnect if idle (no user activity after idleTreshold), pass 0 to always reconnect **/
            idleTreshold: 0
        };
        if (!options) {
            options = {};
        }

        WebSocket = options.WebSocket;
        ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;
        ReconnectingWebSocket.OPEN = WebSocket.OPEN;
        ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;
        ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;
        if (!console.debug) console.debug = console.log;

        // Overwrite and define settings with options if they exist.
        for (var key in settings) {
            if (typeof options[key] !== 'undefined') {
                this[key] = options[key];
            } else {
                this[key] = settings[key];
            }
        }

        // These should be treated as read-only properties

        /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */
        this.url = options.url;

        /** The number of attempted reconnects since starting, or the last successful connection. Read only. */
        this.reconnectAttempts = 0;

        /**
         * The current state of the connection.
         * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED
         * Read only.
         */
        this.readyState = WebSocket.CONNECTING;

        /**
         * A string indicating the name of the sub-protocol the server selected; this will be one of
         * the strings specified in the protocols parameter when creating the WebSocket object.
         * Read only.
         */
        this.protocol = null;

        // Private state variables

        var self = this;
        var ws;
        var forcedClose = false;
        var timedOut = false;
        var handlers = {};
        var eventTarget = {
            addEventListener: function addEventListener(event, handler) {
                handlers[event] = handler;
            },
            removeEventListener: function removeEventListener(event) {
                delete handlers[event];
            },
            dispatchEvent: function dispatchEvent(event) {
                var handler = handlers[event.name];
                if (handler) handler(event);
            }
        }; //document.createElement('div');

        // Wire up "on*" properties as event handlers

        eventTarget.addEventListener('open', function (event) {
            self.onopen(event);
        });
        eventTarget.addEventListener('close', function (event) {
            self.onclose(event);
        });
        eventTarget.addEventListener('connecting', function (event) {
            self.onconnecting(event);
        });
        eventTarget.addEventListener('message', function (event) {
            self.onmessage(event);
        });
        eventTarget.addEventListener('error', function (event) {
            self.onerror(event);
        });

        // Expose the API required by EventTarget

        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);
        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);
        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);

        /**
         * This function generates an event that is compatible with standard
         * compliant browsers and IE9 - IE11
         *
         * This will prevent the error:
         * Object doesn't support this action
         *
         * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563
         * @param s String The name that the event should use
         * @param args Object an optional object that the event will use
         */
        function generateEvent(s, args) {
            //var evt = document.createEvent("CustomEvent");
            //evt.initCustomEvent(s, false, false, args);
            //return evt;
            return { name: s };
        };

        self.pendingReconnect = false;
        self.idleSince = new Date();

        if (this.idleTreshold) {
            if (typeof document !== 'undefined') {
                document.onkeypress = document.onmousemove = document.onclick = document.onscroll = document.touchstart = function () {
                    self.idleSince = new Date();
                    if (self.pendingReconnect) {
                        self.pendingReconnect = false;
                        self.reconnect();
                    }
                };
            }
        }

        this.reconnect = function () {
            var timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);
            timeout = timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout;
            if (self.debug) {
                console.debug('WebSocket: will try to reconnect in ' + parseInt(timeout / 1000) + ' sec, attempt #' + (self.reconnectAttempts + 1));
            }
            setTimeout(function () {
                self.reconnectAttempts++;
                self.open(true);
            }, timeout);
        };

        this.open = function (reconnectAttempt) {
            if (reconnectAttempt) {
                if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {
                    return;
                }
            } else {
                eventTarget.dispatchEvent(generateEvent('connecting'));
                this.reconnectAttempts = 0;
            }

            var surl = self.url;
            if (Array.isArray(self.url)) {
                surl = self.url[this.reconnectAttempts % self.url.length];
            }

            if (self.debug) {
                console.debug('connecting to', surl);
            }
            ws = new WebSocket(surl);
            ws.binaryType = this.binaryType;

            if (self.debug || ReconnectingWebSocket.debugAll) {
                console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);
            }

            var localWs = ws;
            var timeout = setTimeout(function () {
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);
                }
                timedOut = true;
                localWs.close();
                timedOut = false;
            }, self.timeoutInterval);

            ws.onopen = function (event) {
                clearTimeout(timeout);
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket**', 'onopen', self.url);
                }
                self.protocol = ws.protocol;
                self.readyState = WebSocket.OPEN;
                self.reconnectAttempts = 0;
                var e = generateEvent('open');
                e.isReconnect = reconnectAttempt;
                reconnectAttempt = false;
                eventTarget.dispatchEvent(e);
            };

            ws.onclose = function (event) {
                if (event.code !== 1000 && self.debug) console.log('WARNING! ws connection', surl, 'closed');
                clearTimeout(timeout);
                ws = null;
                if (forcedClose) {
                    self.readyState = WebSocket.CLOSED;
                    eventTarget.dispatchEvent(generateEvent('close'));
                } else {
                    self.readyState = WebSocket.CONNECTING;
                    var e = generateEvent('connecting');
                    e.code = event.code;
                    e.reason = event.reason;
                    e.wasClean = event.wasClean;
                    eventTarget.dispatchEvent(e);
                    if (!reconnectAttempt && !timedOut) {
                        if (self.debug || ReconnectingWebSocket.debugAll) {
                            console.debug('ReconnectingWebSocket', 'onclose', self.url);
                        }
                        eventTarget.dispatchEvent(generateEvent('close'));
                    }

                    if (!self.idleTreshold || new Date() - self.idleSince < self.idleTreshold) {
                        self.reconnect();
                    } else {
                        if (self.debug) {
                            console.debug('idle - will reconnect later');
                        }
                        self.pendingReconnect = true;
                    }
                }
            };
            ws.onmessage = function (event) {
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'onmessage', self.url);
                }
                var e = generateEvent('message');
                e.data = event.data;
                eventTarget.dispatchEvent(e);
            };
            ws.onerror = function (event) {
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'onerror', self.url, event);
                }
                eventTarget.dispatchEvent(generateEvent(event));
            };
        };

        // Whether or not to create a websocket upon instantiation
        if (this.automaticOpen == true) {
            this.open(false);
        }

        /**
         * Transmits data to the server over the WebSocket connection.
         *
         * @param data a text string, ArrayBuffer or Blob to send to the server.
         */
        this.send = function (data) {
            if (ws) {
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'send', self.url, data);
                }
                return ws.send(data);
            } else {
                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';
            }
        };

        /**
         * Closes the WebSocket connection or connection attempt, if any.
         * If the connection is already CLOSED, this method does nothing.
         */
        this.close = function (code, reason) {
            // Default CLOSE_NORMAL code
            if (typeof code == 'undefined') {
                code = 1000;
            }
            forcedClose = true;
            if (ws) {
                ws.close(code, reason);
            }
        };

        /**
         * Additional public API method to refresh the connection if still open (close, re-open).
         * For example, if the app suspects bad data / missed heart beats, it can try to refresh.
         */
        this.refresh = function () {
            if (ws) {
                ws.close();
            }
        };
    }

    /**
     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
     * this indicates that the connection is ready to send and receive data.
     */
    ReconnectingWebSocket.prototype.onopen = function (event) {};
    /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */
    ReconnectingWebSocket.prototype.onclose = function (event) {};
    /** An event listener to be called when a connection begins being attempted. */
    ReconnectingWebSocket.prototype.onconnecting = function (event) {};
    /** An event listener to be called when a message is received from the server. */
    ReconnectingWebSocket.prototype.onmessage = function (event) {};
    /** An event listener to be called when an error occurs. */
    ReconnectingWebSocket.prototype.onerror = function (event) {};

    /**
     * Whether all instances of ReconnectingWebSocket should log debug messages.
     * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.
     */
    ReconnectingWebSocket.debugAll = false;

    return ReconnectingWebSocket;
});
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steem-rpc/lib/reconnecting-websocket.js","/../node_modules/steem-rpc/lib")
},{"buffer":11,"pBGvAp":74}],90:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var TransactionBuilder = require("./src/TransactionBuilder");

module.exports = {
    TransactionBuilder: TransactionBuilder,

    ChainTypes: require("./src/ChainTypes"),
    ObjectId: require("./src/ObjectId"),
    NumberUtils: require("./src/NumberUtils"),
    TransactionHelper: require("./src/TransactionHelper"),
    ChainValidation: require("./src/ChainValidation"),
    Login: require("./src/AccountLogin")
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/chain/index.js","/../node_modules/steemjs-lib/dist/chain")
},{"./src/AccountLogin":91,"./src/ChainTypes":93,"./src/ChainValidation":94,"./src/NumberUtils":95,"./src/ObjectId":96,"./src/TransactionBuilder":97,"./src/TransactionHelper":98,"buffer":11,"pBGvAp":74}],91:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PrivateKey = require("../../ecc/src/PrivateKey");
var key = require("../../ecc/src/KeyUtils");

var KeyCache = function () {
    function KeyCache() {
        _classCallCheck(this, KeyCache);

        this._keyCachePriv = new Map();
        this._keyCachePub = new Map();
        this._myKeys = new Map();
    }

    _createClass(KeyCache, [{
        key: "setPrivKey",
        value: function setPrivKey(key, privKey) {
            this._keyCachePriv.set(key, privKey);
        }
    }, {
        key: "hasPrivKey",
        value: function hasPrivKey(key) {
            return this._keyCachePriv.has(key);
        }
    }, {
        key: "getPrivKey",
        value: function getPrivKey(key) {
            return this._keyCachePriv.get(key);
        }
    }, {
        key: "setPubKey",
        value: function setPubKey(key, pubKey) {
            this._keyCachePub.set(key, pubKey);
        }
    }, {
        key: "hasPubKey",
        value: function hasPubKey(key) {
            return this._keyCachePub.has(key);
        }
    }, {
        key: "getPubKey",
        value: function getPubKey(key) {
            return this._keyCachePub.get(key);;
        }
    }, {
        key: "setMyKey",
        value: function setMyKey(key, privKey) {
            this._myKeys.set(key, privKey);
        }
    }, {
        key: "getMyKey",
        value: function getMyKey(key) {
            return this._myKeys.get(key);
        }
    }]);

    return KeyCache;
}();

var AccountLogin = function () {
    function AccountLogin() {
        _classCallCheck(this, AccountLogin);

        this.reset();
        this.keyCache = new KeyCache();
    }

    _createClass(AccountLogin, [{
        key: "reset",
        value: function reset() {
            this.state = { loggedIn: false, roles: ["active", "owner", "posting", "memo"] };

            this.subs = {};
        }
    }, {
        key: "addSubscription",
        value: function addSubscription(cb) {
            this.subs[cb] = cb;
        }
    }, {
        key: "setRoles",
        value: function setRoles(roles) {
            this.state.roles = roles;
        }
    }, {
        key: "getRoles",
        value: function getRoles() {
            return this.state.roles;
        }
    }, {
        key: "generateKeys",
        value: function generateKeys(accountName, password, roles, prefix) {
            var _this = this;

            if (!accountName || !password) {
                throw new Error("Account name or password required");
            }
            if (password.length < 12) {
                throw new Error("Password must have at least 12 characters");
            }

            var privKeys = {};
            var pubKeys = {};

            (roles || this.state.roles).forEach(function (role) {
                var seed = accountName + role + password;
                var pkey = _this.keyCache.hasPrivKey(role) ? _this.keyCache.getPrivKey(role) : PrivateKey.fromSeed(key.normalize_brainKey(seed));
                _this.keyCache.setPrivKey(role, pkey);

                privKeys[role] = pkey;
                pubKeys[role] = _this.keyCache.getPubKey(role) ? _this.keyCache.getPubKey(role) : pkey.toPublicKey().toString(prefix);

                _this.keyCache.setPubKey(role, pubKeys[role]);
            });

            return { privKeys: privKeys, pubKeys: pubKeys };
        }
    }, {
        key: "fromPrivKey",
        value: function fromPrivKey(accountName, privateKey, roles, prefix) {
            var _this2 = this;

            if (!privateKey) {
                return null;
            }
            var privKeys = {};
            var pubKeys = {};

            (roles || this.state.roles).forEach(function (role) {

                var pkey = _this2.keyCache.hasPrivKey(role) ? _this2.keyCache.getPrivKey(role) : PrivateKey.fromWif(privateKey);
                _this2.keyCache.setPrivKey(role, pkey);

                privKeys[role] = pkey;
                pubKeys[role] = _this2.keyCache.getPubKey(role) ? _this2.keyCache.getPubKey(role) : pkey.toPublicKey().toString(prefix);

                _this2.keyCache.setPubKey(role, pubKeys[role]);
            });

            return { privKeys: privKeys, pubKeys: pubKeys };
        }
    }, {
        key: "getPubKeys",
        value: function getPubKeys() {
            var _this3 = this;

            return this.state.roles.map(function (role) {
                return _this3.keyCache.getPubKey(role);
            });
        }
    }, {
        key: "checkKeys",
        value: function checkKeys(_ref) {
            var _this4 = this;

            var accountName = _ref.accountName;
            var password = _ref.password;
            var auths = _ref.auths;
            var _ref$privateKey = _ref.privateKey;
            var privateKey = _ref$privateKey === undefined ? null : _ref$privateKey;

            if (!accountName || !password && !privateKey || !auths) {
                throw new Error("checkKeys: Missing inputs");
            }
            var hasKey = false;

            var _loop = function _loop(role) {
                var keys = void 0;
                if (password) {
                    keys = _this4.generateKeys(accountName, password, [role]);
                } else if (privateKey) {
                    keys = _this4.fromPrivKey(accountName, privateKey, [role]);
                }

                if (keys && Object.keys(keys).length) {
                    (function () {
                        var _keys = keys;
                        var privKeys = _keys.privKeys;
                        var pubKeys = _keys.pubKeys;

                        auths[role].forEach(function (key) {
                            if (key[0] === pubKeys[role]) {
                                hasKey = true;
                                _this4.keyCache.setMyKey(role, { priv: privKeys[role], pub: pubKeys[role] });
                            }
                        });
                    })();
                }
            };

            for (var role in auths) {
                _loop(role);
            };

            if (hasKey) {
                this.name = accountName;
            }

            this.state.loggedIn = hasKey;

            return hasKey;
        }
    }, {
        key: "signTransaction",
        value: function signTransaction(tr) {
            var _this5 = this;

            var signerPubkeys = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            var requiredPubkeys = arguments[2];


            var myKeys = {};
            var hasKey = false;

            this.state.roles.forEach(function (role) {
                var myKey = _this5.keyCache.getMyKey(role);
                if (myKey) {
                    if (signerPubkeys[myKey.pub]) {
                        hasKey = true;
                        return;
                    }
                    hasKey = true;
                    signerPubkeys[myKey.pub] = true;
                    if (requiredPubkeys && requiredPubkeys.indexOf(myKey.pub) !== -1) {
                        tr.add_signer(myKey.priv, myKey.pub);
                    } else if (!requiredPubkeys) {
                        tr.add_signer(myKey.priv, myKey.pub);
                    }
                }
            });

            if (!hasKey) {
                console.error("You do not have any private keys to sign this transaction");
                throw new Error("You do not have any private keys to sign this transaction");
            }
        }
    }]);

    return AccountLogin;
}();

module.exports = AccountLogin;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/chain/src/AccountLogin.js","/../node_modules/steemjs-lib/dist/chain/src")
},{"../../ecc/src/KeyUtils":101,"../../ecc/src/PrivateKey":102,"buffer":11,"pBGvAp":74}],92:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _this;

var ecc_config = {
    address_prefix: "STM"
};

module.exports = _this = {
    core_asset: "STEEM",
    vest_asset: "VESTS",
    dollar_asset: "SBD",
    address_prefix: "STM",
    expire_in_secs: 15,
    expire_in_secs_proposal: 24 * 60 * 60,
    networks: {
        Steem: {
            core_asset: "STEEM",
            address_prefix: "STM",
            chain_id: "0000000000000000000000000000000000000000000000000000000000000000"
        }
    },
    /** Set a few properties for known chain IDs. */
    setChainId: function setChainId(chain_id) {

        var i, len, network, network_name, ref;
        ref = Object.keys(_this.networks);

        for (i = 0, len = ref.length; i < len; i++) {

            network_name = ref[i];
            network = _this.networks[network_name];

            if (network.chain_id === chain_id) {

                _this.network_name = network_name;

                if (network.address_prefix) {
                    _this.address_prefix = network.address_prefix;
                    ecc_config.address_prefix = network.address_prefix;
                }

                // console.log("INFO    Configured for", network_name, ":", network.core_asset, "\n");

                return {
                    network_name: network_name,
                    network: network
                };
            }
        }

        if (!_this.network_name) {
            console.log("Unknown chain id (this may be a testnet)", chain_id);
        }
    },

    reset: function reset() {
        _this.core_asset = "STEEM";
        _this.address_prefix = "STM";
        ecc_config.address_prefix = "STM";
        _this.expire_in_secs = 15;
        _this.expire_in_secs_proposal = 24 * 60 * 60;

        console.log("Chain config reset");
    },

    setPrefix: function setPrefix() {
        var prefix = arguments.length <= 0 || arguments[0] === undefined ? "STM" : arguments[0];

        _this.address_prefix = prefix;
        ecc_config.address_prefix = prefix;
    }
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/chain/src/ChainConfig.js","/../node_modules/steemjs-lib/dist/chain/src")
},{"buffer":11,"pBGvAp":74}],93:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var ChainTypes = {};

ChainTypes.operations = {
    vote: 0,
    comment: 1,
    transfer: 2,
    transfer_to_vesting: 3,
    withdraw_vesting: 4,
    limit_order_create: 5,
    limit_order_cancel: 6,
    feed_publish: 7,
    convert: 8,
    account_create: 9,
    account_update: 10,
    witness_update: 11,
    account_witness_vote: 12,
    account_witness_proxy: 13,
    pow: 14,
    custom: 15,
    report_over_production: 16,
    delete_comment: 17,
    custom_json: 18,
    comment_options: 19,
    set_withdraw_vesting_route: 20,
    fill_convert_request: 21,
    author_reward: 22,
    curation_reward: 23,
    liquidity_reward: 24,
    interest: 25,
    fill_vesting_withdraw: 26,
    fill_order: 27,
    comment_payout: 28,
    escrow_transfer: 29,
    escrow_approve: 30,
    escrow_dispute: 31,
    escrow_release: 32
};

module.exports = ChainTypes;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/chain/src/ChainTypes.js","/../node_modules/steemjs-lib/dist/chain/src")
},{"buffer":11,"pBGvAp":74}],94:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

/**
    Account names may contain one or more names separated by a dot.
    Each name needs to start with a letter and may contain
    numbers, or well placed dashes.
    @see is_valid_name graphene/libraries/chain/protocol/account.cpp
*/
var id_regex = /\b\d+\.\d+\.(\d+)\b/;

var chainValidation = {
    is_account_name: function is_account_name(value) {
        var allow_too_short = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

        var i, label, len, length, ref;

        if (this.is_empty(value)) {
            return false;
        }

        length = value.length;

        if (!allow_too_short && length < 3 || length > 63) {
            return false;
        }

        ref = value.split('.');

        for (i = 0, len = ref.length; i < len; i++) {

            label = ref[i];

            if (!(/^[a-z][a-z0-9-]*$/.test(label) && !/--/.test(label) && /[a-z0-9]$/.test(label))) {
                return false;
            }
        }
        return true;
    },

    is_object_id: function is_object_id(obj_id) {
        if ('string' != typeof obj_id) return false;

        var match = id_regex.exec(obj_id);
        return match !== null && obj_id.split(".").length === 3;
    },

    is_empty: function is_empty(value) {
        return value == null || value.length === 0;
    },

    is_account_name_error: function is_account_name_error(value, allow_too_short) {
        var i, label, len, length, ref, suffix;
        if (allow_too_short == null) {
            allow_too_short = false;
        }
        suffix = "Account name should ";
        if (this.is_empty(value)) {
            return suffix + "not be empty.";
        }
        length = value.length;
        if (!allow_too_short && length < 3) {
            return suffix + "be longer.";
        }
        if (length > 63) {
            return suffix + "be shorter.";
        }
        if (/\./.test(value)) {
            suffix = "Each account segment should ";
        }
        ref = value.split('.');
        for (i = 0, len = ref.length; i < len; i++) {
            label = ref[i];
            if (!/^[~a-z]/.test(label)) {
                return suffix + "start with a letter.";
            }
            if (!/^[~a-z0-9-]*$/.test(label)) {
                return suffix + "have only letters, digits, or dashes.";
            }
            if (/--/.test(label)) {
                return suffix + "have only one dash in a row.";
            }
            if (!/[a-z0-9]$/.test(label)) {
                return suffix + "end with a letter or digit.";
            }
            if (!(label.length >= 3)) {
                return suffix + "be longer";
            }
        }
        return null;
    },

    is_cheap_name: function is_cheap_name(account_name) {
        return (/[0-9-]/.test(account_name) || !/[aeiouy]/.test(account_name)
        );
    },

    is_empty_user_input: function is_empty_user_input(value) {
        if (this.is_empty(value)) {
            return true;
        }
        if ((value + "").trim() === "") {
            return true;
        }
        return false;
    },

    required: function required(value) {
        var field_name = arguments.length <= 1 || arguments[1] === undefined ? "" : arguments[1];

        if (this.is_empty(value)) {
            throw new Error("value required for " + field_name + ": " + value);
        }
        return value;
    },

    /** @see is_valid_symbol graphene/libraries/chain/protocol/asset_ops.cpp */
    is_valid_symbol_error: function is_valid_symbol_error(value) {
        var suffix = "Asset name should ";
        if (this.is_empty(value)) {
            return suffix + "not be empty.";
        }
        if (value.split('.').length > 2) {
            return suffix + "have only one dot.";
        }
        if (value.length < 3) {
            return suffix + "be longer.";
        }
        if (value.length > 16) {
            return suffix + "be shorter.";
        }
        if (!/^[A-Z]/.test(value)) {
            return suffix + "start with a letter";
        }
        if (!/[A-Z]$/.test(value)) {
            return suffix + "end with a letter";
        }
        if (/^[A-Z0-9\.]$/.test(value)) {
            return suffix + "contain only letters numbers and perhaps a dot.";
        }
        return null;
    }
};

module.exports = chainValidation;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/chain/src/ChainValidation.js","/../node_modules/steemjs-lib/dist/chain/src")
},{"buffer":11,"pBGvAp":74}],95:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var assert = require("assert");

/**
    Convert 12.34 with a precision of 3 into 12340
    
    @arg {number|string} number - Use strings for large numbers.  This may contain one decimal but no sign
    @arg {number} precision - number of implied decimal places (usually causes right zero padding)
    @return {string} -
*/
module.exports = {
    toImpliedDecimal: function toImpliedDecimal(number, precision) {

        if (typeof number === "number") {
            assert(number <= 9007199254740991, "overflow");
            number = "" + number;
        } else if (number.toString) number = number.toString();

        assert(typeof number === "string", "number should be an actual number or string: " + (typeof number === "undefined" ? "undefined" : _typeof(number)));
        number = number.trim();
        assert(/^[0-9]*\.?[0-9]*$/.test(number), "Invalid decimal number " + number);

        var _number$split = number.split(".");

        var _number$split2 = _slicedToArray(_number$split, 2);

        var _number$split2$ = _number$split2[0];
        var whole = _number$split2$ === undefined ? "" : _number$split2$;
        var _number$split2$2 = _number$split2[1];
        var decimal = _number$split2$2 === undefined ? "" : _number$split2$2;


        var padding = precision - decimal.length;
        assert(padding >= 0, "Too many decimal digits in " + number + " to create an implied decimal of " + precision);

        for (var i = 0; i < padding; i++) {
            decimal += "0";
        }while (whole.charAt(0) === "0") {
            whole = whole.substring(1);
        }return whole + decimal;
    }
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/chain/src/NumberUtils.js","/../node_modules/steemjs-lib/dist/chain/src")
},{"assert":1,"buffer":11,"pBGvAp":74}],96:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('bytebuffer');

var Long = _require.Long;


var v = require('../../serializer/src/SerializerValidation');

var DB_MAX_INSTANCE_ID = Long.fromNumber(Math.pow(2, 48) - 1);

var ObjectId = function () {
    function ObjectId(space, type, instance) {
        _classCallCheck(this, ObjectId);

        this.space = space;
        this.type = type;
        this.instance = instance;
        var instance_string = this.instance.toString();
        var _ObjectId = this.space + '.' + this.type + '.' + instance_string;
        if (!v.is_digits(instance_string)) {
            throw new ('Invalid object id ' + _ObjectId)();
        }
    }

    _createClass(ObjectId, [{
        key: 'toLong',
        value: function toLong() {
            return Long.fromNumber(this.space).shiftLeft(56).or(Long.fromNumber(this.type).shiftLeft(48).or(this.instance));
        }
    }, {
        key: 'appendByteBuffer',
        value: function appendByteBuffer(b) {
            return b.writeUint64(this.toLong());
        }
    }, {
        key: 'toString',
        value: function toString() {
            return this.space + '.' + this.type + '.' + this.instance.toString();
        }
    }], [{
        key: 'fromString',
        value: function fromString(value) {
            if (value.space !== undefined && value.type !== undefined && value.instance !== undefined) {
                return value;
            }

            var params = v.require_match(/^([0-9]+)\.([0-9]+)\.([0-9]+)$/, v.required(value, "ObjectId"), "ObjectId");
            return new ObjectId(parseInt(params[1]), parseInt(params[2]), Long.fromString(params[3]));
        }
    }, {
        key: 'fromLong',
        value: function fromLong(long) {
            var space = long.shiftRight(56).toInt();
            var type = long.shiftRight(48).toInt() & 0x00ff;
            var instance = long.and(DB_MAX_INSTANCE_ID);
            return new ObjectId(space, type, instance);
        }
    }, {
        key: 'fromByteBuffer',
        value: function fromByteBuffer(b) {
            return ObjectId.fromLong(b.readUint64());
        }
    }]);

    return ObjectId;
}();

module.exports = ObjectId;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/chain/src/ObjectId.js","/../node_modules/steemjs-lib/dist/chain/src")
},{"../../serializer/src/SerializerValidation":114,"buffer":11,"bytebuffer":12,"pBGvAp":74}],97:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assert = require("assert");

var _require = require("../../ecc");

var Signature = _require.Signature;
var PublicKey = _require.PublicKey;
var hash = _require.hash;

var _require2 = require("../../serializer");

var ops = _require2.ops;

var ChainConfig = require("../../chain/src/ChainConfig");

var _require3 = require('steem-rpc');

var Client = _require3.Client;

var Api = Client.get();

var _require4 = require('bytebuffer');

var Long = _require4.Long;


var ChainTypes = require('./ChainTypes');

var head_block_time_string;

var TransactionBuilder = function () {
    function TransactionBuilder() {
        _classCallCheck(this, TransactionBuilder);

        this.ref_block_num = 0;
        this.ref_block_prefix = 0;
        this.expiration = 0;
        this.operations = [];
        this.signatures = [];
        this.signer_private_keys = [];

        // semi-private method bindings
        this._broadcast = _broadcast.bind(this);
    }

    /**
        @arg {string} name - like "transfer"
        @arg {object} operation - JSON matchching the operation's format
    */


    _createClass(TransactionBuilder, [{
        key: "add_type_operation",
        value: function add_type_operation(name, operation) {
            this.add_operation(this.get_type_operation(name, operation));
            return;
        }

        /**
            This does it all: set fees, finalize, sign, and broadcast (if wanted).
             @arg {ConfidentialWallet} cwallet - must be unlocked, used to gather signing keys
             @arg {array<string>} [signer_pubkeys = null] - Optional ["GPHAbc9Def0...", ...].  These are additional signing keys.  Some balance claims require propritary address formats, the witness node can't tell us which ones are needed so they must be passed in.  If the witness node can figure out a signing key (mostly all other transactions), it should not be passed in here.
             @arg {boolean} [broadcast = false]
        */

    }, {
        key: "process_transaction",
        value: function process_transaction(accountLogin) {
            var _this = this;

            var signer_pubkeys = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
            var broadcast = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];


            // let wallet_object = cwallet.wallet.wallet_object
            // if(Api.chain_id !== wallet_object.get("chain_id"))
            //     return Promise.reject("Mismatched chain_id; expecting " +
            //         wallet_object.get("chain_id") + ", but got " +
            //         Api.chain_id)

            var signer_pubkeys_added = {};
            // if(signer_pubkeys) {
            //
            //     // Balance claims are by address, only the private
            //     // key holder can know about these additional
            //     // potential keys.
            //     var pubkeys = accountLogin.getPubKeys()
            //     if( ! pubkeys.length)
            //         throw new Error("Missing signing key")
            //
            //     for(let pubkey_string of pubkeys) {
            //         var private_key = cwallet.getPrivateKey(pubkey_string)
            //         this.add_signer(private_key, pubkey_string)
            //         signer_pubkeys_added[pubkey_string] = true
            //     }
            // }

            // return this.get_potential_signatures().then( (pubkeys)=> {
            var my_pubkeys = accountLogin.getPubKeys();

            //{//Testing only, don't send All public keys!
            //    var pubkeys_all = PrivateKeyStore.getPubkeys() // All public keys
            //    this.get_required_signatures(pubkeys_all).then( required_pubkey_strings =>
            //        console.log('get_required_signatures all\t',required_pubkey_strings.sort(), pubkeys_all))
            //    this.get_required_signatures(my_pubkeys).then( required_pubkey_strings =>
            //        console.log('get_required_signatures normal\t',required_pubkey_strings.sort(), pubkeys))
            //}

            return this.get_required_signatures(my_pubkeys).then(function (required_pubkeys) {
                // console.log("required_pubkeys", required_pubkeys);
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = my_pubkeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var pubkey_string = _step.value;

                        // console.log("pubkey_string", pubkey_string);

                        if (signer_pubkeys_added[pubkey_string]) continue;

                        accountLogin.signTransaction(_this, signer_pubkeys_added, required_pubkeys);
                        // var private_key = cwallet.getPrivateKey(pubkey_string)
                        // if( ! private_key)
                        //     // This should not happen, get_required_signatures will only
                        //     // returned keys from my_pubkeys
                        //     throw new Error("Missing signing key for " + pubkey_string)
                        // this.add_signer(private_key, pubkey_string)
                    }

                    // console.log("signer_pubkeys_added", signer_pubkeys_added);
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }).then(function () {
                if (broadcast) {
                    return _this.broadcast();
                } else {
                    return _this.serialize();
                }
            });
        }

        /** Typically this is called automatically just prior to signing.  Once finalized this transaction can not be changed. */

    }, {
        key: "finalize",
        value: function finalize() {
            var _this2 = this;

            // console.log("Try to finalize", "expiration:", this.expiration);
            return new Promise(function (resolve, reject) {

                if (_this2.tr_buffer) {
                    throw new Error("already finalized");
                }

                resolve(Api.database_api().exec("get_dynamic_global_properties", []).then(function (r) {
                    head_block_time_string = r.time;
                    if (_this2.expiration === 0) _this2.expiration = base_expiration_sec() + ChainConfig.expire_in_secs;
                    // console.log("new expiration:", this.expiration);
                    _this2.ref_block_num = r.head_block_number & 0xFFFF;
                    _this2.ref_block_prefix = new Buffer(r.head_block_id, 'hex').readUInt32LE(4);
                    //DEBUG console.log("ref_block",@ref_block_num,@ref_block_prefix,r)

                    var iterable = _this2.operations;
                    for (var i = 0, op; i < iterable.length; i++) {
                        op = iterable[i];
                        if (op[1]["finalize"]) {
                            op[1].finalize();
                        }
                    }
                    _this2.tr_buffer = ops.transaction.toBuffer(_this2);
                }).catch(function (err) {
                    console.log("get_dynamic_global_properties err:", err);
                }));
            });
        }

        /** @return {string} hex transaction ID */

    }, {
        key: "id",
        value: function id() {
            if (!this.tr_buffer) {
                throw new Error("not finalized");
            }
            return hash.sha256(this.tr_buffer).toString('hex').substring(0, 40);
        }

        /**
            Typically one will use {@link this.add_type_operation} instead.
            @arg {array} operation - [operation_id, operation]
        */

    }, {
        key: "add_operation",
        value: function add_operation(operation) {
            if (this.tr_buffer) {
                throw new Error("already finalized");
            }
            assert(operation, "operation");
            if (!Array.isArray(operation)) {
                throw new Error("Expecting array [operation_id, operation]");
            }
            this.operations.push(operation);
            return;
        }
    }, {
        key: "get_type_operation",
        value: function get_type_operation(name, operation) {
            if (this.tr_buffer) {
                throw new Error("already finalized");
            }
            assert(name, "name");
            assert(operation, "operation");
            var _type = ops[name];
            assert(_type, "Unknown operation " + name);
            var operation_id = ChainTypes.operations[_type.operation_name];
            if (operation_id === undefined) {
                throw new Error("unknown operation: " + _type.operation_name);
            }
            if (!operation.fee) {
                operation.fee = { amount: 0, asset_id: 0 };
            }
            if (name === 'proposal_create') {
                operation.expiration_time || (operation.expiration_time = base_expiration_sec() + ChainConfig.expire_in_secs_proposal);
            }
            var operation_instance = _type.fromObject(operation);
            return [operation_id, operation_instance];
        }

        /** optional: there is a deafult expiration */

    }, {
        key: "set_expire_seconds",
        value: function set_expire_seconds(sec) {
            if (this.tr_buffer) {
                throw new Error("already finalized");
            }
            return this.expiration = base_expiration_sec() + sec;
        }

        /* Wraps this transaction in a proposal_create transaction */

    }, {
        key: "propose",
        value: function propose(proposal_create_options) {
            if (this.tr_buffer) {
                throw new Error("already finalized");
            }
            if (!this.operations.length) {
                throw new Error("add operation first");
            }

            assert(proposal_create_options, "proposal_create_options");
            assert(proposal_create_options.fee_paying_account, "proposal_create_options.fee_paying_account");

            var proposed_ops = this.operations.map(function (op) {
                return { op: op };
            });

            this.operations = [];
            this.signatures = [];
            this.signer_private_keys = [];
            proposal_create_options.proposed_ops = proposed_ops;
            this.add_type_operation("proposal_create", proposal_create_options);
            return this;
        }
    }, {
        key: "has_proposed_operation",
        value: function has_proposed_operation() {
            var hasProposed = false;
            for (var i = 0; i < this.operations.length; i++) {
                if ("proposed_ops" in this.operations[i][1]) {
                    hasProposed = true;
                    break;
                }
            }

            return hasProposed;
        }
    }, {
        key: "get_potential_signatures",
        value: function get_potential_signatures() {
            var tr_object = ops.signed_transaction.toObject(this);
            return Api.database_api().exec("get_potential_signatures", [tr_object]).then(function (pubkeys) {
                return { pubkeys: pubkeys };
            });
        }
    }, {
        key: "get_required_signatures",
        value: function get_required_signatures(available_keys) {

            if (!available_keys.length) {
                return Promise.resolve([]);
            }
            var tr_object = ops.signed_transaction.toObject(this);
            // console.log('... tr_object',tr_object)
            //DEBUG console.log('... tr_object',tr_object)
            return Api.database_api().exec("get_required_signatures", [tr_object, available_keys]).then(function (required_public_keys) {
                // DEBUG console.log('... get_required_signatures',required_public_keys)
                return required_public_keys;
            });
        }
    }, {
        key: "add_signer",
        value: function add_signer(private_key) {
            var public_key = arguments.length <= 1 || arguments[1] === undefined ? private_key.toPublicKey() : arguments[1];


            assert(private_key.d, "required PrivateKey object");

            if (this.signed) {
                throw new Error("already signed");
            }
            if (!public_key.Q) {
                public_key = PublicKey.fromPublicKeyString(public_key);
            }
            // prevent duplicates
            var spHex = private_key.toHex();
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = this.signer_private_keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var sp = _step2.value;

                    if (sp[0].toHex() === spHex) return;
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            this.signer_private_keys.push([private_key, public_key]);
        }
    }, {
        key: "sign",
        value: function sign() {
            var chain_id = arguments.length <= 0 || arguments[0] === undefined ? ChainConfig.networks.Steem.chain_id : arguments[0];

            if (!this.tr_buffer) {
                throw new Error("not finalized");
            }
            if (this.signed) {
                throw new Error("already signed");
            }
            var end = this.signer_private_keys.length;
            for (var i = 0; 0 < end ? i < end : i > end; 0 < end ? i++ : i++) {
                var _signer_private_keys$ = _slicedToArray(this.signer_private_keys[i], 2);

                var private_key = _signer_private_keys$[0];
                var public_key = _signer_private_keys$[1];

                var sig = Signature.signBuffer(Buffer.concat([new Buffer(chain_id, 'hex'), this.tr_buffer]), private_key, public_key);
                this.signatures.push(sig.toBuffer());
            }
            this.signer_private_keys = [];
            this.signed = true;
            return;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            return ops.signed_transaction.toObject(this);
        }
    }, {
        key: "toObject",
        value: function toObject() {
            return ops.signed_transaction.toObject(this);
        }
    }, {
        key: "broadcast",
        value: function broadcast(was_broadcast_callback) {
            var _this3 = this;

            if (this.tr_buffer) {
                return this._broadcast(was_broadcast_callback);
            } else {
                return this.finalize().then(function () {
                    return _this3._broadcast(was_broadcast_callback);
                });
            }
        }
    }]);

    return TransactionBuilder;
}();

var base_expiration_sec = function base_expiration_sec() {
    var head_block_sec = Math.ceil(getHeadBlockDate().getTime() / 1000);
    var now_sec = Math.ceil(Date.now() / 1000);
    // The head block time should be updated every 3 seconds.  If it isn't
    // then help the transaction to expire (use head_block_sec)
    if (now_sec - head_block_sec > 30) {
        return head_block_sec;
    }
    // If the user's clock is very far behind, use the head block time.
    return Math.max(now_sec, head_block_sec);
};

function _broadcast(was_broadcast_callback) {
    var _this4 = this;

    return new Promise(function (resolve, reject) {
        if (!_this4.signed) {
            _this4.sign();
        }
        if (!_this4.tr_buffer) {
            reject(new Error("not finalized"));
        }
        if (!_this4.signatures.length) {
            reject(new Error("not signed"));
        }
        if (!_this4.operations.length) {
            reject(new Error("no operations"));
        }

        if (!("network_broadcast_api" in Api)) {
            reject(new Error("Api does not include network_broadcast_api"));
        }
        var tr_object = ops.signed_transaction.toObject(_this4);

        return Api.network_broadcast_api().exec("broadcast_transaction_with_callback", [{ reject: reject, resolve: resolve }, tr_object]).then(function () {
            // console.log('... broadcast success, waiting for callback')
            if (was_broadcast_callback) was_broadcast_callback();
            return;
        }).catch(function (error) {
            // console.log may be redundant for network errors, other errors could occur
            // console.log(error);
            var message = error.message;
            if (!message) {
                message = "";
            }
            reject(new Error(message + "\n" + 'graphene-crypto ' + ' digest ' + hash.sha256(_this4.tr_buffer).toString('hex') + ' transaction ' + _this4.tr_buffer.toString('hex') + ' ' + JSON.stringify(tr_object)));
        });
    });
}

function getHeadBlockDate() {
    return timeStringToDate(head_block_time_string);
}

function timeStringToDate(time_string) {
    if (!time_string) return new Date("1970-01-01T00:00:00.000Z");
    if (!/Z$/.test(time_string)) //does not end in Z
        // https://github.com/cryptonomex/graphene/issues/368
        time_string = time_string + "Z";
    return new Date(time_string);
}

module.exports = TransactionBuilder;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/chain/src/TransactionBuilder.js","/../node_modules/steemjs-lib/dist/chain/src")
},{"../../chain/src/ChainConfig":92,"../../ecc":99,"../../serializer":112,"./ChainTypes":93,"assert":1,"buffer":11,"bytebuffer":12,"pBGvAp":74,"steem-rpc":88}],98:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var helper;
module.exports = helper = {};

var secureRandom = require('secure-random');

//Promise = require '../common/Promise'

var _require = require('bytebuffer');

var Long = _require.Long;

var _require2 = require("../../ecc");

var Signature = _require2.Signature;

var _require3 = require("../../serializer");

var ops = _require3.ops;


helper.unique_nonce_entropy = null;
helper.unique_nonce_uint64 = function () {
    var entropy = helper.unique_nonce_entropy = function () {

        if (helper.unique_nonce_entropy === null) {
            //console.log('... secureRandom.randomUint8Array(1)[0]',secureRandom.randomUint8Array(1)[0])
            return parseInt(secureRandom.randomUint8Array(1)[0]);
        } else {
            return ++helper.unique_nonce_entropy % 256;
        }
    }();
    var long = Long.fromNumber(Date.now());
    //console.log('unique_nonce_uint64 date\t',ByteBuffer.allocate(8).writeUint64(long).toHex(0))
    //console.log('unique_nonce_uint64 entropy\t',ByteBuffer.allocate(8).writeUint64(Long.fromNumber(entropy)).toHex(0))
    long = long.shiftLeft(8).or(Long.fromNumber(entropy));
    //console.log('unique_nonce_uint64 shift8\t',ByteBuffer.allocate(8).writeUint64(long).toHex(0))
    return long.toString();
};

/* Todo, set fees */
helper.to_json = function (tr) {
    var broadcast = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

    return function (tr, broadcast) {
        var tr_object = ops.signed_transaction.toObject(tr);
        if (broadcast) {
            var net = Apis.instance().network_api();
            console.log('... tr_object', JSON.stringify(tr_object));
            return net.exec("broadcast_transaction", [tr_object]);
        } else {
            return tr_object;
        }
    }(tr, broadcast);
};

helper.signed_tr_json = function (tr, private_keys) {
    var tr_buffer = ops.transaction.toBuffer(tr);
    tr = ops.transaction.toObject(tr);
    tr.signatures = function () {
        var result = [];
        for (var i = 0; 0 < private_keys.length ? i < private_keys.length : i > private_keys.length; 0 < private_keys.length ? i++ : i++) {
            var private_key = private_keys[i];
            result.push(Signature.signBuffer(tr_buffer, private_key).toHex());
        }
        return result;
    }();
    return tr;
};

helper.expire_in_min = function (min) {
    return Math.round(Date.now() / 1000) + min * 60;
};

helper.seconds_from_now = function (timeout_sec) {
    return Math.round(Date.now() / 1000) + timeout_sec;
};

/**
    Print to the console a JSON representation of any object in
    @graphene/serializer { types }
*/
helper.template = function (serializer_operation_type_name) {
    var debug = arguments.length <= 1 || arguments[1] === undefined ? { use_default: true, annotate: true } : arguments[1];

    var so = type[serializer_operation_type_name];
    if (!so) {
        throw new Error('unknown serializer_operation_type ' + serializer_operation_type_name);
    }
    return so.toObject(undefined, debug);
};

helper.new_operation = function (serializer_operation_type_name) {
    var so = type[serializer_operation_type_name];
    if (!so) {
        throw new Error('unknown serializer_operation_type ' + serializer_operation_type_name);
    }
    var object = so.toObject(undefined, { use_default: true, annotate: true });
    return so.fromObject(object);
};

helper.instance = function (ObjectId) {
    return ObjectId.substring("0.0.".length);
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/chain/src/TransactionHelper.js","/../node_modules/steemjs-lib/dist/chain/src")
},{"../../ecc":99,"../../serializer":112,"buffer":11,"bytebuffer":12,"pBGvAp":74,"secure-random":76}],99:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = {
    Address: require("./src/address"),
    Aes: require("./src/aes"),
    PrivateKey: require("./src/PrivateKey"),
    PublicKey: require("./src/PublicKey"),
    Signature: require("./src/signature"),
    brainKey: require("./src/BrainKey"),
    hash: require("./src/hash"),
    key: require("./src/KeyUtils")
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/ecc/index.js","/../node_modules/steemjs-lib/dist/ecc")
},{"./src/BrainKey":100,"./src/KeyUtils":101,"./src/PrivateKey":102,"./src/PublicKey":103,"./src/address":104,"./src/aes":105,"./src/hash":109,"./src/signature":110,"buffer":11,"pBGvAp":74}],100:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

module.exports = function normalize(brainKey) {
    if (typeof brainKey !== 'string') {
        throw new Error("string required for brainKey");
    }
    brainKey = brainKey.trim();
    return brainKey.split(/[\t\n\v\f\r ]+/).join(' ');
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/ecc/src/BrainKey.js","/../node_modules/steemjs-lib/dist/ecc/src")
},{"buffer":11,"pBGvAp":74}],101:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var key;
var PrivateKey = require('./PrivateKey');
var PublicKey = require('./PublicKey');
var Address = require('./address');
var Aes = require('./aes');

var hash = require('./hash');
// var dictionary = require('./dictionary_en');
var secureRandom = require('secure-random');
var ChainConfig = require("../../chain/src/ChainConfig");

// hash for .25 second
var HASH_POWER_MILLS = 250;

module.exports = key = {

    /** Uses 1 second of hashing power to create a key/password checksum.  An
    implementation can re-call this method with the same password to re-match
    the strength of the CPU (either after moving from a desktop to a mobile,
    mobile to desktop, or N years from now when CPUs are presumably stronger).
     A salt is used for all the normal reasons...
     @return object {
        aes_private: Aes,
        checksum: "{hash_iteration_count},{salt},{checksum}"
    }
    */

    aes_checksum: function aes_checksum(password) {
        if (!(typeof password === "string")) {
            throw new "password string required"();
        }
        var salt = secureRandom.randomBuffer(4).toString('hex');
        var iterations = 0;
        var secret = salt + password;
        // hash for .1 second
        var start_t = Date.now();
        while (Date.now() - start_t < HASH_POWER_MILLS) {
            secret = hash.sha256(secret);
            iterations += 1;
        }

        var checksum = hash.sha256(secret);
        var checksum_string = [iterations, salt.toString('hex'), checksum.slice(0, 4).toString('hex')].join(',');

        return { aes_private: Aes.fromSeed(secret),
            checksum: checksum_string
        };
    },


    /** Provide a matching password and key_checksum.  A "wrong password"
    error is thrown if the password does not match.  If this method takes
    much more or less than 1 second to return, one should consider updating
    all encyrpted fields using a new key.key_checksum.
    */
    aes_private: function aes_private(password, key_checksum) {
        var _key_checksum$split = key_checksum.split(',');

        var _key_checksum$split2 = _slicedToArray(_key_checksum$split, 3);

        var iterations = _key_checksum$split2[0];
        var salt = _key_checksum$split2[1];
        var checksum = _key_checksum$split2[2];

        var secret = salt + password;
        for (var i = 0; 0 < iterations ? i < iterations : i > iterations; 0 < iterations ? i++ : i++) {
            secret = hash.sha256(secret);
        }
        var new_checksum = hash.sha256(secret);
        if (!(new_checksum.slice(0, 4).toString('hex') === checksum)) {
            throw new Error("wrong password");
        }
        return Aes.fromSeed(secret);
    },


    /**
        A week random number generator can run out of entropy.  This should ensure even the worst random number implementation will be reasonably safe.
         @param1 string entropy of at least 32 bytes
    */
    random32ByteBuffer: function random32ByteBuffer() {
        var entropy = arguments.length <= 0 || arguments[0] === undefined ? this.browserEntropy() : arguments[0];


        if (!(typeof entropy === 'string')) {
            throw new Error("string required for entropy");
        }

        if (entropy.length < 32) {
            throw new Error("expecting at least 32 bytes of entropy");
        }

        var start_t = Date.now();

        while (Date.now() - start_t < HASH_POWER_MILLS) {
            entropy = hash.sha256(entropy);
        }var hash_array = [];
        hash_array.push(entropy);

        // Hashing for 1 second may helps the computer is not low on entropy (this method may be called back-to-back).
        hash_array.push(secureRandom.randomBuffer(32));

        return hash.sha256(Buffer.concat(hash_array));
    },


    suggest_brain_key: function suggest_brain_key() {
        var dictionary = arguments.length <= 0 || arguments[0] === undefined ? "," : arguments[0];
        var entropy = arguments.length <= 1 || arguments[1] === undefined ? this.browserEntropy() : arguments[1];


        var randomBuffer = this.random32ByteBuffer(entropy);

        var word_count = 16;
        var dictionary_lines = dictionary.split(',');

        if (!(dictionary_lines.length === 49744)) {
            throw new Error('expecting ' + 49744 + ' but got ' + dictionary_lines.length + ' dictionary words');
        }

        var brainkey = [];
        var end = word_count * 2;

        for (var i = 0; i < end; i += 2) {

            // randomBuffer has 256 bits / 16 bits per word == 16 words
            var num = (randomBuffer[i] << 8) + randomBuffer[i + 1];

            // convert into a number between 0 and 1 (inclusive)
            var rndMultiplier = num / Math.pow(2, 16);
            var wordIndex = Math.round(dictionary_lines.length * rndMultiplier);

            brainkey.push(dictionary_lines[wordIndex]);
        }
        return this.normalize_brainKey(brainkey.join(' '));
    },

    get_random_key: function get_random_key(entropy) {
        return PrivateKey.fromBuffer(this.random32ByteBuffer(entropy));
    },
    get_brainPrivateKey: function get_brainPrivateKey(brainKey) {
        var sequence = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        if (sequence < 0) {
            throw new Error("invalid sequence");
        }
        brainKey = key.normalize_brainKey(brainKey);
        return PrivateKey.fromBuffer(hash.sha256(hash.sha512(brainKey + " " + sequence)));
    },


    // Turn invisible space like characters into a single space
    normalize_brainKey: function normalize_brainKey(brainKey) {
        if (!(typeof brainKey === 'string')) {
            throw new Error("string required for brainKey");
        }

        brainKey = brainKey.trim();
        return brainKey.split(/[\t\n\v\f\r ]+/).join(' ');
    },
    browserEntropy: function browserEntropy() {

        var entropyStr = "";
        try {
            entropyStr = new Date().toString() + " " + window.screen.height + " " + window.screen.width + " " + window.screen.colorDepth + " " + " " + window.screen.availHeight + " " + window.screen.availWidth + " " + window.screen.pixelDepth + navigator.language + " " + window.location + " " + window.history.length;

            for (var i = 0, mimeType; i < navigator.mimeTypes.length; i++) {
                mimeType = navigator.mimeTypes[i];
                entropyStr += mimeType.description + " " + mimeType.type + " " + mimeType.suffixes + " ";
            }
            console.log("INFO\tbrowserEntropy gathered");
        } catch (error) {
            //nodejs:ReferenceError: window is not defined
            entropyStr = hash.sha256(new Date().toString());
        }

        var b = new Buffer(entropyStr);
        entropyStr += b.toString('binary') + " " + new Date().toString();
        return entropyStr;
    },


    // @return array of 5 legacy addresses for a pubkey string parameter.
    addresses: function addresses(pubkey) {
        var address_prefix = arguments.length <= 1 || arguments[1] === undefined ? ChainConfig.address_prefix : arguments[1];

        var public_key = PublicKey.fromPublicKeyString(pubkey, address_prefix);
        // S L O W
        var address_string = [Address.fromPublic(public_key, false, 0).toString(address_prefix), // btc_uncompressed
        Address.fromPublic(public_key, true, 0).toString(address_prefix), // btc_compressed
        Address.fromPublic(public_key, false, 56).toString(address_prefix), // pts_uncompressed
        Address.fromPublic(public_key, true, 56).toString(address_prefix), // pts_compressed
        public_key.toAddressString(address_prefix) // bts_short, most recent format
        ];
        return address_string;
    }
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/ecc/src/KeyUtils.js","/../node_modules/steemjs-lib/dist/ecc/src")
},{"../../chain/src/ChainConfig":92,"./PrivateKey":102,"./PublicKey":103,"./address":104,"./aes":105,"./hash":109,"buffer":11,"pBGvAp":74,"secure-random":76}],102:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ecurve = require('ecurve');

var _require = require('ecurve');

var Point = _require.Point;
var getCurveByName = _require.getCurveByName;

var secp256k1 = getCurveByName('secp256k1');
var BigInteger = require('bigi');

var _require2 = require('bs58');

var encode = _require2.encode;
var decode = _require2.decode;

var assert = require('assert');
var hash = require('./hash');
var PublicKey = require('./PublicKey');
var deepEqual = require("deep-equal");

var G = secp256k1.G;
var n = secp256k1.n;

var PrivateKey = function () {

    /**
        @private see static functions
        @param {BigInteger}
    */

    function PrivateKey(d) {
        _classCallCheck(this, PrivateKey);

        this.d = d;
    }

    _createClass(PrivateKey, [{
        key: 'toWif',
        value: function toWif() {
            var private_key = this.toBuffer();
            // checksum includes the version
            private_key = Buffer.concat([new Buffer([0x80]), private_key]);
            var checksum = hash.sha256(private_key);
            checksum = hash.sha256(checksum);
            checksum = checksum.slice(0, 4);
            var private_wif = Buffer.concat([private_key, checksum]);
            return encode(private_wif);
        }

        /**
            @return {Point}
        */

    }, {
        key: 'toPublicKeyPoint',
        value: function toPublicKeyPoint() {
            var Q;
            return Q = secp256k1.G.multiply(this.d);
        }
    }, {
        key: 'toPublicKey',
        value: function toPublicKey() {
            if (this.public_key) {
                return this.public_key;
            }
            return this.public_key = PublicKey.fromPoint(this.toPublicKeyPoint());
        }
    }, {
        key: 'toBuffer',
        value: function toBuffer() {
            return this.d.toBuffer(32);
        }

        /** ECIES */

    }, {
        key: 'get_shared_secret',
        value: function get_shared_secret(public_key) {
            var legacy = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

            public_key = toPublic(public_key);
            var KB = public_key.toUncompressed().toBuffer();
            var KBP = Point.fromAffine(secp256k1, BigInteger.fromBuffer(KB.slice(1, 33)), // x
            BigInteger.fromBuffer(KB.slice(33, 65)) // y
            );
            var r = this.toBuffer();
            var P = KBP.multiply(BigInteger.fromBuffer(r));
            var S = P.affineX.toBuffer({ size: 32 });
            /*
            the input to sha512 must be exactly 32-bytes, to match the c++ implementation
            of get_shared_secret.  Right now S will be shorter if the most significant
            byte(s) is zero.  Pad it back to the full 32-bytes
            */
            if (!legacy && S.length < 32) {
                pad = new Buffer(32 - S.length).fill(0);
                S = Buffer.concat([pad, S]);
            }

            // SHA512 used in ECIES
            return hash.sha512(S);
        }

        // /** ECIES (does not always match the Point.fromAffine version above) */
        // get_shared_secret(public_key){
        //     public_key = toPublic(public_key)
        //     var P = public_key.Q.multiply( this.d );
        //     var S = P.affineX.toBuffer({size: 32});
        //     // ECIES, adds an extra sha512
        //     return hash.sha512(S);
        // }

        /** @throws {Error} - overflow of the key could not be derived */

    }, {
        key: 'child',
        value: function child(offset) {
            offset = Buffer.concat([this.toPublicKey().toBuffer(), offset]);
            offset = hash.sha256(offset);
            var c = BigInteger.fromBuffer(offset);

            if (c.compareTo(n) >= 0) throw new Error("Child offset went out of bounds, try again");

            var derived = this.d.add(c); //.mod(n)

            if (derived.signum() === 0) throw new Error("Child offset derived to an invalid key, try again");

            return new PrivateKey(derived);
        }

        /* <helper_functions> */

    }, {
        key: 'toByteBuffer',
        value: function toByteBuffer() {
            var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            this.appendByteBuffer(b);
            return b.copy(0, b.offset);
        }
    }, {
        key: 'toHex',
        value: function toHex() {
            return this.toBuffer().toString('hex');
        }

        /* </helper_functions> */

    }], [{
        key: 'fromBuffer',
        value: function fromBuffer(buf) {
            if (!Buffer.isBuffer(buf)) {
                throw new Error("Expecting paramter to be a Buffer type");
            }
            if (32 !== buf.length) {
                console.log('WARN: Expecting 32 bytes, instead got ' + buf.length + ', stack trace:', new Error().stack);
            }
            if (buf.length === 0) {
                throw new Error("Empty buffer");
            }
            return new PrivateKey(BigInteger.fromBuffer(buf));
        }

        /** @arg {string} seed - any length string.  This is private, the same seed produces the same private key every time.  */

    }, {
        key: 'fromSeed',
        value: function fromSeed(seed) {
            // generate_private_key
            if (!(typeof seed === 'string')) {
                throw new Error('seed must be of type string');
            }
            return PrivateKey.fromBuffer(hash.sha256(seed));
        }

        /** @return {string} Wallet Import Format (still a secret, Not encrypted) */

    }, {
        key: 'fromWif',
        value: function fromWif(_private_wif) {
            var private_wif = new Buffer(decode(_private_wif));
            var version = private_wif.readUInt8(0);
            assert.equal(0x80, version, 'Expected version ' + 0x80 + ', instead got ' + version);
            // checksum includes the version
            var private_key = private_wif.slice(0, -4);
            var checksum = private_wif.slice(-4);
            var new_checksum = hash.sha256(private_key);
            new_checksum = hash.sha256(new_checksum);
            new_checksum = new_checksum.slice(0, 4);
            var isEqual = deepEqual(checksum, new_checksum); //, 'Invalid checksum'
            if (!isEqual) {
                throw new Error("Checksum did not match");
            }
            private_key = private_key.slice(1);
            return PrivateKey.fromBuffer(private_key);
        }
    }, {
        key: 'fromHex',
        value: function fromHex(hex) {
            return PrivateKey.fromBuffer(new Buffer(hex, 'hex'));
        }
    }]);

    return PrivateKey;
}();

module.exports = PrivateKey;

var toPublic = function toPublic(data) {
    return data == null ? data : data.Q ? data : PublicKey.fromStringOrThrow(data);
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/ecc/src/PrivateKey.js","/../node_modules/steemjs-lib/dist/ecc/src")
},{"./PublicKey":103,"./hash":109,"assert":1,"bigi":6,"bs58":10,"buffer":11,"deep-equal":121,"ecurve":32,"pBGvAp":74}],103:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BigInteger = require('bigi');

var _require = require('ecurve');

var Point = _require.Point;
var getCurveByName = _require.getCurveByName;

var secp256k1 = getCurveByName('secp256k1');

var _require2 = require('bs58');

var encode = _require2.encode;
var decode = _require2.decode;

var hash = require('./hash');
var ChainConfig = require("../../chain/src/ChainConfig");
var assert = require('assert');
var deepEqual = require("deep-equal");

var G = secp256k1.G;
var n = secp256k1.n;

var PublicKey = function () {

    /** @param {Point} public key */

    function PublicKey(Q) {
        _classCallCheck(this, PublicKey);

        this.Q = Q;
    }

    _createClass(PublicKey, [{
        key: 'toBuffer',
        value: function toBuffer() {
            var compressed = arguments.length <= 0 || arguments[0] === undefined ? this.Q ? this.Q.compressed : null : arguments[0];

            if (this.Q === null) return new Buffer('000000000000000000000000000000000000000000000000000000000000000000', 'hex');
            return this.Q.getEncoded(compressed);
        }
    }, {
        key: 'toUncompressed',
        value: function toUncompressed() {
            var buf = this.Q.getEncoded(false);
            var point = Point.decodeFrom(secp256k1, buf);
            return PublicKey.fromPoint(point);
        }

        /** bts::blockchain::address (unique but not a full public key) */

    }, {
        key: 'toBlockchainAddress',
        value: function toBlockchainAddress() {
            var pub_buf = this.toBuffer();
            var pub_sha = hash.sha512(pub_buf);
            return hash.ripemd160(pub_sha);
        }

        /** Alias for {@link toPublicKeyString} */

    }, {
        key: 'toString',
        value: function toString() {
            var address_prefix = arguments.length <= 0 || arguments[0] === undefined ? ChainConfig.address_prefix : arguments[0];

            return this.toPublicKeyString(address_prefix);
        }

        /**
            Full public key
            {return} string
        */

    }, {
        key: 'toPublicKeyString',
        value: function toPublicKeyString() {
            var address_prefix = arguments.length <= 0 || arguments[0] === undefined ? ChainConfig.address_prefix : arguments[0];

            var pub_buf = this.toBuffer();
            var checksum = hash.ripemd160(pub_buf);
            var addy = Buffer.concat([pub_buf, checksum.slice(0, 4)]);
            return address_prefix + encode(addy);
        }

        /**
            @arg {string} public_key - like GPHXyz...
            @arg {string} address_prefix - like GPH
            @return PublicKey or `null` (if the public_key string is invalid)
        */

    }, {
        key: 'toAddressString',
        value: function toAddressString() {
            var address_prefix = arguments.length <= 0 || arguments[0] === undefined ? ChainConfig.address_prefix : arguments[0];

            var pub_buf = this.toBuffer();
            var pub_sha = hash.sha512(pub_buf);
            var addy = hash.ripemd160(pub_sha);
            var checksum = hash.ripemd160(addy);
            addy = Buffer.concat([addy, checksum.slice(0, 4)]);
            return address_prefix + encode(addy);
        }
    }, {
        key: 'toPtsAddy',
        value: function toPtsAddy() {
            var pub_buf = this.toBuffer();
            var pub_sha = hash.sha256(pub_buf);
            var addy = hash.ripemd160(pub_sha);
            addy = Buffer.concat([new Buffer([0x38]), addy]); //version 56(decimal)

            var checksum = hash.sha256(addy);
            checksum = hash.sha256(checksum);

            addy = Buffer.concat([addy, checksum.slice(0, 4)]);
            return encode(addy);
        }
    }, {
        key: 'child',
        value: function child(offset) {

            assert(Buffer.isBuffer(offset), "Buffer required: offset");
            assert.equal(offset.length, 32, "offset length");

            offset = Buffer.concat([this.toBuffer(), offset]);
            offset = hash.sha256(offset);

            var c = BigInteger.fromBuffer(offset);

            if (c.compareTo(n) >= 0) throw new Error("Child offset went out of bounds, try again");

            var cG = G.multiply(c);
            var Qprime = this.Q.add(cG);

            if (secp256k1.isInfinity(Qprime)) throw new Error("Child offset derived to an invalid key, try again");

            return PublicKey.fromPoint(Qprime);
        }

        /* <HEX> */

    }, {
        key: 'toByteBuffer',
        value: function toByteBuffer() {
            var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            this.appendByteBuffer(b);
            return b.copy(0, b.offset);
        }
    }, {
        key: 'toHex',
        value: function toHex() {
            return this.toBuffer().toString('hex');
        }
    }], [{
        key: 'fromBinary',
        value: function fromBinary(bin) {
            return PublicKey.fromBuffer(new Buffer(bin, 'binary'));
        }
    }, {
        key: 'fromBuffer',
        value: function fromBuffer(buffer) {
            if (buffer.toString('hex') === '000000000000000000000000000000000000000000000000000000000000000000') return new PublicKey(null);
            return new PublicKey(Point.decodeFrom(secp256k1, buffer));
        }
    }, {
        key: 'fromPoint',
        value: function fromPoint(point) {
            return new PublicKey(point);
        }
    }, {
        key: 'fromPublicKeyString',
        value: function fromPublicKeyString(public_key) {
            var address_prefix = arguments.length <= 1 || arguments[1] === undefined ? ChainConfig.address_prefix : arguments[1];

            try {
                return PublicKey.fromStringOrThrow(public_key, address_prefix);
            } catch (e) {
                return null;
            }
        }

        /**
            @arg {string} public_key - like GPHXyz...
            @arg {string} address_prefix - like GPH
            @throws {Error} if public key is invalid
            @return PublicKey
        */

    }, {
        key: 'fromStringOrThrow',
        value: function fromStringOrThrow(public_key) {
            var address_prefix = arguments.length <= 1 || arguments[1] === undefined ? ChainConfig.address_prefix : arguments[1];

            var prefix = public_key.slice(0, address_prefix.length);
            assert.equal(address_prefix, prefix, 'Expecting key to begin with ' + address_prefix + ', instead got ' + prefix);
            public_key = public_key.slice(address_prefix.length);

            public_key = new Buffer(decode(public_key), 'binary');
            var checksum = public_key.slice(-4);
            public_key = public_key.slice(0, -4);
            var new_checksum = hash.ripemd160(public_key);
            new_checksum = new_checksum.slice(0, 4);
            var isEqual = deepEqual(checksum, new_checksum); //, 'Invalid checksum'
            if (!isEqual) {
                throw new Error("Checksum did not match");
            }
            return PublicKey.fromBuffer(public_key);
        }
    }, {
        key: 'fromHex',
        value: function fromHex(hex) {
            return PublicKey.fromBuffer(new Buffer(hex, 'hex'));
        }
    }, {
        key: 'fromPublicKeyStringHex',
        value: function fromPublicKeyStringHex(hex) {
            return PublicKey.fromPublicKeyString(new Buffer(hex, 'hex'));
        }

        /* </HEX> */

    }]);

    return PublicKey;
}();

module.exports = PublicKey;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/ecc/src/PublicKey.js","/../node_modules/steemjs-lib/dist/ecc/src")
},{"../../chain/src/ChainConfig":92,"./hash":109,"assert":1,"bigi":6,"bs58":10,"buffer":11,"deep-equal":121,"ecurve":32,"pBGvAp":74}],104:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assert = require('assert');
var ChainConfig = require("../../chain/src/ChainConfig");
var hash = require('./hash');

var _require = require('bs58');

var encode = _require.encode;
var decode = _require.decode;

var deepEqual = require("deep-equal");

/** Addresses are shortened non-reversable hashes of a public key.  The full PublicKey is preferred.
    @deprecated
*/

var Address = function () {
    function Address(addy) {
        _classCallCheck(this, Address);

        this.addy = addy;
    }

    _createClass(Address, [{
        key: 'toBuffer',
        value: function toBuffer() {
            return this.addy;
        }
    }, {
        key: 'toString',
        value: function toString() {
            var address_prefix = arguments.length <= 0 || arguments[0] === undefined ? ChainConfig.address_prefix : arguments[0];

            var checksum = hash.ripemd160(this.addy);
            var addy = Buffer.concat([this.addy, checksum.slice(0, 4)]);
            return address_prefix + encode(addy);
        }
    }], [{
        key: 'fromBuffer',
        value: function fromBuffer(buffer) {
            var _hash = hash.sha512(buffer);
            var addy = hash.ripemd160(_hash);
            return new Address(addy);
        }
    }, {
        key: 'fromString',
        value: function fromString(string) {
            var address_prefix = arguments.length <= 1 || arguments[1] === undefined ? ChainConfig.address_prefix : arguments[1];

            var prefix = string.slice(0, address_prefix.length);
            assert.equal(address_prefix, prefix, 'Expecting key to begin with ' + address_prefix + ', instead got ' + prefix);
            var addy = string.slice(address_prefix.length);
            addy = new Buffer(decode(addy), 'binary');
            var checksum = addy.slice(-4);
            addy = addy.slice(0, -4);
            var new_checksum = hash.ripemd160(addy);
            new_checksum = new_checksum.slice(0, 4);
            var isEqual = deepEqual(checksum, new_checksum); //, 'Invalid checksum'
            if (!isEqual) {
                throw new Error("Checksum did not match");
            }
            return new Address(addy);
        }
    }, {
        key: 'fromPublic',


        /** @return Address - Compressed PTS format (by default) */
        value: function fromPublic(public_key) {
            var compressed = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
            var version = arguments.length <= 2 || arguments[2] === undefined ? 56 : arguments[2];

            var sha2 = hash.sha256(public_key.toBuffer(compressed));
            var rep = hash.ripemd160(sha2);
            var versionBuffer = new Buffer(1);
            versionBuffer.writeUInt8(0xFF & version, 0);
            var addr = Buffer.concat([versionBuffer, rep]);
            var check = hash.sha256(addr);
            check = hash.sha256(check);
            var buffer = Buffer.concat([addr, check.slice(0, 4)]);
            return new Address(hash.ripemd160(buffer));
        }
    }]);

    return Address;
}();

module.exports = Address;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/ecc/src/address.js","/../node_modules/steemjs-lib/dist/ecc/src")
},{"../../chain/src/ChainConfig":92,"./hash":109,"assert":1,"bs58":10,"buffer":11,"deep-equal":121,"pBGvAp":74}],105:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// https://code.google.com/p/crypto-js
var AES = require("crypto-js/aes");
var encHex = require("crypto-js/enc-hex");
var encBase64 = require("crypto-js/enc-base64");
var assert = require("assert");

var _require = require("bytebuffer");

var Long = _require.Long;

var hash = require('./hash');

/** Provides symetric encrypt and decrypt via AES. */

var Aes = function () {

    /** @private */

    function Aes(iv, key) {
        _classCallCheck(this, Aes);

        this.iv = iv, this.key = key;
    }

    /** This is an excellent way to ensure that all references to Aes can not operate anymore (example: a wallet becomes locked).  An application should ensure there is only one Aes object instance for a given secret `seed`. */


    _createClass(Aes, [{
        key: "clear",
        value: function clear() {
            return this.iv = this.key = undefined;
        }

        /** @arg {string} seed - secret seed may be used to encrypt or decrypt. */

    }, {
        key: "_decrypt_word_array",


        /** @private */
        value: function _decrypt_word_array(cipher) {
            // https://code.google.com/p/crypto-js/#Custom_Key_and_IV
            // see wallet_records.cpp master_key::decrypt_key
            return AES.decrypt({ ciphertext: cipher, salt: null }, this.key, { iv: this.iv });
        }

        /** @private */

    }, {
        key: "_encrypt_word_array",
        value: function _encrypt_word_array(plaintext) {
            //https://code.google.com/p/crypto-js/issues/detail?id=85
            var cipher = AES.encrypt(plaintext, this.key, { iv: this.iv });
            return encBase64.parse(cipher.toString());
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} ciphertext
            @return {Buffer} binary
        */

    }, {
        key: "decrypt",
        value: function decrypt(ciphertext) {
            if (typeof ciphertext === "string") {
                ciphertext = new Buffer(ciphertext, 'binary');
            }
            if (!Buffer.isBuffer(ciphertext)) {
                throw new Error("buffer required");
            }
            assert(ciphertext, "Missing cipher text");
            // hex is the only common format
            var hex = this.decryptHex(ciphertext.toString('hex'));
            return new Buffer(hex, 'hex');
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} plaintext
            @return {Buffer} binary
        */

    }, {
        key: "encrypt",
        value: function encrypt(plaintext) {
            if (typeof plaintext === "string") {
                plaintext = new Buffer(plaintext, 'binary');
            }
            if (!Buffer.isBuffer(plaintext)) {
                throw new Error("buffer required");
            }
            //assert plaintext, "Missing plain text"
            // hex is the only common format
            var hex = this.encryptHex(plaintext.toString('hex'));
            return new Buffer(hex, 'hex');
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string|Buffer} plaintext
            @return {string} hex
        */

    }, {
        key: "encryptToHex",
        value: function encryptToHex(plaintext) {
            if (typeof plaintext === "string") {
                plaintext = new Buffer(plaintext, 'binary');
            }
            if (!Buffer.isBuffer(plaintext)) {
                throw new Error("buffer required");
            }
            //assert plaintext, "Missing plain text"
            // hex is the only common format
            return this.encryptHex(plaintext.toString('hex'));
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} cipher - hex
            @return {string} binary (could easily be readable text)
        */

    }, {
        key: "decryptHex",
        value: function decryptHex(cipher) {
            assert(cipher, "Missing cipher text");
            // Convert data into word arrays (used by Crypto)
            var cipher_array = encHex.parse(cipher);
            var plainwords = this._decrypt_word_array(cipher_array);
            return encHex.stringify(plainwords);
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} cipher - hex
            @return {Buffer} encoded as specified by the parameter
        */

    }, {
        key: "decryptHexToBuffer",
        value: function decryptHexToBuffer(cipher) {
            assert(cipher, "Missing cipher text");
            // Convert data into word arrays (used by Crypto)
            var cipher_array = encHex.parse(cipher);
            var plainwords = this._decrypt_word_array(cipher_array);
            var plainhex = encHex.stringify(plainwords);
            return new Buffer(plainhex, 'hex');
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} cipher - hex
            @arg {string} [encoding = 'binary'] - a valid Buffer encoding
            @return {String} encoded as specified by the parameter
        */

    }, {
        key: "decryptHexToText",
        value: function decryptHexToText(cipher) {
            var encoding = arguments.length <= 1 || arguments[1] === undefined ? 'binary' : arguments[1];

            return this.decryptHexToBuffer(cipher).toString(encoding);
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} plainhex - hex format
            @return {String} hex
        */

    }, {
        key: "encryptHex",
        value: function encryptHex(plainhex) {
            var plain_array = encHex.parse(plainhex);
            var cipher_array = this._encrypt_word_array(plain_array);
            return encHex.stringify(cipher_array);
        }
    }], [{
        key: "fromSeed",
        value: function fromSeed(seed) {
            if (seed === undefined) {
                throw new Error("seed is required");
            }
            var _hash = hash.sha512(seed);
            _hash = _hash.toString('hex');
            // DEBUG console.log('... fromSeed _hash',_hash)
            return Aes.fromSha512(_hash);
        }
    }, {
        key: "fromSha512",


        /** @arg {string} hash - A 128 byte hex string, typically one would call {@link fromSeed} instead. */
        value: function fromSha512(hash) {
            assert.equal(hash.length, 128, "A Sha512 in HEX should be 128 characters long, instead got " + hash.length);
            var iv = encHex.parse(hash.substring(64, 96));
            var key = encHex.parse(hash.substring(0, 64));
            return new Aes(iv, key);
        }
    }, {
        key: "fromBuffer",
        value: function fromBuffer(buf) {
            assert(Buffer.isBuffer(buf), "Expecting Buffer");
            assert.equal(buf.length, 64, "A Sha512 Buffer should be 64 characters long, instead got " + buf.length);
            return Aes.fromSha512(buf.toString("hex"));
        }
        /**
            @throws {Error} - "Invalid Key, ..."
            @arg {PrivateKey} private_key - required and used for decryption
            @arg {PublicKey} public_key - required and used to calcualte the shared secret
            @arg {string} [nonce = ""] optional but should always be provided and be unique when re-using the same private/public keys more than once.  This nonce is not a secret.
            @arg {string|Buffer} message - Encrypted message containing a checksum
            @return {Buffer}
        */

    }, {
        key: "decrypt_with_checksum",
        value: function decrypt_with_checksum(private_key, public_key, nonce, message) {
            var legacy = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];


            // Warning: Do not put `nonce = ""` in the arguments, in es6 this will not convert "null" into an emtpy string
            if (nonce == null) // null or undefined
                nonce = "";

            if (!Buffer.isBuffer(message)) {
                message = new Buffer(message, 'hex');
            }

            var S = private_key.get_shared_secret(public_key, legacy);
            // D E B U G
            // console.log('decrypt_with_checksum', {
            //     priv_to_pub: private_key.toPublicKey().toString(),
            //     pub: public_key.toPublicKeyString(),
            //     nonce: nonce,
            //     message: message.length,
            //     S: S.toString('hex')
            // })

            var aes = Aes.fromSeed(Buffer.concat([
            // A null or empty string nonce will not effect the hash
            new Buffer("" + nonce), new Buffer(S.toString('hex'))]));

            var planebuffer = aes.decrypt(message);
            if (!(planebuffer.length >= 4)) {
                throw new Error("Invalid key, could not decrypt message(1)");
            }

            // DEBUG console.log('... planebuffer',planebuffer)
            var checksum = planebuffer.slice(0, 4);
            var plaintext = planebuffer.slice(4);

            // console.log('... checksum',checksum.toString('hex'))
            // console.log('... plaintext',plaintext.toString())

            var new_checksum = hash.sha256(plaintext);
            new_checksum = new_checksum.slice(0, 4);
            new_checksum = new_checksum.toString('hex');

            if (!(checksum.toString('hex') === new_checksum)) {
                throw new Error("Invalid key, could not decrypt message(2)");
            }

            return plaintext;
        }
    }, {
        key: "encrypt_with_checksum",


        /** Identical to {@link decrypt_with_checksum} but used to encrypt.  Should not throw an error.
            @return {Buffer} message - Encrypted message which includes a checksum
        */
        value: function encrypt_with_checksum(private_key, public_key, nonce, message) {

            // Warning: Do not put `nonce = ""` in the arguments, in es6 this will not convert "null" into an emtpy string

            if (nonce == null) // null or undefined
                nonce = "";

            if (!Buffer.isBuffer(message)) {
                message = new Buffer(message, 'binary');
            }

            var S = private_key.get_shared_secret(public_key);

            // D E B U G
            // console.log('encrypt_with_checksum', {
            //     priv_to_pub: private_key.toPublicKey().toString()
            //     pub: public_key.toPublicKeyString()
            //     nonce: nonce
            //     message: message.length
            //     S: S.toString('hex')
            // })

            var aes = Aes.fromSeed(Buffer.concat([
            // A null or empty string nonce will not effect the hash
            new Buffer("" + nonce), new Buffer(S.toString('hex'))]));
            // DEBUG console.log('... S',S.toString('hex'))
            var checksum = hash.sha256(message).slice(0, 4);
            var payload = Buffer.concat([checksum, message]);
            // DEBUG console.log('... payload',payload.toString())
            return aes.encrypt(payload);
        }
    }]);

    return Aes;
}();

module.exports = Aes;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/ecc/src/aes.js","/../node_modules/steemjs-lib/dist/ecc/src")
},{"./hash":109,"assert":1,"buffer":11,"bytebuffer":12,"crypto-js/aes":18,"crypto-js/enc-base64":21,"crypto-js/enc-hex":22,"pBGvAp":74}],106:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var assert = require('assert'); // from github.com/bitcoinjs/bitcoinjs-lib from github.com/cryptocoinjs/ecdsa
var crypto = require('./hash');
var enforceType = require('./enforce_types');

var BigInteger = require('bigi');
var ECSignature = require('./ecsignature');

// https://tools.ietf.org/html/rfc6979#section-3.2
function deterministicGenerateK(curve, hash, d, checkSig, nonce) {

  enforceType('Buffer', hash);
  enforceType(BigInteger, d);

  if (nonce) {
    hash = crypto.sha256(Buffer.concat([hash, new Buffer(nonce)]));
  }

  // sanity check
  assert.equal(hash.length, 32, 'Hash must be 256 bit');

  var x = d.toBuffer(32);
  var k = new Buffer(32);
  var v = new Buffer(32);

  // Step B
  v.fill(1);

  // Step C
  k.fill(0);

  // Step D
  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0]), x, hash]), k);

  // Step E
  v = crypto.HmacSHA256(v, k);

  // Step F
  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([1]), x, hash]), k);

  // Step G
  v = crypto.HmacSHA256(v, k);

  // Step H1/H2a, ignored as tlen === qlen (256 bit)
  // Step H2b
  v = crypto.HmacSHA256(v, k);

  var T = BigInteger.fromBuffer(v);

  // Step H3, repeat until T is within the interval [1, n - 1]
  while (T.signum() <= 0 || T.compareTo(curve.n) >= 0 || !checkSig(T)) {
    k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0])]), k);
    v = crypto.HmacSHA256(v, k);

    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
    // Step H2b again
    v = crypto.HmacSHA256(v, k);

    T = BigInteger.fromBuffer(v);
  }

  return T;
}

function sign(curve, hash, d, nonce) {

  var e = BigInteger.fromBuffer(hash);
  var n = curve.n;
  var G = curve.G;

  var r, s;
  var k = deterministicGenerateK(curve, hash, d, function (k) {
    // find canonically valid signature
    var Q = G.multiply(k);

    if (curve.isInfinity(Q)) return false;

    r = Q.affineX.mod(n);
    if (r.signum() === 0) return false;

    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);
    if (s.signum() === 0) return false;

    return true;
  }, nonce);

  var N_OVER_TWO = n.shiftRight(1);

  // enforce low S values, see bip62: 'low s values in signatures'
  if (s.compareTo(N_OVER_TWO) > 0) {
    s = n.subtract(s);
  }

  return new ECSignature(r, s);
}

function verifyRaw(curve, e, signature, Q) {
  var n = curve.n;
  var G = curve.G;

  var r = signature.r;
  var s = signature.s;

  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]
  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false;
  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false;

  // c = s^-1 mod n
  var c = s.modInverse(n);

  // 1.4.4 Compute u1 = es^−1 mod n
  //               u2 = rs^−1 mod n
  var u1 = e.multiply(c).mod(n);
  var u2 = r.multiply(c).mod(n);

  // 1.4.5 Compute R = (xR, yR) = u1G + u2Q
  var R = G.multiplyTwo(u1, Q, u2);

  // 1.4.5 (cont.) Enforce R is not at infinity
  if (curve.isInfinity(R)) return false;

  // 1.4.6 Convert the field element R.x to an integer
  var xR = R.affineX;

  // 1.4.7 Set v = xR mod n
  var v = xR.mod(n);

  // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"
  return v.equals(r);
}

function verify(curve, hash, signature, Q) {
  // 1.4.2 H = Hash(M), already done by the user
  // 1.4.3 e = H
  var e = BigInteger.fromBuffer(hash);
  return verifyRaw(curve, e, signature, Q);
}

/**
  * Recover a public key from a signature.
  *
  * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, "Public
  * Key Recovery Operation".
  *
  * http://www.secg.org/download/aid-780/sec1-v2.pdf
  */
function recoverPubKey(curve, e, signature, i) {
  assert.strictEqual(i & 3, i, 'Recovery param is more than two bits');

  var n = curve.n;
  var G = curve.G;

  var r = signature.r;
  var s = signature.s;

  assert(r.signum() > 0 && r.compareTo(n) < 0, 'Invalid r value');
  assert(s.signum() > 0 && s.compareTo(n) < 0, 'Invalid s value');

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = i & 1;

  // The more significant bit specifies whether we should use the
  // first or second candidate key.
  var isSecondKey = i >> 1;

  // 1.1 Let x = r + jn
  var x = isSecondKey ? r.add(n) : r;
  var R = curve.pointFromX(isYOdd, x);

  // 1.4 Check that nR is at infinity
  var nR = R.multiply(n);
  assert(curve.isInfinity(nR), 'nR is not a valid curve point');

  // Compute -e from e
  var eNeg = e.negate().mod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  var rInv = r.modInverse(n);

  var Q = R.multiplyTwo(s, G, eNeg).multiply(rInv);
  curve.validate(Q);

  return Q;
}

/**
  * Calculate pubkey extraction parameter.
  *
  * When extracting a pubkey from a signature, we have to
  * distinguish four different cases. Rather than putting this
  * burden on the verifier, Bitcoin includes a 2-bit value with the
  * signature.
  *
  * This function simply tries all four cases and returns the value
  * that resulted in a successful pubkey recovery.
  */
function calcPubKeyRecoveryParam(curve, e, signature, Q) {
  for (var i = 0; i < 4; i++) {
    var Qprime = recoverPubKey(curve, e, signature, i);

    // 1.6.2 Verify Q
    if (Qprime.equals(Q)) {
      return i;
    }
  }

  throw new Error('Unable to find valid recovery factor');
}

module.exports = {
  calcPubKeyRecoveryParam: calcPubKeyRecoveryParam,
  deterministicGenerateK: deterministicGenerateK,
  recoverPubKey: recoverPubKey,
  sign: sign,
  verify: verify,
  verifyRaw: verifyRaw
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/ecc/src/ecdsa.js","/../node_modules/steemjs-lib/dist/ecc/src")
},{"./ecsignature":107,"./enforce_types":108,"./hash":109,"assert":1,"bigi":6,"buffer":11,"pBGvAp":74}],107:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var assert = require('assert'); // from https://github.com/bitcoinjs/bitcoinjs-lib
var enforceType = require('./enforce_types');

var BigInteger = require('bigi');

function ECSignature(r, s) {
  enforceType(BigInteger, r);
  enforceType(BigInteger, s);

  this.r = r;
  this.s = s;
}

// Import operations
ECSignature.parseCompact = function (buffer) {
  assert.equal(buffer.length, 65, 'Invalid signature length');
  var i = buffer.readUInt8(0) - 27;

  // At most 3 bits
  assert.equal(i, i & 7, 'Invalid signature parameter');
  var compressed = !!(i & 4);

  // Recovery param only
  i = i & 3;

  var r = BigInteger.fromBuffer(buffer.slice(1, 33));
  var s = BigInteger.fromBuffer(buffer.slice(33));

  return {
    compressed: compressed,
    i: i,
    signature: new ECSignature(r, s)
  };
};

ECSignature.fromDER = function (buffer) {
  assert.equal(buffer.readUInt8(0), 0x30, 'Not a DER sequence');
  assert.equal(buffer.readUInt8(1), buffer.length - 2, 'Invalid sequence length');
  assert.equal(buffer.readUInt8(2), 0x02, 'Expected a DER integer');

  var rLen = buffer.readUInt8(3);
  assert(rLen > 0, 'R length is zero');

  var offset = 4 + rLen;
  assert.equal(buffer.readUInt8(offset), 0x02, 'Expected a DER integer (2)');

  var sLen = buffer.readUInt8(offset + 1);
  assert(sLen > 0, 'S length is zero');

  var rB = buffer.slice(4, offset);
  var sB = buffer.slice(offset + 2);
  offset += 2 + sLen;

  if (rLen > 1 && rB.readUInt8(0) === 0x00) {
    assert(rB.readUInt8(1) & 0x80, 'R value excessively padded');
  }

  if (sLen > 1 && sB.readUInt8(0) === 0x00) {
    assert(sB.readUInt8(1) & 0x80, 'S value excessively padded');
  }

  assert.equal(offset, buffer.length, 'Invalid DER encoding');
  var r = BigInteger.fromDERInteger(rB);
  var s = BigInteger.fromDERInteger(sB);

  assert(r.signum() >= 0, 'R value is negative');
  assert(s.signum() >= 0, 'S value is negative');

  return new ECSignature(r, s);
};

// FIXME: 0x00, 0x04, 0x80 are SIGHASH_* boundary constants, importing Transaction causes a circular dependency
ECSignature.parseScriptSignature = function (buffer) {
  var hashType = buffer.readUInt8(buffer.length - 1);
  var hashTypeMod = hashType & ~0x80;

  assert(hashTypeMod > 0x00 && hashTypeMod < 0x04, 'Invalid hashType');

  return {
    signature: ECSignature.fromDER(buffer.slice(0, -1)),
    hashType: hashType
  };
};

// Export operations
ECSignature.prototype.toCompact = function (i, compressed) {
  if (compressed) i += 4;
  i += 27;

  var buffer = new Buffer(65);
  buffer.writeUInt8(i, 0);

  this.r.toBuffer(32).copy(buffer, 1);
  this.s.toBuffer(32).copy(buffer, 33);

  return buffer;
};

ECSignature.prototype.toDER = function () {
  var rBa = this.r.toDERInteger();
  var sBa = this.s.toDERInteger();

  var sequence = [];

  // INTEGER
  sequence.push(0x02, rBa.length);
  sequence = sequence.concat(rBa);

  // INTEGER
  sequence.push(0x02, sBa.length);
  sequence = sequence.concat(sBa);

  // SEQUENCE
  sequence.unshift(0x30, sequence.length);

  return new Buffer(sequence);
};

ECSignature.prototype.toScriptSignature = function (hashType) {
  var hashTypeBuffer = new Buffer(1);
  hashTypeBuffer.writeUInt8(hashType, 0);

  return Buffer.concat([this.toDER(), hashTypeBuffer]);
};

module.exports = ECSignature;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/ecc/src/ecsignature.js","/../node_modules/steemjs-lib/dist/ecc/src")
},{"./enforce_types":108,"assert":1,"bigi":6,"buffer":11,"pBGvAp":74}],108:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

module.exports = function enforce(type, value) {
  // Copied from https://github.com/bitcoinjs/bitcoinjs-lib
  switch (type) {
    case 'Array':
      {
        if (Array.isArray(value)) return;
        break;
      }

    case 'Boolean':
      {
        if (typeof value === 'boolean') return;
        break;
      }

    case 'Buffer':
      {
        if (Buffer.isBuffer(value)) return;
        break;
      }

    case 'Number':
      {
        if (typeof value === 'number') return;
        break;
      }

    case 'String':
      {
        if (typeof value === 'string') return;
        break;
      }

    default:
      {
        if (getName(value.constructor) === getName(type)) return;
      }
  }

  throw new TypeError('Expected ' + (getName(type) || type) + ', got ' + value);
};

function getName(fn) {
  // Why not fn.name: https://kangax.github.io/compat-table/es6/#function_name_property
  var match = fn.toString().match(/function (.*?)\(/);
  return match ? match[1] : null;
}
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/ecc/src/enforce_types.js","/../node_modules/steemjs-lib/dist/ecc/src")
},{"buffer":11,"pBGvAp":74}],109:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var createHash = require("create-hash");
var createHmac = require("create-hmac");

/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
function sha1(data, encoding) {
    return createHash('sha1').update(data).digest(encoding);
}

/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
function sha256(data, encoding) {
    return createHash('sha256').update(data).digest(encoding);
}

/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
function sha512(data, encoding) {
    return createHash('sha512').update(data).digest(encoding);
}

function HmacSHA256(buffer, secret) {
    return createHmac('sha256', secret).update(buffer).digest();
}

function ripemd160(data) {
    return createHash('rmd160').update(data).digest();
}

// function hash160(buffer) {
//   return ripemd160(sha256(buffer))
// }
//
// function hash256(buffer) {
//   return sha256(sha256(buffer))
// }

//
// function HmacSHA512(buffer, secret) {
//   return crypto.createHmac('sha512', secret).update(buffer).digest()
// }

module.exports = {
    sha1: sha1,
    sha256: sha256,
    sha512: sha512,
    HmacSHA256: HmacSHA256,
    ripemd160: ripemd160
    // hash160: hash160,
    // hash256: hash256,
    // HmacSHA512: HmacSHA512
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/ecc/src/hash.js","/../node_modules/steemjs-lib/dist/ecc/src")
},{"buffer":11,"create-hash":14,"create-hmac":17,"pBGvAp":74}],110:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ecdsa = require('./ecdsa');
var hash = require('./hash');

var _require = require('ecurve');

var getCurveByName = _require.getCurveByName;

var secp256k1 = getCurveByName('secp256k1');
var assert = require('assert');
var BigInteger = require('bigi');
var PublicKey = require('./PublicKey');

var Signature = function () {
    function Signature(r1, s1, i1) {
        _classCallCheck(this, Signature);

        this.r = r1;
        this.s = s1;
        this.i = i1;
        assert.equal(this.r != null, true, 'Missing parameter');
        assert.equal(this.s != null, true, 'Missing parameter');
        assert.equal(this.i != null, true, 'Missing parameter');
    }

    _createClass(Signature, [{
        key: 'toBuffer',
        value: function toBuffer() {
            var buf;
            buf = new Buffer(65);
            buf.writeUInt8(this.i, 0);
            this.r.toBuffer(32).copy(buf, 1);
            this.s.toBuffer(32).copy(buf, 33);
            return buf;
        }
    }, {
        key: 'recoverPublicKeyFromBuffer',
        value: function recoverPublicKeyFromBuffer(buffer) {
            return this.recoverPublicKey(hash.sha256(buffer));
        }
    }, {
        key: 'recoverPublicKey',


        /**
            @return {PublicKey}
        */
        value: function recoverPublicKey(sha256_buffer) {
            var Q = void 0,
                e = void 0,
                i = void 0;
            e = BigInteger.fromBuffer(sha256_buffer);
            i = this.i;
            i -= 27;
            i = i & 3;
            Q = ecdsa.recoverPubKey(secp256k1, e, this, i);
            return PublicKey.fromPoint(Q);
        }
    }, {
        key: 'verifyBuffer',


        /**
            @param {Buffer} un-hashed
            @param {./PublicKey}
            @return {boolean}
        */
        value: function verifyBuffer(buf, public_key) {
            var _hash = hash.sha256(buf);
            return this.verifyHash(_hash, public_key);
        }
    }, {
        key: 'verifyHash',
        value: function verifyHash(hash, public_key) {
            assert.equal(hash.length, 32, "A SHA 256 should be 32 bytes long, instead got " + hash.length);
            return ecdsa.verify(secp256k1, hash, {
                r: this.r,
                s: this.s
            }, public_key.Q);
        }
    }, {
        key: 'toByteBuffer',


        /* <HEX> */

        value: function toByteBuffer() {
            var b;
            b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            this.appendByteBuffer(b);
            return b.copy(0, b.offset);
        }
    }, {
        key: 'toHex',
        value: function toHex() {
            return this.toBuffer().toString("hex");
        }
    }, {
        key: 'verifyHex',
        value: function verifyHex(hex, public_key) {
            var buf;
            buf = new Buffer(hex, 'hex');
            return this.verifyBuffer(buf, public_key);
        }
    }], [{
        key: 'fromBuffer',
        value: function fromBuffer(buf) {
            var i, r, s;
            assert.equal(buf.length, 65, 'Invalid signature length');
            i = buf.readUInt8(0);
            assert.equal(i - 27, i - 27 & 7, 'Invalid signature parameter');
            r = BigInteger.fromBuffer(buf.slice(1, 33));
            s = BigInteger.fromBuffer(buf.slice(33));
            return new Signature(r, s, i);
        }
    }, {
        key: 'signBuffer',


        /**
            @param {Buffer} buf
            @param {PrivateKey} private_key
            @return {Signature}
        */
        value: function signBuffer(buf, private_key) {
            var _hash = hash.sha256(buf);
            return Signature.signBufferSha256(_hash, private_key);
        }

        /** Sign a buffer of exactally 32 bytes in size (sha256(text))
            @param {Buffer} buf - 32 bytes binary
            @param {PrivateKey} private_key
            @return {Signature}
        */

    }, {
        key: 'signBufferSha256',
        value: function signBufferSha256(buf_sha256, private_key) {
            if (buf_sha256.length !== 32 || !Buffer.isBuffer(buf_sha256)) throw new Error("buf_sha256: 32 byte buffer requred");
            var der, e, ecsignature, i, lenR, lenS, nonce;
            i = null;
            nonce = 0;
            e = BigInteger.fromBuffer(buf_sha256);
            while (true) {
                ecsignature = ecdsa.sign(secp256k1, buf_sha256, private_key.d, nonce++);
                der = ecsignature.toDER();
                lenR = der[3];
                lenS = der[5 + lenR];
                if (lenR === 32 && lenS === 32) {
                    i = ecdsa.calcPubKeyRecoveryParam(secp256k1, e, ecsignature, private_key.toPublicKey().Q);
                    i += 4; // compressed
                    i += 27; // compact  //  24 or 27 :( forcing odd-y 2nd key candidate)
                    break;
                }
                if (nonce % 10 === 0) {
                    console.log("WARN: " + nonce + " attempts to find canonical signature");
                }
            }
            return new Signature(ecsignature.r, ecsignature.s, i);
        }
    }, {
        key: 'sign',
        value: function sign(string, private_key) {
            return Signature.signBuffer(new Buffer(string), private_key);
        }
    }, {
        key: 'fromHex',
        value: function fromHex(hex) {
            return Signature.fromBuffer(new Buffer(hex, "hex"));
        }
    }, {
        key: 'signHex',
        value: function signHex(hex, private_key) {
            var buf;
            buf = new Buffer(hex, 'hex');
            return Signature.signBuffer(buf, private_key);
        }
    }]);

    return Signature;
}();

module.exports = Signature;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/ecc/src/signature.js","/../node_modules/steemjs-lib/dist/ecc/src")
},{"./PublicKey":103,"./ecdsa":106,"./hash":109,"assert":1,"bigi":6,"buffer":11,"ecurve":32,"pBGvAp":74}],111:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var objectAssign = require('object-assign');

module.exports = objectAssign(require("./chain"), require("./ecc"), require("./serializer"));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/index.js","/../node_modules/steemjs-lib/dist")
},{"./chain":90,"./ecc":99,"./serializer":112,"buffer":11,"object-assign":73,"pBGvAp":74}],112:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

module.exports = {

    // Primary class for creating operations
    Serializer: require('./src/serializer'),

    // helper functions for creating operations
    fp: require('./src/FastParser'),

    // Low level types
    types: require('./src/types'),

    // Higher level operations (made out of generic types)
    ops: require('./src/operations'),

    // Utility that generates JSON examples
    template: require('./src/template'),

    // Serializer validation
    SerializerValidation: require('./src/SerializerValidation')
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/serializer/index.js","/../node_modules/steemjs-lib/dist/serializer")
},{"./src/FastParser":113,"./src/SerializerValidation":114,"./src/operations":117,"./src/serializer":118,"./src/template":119,"./src/types":120,"buffer":11,"pBGvAp":74}],113:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PublicKey = require("../../ecc/src/PublicKey");

var FastParser = function () {
    function FastParser() {
        _classCallCheck(this, FastParser);
    }

    _createClass(FastParser, null, [{
        key: 'fixed_data',
        value: function fixed_data(b, len, buffer) {
            if (!b) {
                return;
            }
            if (buffer) {
                var data = buffer.slice(0, len).toString('binary');
                b.append(data, 'binary');
                while (len-- > data.length) {
                    b.writeUint8(0);
                }
            } else {
                var b_copy = b.copy(b.offset, b.offset + len);
                b.skip(len);
                return new Buffer(b_copy.toBinary(), 'binary');
            }
        }
    }, {
        key: 'public_key',
        value: function public_key(b, _public_key) {
            if (!b) {
                return;
            }
            if (_public_key) {
                var buffer = _public_key.toBuffer();
                b.append(buffer.toString('binary'), 'binary');
                return;
            } else {
                buffer = FastParser.fixed_data(b, 33);
                return PublicKey.fromBuffer(buffer);
            }
        }
    }, {
        key: 'ripemd160',
        value: function ripemd160(b, _ripemd) {
            if (!b) {
                return;
            }
            if (_ripemd) {
                FastParser.fixed_data(b, 20, _ripemd);
                return;
            } else {
                return FastParser.fixed_data(b, 20);
            }
        }
    }, {
        key: 'time_point_sec',
        value: function time_point_sec(b, epoch) {
            if (epoch) {
                epoch = Math.ceil(epoch / 1000);
                b.writeInt32(epoch);
                return;
            } else {
                epoch = b.readInt32(); // fc::time_point_sec
                return new Date(epoch * 1000);
            }
        }
    }]);

    return FastParser;
}();

module.exports = FastParser;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/serializer/src/FastParser.js","/../node_modules/steemjs-lib/dist/serializer/src")
},{"../../ecc/src/PublicKey":103,"buffer":11,"pBGvAp":74}],114:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _require = require('bytebuffer');

var Long = _require.Long;

var ChainTypes = require('../../chain/src/ChainTypes');

var MAX_SAFE_INT = 9007199254740991;
var MIN_SAFE_INT = -9007199254740991;

/**
    Most validations are skipped and the value returned unchanged when an empty string, null, or undefined is encountered (except "required").

    Validations support a string format for dealing with large numbers.
*/
var _my = {

    is_empty: function is_empty(value) {
        return value === null || value === undefined;
    },

    required: function required(value) {
        var field_name = arguments.length <= 1 || arguments[1] === undefined ? "" : arguments[1];

        if (this.is_empty(value)) {
            throw new Error('value required ' + field_name + ' ' + value);
        }
        return value;
    },
    require_long: function require_long(value) {
        var field_name = arguments.length <= 1 || arguments[1] === undefined ? "" : arguments[1];

        if (!Long.isLong(value)) {
            throw new Error('Long value required ' + field_name + ' ' + value);
        }
        return value;
    },
    string: function string(value) {
        if (this.is_empty(value)) {
            return value;
        }
        if (typeof value !== "string") {
            throw new Error('string required: ' + value);
        }
        return value;
    },
    number: function number(value) {
        if (this.is_empty(value)) {
            return value;
        }
        if (typeof value !== "number") {
            throw new Error('number required: ' + value);
        }
        return value;
    },
    whole_number: function whole_number(value) {
        var field_name = arguments.length <= 1 || arguments[1] === undefined ? "" : arguments[1];

        if (this.is_empty(value)) {
            return value;
        }
        if (/\./.test(value)) {
            throw new Error('whole number required ' + field_name + ' ' + value);
        }
        return value;
    },
    unsigned: function unsigned(value) {
        var field_name = arguments.length <= 1 || arguments[1] === undefined ? "" : arguments[1];

        if (this.is_empty(value)) {
            return value;
        }
        if (/-/.test(value)) {
            throw new Error('unsigned required ' + field_name + ' ' + value);
        }
        return value;
    },


    is_digits: function is_digits(value) {
        if (typeof value === "numeric") {
            return true;
        }
        return (/^[0-9]+$/.test(value)
        );
    },

    to_number: function to_number(value) {
        var field_name = arguments.length <= 1 || arguments[1] === undefined ? "" : arguments[1];

        if (this.is_empty(value)) {
            return value;
        }
        this.no_overflow53(value, field_name);
        var int_value = function () {
            if (typeof value === "number") {
                return value;
            } else {
                return parseInt(value);
            }
        }();
        return int_value;
    },

    to_long: function to_long(value) {
        var field_name = arguments.length <= 1 || arguments[1] === undefined ? "" : arguments[1];

        if (this.is_empty(value)) {
            return value;
        }
        if (Long.isLong(value)) {
            return value;
        }

        this.no_overflow64(value, field_name);
        if (typeof value === "number") {
            value = "" + value;
        }
        return Long.fromString(value);
    },
    to_string: function to_string(value) {
        var field_name = arguments.length <= 1 || arguments[1] === undefined ? "" : arguments[1];

        if (this.is_empty(value)) {
            return value;
        }
        if (typeof value === "string") {
            return value;
        }
        if (typeof value === "number") {
            this.no_overflow53(value, field_name);
            return "" + value;
        }
        if (Long.isLong(value)) {
            return value.toString();
        }
        throw 'unsupported type ' + field_name + ': (' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + ') ' + value;
    },
    require_test: function require_test(regex, value) {
        var field_name = arguments.length <= 2 || arguments[2] === undefined ? "" : arguments[2];

        if (this.is_empty(value)) {
            return value;
        }
        if (!regex.test(value)) {
            throw new Error('unmatched ' + regex + ' ' + field_name + ' ' + value);
        }
        return value;
    },


    require_match: function require_match(regex, value) {
        var field_name = arguments.length <= 2 || arguments[2] === undefined ? "" : arguments[2];

        if (this.is_empty(value)) {
            return value;
        }
        var match = value.match(regex);
        if (match === null) {
            throw new Error('unmatched ' + regex + ' ' + field_name + ' ' + value);
        }
        return match;
    },

    require_object_id: function require_object_id(value, field_name) {
        return require_match(/^([0-9]+)\.([0-9]+)\.([0-9]+)$/, value, field_name);
    },

    // Does not support over 53 bits
    require_range: function require_range(min, max, value) {
        var field_name = arguments.length <= 3 || arguments[3] === undefined ? "" : arguments[3];

        if (this.is_empty(value)) {
            return value;
        }
        var number = this.to_number(value);
        if (value < min || value > max) {
            throw new Error('out of range ' + value + ' ' + field_name + ' ' + value);
        }
        return value;
    },


    require_object_type: function require_object_type() {
        var reserved_spaces = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
        var type = arguments[1];
        var value = arguments[2];
        var field_name = arguments.length <= 3 || arguments[3] === undefined ? "" : arguments[3];

        if (this.is_empty(value)) {
            return value;
        }
        var object_type = ChainTypes.object_type[type];
        if (!object_type) {
            throw new Error('Unknown object type ' + type + ' ' + field_name + ' ' + value);
        }
        var re = new RegExp(reserved_spaces + '.' + object_type + '.[0-9]+$');
        if (!re.test(value)) {
            throw new Error('Expecting ' + type + ' in format ' + (reserved_spaces + '.' + object_type + '.[0-9]+ ') + ('instead of ' + value + ' ' + field_name + ' ' + value));
        }
        return value;
    },

    get_instance: function get_instance(reserve_spaces, type, value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        this.require_object_type(reserve_spaces, type, value, field_name);
        return this.to_number(value.split('.')[2]);
    },

    require_relative_type: function require_relative_type(type, value, field_name) {
        this.require_object_type(0, type, value, field_name);
        return value;
    },

    get_relative_instance: function get_relative_instance(type, value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        this.require_object_type(0, type, value, field_name);
        return this.to_number(value.split('.')[2]);
    },

    require_protocol_type: function require_protocol_type(type, value, field_name) {
        this.require_object_type(1, type, value, field_name);
        return value;
    },

    get_protocol_instance: function get_protocol_instance(type, value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        this.require_object_type(1, type, value, field_name);
        return this.to_number(value.split('.')[2]);
    },

    get_protocol_type: function get_protocol_type(value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        this.require_object_id(value, field_name);
        var values = value.split('.');
        return this.to_number(values[1]);
    },

    get_protocol_type_name: function get_protocol_type_name(value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        var type_id = this.get_protocol_type(value, field_name);
        return Object.keys(ChainTypes.object_type)[type_id];
    },


    require_implementation_type: function require_implementation_type(type, value, field_name) {
        this.require_object_type(2, type, value, field_name);
        return value;
    },

    get_implementation_instance: function get_implementation_instance(type, value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        this.require_object_type(2, type, value, field_name);
        return this.to_number(value.split('.')[2]);
    },

    // signed / unsigned decimal
    no_overflow53: function no_overflow53(value) {
        var field_name = arguments.length <= 1 || arguments[1] === undefined ? "" : arguments[1];

        if (typeof value === "number") {
            if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
                throw new Error('overflow ' + field_name + ' ' + value);
            }
            return;
        }
        if (typeof value === "string") {
            var int = parseInt(value);
            if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
                throw new Error('overflow ' + field_name + ' ' + value);
            }
            return;
        }
        if (Long.isLong(value)) {
            // typeof value.toInt() is 'number'
            this.no_overflow53(value.toInt(), field_name);
            return;
        }
        throw 'unsupported type ' + field_name + ': (' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + ') ' + value;
    },


    // signed / unsigned whole numbers only
    no_overflow64: function no_overflow64(value) {
        var field_name = arguments.length <= 1 || arguments[1] === undefined ? "" : arguments[1];

        // https://github.com/dcodeIO/Long.js/issues/20
        if (Long.isLong(value)) {
            return;
        }

        // BigInteger#isBigInteger https://github.com/cryptocoinjs/bigi/issues/20
        if (value.t !== undefined && value.s !== undefined) {
            this.no_overflow64(value.toString(), field_name);
            return;
        }

        if (typeof value === "string") {
            // remove leading zeros, will cause a false positive
            value = value.replace(/^0+/, '');
            // remove trailing zeros
            while (/0$/.test(value)) {
                value = value.substring(0, value.length - 1);
            }
            if (/\.$/.test(value)) {
                // remove trailing dot
                value = value.substring(0, value.length - 1);
            }
            if (value === "") {
                value = "0";
            }
            var long_string = Long.fromString(value).toString();
            if (long_string !== value.trim()) {
                throw new Error('overflow ' + field_name + ' ' + value);
            }
            return;
        }
        if (typeof value === "number") {
            if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
                throw new Error('overflow ' + field_name + ' ' + value);
            }
            return;
        }

        throw 'unsupported type ' + field_name + ': (' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + ') ' + value;
    }
};

module.exports = _my;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/serializer/src/SerializerValidation.js","/../node_modules/steemjs-lib/dist/serializer/src")
},{"../../chain/src/ChainTypes":93,"buffer":11,"bytebuffer":12,"pBGvAp":74}],115:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** Exception nesting.  */

var ErrorWithCause = function () {
    function ErrorWithCause(message, cause) {
        _classCallCheck(this, ErrorWithCause);

        this.message = message;
        if (typeof cause !== "undefined" && cause !== null ? cause.message : undefined) {
            this.message = "cause\t" + cause.message + "\t" + this.message;
        }

        var stack = ""; //(new Error).stack
        if (typeof cause !== "undefined" && cause !== null ? cause.stack : undefined) {
            stack = "caused by\n\t" + cause.stack + "\t" + stack;
        }

        this.stack = this.message + "\n" + stack;
    }

    _createClass(ErrorWithCause, null, [{
        key: "throw",
        value: function _throw(message, cause) {
            var msg = message;
            if (typeof cause !== "undefined" && cause !== null ? cause.message : undefined) {
                msg += "\t cause: " + cause.message + " ";
            }
            if (typeof cause !== "undefined" && cause !== null ? cause.stack : undefined) {
                msg += "\n stack: " + cause.stack + " ";
            }
            throw new Error(msg);
        }
    }]);

    return ErrorWithCause;
}();

module.exports = ErrorWithCause;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/serializer/src/error_with_cause.js","/../node_modules/steemjs-lib/dist/serializer/src")
},{"buffer":11,"pBGvAp":74}],116:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var assert = require("assert");

/**
    Convert 12.34 with a precision of 3 into 12340

    @arg {number|string} number - Use strings for large numbers.  This may contain one decimal but no sign
    @arg {number} precision - number of implied decimal places (usually causes right zero padding)
    @return {string} -
*/
module.exports = {
    toImpliedDecimal: function toImpliedDecimal(number, precision) {

        if (typeof number === "number") {
            assert(number <= 9007199254740991, "overflow");
            number = "" + number;
        } else if (number.toString) number = number.toString();

        assert(typeof number === "string", "number should be an actual number or string: " + (typeof number === "undefined" ? "undefined" : _typeof(number)));
        number = number.trim();
        assert(/^[0-9]*\.?[0-9]*$/.test(number), "Invalid decimal number " + number);

        var _number$split = number.split(".");

        var _number$split2 = _slicedToArray(_number$split, 2);

        var _number$split2$ = _number$split2[0];
        var whole = _number$split2$ === undefined ? "" : _number$split2$;
        var _number$split2$2 = _number$split2[1];
        var decimal = _number$split2$2 === undefined ? "" : _number$split2$2;


        var padding = precision - decimal.length;
        assert(padding >= 0, "Too many decimal digits in " + number + " to create an implied decimal of " + precision);

        for (var i = 0; i < padding; i++) {
            decimal += "0";
        }while (whole.charAt(0) === "0") {
            whole = whole.substring(1);
        }return whole + decimal;
    },

    fromImpliedDecimal: function fromImpliedDecimal(number, precision) {
        if (typeof number === "number") {
            assert(number <= 9007199254740991, "overflow");
            number = "" + number;
        } else if (number.toString) number = number.toString();

        while (number.length < precision + 1) {
            // 0.123
            number = "0" + number;
        } // 44000 => 44.000
        var dec_string = number.substring(number.length - precision);
        return number.substring(0, number.length - precision) + (dec_string ? "." + dec_string : "");
    }
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/serializer/src/numberUtils.js","/../node_modules/steemjs-lib/dist/serializer/src")
},{"assert":1,"buffer":11,"pBGvAp":74}],117:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var types = require("./types");
var SerializerImpl = require("./serializer");

var int16 = types.int16;
var uint16 = types.uint16;
var uint32 = types.uint32;
var int64 = types.int64;
var uint64 = types.uint64;
var string = types.string;
var bytes = types.bytes;
var bool = types.bool;
var array = types.array;
var fixed_array = types.fixed_array;
var object_id_type = types.object_id_type;
var vote_id = types.vote_id;
var future_extensions = types.future_extensions;
var static_variant = types.static_variant;
var map = types.map;
var set = types.set;
var public_key = types.public_key;
var address = types.address;
var time_point_sec = types.time_point_sec;
var optional = types.optional;
var asset = types.asset;


future_extensions = types.void;

/*
When updating generated code
Replace:  operation = static_variant [
with:     operation.st_operations = [

at the end of this file.

Then, delete this part:
public_key = new Serializer(
    "public_key"
    key_data: bytes 33
)

*/
// Place-holder, their are dependencies on "operation" .. The final list of
// operations is not avialble until the very end of the generated code.
// See: operation.st_operations = ...
var operation = static_variant();
module.exports["operation"] = operation;

// For module.exports
var Serializer = function Serializer(operation_name, serilization_types_object) {
    var s = new SerializerImpl(operation_name, serilization_types_object);
    return module.exports[operation_name] = s;
};

// Custom-types follow Generated code:

// ##  Generated code follows
// # npm i -g decaffeinate
// # programs/js_operation_serializer > ops.coffee && decaffeinate ops.coffee
// # open ops.txt, copy to Chain/ChainTypes and operations.js
// ## -------------------------------
var signed_transaction = new Serializer("signed_transaction", {
    ref_block_num: uint16,
    ref_block_prefix: uint32,
    expiration: time_point_sec,
    operations: array(operation),
    extensions: set(future_extensions),
    signatures: array(bytes(65))
});

var signed_block = new Serializer("signed_block", {
    previous: bytes(20),
    timestamp: time_point_sec,
    witness: string,
    transaction_merkle_root: bytes(20),
    extensions: set(future_extensions),
    witness_signature: bytes(65),
    transactions: array(signed_transaction)
});

var block_header = new Serializer("block_header", {
    previous: bytes(20),
    timestamp: time_point_sec,
    witness: string,
    transaction_merkle_root: bytes(20),
    extensions: set(future_extensions)
});

var signed_block_header = new Serializer("signed_block_header", {
    previous: bytes(20),
    timestamp: time_point_sec,
    witness: string,
    transaction_merkle_root: bytes(20),
    extensions: set(future_extensions),
    witness_signature: bytes(65)
});

var vote = new Serializer("vote", {
    voter: string,
    author: string,
    permlink: string,
    weight: uint16
});

var comment = new Serializer("comment", {
    parent_author: string,
    parent_permlink: string,
    author: string,
    permlink: string,
    title: string,
    body: string,
    json_metadata: string
});

// let asset = new Serializer(
//     "asset",{
//     amount: int64,
//     symbol: string
// }
// );

var transfer = new Serializer("transfer", {
    from: string,
    to: string,
    amount: asset,
    memo: string
});

var transfer_to_vesting = new Serializer("transfer_to_vesting", {
    from: string,
    to: string,
    amount: asset
});

var withdraw_vesting = new Serializer("withdraw_vesting", {
    account: string,
    vesting_shares: asset
});

var limit_order_create = new Serializer("limit_order_create", {
    owner: string,
    orderid: uint32,
    amount_to_sell: asset,
    min_to_receive: asset,
    fill_or_kill: bool,
    expiration: time_point_sec
});

var limit_order_cancel = new Serializer("limit_order_cancel", {
    owner: string,
    orderid: uint32
});

var price = new Serializer("price", {
    base: asset,
    quote: asset
});

var feed_publish = new Serializer("feed_publish", {
    publisher: string,
    exchange_rate: price
});

var convert = new Serializer("convert", {
    owner: string,
    requestid: uint32,
    amount: asset
});

var authority = new Serializer("authority", {
    weight_threshold: uint32,
    account_auths: map(string, uint16),
    key_auths: map(public_key, uint16)
});

var account_create = new Serializer("account_create", {
    fee: asset,
    creator: string,
    new_account_name: string,
    owner: authority,
    active: authority,
    posting: authority,
    memo_key: public_key,
    json_metadata: string
});

var account_update = new Serializer("account_update", {
    account: string,
    owner: optional(authority),
    active: optional(authority),
    posting: optional(authority),
    memo_key: public_key,
    json_metadata: string
});

var chain_properties = new Serializer("chain_properties", {
    account_creation_fee: asset,
    maximum_block_size: uint32,
    sbd_interest_rate: uint16
});

var witness_update = new Serializer("witness_update", {
    owner: string,
    url: string,
    block_signing_key: public_key,
    props: chain_properties,
    fee: asset
});

var account_witness_vote = new Serializer("account_witness_vote", {
    account: string,
    witness: string,
    approve: bool
});

var account_witness_proxy = new Serializer("account_witness_proxy", {
    account: string,
    proxy: string
});

var pow = new Serializer("pow", {
    worker: public_key,
    input: bytes(32),
    signature: bytes(65),
    work: bytes(32)
});

var custom = new Serializer("custom", {
    required_auths: set(string),
    id: uint16,
    data: bytes()
});

var report_over_production = new Serializer("report_over_production", {
    reporter: string,
    first_block: signed_block_header,
    second_block: signed_block_header
});

var delete_comment = new Serializer("delete_comment", {
    author: string,
    permlink: string
});

var custom_json = new Serializer("custom_json", {
    required_auths: set(string),
    required_posting_auths: set(string),
    id: string,
    json: string
});

var comment_options = new Serializer("comment_options", {
    author: string,
    permlink: string,
    max_accepted_payout: asset,
    percent_steem_dollars: uint16,
    allow_votes: bool,
    allow_curation_rewards: bool,
    extensions: set(static_variant([future_extensions]))
});

var set_withdraw_vesting_route = new Serializer("set_withdraw_vesting_route", {
    from_account: string,
    to_account: string,
    percent: uint16,
    auto_vest: bool
});

var fill_convert_request = new Serializer("fill_convert_request", {
    owner: string,
    requestid: uint32,
    amount_in: asset,
    amount_out: asset
});

var comment_reward = new Serializer("comment_reward", {
    author: string,
    permlink: string,
    sbd_payout: asset,
    vesting_payout: asset
});

var curate_reward = new Serializer("curate_reward", {
    curator: string,
    reward: asset,
    comment_author: string,
    comment_permlink: string
});

var liquidity_reward = new Serializer("liquidity_reward", {
    owner: string,
    payout: asset
});

var interest = new Serializer("interest", {
    owner: string,
    interest: asset
});

var fill_vesting_withdraw = new Serializer("fill_vesting_withdraw", {
    from_account: string,
    to_account: string,
    withdrawn: asset,
    deposited: asset
});

var fill_order = new Serializer("fill_order", {
    current_owner: string,
    current_orderid: uint32,
    current_pays: asset,
    open_owner: string,
    open_orderid: uint32,
    open_pays: asset
});

var comment_payout = new Serializer("comment_payout", {
    author: string,
    permlink: string,
    payout: asset
});

var escrow_transfer = new Serializer("escrow_transfer", {
    from: string,
    to: string,
    agent: string,
    escrow_id: uint32,
    sbd_amount: asset,
    steem_amount: asset,
    fee: asset,
    ratification_deadline: time_point_sec,
    escrow_expiration: time_point_sec,
    json_metadata: string
});

var escrow_approve = new Serializer("escrow_approve", {
    from: string,
    to: string,
    agent: string,
    who: string,
    escrow_id: uint32,
    approve: bool
});

var escrow_dispute = new Serializer("escrow_dispute", {
    from: string,
    to: string,
    agent: string,
    who: string,
    escrow_id: uint32
});

var escrow_release = new Serializer("escrow_release", {
    from: string,
    to: string,
    agent: string,
    who: string,
    receiver: string,
    escrow_id: uint32,
    sbd_amount: asset,
    steem_amount: asset
});

operation.st_operations = [vote, comment, transfer, transfer_to_vesting, withdraw_vesting, limit_order_create, limit_order_cancel, feed_publish, convert, account_create, account_update, witness_update, account_witness_vote, account_witness_proxy, pow, custom, report_over_production, delete_comment, custom_json, comment_options, set_withdraw_vesting_route, fill_convert_request, comment_reward, curate_reward, liquidity_reward, interest, fill_vesting_withdraw, fill_order, comment_payout, escrow_transfer, escrow_approve, escrow_dispute, escrow_release];

var transaction = new Serializer("transaction", {
    ref_block_num: uint16,
    ref_block_prefix: uint32,
    expiration: time_point_sec,
    operations: array(operation),
    extensions: set(future_extensions)
});

//# -------------------------------
//#  Generated code end
//# -------------------------------
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/serializer/src/operations.js","/../node_modules/steemjs-lib/dist/serializer/src")
},{"./serializer":118,"./types":120,"buffer":11,"pBGvAp":74}],118:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ByteBuffer = require('bytebuffer');
var EC = require('./error_with_cause');

var HEX_DUMP = process.env.npm_config__graphene_serializer_hex_dump;

var Serializer = function () {
    function Serializer(operation_name, types) {
        _classCallCheck(this, Serializer);

        this.operation_name = operation_name;
        this.types = types;
        if (this.types) this.keys = Object.keys(this.types);

        Serializer.printDebug = true;
    }

    _createClass(Serializer, [{
        key: 'fromByteBuffer',
        value: function fromByteBuffer(b) {
            var object = {};
            var field = null;
            try {
                var iterable = this.keys;
                for (var i = 0, field; i < iterable.length; i++) {
                    field = iterable[i];
                    var type = this.types[field];
                    try {
                        if (HEX_DUMP) {
                            if (type.operation_name) {
                                console.error(type.operation_name);
                            } else {
                                var o1 = b.offset;
                                type.fromByteBuffer(b);
                                var o2 = b.offset;
                                b.offset = o1;
                                //b.reset()
                                var _b = b.copy(o1, o2);
                                console.error(this.operation_name + '.' + field + '\t', _b.toHex());
                            }
                        }
                        object[field] = type.fromByteBuffer(b);
                    } catch (e) {
                        if (Serializer.printDebug) {
                            console.error('Error reading ' + this.operation_name + '.' + field + ' in data:');
                            b.printDebug();
                        }
                        throw e;
                    }
                }
            } catch (error) {
                EC.throw(this.operation_name + '.' + field, error);
            }

            return object;
        }
    }, {
        key: 'appendByteBuffer',
        value: function appendByteBuffer(b, object) {
            var field = null;
            try {
                var iterable = this.keys;
                for (var i = 0, field; i < iterable.length; i++) {
                    field = iterable[i];
                    var type = this.types[field];
                    type.appendByteBuffer(b, object[field]);
                }
            } catch (error) {
                try {
                    EC.throw(this.operation_name + '.' + field + " = " + JSON.stringify(object[field]), error);
                } catch (e) {
                    // circular ref
                    EC.throw(this.operation_name + '.' + field + " = " + object[field], error);
                }
            }
            return;
        }
    }, {
        key: 'fromObject',
        value: function fromObject(serialized_object) {
            var result = {};
            var field = null;
            try {
                var iterable = this.keys;
                for (var i = 0, field; i < iterable.length; i++) {
                    field = iterable[i];
                    var type = this.types[field];
                    var value = serialized_object[field];
                    //DEBUG value = value.resolve if value.resolve
                    //DEBUG console.log('... value',field,value)
                    var object = type.fromObject(value);
                    result[field] = object;
                }
            } catch (error) {
                EC.throw(this.operation_name + '.' + field, error);
            }

            return result;
        }

        /**
            @arg {boolean} [debug.use_default = false] - more template friendly
            @arg {boolean} [debug.annotate = false] - add user-friendly information
        */

    }, {
        key: 'toObject',
        value: function toObject() {
            var serialized_object = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
            var debug = arguments.length <= 1 || arguments[1] === undefined ? { use_default: false, annotate: false } : arguments[1];

            var result = {};
            var field = null;
            try {
                if (!this.types) return result;

                var iterable = this.keys;
                for (var i = 0, field; i < iterable.length; i++) {
                    field = iterable[i];
                    var type = this.types[field];
                    var object = type.toObject(typeof serialized_object !== "undefined" && serialized_object !== null ? serialized_object[field] : undefined, debug);
                    result[field] = object;
                    if (HEX_DUMP) {
                        var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
                        type.appendByteBuffer(b, typeof serialized_object !== "undefined" && serialized_object !== null ? serialized_object[field] : undefined);
                        b = b.copy(0, b.offset);
                        console.error(this.operation_name + '.' + field, b.toHex());
                    }
                }
            } catch (error) {
                EC.throw(this.operation_name + '.' + field, error);
            }

            return result;
        }

        /** Sort by the first element in a operation */

    }, {
        key: 'compare',
        value: function compare(a, b) {

            var first_key = this.keys[0];
            var first_type = this.types[first_key];

            var valA = a[first_key];
            var valB = b[first_key];

            if (first_type.compare) return first_type.compare(valA, valB);

            if (typeof valA === "number" && typeof valB === "number") return valA - valB;

            var encoding = void 0;
            if (Buffer.isBuffer(valA) && Buffer.isBuffer(valB)) {
                // A binary string compare does not work.  If localeCompare is well supported that could replace HEX.  Performanance is very good so comparing HEX works.
                encoding = "hex";
            }

            var strA = valA.toString(encoding);
            var strB = valB.toString(encoding);
            return strA > strB ? 1 : strA < strB ? -1 : 0;
        }

        // <helper_functions>

    }, {
        key: 'fromHex',
        value: function fromHex(hex) {
            var b = ByteBuffer.fromHex(hex, ByteBuffer.LITTLE_ENDIAN);
            return this.fromByteBuffer(b);
        }
    }, {
        key: 'fromBuffer',
        value: function fromBuffer(buffer) {
            var b = ByteBuffer.fromBinary(buffer.toString("binary"), ByteBuffer.LITTLE_ENDIAN);
            return this.fromByteBuffer(b);
        }
    }, {
        key: 'toHex',
        value: function toHex(object) {
            // return this.toBuffer(object).toString("hex")
            var b = this.toByteBuffer(object);
            return b.toHex();
        }
    }, {
        key: 'toByteBuffer',
        value: function toByteBuffer(object) {
            var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            this.appendByteBuffer(b, object);
            return b.copy(0, b.offset);
        }
    }, {
        key: 'toBuffer',
        value: function toBuffer(object) {
            return new Buffer(this.toByteBuffer(object).toBinary(), 'binary');
        }
    }]);

    return Serializer;
}();

module.exports = Serializer;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/serializer/src/serializer.js","/../node_modules/steemjs-lib/dist/serializer/src")
},{"./error_with_cause":115,"buffer":11,"bytebuffer":12,"pBGvAp":74}],119:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

/** Console print any transaction object with zero default values. */
module.exports = function template(op) {

    var object = op.toObject(void 0, { use_default: true, annotate: true });

    // visual (with descriptions)
    console.error(JSON.stringify(object, null, 4));

    // usable in a copy-paste

    object = op.toObject(void 0, { use_default: true, annotate: false });

    // copy-paste one-lineer
    console.error(JSON.stringify(object));
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/serializer/src/template.js","/../node_modules/steemjs-lib/dist/serializer/src")
},{"buffer":11,"pBGvAp":74}],120:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Low-level types that make up operations

var v = require('./SerializerValidation');
var fp = require('./FastParser');

var ChainTypes = require("../../chain/src/ChainTypes");
var ObjectId = require("../../chain/src/ObjectId");

var _require = require("../../ecc");

var PublicKey = _require.PublicKey;
var Address = _require.Address;

var ChainConfig = require("../../chain/src/ChainConfig");

var _require2 = require("./numberUtils");

var fromImpliedDecimal = _require2.fromImpliedDecimal;

var Types = {};
module.exports = Types;

var HEX_DUMP = process.env.npm_config__graphene_serializer_hex_dump;

Types.asset = {
    fromByteBuffer: function fromByteBuffer(b) {
        var amount = b.readInt64();
        var precision = b.readUint8();
        var b_copy = b.copy(b.offset, b.offset + 7);
        var symbol = new Buffer(b_copy.toBinary(), "binary").toString().replace(/\x00/g, "");
        b.skip(7);
        // "1.000 STEEM" always written with full precision
        var amount_string = fromImpliedDecimal(amount, precision);
        return amount_string + " " + symbol;
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        object = object.trim();
        if (!/^[0-9]+\.?[0-9]* [A-Za-z0-9]+$/.test(object)) throw new Error("Expecting amount like '99.000 SYMBOL', instead got '" + object + "'");

        var _object$split = object.split(" ");

        var _object$split2 = _slicedToArray(_object$split, 2);

        var amount = _object$split2[0];
        var symbol = _object$split2[1];

        if (symbol.length > 6) throw new Error("Symbols are not longer than 6 characters " + symbol + "-" + symbol.length);

        b.writeInt64(v.to_long(amount.replace(".", "")));
        var dot = amount.indexOf("."); // 0.000
        var precision = dot === -1 ? 0 : amount.length - dot - 1;
        b.writeUint8(precision);
        b.append(symbol.toUpperCase(), 'binary');
        for (var i = 0; i < 7 - symbol.length; i++) {
            b.writeUint8(0);
        }return;
    },
    fromObject: function fromObject(object) {
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (debug.use_default && object === undefined) {
            return "0.000 STEEM";
        }
        return object;
    }
};

Types.uint8 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint8();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(0, 0xFF, object, 'uint8 ' + object);
        b.writeUint8(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(0, 0xFF, object, 'uint8 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(0, 0xFF, object, 'uint8 ' + object);
        return parseInt(object);
    }
};

Types.int16 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readInt16();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(0, 0xFFFF, object, 'int16 ' + object);
        b.writeInt16(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(0, 0xFFFF, object, 'int16 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(0, 0xFFFF, object, 'int16 ' + object);
        return parseInt(object);
    }
};

Types.uint16 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint16();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(-0xFFFF, 0xFFFF, object, 'uint16 ' + object);
        b.writeUint16(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(-0xFFFF, 0xFFFF, object, 'uint16 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(-0xFFFF, 0xFFFF, object, 'uint16 ' + object);
        return parseInt(object);
    }
};

Types.uint32 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(0, 0xFFFFFFFF, object, 'uint32 ' + object);
        b.writeUint32(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(0, 0xFFFFFFFF, object, 'uint32 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(0, 0xFFFFFFFF, object, 'uint32 ' + object);
        return parseInt(object);
    }
};

var MIN_SIGNED_32 = -1 * Math.pow(2, 31);
var MAX_SIGNED_32 = Math.pow(2, 31) - 1;

Types.varint32 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readVarint32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, 'uint32 ' + object);
        b.writeVarint32(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, 'uint32 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, 'uint32 ' + object);
        return parseInt(object);
    }
};

Types.int64 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readInt64();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        b.writeInt64(v.to_long(object));
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        return v.to_long(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (debug.use_default && object === undefined) {
            return "0";
        }
        v.required(object);
        return v.to_long(object).toString();
    }
};

Types.uint64 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint64();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        b.writeUint64(v.to_long(v.unsigned(object)));
        return;
    },
    fromObject: function fromObject(object) {
        return v.to_long(v.unsigned(object));
    },
    toObject: function toObject(object) {
        var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (debug.use_default && object === undefined) {
            return "0";
        }
        return v.to_long(object).toString();
    }
};

Types.string = {
    fromByteBuffer: function fromByteBuffer(b) {
        var b_copy;
        var len = b.readVarint32();
        b_copy = b.copy(b.offset, b.offset + len), b.skip(len);
        return new Buffer(b_copy.toBinary(), 'binary');
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        b.writeVarint32(object.length);
        b.append(object.toString('binary'), 'binary');
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        return new Buffer(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (debug.use_default && object === undefined) {
            return "";
        }
        return object.toString();
    }
};

Types.bytes = function (size) {
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            if (size === undefined) {
                var b_copy;
                var len = b.readVarint32();
                b_copy = b.copy(b.offset, b.offset + len), b.skip(len);
                return new Buffer(b_copy.toBinary(), 'binary');
            } else {
                b_copy = b.copy(b.offset, b.offset + size), b.skip(size);
                return new Buffer(b_copy.toBinary(), 'binary');
            }
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            v.required(object);
            if (typeof object === "string") object = new Buffer(object, "hex");

            if (size === undefined) {
                b.writeVarint32(object.length);
            }
            b.append(object.toString('binary'), 'binary');
            return;
        },
        fromObject: function fromObject(object) {
            v.required(object);
            if (Buffer.isBuffer(object)) return object;

            return new Buffer(object, 'hex');
        },
        toObject: function toObject(object) {
            var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            if (debug.use_default && object === undefined) {
                var zeros = function zeros(num) {
                    return new Array(num).join("00");
                };
                return zeros(size);
            }
            v.required(object);
            return object.toString('hex');
        }
    };
};

Types.bool = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint8() === 1;
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        // supports boolean or integer
        b.writeUint8(JSON.parse(object) ? 1 : 0);
        return;
    },
    fromObject: function fromObject(object) {
        return JSON.parse(object) ? true : false;
    },
    toObject: function toObject(object) {
        var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (debug.use_default && object === undefined) {
            return false;
        }
        return JSON.parse(object) ? true : false;
    }
};

Types.void = {
    fromByteBuffer: function fromByteBuffer(b) {
        throw new Error("(void) undefined type");
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        throw new Error("(void) undefined type");
    },
    fromObject: function fromObject(object) {
        throw new Error("(void) undefined type");
    },
    toObject: function toObject(object) {
        var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (debug.use_default && object === undefined) {
            return undefined;
        }
        throw new Error("(void) undefined type");
    }
};

Types.array = function (st_operation) {
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            var size = b.readVarint32();
            if (HEX_DUMP) {
                console.log("varint32 size = " + size.toString(16));
            }
            var result = [];
            for (var i = 0; 0 < size ? i < size : i > size; 0 < size ? i++ : i++) {
                result.push(st_operation.fromByteBuffer(b));
            }
            return sortOperation(result, st_operation);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            v.required(object);
            object = sortOperation(object, st_operation);
            b.writeVarint32(object.length);
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                st_operation.appendByteBuffer(b, o);
            }
        },
        fromObject: function fromObject(object) {
            v.required(object);
            object = sortOperation(object, st_operation);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push(st_operation.fromObject(o));
            }
            return result;
        },
        toObject: function toObject(object) {
            var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            if (debug.use_default && object === undefined) {
                return [st_operation.toObject(object, debug)];
            }
            v.required(object);
            object = sortOperation(object, st_operation);

            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push(st_operation.toObject(o, debug));
            }
            return result;
        }
    };
};

Types.time_point_sec = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        if (typeof object !== "number") object = Types.time_point_sec.fromObject(object);

        b.writeUint32(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);

        if (typeof object === "number") return object;

        if (object.getTime) return Math.floor(object.getTime() / 1000);

        if (typeof object !== "string") throw new Error("Unknown date type: " + object);

        // if(typeof object === "string" && !/Z$/.test(object))
        //     object = object + "Z"

        return Math.floor(new Date(object).getTime() / 1000);
    },
    toObject: function toObject(object) {
        var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (debug.use_default && object === undefined) return new Date(0).toISOString().split('.')[0];

        v.required(object);

        if (typeof object === "string") return object;

        if (object.getTime) return object.toISOString().split('.')[0];

        var int = parseInt(object);
        v.require_range(0, 0xFFFFFFFF, int, 'uint32 ' + object);
        return new Date(int * 1000).toISOString().split('.')[0];
    }
};

Types.set = function (st_operation) {
    return {
        validate: function validate(array) {
            var dup_map = {};
            for (var i = 0, o; i < array.length; i++) {
                o = array[i];
                var ref;
                if (ref = typeof o === 'undefined' ? 'undefined' : _typeof(o), ['string', 'number'].indexOf(ref) >= 0) {
                    if (dup_map[o] !== undefined) {
                        throw new Error("duplicate (set)");
                    }
                    dup_map[o] = true;
                }
            }
            return sortOperation(array, st_operation);
        },
        fromByteBuffer: function fromByteBuffer(b) {
            var size = b.readVarint32();
            if (HEX_DUMP) {
                console.log("varint32 size = " + size.toString(16));
            }
            return this.validate(function () {
                var result = [];
                for (var i = 0; 0 < size ? i < size : i > size; 0 < size ? i++ : i++) {
                    result.push(st_operation.fromByteBuffer(b));
                }
                return result;
            }());
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            if (!object) {
                object = [];
            }
            b.writeVarint32(object.length);
            var iterable = this.validate(object);
            for (var i = 0, o; i < iterable.length; i++) {
                o = iterable[i];
                st_operation.appendByteBuffer(b, o);
            }
            return;
        },
        fromObject: function fromObject(object) {
            if (!object) {
                object = [];
            }
            return this.validate(function () {
                var result = [];
                for (var i = 0, o; i < object.length; i++) {
                    o = object[i];
                    result.push(st_operation.fromObject(o));
                }
                return result;
            }());
        },
        toObject: function toObject(object) {
            var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            if (debug.use_default && object === undefined) {
                return [st_operation.toObject(object, debug)];
            }
            if (!object) {
                object = [];
            }
            return this.validate(function () {
                var result = [];
                for (var i = 0, o; i < object.length; i++) {
                    o = object[i];
                    result.push(st_operation.toObject(o, debug));
                }
                return result;
            }());
        }
    };
};

// global_parameters_update_operation current_fees
Types.fixed_array = function (count, st_operation) {
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            var i, j, ref, results;
            results = [];
            for (i = j = 0, ref = count; j < ref; i = j += 1) {
                results.push(st_operation.fromByteBuffer(b));
            }
            return sortOperation(results, st_operation);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            var i, j, ref;
            if (count !== 0) {
                v.required(object);
                object = sortOperation(object, st_operation);
            }
            for (i = j = 0, ref = count; j < ref; i = j += 1) {
                st_operation.appendByteBuffer(b, object[i]);
            }
        },
        fromObject: function fromObject(object) {
            var i, j, ref, results;
            if (count !== 0) {
                v.required(object);
            }
            results = [];
            for (i = j = 0, ref = count; j < ref; i = j += 1) {
                results.push(st_operation.fromObject(object[i]));
            }
            return results;
        },
        toObject: function toObject(object, debug) {
            var i, j, k, ref, ref1, results, results1;
            if (debug == null) {
                debug = {};
            }
            if (debug.use_default && object === void 0) {
                results = [];
                for (i = j = 0, ref = count; j < ref; i = j += 1) {
                    results.push(st_operation.toObject(void 0, debug));
                }
                return results;
            }
            if (count !== 0) {
                v.required(object);
            }
            results1 = [];
            for (i = k = 0, ref1 = count; k < ref1; i = k += 1) {
                results1.push(st_operation.toObject(object[i], debug));
            }
            return results1;
        }
    };
};

/* Supports instance numbers (11) or object types (1.2.11).  Object type
Validation is enforced when an object type is used. */
var id_type = function id_type(reserved_spaces, object_type) {
    v.required(reserved_spaces, "reserved_spaces");
    v.required(object_type, "object_type");
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            return b.readVarint32();
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            v.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            // convert 1.2.n into just n
            if (/^[0-9]+\.[0-9]+\.[0-9]+$/.test(object)) {
                object = v.get_instance(reserved_spaces, object_type, object);
            }
            b.writeVarint32(v.to_number(object));
            return;
        },
        fromObject: function fromObject(object) {
            v.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            if (v.is_digits(object)) {
                return v.to_number(object);
            }
            return v.get_instance(reserved_spaces, object_type, object);
        },
        toObject: function toObject(object) {
            var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            var object_type_id = ChainTypes.object_type[object_type];
            if (debug.use_default && object === undefined) {
                return reserved_spaces + '.' + object_type_id + '.0';
            }
            v.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            if (/^[0-9]+\.[0-9]+\.[0-9]+$/.test(object)) {
                object = v.get_instance(reserved_spaces, object_type, object);
            }

            return reserved_spaces + '.' + object_type_id + '.' + object;
        }
    };
};

Types.object_id_type = {
    fromByteBuffer: function fromByteBuffer(b) {
        return ObjectId.fromByteBuffer(b);
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        object = ObjectId.fromString(object);
        object.appendByteBuffer(b);
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        return ObjectId.fromString(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (debug.use_default && object === undefined) {
            return "0.0.0";
        }
        v.required(object);
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        object = ObjectId.fromString(object);
        return object.toString();
    }
};

Types.vote_id = { TYPE: 0x000000FF,
    ID: 0xFFFFFF00,
    fromByteBuffer: function fromByteBuffer(b) {
        var value = b.readUint32();
        return {
            type: value & this.TYPE,
            id: value & this.ID
        };
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        if (object === "string") object = Types.vote_id.fromObject(object);

        var value = object.id << 8 | object.type;
        b.writeUint32(value);
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object, "(type vote_id)");
        if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) === "object") {
            v.required(object.type, "type");
            v.required(object.id, "id");
            return object;
        }
        v.require_test(/^[0-9]+:[0-9]+$/, object, 'vote_id format ' + object);

        var _object$split3 = object.split(':');

        var _object$split4 = _slicedToArray(_object$split3, 2);

        var type = _object$split4[0];
        var id = _object$split4[1];

        v.require_range(0, 0xff, type, 'vote type ' + object);
        v.require_range(0, 0xffffff, id, 'vote id ' + object);
        return { type: type, id: id };
    },
    toObject: function toObject(object) {
        var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (debug.use_default && object === undefined) {
            return "0:0";
        }
        v.required(object);
        if (typeof object === "string") object = Types.vote_id.fromObject(object);

        return object.type + ":" + object.id;
    },
    compare: function compare(a, b) {
        if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== "object") a = Types.vote_id.fromObject(a);
        if ((typeof b === 'undefined' ? 'undefined' : _typeof(b)) !== "object") b = Types.vote_id.fromObject(b);
        return parseInt(a.id) - parseInt(b.id);
    }
};

Types.optional = function (st_operation) {
    v.required(st_operation, "st_operation");
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            if (!(b.readUint8() === 1)) {
                return undefined;
            }
            return st_operation.fromByteBuffer(b);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            if (object !== null && object !== undefined) {
                b.writeUint8(1);
                st_operation.appendByteBuffer(b, object);
            } else {
                b.writeUint8(0);
            }
            return;
        },
        fromObject: function fromObject(object) {
            if (object === undefined) {
                return undefined;
            }
            return st_operation.fromObject(object);
        },
        toObject: function toObject(object) {
            var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            // toObject is only null save if use_default is true
            var result_object = function () {
                if (!debug.use_default && object === undefined) {
                    return undefined;
                } else {
                    return st_operation.toObject(object, debug);
                }
            }();

            if (debug.annotate) {
                if ((typeof result_object === 'undefined' ? 'undefined' : _typeof(result_object)) === "object") {
                    result_object.__optional = "parent is optional";
                } else {
                    result_object = { __optional: result_object };
                }
            }
            return result_object;
        }
    };
};

Types.static_variant = function (_st_operations) {
    return {
        nosort: true,
        st_operations: _st_operations,
        fromByteBuffer: function fromByteBuffer(b) {
            var type_id = b.readVarint32();
            var st_operation = this.st_operations[type_id];
            if (HEX_DUMP) {
                console.error('static_variant id 0x' + type_id.toString(16) + ' (' + type_id + ')');
            }
            v.required(st_operation, 'operation ' + type_id);
            return [type_id, st_operation.fromByteBuffer(b)];
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            v.required(object);
            var type_id = object[0];
            var st_operation = this.st_operations[type_id];
            v.required(st_operation, 'operation ' + type_id);
            b.writeVarint32(type_id);
            st_operation.appendByteBuffer(b, object[1]);
            return;
        },
        fromObject: function fromObject(object) {
            v.required(object);
            var type_id = object[0];
            var st_operation = this.st_operations[type_id];
            v.required(st_operation, 'operation ' + type_id);
            return [type_id, st_operation.fromObject(object[1])];
        },
        toObject: function toObject(object) {
            var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            if (debug.use_default && object === undefined) {
                return [0, this.st_operations[0].toObject(undefined, debug)];
            }
            v.required(object);
            var type_id = object[0];
            var st_operation = this.st_operations[type_id];
            v.required(st_operation, 'operation ' + type_id);
            return [type_id, st_operation.toObject(object[1], debug)];
        }
    };
};

Types.map = function (key_st_operation, value_st_operation) {
    return {
        validate: function validate(array) {
            if (!Array.isArray(array)) {
                throw new Error("expecting array");
            }
            var dup_map = {};
            for (var i = 0, o; i < array.length; i++) {
                o = array[i];
                var ref;
                if (!(o.length === 2)) {
                    throw new Error("expecting two elements");
                }
                if (ref = _typeof(o[0]), ['number', 'string'].indexOf(ref) >= 0) {
                    if (dup_map[o[0]] !== undefined) {
                        throw new Error("duplicate (map)");
                    }
                    dup_map[o[0]] = true;
                }
            }
            return sortOperation(array, key_st_operation);
        },
        fromByteBuffer: function fromByteBuffer(b) {
            var result = [];
            var end = b.readVarint32();
            for (var i = 0; 0 < end ? i < end : i > end; 0 < end ? i++ : i++) {
                result.push([key_st_operation.fromByteBuffer(b), value_st_operation.fromByteBuffer(b)]);
            }
            return this.validate(result);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            this.validate(object);
            b.writeVarint32(object.length);
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                key_st_operation.appendByteBuffer(b, o[0]);
                value_st_operation.appendByteBuffer(b, o[1]);
            }
            return;
        },
        fromObject: function fromObject(object) {
            v.required(object);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push([key_st_operation.fromObject(o[0]), value_st_operation.fromObject(o[1])]);
            }
            return this.validate(result);
        },
        toObject: function toObject(object) {
            var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            if (debug.use_default && object === undefined) {
                return [[key_st_operation.toObject(undefined, debug), value_st_operation.toObject(undefined, debug)]];
            }
            v.required(object);
            object = this.validate(object);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push([key_st_operation.toObject(o[0], debug), value_st_operation.toObject(o[1], debug)]);
            }
            return result;
        }
    };
};

Types.public_key = {
    toPublic: function toPublic(object) {
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        return object == null ? object : object.Q ? object : PublicKey.fromStringOrThrow(object);
    },
    fromByteBuffer: function fromByteBuffer(b) {
        return fp.public_key(b);
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        fp.public_key(b, Types.public_key.toPublic(object));
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        if (object.Q) {
            return object;
        }
        return Types.public_key.toPublic(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (debug.use_default && object === undefined) {
            return ChainConfig.address_prefix + "859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2HqhToVM";
        }
        v.required(object);
        return object.toString();
    },
    compare: function compare(a, b) {
        return strCmp(a.toString(), b.toString());
    }
};

Types.address = {
    _to_address: function _to_address(object) {
        v.required(object);
        if (object.addy) {
            return object;
        }
        return Address.fromString(object);
    },
    fromByteBuffer: function fromByteBuffer(b) {
        return new Address(fp.ripemd160(b));
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        fp.ripemd160(b, Types.address._to_address(object).toBuffer());
        return;
    },
    fromObject: function fromObject(object) {
        return Types.address._to_address(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        if (debug.use_default && object === undefined) {
            return ChainConfig.address_prefix + "664KmHxSuQyDsfwo4WEJvWpzg1QKdg67S";
        }
        return Types.address._to_address(object).toString();
    },
    compare: function compare(a, b) {
        return strCmp(a.toString(), b.toString());
    }
};

var strCmp = function strCmp(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
};
var firstEl = function firstEl(el) {
    return Array.isArray(el) ? el[0] : el;
};
var sortOperation = function sortOperation(array, st_operation) {
    return st_operation.nosort ? array : st_operation.compare ? array.sort(function (a, b) {
        return st_operation.compare(firstEl(a), firstEl(b));
    }) : // custom compare operation
    array.sort(function (a, b) {
        return typeof firstEl(a) === "number" && typeof firstEl(b) === "number" ? firstEl(a) - firstEl(b) :
        // A binary string compare does not work. Performanance is very good so HEX is used..  localeCompare is another option.
        Buffer.isBuffer(firstEl(a)) && Buffer.isBuffer(firstEl(b)) ? strCmp(firstEl(a).toString("hex"), firstEl(b).toString("hex")) : strCmp(firstEl(a).toString(), firstEl(b).toString());
    });
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/dist/serializer/src/types.js","/../node_modules/steemjs-lib/dist/serializer/src")
},{"../../chain/src/ChainConfig":92,"../../chain/src/ChainTypes":93,"../../chain/src/ObjectId":96,"../../ecc":99,"./FastParser":113,"./SerializerValidation":114,"./numberUtils":116,"buffer":11,"pBGvAp":74}],121:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/node_modules/deep-equal/index.js","/../node_modules/steemjs-lib/node_modules/deep-equal")
},{"./lib/is_arguments.js":122,"./lib/keys.js":123,"buffer":11,"pBGvAp":74}],122:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/node_modules/deep-equal/lib/is_arguments.js","/../node_modules/steemjs-lib/node_modules/deep-equal/lib")
},{"buffer":11,"pBGvAp":74}],123:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steemjs-lib/node_modules/deep-equal/lib/keys.js","/../node_modules/steemjs-lib/node_modules/deep-equal/lib")
},{"buffer":11,"pBGvAp":74}],124:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;
var inherits = require('inherits');
var setImmediate = require('process/browser.js').nextTick;
var Readable = require('./readable.js');
var Writable = require('./writable.js');

inherits(Duplex, Readable);

Duplex.prototype.write = Writable.prototype.write;
Duplex.prototype.end = Writable.prototype.end;
Duplex.prototype._write = Writable.prototype._write;

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  var self = this;
  setImmediate(function () {
    self.end();
  });
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/duplex.js","/../node_modules/stream-browserify")
},{"./readable.js":128,"./writable.js":130,"buffer":11,"inherits":71,"pBGvAp":74,"process/browser.js":126}],125:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('./readable.js');
Stream.Writable = require('./writable.js');
Stream.Duplex = require('./duplex.js');
Stream.Transform = require('./transform.js');
Stream.PassThrough = require('./passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/index.js","/../node_modules/stream-browserify")
},{"./duplex.js":124,"./passthrough.js":127,"./readable.js":128,"./transform.js":129,"./writable.js":130,"buffer":11,"events":35,"inherits":71,"pBGvAp":74}],126:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/node_modules/process/browser.js","/../node_modules/stream-browserify/node_modules/process")
},{"buffer":11,"pBGvAp":74}],127:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./transform.js');
var inherits = require('inherits');
inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/passthrough.js","/../node_modules/stream-browserify")
},{"./transform.js":129,"buffer":11,"inherits":71,"pBGvAp":74}],128:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;
Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;
var Stream = require('./index.js');
var Buffer = require('buffer').Buffer;
var setImmediate = require('process/browser.js').nextTick;
var StringDecoder;

var inherits = require('inherits');
inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || n === null) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode &&
      !er) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    setImmediate(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    setImmediate(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    setImmediate(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  // check for listeners before emit removes one-time listeners.
  var errListeners = EE.listenerCount(dest, 'error');
  function onerror(er) {
    unpipe();
    if (errListeners === 0 && EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  dest.once('error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    setImmediate(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      setImmediate(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, function (x) {
      return self.emit.apply(self, ev, x);
    });
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    setImmediate(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/readable.js","/../node_modules/stream-browserify")
},{"./index.js":125,"buffer":11,"events":35,"inherits":71,"pBGvAp":74,"process/browser.js":126,"string_decoder":9}],129:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./duplex.js');
var inherits = require('inherits');
inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/transform.js","/../node_modules/stream-browserify")
},{"./duplex.js":124,"buffer":11,"inherits":71,"pBGvAp":74}],130:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;
Writable.WritableState = WritableState;

var isUint8Array = typeof Uint8Array !== 'undefined'
  ? function (x) { return x instanceof Uint8Array }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'Uint8Array'
  }
;
var isArrayBuffer = typeof ArrayBuffer !== 'undefined'
  ? function (x) { return x instanceof ArrayBuffer }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'ArrayBuffer'
  }
;

var inherits = require('inherits');
var Stream = require('./index.js');
var setImmediate = require('process/browser.js').nextTick;
var Buffer = require('buffer').Buffer;

inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];
}

function Writable(options) {
  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Stream.Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  setImmediate(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    setImmediate(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (!Buffer.isBuffer(chunk) && isUint8Array(chunk))
    chunk = new Buffer(chunk);
  if (isArrayBuffer(chunk) && typeof Uint8Array !== 'undefined')
    chunk = new Buffer(new Uint8Array(chunk));
  
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  state.needDrain = !ret;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    setImmediate(function() {
      cb(er);
    });
  else
    cb(er);

  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      setImmediate(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      setImmediate(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/writable.js","/../node_modules/stream-browserify")
},{"./index.js":125,"buffer":11,"inherits":71,"pBGvAp":74,"process/browser.js":126}],131:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/util/node_modules/inherits/inherits_browser.js","/../node_modules/util/node_modules/inherits")
},{"buffer":11,"pBGvAp":74}],132:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/util/support/isBufferBrowser.js","/../node_modules/util/support")
},{"buffer":11,"pBGvAp":74}],133:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/util/util.js","/../node_modules/util")
},{"./support/isBuffer":132,"buffer":11,"inherits":131,"pBGvAp":74}],134:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
require('./posts')
//require('steemjs-lib')

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_d2eccc0c.js","/")
},{"./posts":137,"buffer":11,"pBGvAp":74}],135:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function (app) {
	app.constant('API_END_POINT','http://api.esteem.ws:8080');
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/posts/config.js","/posts")
},{"buffer":11,"pBGvAp":74}],136:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function (app) {
//angular.module('steem.controllers', [])

app.controller('AppCtrl', function($scope, $ionicModal, $timeout, $rootScope, $state, $ionicHistory, $cordovaSocialSharing, ImageUploadService, $cordovaCamera, $ionicSideMenuDelegate, $ionicPlatform, $filter, APIs, $window, $ionicPopover) {

  $scope.loginData = {};

  $ionicModal.fromTemplateUrl('templates/login.html', {
    scope: $scope  }).then(function(modal) {
    $scope.loginModal = modal;
  });


  $ionicPopover.fromTemplateUrl('templates/popover.html', {
    scope: $scope,
  }).then(function(popover) {
    $scope.menupopover = popover;
  });

  $scope.openMenuPopover = function($event) {
    $scope.menupopover.show($event);
  };
  $scope.closeMenuPopover = function() {
    $scope.menupopover.hide();
  };

  $rootScope.$on('close:popover', function(){
    console.log('close:popover');
    $scope.menupopover.hide();

    $ionicHistory.nextViewOptions({
      disableBack: true
    });
    //$scope.closeMenuPopover();
    //$scope.fetchPosts();
  });

  $scope.$on('$destroy', function() {
    $scope.menupopover.remove();
  });

  $scope.changeUsername = function(){
    $scope.loginData.username = angular.lowercase($scope.loginData.username);
  }
  $scope.open = function(item) {
    item.json_metadata = angular.fromJson(item.json_metadata);
    $rootScope.$storage.sitem = item;
    //console.log(item);

    //$state.go('app.single');*/
    $state.go('app.post', {category: item.category, author: item.author, permlink: item.permlink});
  };
  $scope.advancedChange = function() {
    $rootScope.log(angular.toJson($scope.loginData.advanced));
    if ($scope.loginData.advanced) {
      $scope.loginData.password = null;
    }
  }
  $scope.closeLogin = function() {
    $scope.loginModal.hide();
  };
  
  $scope.openSignUP = function() {
    $scope.chainurl = $rootScope.$storage.chain=='steem'?'https://steemit.com/create_account':'https://golos.io/create_account';
    window.open($scope.chainurl, '_blank', 'location=yes');
    return false;  
  }
  $scope.openLogin = function() {
    if ($rootScope.$storage.language == 'ru-RU') {
      $scope.loginData.chain = "golos";
    } else {
      $scope.loginData.chain = "steem";
    }
    setTimeout(function() {
      $scope.loginModal.show();
    }, 1);
  };
  $scope.goProfile = function() {
    $state.go("app.profile", {username:$rootScope.$storage.user.username});
    //$ionicSideMenuDelegate.toggleLeft();
  }
  $scope.share = function() {
    var host = "";
    if ($rootScope.$storage.chain == 'steem') {
      host = "https://steemit.com/";
    } else {
      host = "https://golos.io/";
    }
    var link = host+$rootScope.$storage.sitem.category+"/@"+$rootScope.$storage.sitem.author+"/"+$rootScope.$storage.sitem.permlink;
    var message = "Hey! Checkout blog post on Steem "+link;
    var subject = "Via eSteem Mobile";
    var file = null;
    $cordovaSocialSharing.share(message, subject, file, link) // Share via native share sheet
    .then(function(result) {
      // Success!
      $rootScope.log("shared");
    }, function(err) {
      // An error occured. Show a message to the user
      $rootScope.log("not shared");
    });
  }


  $scope.loginChain = function(x){
    console.log(x);
    $scope.loginData.chain = x;
  }
  
  $scope.doLogin = function() {
    $rootScope.log('Doing login');
    if ($scope.loginData.password || $scope.loginData.privatePostingKey) {
      $rootScope.$broadcast('show:loading');
      $scope.loginData.username = $scope.loginData.username.trim();
      console.log('doLogin'+$scope.loginData.username+$scope.loginData.password);
      window.Api.close();
      window.Api = null;
      window.steemRPC.Client.close();
      
      var socketUrl = $rootScope.$storage["socket"+$scope.loginData.chain];
      console.log(socketUrl);

      window.Api = window.steemRPC.Client.get({url:socketUrl}, true);
      setTimeout(function() {
        window.Api.initPromise.then(function(response) {
          window.Api.database_api().exec("get_accounts", [[$scope.loginData.username]]).then(function(dd){
            dd = dd[0];
            console.log(dd);
            $scope.loginData.id = dd.id;
            $scope.loginData.owner = dd.owner;
            $scope.loginData.active = dd.active;
            $scope.loginData.reputation = dd.reputation;
            $scope.loginData.posting = dd.posting;
            $scope.loginData.memo_key = dd.memo_key;
            $scope.loginData.post_count = dd.post_count;
            $scope.loginData.voting_power = dd.voting_power;
            $scope.loginData.witness_votes = dd.witness_votes;
            $scope.login = new window[$scope.loginData.chain+"JS"].Login();
            $scope.login.setRoles(["posting"]);
            
            var loginSuccess = $scope.login.checkKeys({
                accountName: $scope.loginData.username,
                password: $scope.loginData.password || null,
                auths: {
                    posting: dd.posting.key_auths
                },
                privateKey: $scope.loginData.privatePostingKey || null
              }
            );

            if (!loginSuccess) {
                $rootScope.$broadcast('hide:loading');
                $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('PASSWORD_INCORRECT'));
            } else {
              $rootScope.$storage.user = $scope.loginData;

              $rootScope.$storage.users.push($rootScope.$storage.user);
              $rootScope.$storage.mylogin = $scope.login;
              APIs.updateSubscription($rootScope.$storage.deviceid, $rootScope.$storage.user.username, {device: ionic.Platform.platform(), timestamp: $filter('date')(new Date(), 'medium'), appversion: $rootScope.$storage.appversion}).then(function(res){
                $rootScope.$broadcast('hide:loading');
                //$state.go($state.current, {}, {reload: true});
                //$state.go('app.posts', {}, { reload: true });
                //$scope.closeLogin();
                $scope.loginModal.hide();
                //$ionicHistory.clearCache();
                //$ionicHistory.clearHistory();
                $rootScope.$broadcast('refreshLocalUserData');
                  
                //window.Api.close();
                //var steemRPC = require("steem-rpc");
                //window.Api = steemRPC.Client.get({url:localStorage.socketUrl}, true);

                //window.Api = steemRPC.Client.get({url:localStorage.socketUrl}, true);
                $rootScope.$storage.chain = $scope.loginData.chain;

                $rootScope.$broadcast('changedChain');
                $rootScope.$broadcast('changedCurrency', {currency: $rootScope.$storage.currency, enforce: true});

                setTimeout(function() {
                  $window.location.reload(true);
                  $rootScope.$broadcast('fetchPosts');
                }, 2000);

              });
            }
            /*if(!$scope.$$phase) {
              $scope.$apply();
            }*/
          });
        });
      }, 1000);
      
    } else {
      $scope.loginModal.hide();
      $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_FAIL'));
    }
  };

  $scope.selectAccount = function(user) {
    $rootScope.$storage.user = user;
    $rootScope.$storage.chain = user.chain;

    $rootScope.$broadcast('changedChain');

    $rootScope.$broadcast('changedCurrency', {currency: $rootScope.$storage.currency, enforce: true});
    
    $rootScope.$broadcast('refreshLocalUserData');
    
    setTimeout(function() {
      $window.location.reload(true);
    }, 2000);
  }

  $rootScope.$on('refreshLocalUserData', function() {
    $rootScope.log('refreshLocalUserData');
    if ($rootScope.$storage.user && $rootScope.$storage.user.username && $rootScope.$storage.user.chain == $rootScope.$storage.chain) {
      window.Api.initPromise.then(function(response) {
        if (typeof window.Api.database_api === "function") {
          window.Api.database_api().exec("get_accounts", [ [ $rootScope.$storage.user.username ] ]).then(function(dd){
            dd = dd[0];
            if (dd && dd.json_metadata) {
              dd.json_metadata = angular.fromJson(dd.json_metadata);
            }
            angular.merge($rootScope.$storage.user, dd);
            if (!$scope.$$phase) {
              $scope.$apply();
            }
            $scope.mcss = ($rootScope.$storage.user.json_metadata && $rootScope.$storage.user.json_metadata.profile && $rootScope.$storage.user.json_metadata.profile.cover_image) ? {'background': 'url('+$rootScope.$storage.user.json_metadata.profile.cover_image+')', 'background-size': 'cover', 'background-position':'fixed'} : null;
          });
        }
      });
    }
  })

  $scope.openPostModal = function() {
    $state.go('app.posts');
    $rootScope.$broadcast('openPostModal');
  }

  $scope.changeView = function(view) {
    $rootScope.$storage.view = view;
    $rootScope.$broadcast('changeView');
  }

  $scope.$on("$ionicView.enter", function(){
    $rootScope.$broadcast('refreshLocalUserData');
  });

  // get app version
  $ionicPlatform.ready(function(){
    if (window.cordova) {
      cordova.getAppVersion.getVersionNumber(function (version) {
        $rootScope.$storage.appversion = version;
      });
    } else {
      $rootScope.$storage.appversion = 'debug';
    }
  });

  $scope.logout = function() {
    if ($rootScope.$storage.users.length>1) {
      angular.forEach($rootScope.$storage.users, function(v,k){
        if (v.chain == $rootScope.$storage.user.chain && v.username == $rootScope.$storage.user.username) {
          $rootScope.$storage.users.splice(k,1);
        }
      });
      $rootScope.$storage.user = $rootScope.$storage.users[0];
    } else {
      $rootScope.$storage.user = undefined;
      $rootScope.$storage.user = null;
      $rootScope.$storage.mylogin = undefined;
      $rootScope.$storage.mylogin = null;
    }
    //make sure user credentials cleared.
    if ($rootScope.$storage.deviceid) {
      APIs.deleteSubscription($rootScope.$storage.deviceid).then(function(res){
        $ionicSideMenuDelegate.toggleLeft();
        $window.location.reload(true);
      });
    } else {
      $ionicSideMenuDelegate.toggleLeft();
      $window.location.reload(true);
    }
    $rootScope.$storage.filter = undefined;
    $rootScope.$storage.tag = undefined;

    $ionicHistory.clearCache();
    $ionicHistory.clearHistory();
  };
  $scope.data = {};
  $ionicModal.fromTemplateUrl('templates/search.html', {
    scope: $scope,
    animation: 'slide-in-down'
  }).then(function(modal) {
    $scope.smodal = modal;
  });

  // Triggered in the login modal to close it
  $scope.closeSmodal = function() {
    $scope.smodal.hide();
    if (!$scope.$$phase) {
      $scope.$apply();
    }
  };

  // Open the login modal
  $scope.openSmodal = function() {
    //if(!$scope.smodal) return;
    $rootScope.$broadcast('close:popover');
    setTimeout(function() {
      $scope.data.type="tag";
      $scope.data.searchResult = [];
      $scope.smodal.show();
    }, 5);
  };
  $scope.clearSearch = function() {
    if ($rootScope.$storage.tag) {
      $rootScope.$storage.tag = undefined;
      $rootScope.$storage.taglimits = undefined;
      $rootScope.$broadcast('close:popover');
      $rootScope.$broadcast('fetchPosts');
    }
  };
  $scope.showMeExtra = function() {
    if ($scope.showExtra) {
      $scope.showExtra = false;
    } else {
      $scope.showExtra = true;
    }
  }
  $scope.search = function() {
    $rootScope.log('Doing search '+$scope.data.search);
    $scope.data.search = angular.lowercase($scope.data.search);
    setTimeout(function() {
      if ($scope.data.search.length > 1) {
        if ($scope.data.type == "tag"){
          window.Api.initPromise.then(function(response) {
            window.Api.database_api().exec("get_trending_tags", [$scope.data.search, 15]).then(function(result){
              var ee = [];
              //console.log(result);
              /*if (result){
                var ll = result.length;
                for (var i = ll - 1; i >= 0; i--) {
                  if (result[i].name.indexOf($scope.data.search) > -1){
                    ee.push(result[i]);
                  }
                }
                $scope.data.searchResult = ee;
              }*/
              $scope.data.searchResult = result;

              if (!$scope.$$phase) {
                $scope.$apply();
              }
            });
          });
        }
        if ($scope.data.type == "user"){
          var ee = [];
          window.Api.initPromise.then(function(response) {
            window.Api.database_api().exec("lookup_accounts", [$scope.data.search, 15]).then(function(result){
              if (result){
                $scope.data.searchResult = result;
              }

                if (!$scope.$$phase) {
                  $scope.$apply();
                }
            });
          });
        }

      }
    }, 5);

  };
  $scope.typechange = function() {
    $scope.data.searchResult = undefined;
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $rootScope.log("changing search type");
  }
  $scope.openTag = function(xx, yy) {
    $rootScope.log("opening tag "+xx);
    $rootScope.$storage.tag = xx;
    $rootScope.$storage.taglimits = yy;
    if ($scope.smodal.isShown()){
      $scope.closeSmodal();
    }
    $rootScope.$broadcast('close:popover');
    $state.go("app.posts", {tags: xx});
  };
  $scope.openUser = function(xy) {
    $rootScope.log("opening user "+xy);
    $scope.closeSmodal();
    $rootScope.$broadcast('close:popover');
    $state.go("app.profile", {username: xy});
  };
  $scope.testfunction = function() {
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_account_history", [$rootScope.$storage.user.username, -1, 25]).then(function(response){
        $rootScope.log(angular.toJson(response));
      });
    });
  }

})

app.controller('SendCtrl', function($scope, $rootScope, $state, $ionicPopup, $ionicPopover, $interval, $filter, $q, $timeout, $cordovaBarcodeScanner, $ionicPlatform) {

  if ($rootScope.$storage.chain == "steem") {
    $scope.data = {types: [{type: "steem", name:"Steem", id:1},{type: "sbd", name:"Steem Dollar", id:2}, {type: "sp", name:"Steem Power", id:3}], type: "steem", amount: 0.001};
  } else {
    $scope.data = {types: [{type: "golos", name: "ГОЛОС", id:1},{type: "gbg", name:"ЗОЛОТОЙ", id:2}, {type: "golosp", name:"СИЛА ГОЛОСА", id:3}], type: "golos", amount: 0.001};
  }
  $scope.changeUsername = function(typed) {
    $rootScope.log('searching');
    $scope.data.username = angular.lowercase($scope.data.username);
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("lookup_account_names", [[$scope.data.username]]).then(function(response){
        $scope.users = response[0];
        if (!$scope.$$phase) {
          $scope.$apply();
        }
      });
    });
  }
  $scope.qrScan = function() {
    $ionicPlatform.ready(function() {
      $cordovaBarcodeScanner.scan({
          "preferFrontCamera" : false, // iOS and Android
          "showFlipCameraButton" : false, // iOS and Android
          "prompt" : $filter('translate')('QR_TEXT'), // supported on Android only
          "formats" : "QR_CODE" // default: all but PDF_417 and RSS_EXPANDED
          //"orientation" : "landscape" // Android only (portrait|landscape), default unset so it rotates with the device
        }).then(function(barcodeData) {
        //alert(barcodeData);
        if (barcodeData.text.indexOf('?amount')>-1) {
          //steem dollar:blocktrades?amount=12.080

          $scope.data.username = barcodeData.text.split(':')[1].split('?')[0].trim();
          $scope.data.amount = Number(barcodeData.text.split('=')[1]);
          if (barcodeData.text.split(':')[0]==='steem dollar') {
            $scope.data.type = 'sbd';
          }
          if (barcodeData.text.split(':')[0]==='steem') {
            $scope.data.type = 'steem';
          }
          if (barcodeData.text.split(':')[0]==='steem power') {
            $scope.data.type = 'sp';
          }

        } else {
          $scope.data.username = barcodeData.text;
        }
        $scope.changeUsername();
      }, function(error) {
        $rootScope.showMessage('Error',angular.toJson(error));
      });
    });
  };
  $scope.transfer = function () {
    if ($rootScope.$storage.user) {
      if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
        $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('ACTIVE_KEY_REQUIRED_TEXT'));
      } else {
        if ($scope.data.type === 'sbd' || $scope.data.type === 'gbg') {
          if ($scope.data.amount > Number($scope.balance.sbd_balance.split(" ")[0])) {
            $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('BALANCE_TEXT'));
          } else {
            $scope.okbalance = true;
          }
        }
        if ($scope.data.type === 'sp' || $scope.data.type === 'steem' || $scope.data.type === 'golos' || $scope.data.type === 'golosp') {
          if ($scope.data.amount > Number($scope.balance.balance.split(" ")[0])) {
            $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('BALANCE_TEXT'));
          } else {
            $scope.okbalance = true;
          }
        }
        if (!$scope.users || $scope.users.name !== $scope.data.username) {
          $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('NONEXIST_USER'));
        } else {
          $scope.okuser = true;
        }
        if ($scope.okbalance && $scope.okuser) {
          var confirmPopup = $ionicPopup.confirm({
            title: $filter('translate')('CONFIRMATION'),
            template: $filter('translate')('TRANSFER_TEXT')
          });

          confirmPopup.then(function(res) {
            if(res) {
              $rootScope.log('You are sure');
              $rootScope.$broadcast('show:loading');
              $scope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
              $scope.mylogin.setRoles(["active"]);
              var loginSuccess = $scope.mylogin.checkKeys({
                  accountName: $rootScope.$storage.user.username,
                  password: $rootScope.$storage.user.password || null,
                  auths: {
                    active: $rootScope.$storage.user.active.key_auths
                  },
                  privateKey: $rootScope.$storage.user.privateActiveKey || null
                }
              );
              if (loginSuccess) {
                var tr = new window[$rootScope.$storage.chain+"JS"].TransactionBuilder();
                if ($scope.data.type !== 'sp' && $scope.data.type !== 'golosp') {

                  var tt = $filter('number')($scope.data.amount) +" "+angular.uppercase($scope.data.type);
                  tr.add_type_operation("transfer", {
                    from: $rootScope.$storage.user.username,
                    to: $scope.data.username,
                    amount: tt,
                    memo: $scope.data.memo || ""
                  });
                  localStorage.error = 0;
                  tr.process_transaction($scope.mylogin, null, true);
                  setTimeout(function() {
                    if (localStorage.error == 1) {
                      $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                    } else {
                      $rootScope.showAlert($filter('translate')('INFO'), $filter('translate')('TX_BROADCASTED')).then(function(){
                        $scope.data.type=$rootScope.$storage.chain;
                        $scope.data.amount= 0.001;
                      });
                    }
                  }, 3000);
                } else {
                  var tt = $filter('number')($scope.data.amount) + " "+$filter('uppercase')($rootScope.$storage.chain);
                  tr.add_type_operation("transfer_to_vesting", {
                    from: $rootScope.$storage.user.username,
                    to: $scope.data.username,
                    amount: tt
                  });
                  localStorage.error = 0;
                  tr.process_transaction($scope.mylogin, null, true);
                  setTimeout(function() {
                    if (localStorage.error == 1) {
                      $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                    } else {
                      $rootScope.showAlert($filter('translate')('INFO'), $filter('translate')('TX_BROADCASTED')).then(function(){
                        $scope.data.type=$rootScope.$storage.chain;
                        $scope.data.amount= 0.001;
                      });
                    }
                  }, 3000);

                }
              } else {
                $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
              }
              $rootScope.$broadcast('hide:loading');
             } else {
               $rootScope.log('You are not sure');
             }
          });
        }
      }
    } else {
      $rootScope.$broadcast('hide:loading');
      $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
    }
  };
  $scope.refresh = function() {
    $rootScope.$broadcast('show:loading');
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_accounts", [ [ $rootScope.$storage.user.username ] ]).then(function(dd){
        $scope.balance = dd[0];
        console.log($scope.balance);
        $rootScope.$broadcast('hide:loading');
        if (!$scope.$$phase){
          $scope.$apply();
        }
      });
    });
    $rootScope.$broadcast('hide:loading');
  }
  $scope.$on('$ionicView.beforeEnter', function(){
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_accounts", [ [ $rootScope.$storage.user.username ] ]).then(function(dd){
        $scope.balance = dd[0];
        if (!$scope.$$phase){
          $scope.$apply();
        }
      });
    });
  });

});
app.controller('PostsCtrl', function($scope, $rootScope, $state, $ionicPopup, $ionicPopover, $interval, $ionicScrollDelegate, $ionicModal, $filter, $stateParams, $ionicSlideBoxDelegate, $ionicActionSheet, $ionicPlatform, $cordovaCamera, ImageUploadService, $filter, $ionicHistory, $timeout, APIs, $translate) {

  var formatToPercentage = function (value) {
    return value + '%';
  };

  $scope.pslider = {
    value: $rootScope.$storage.voteWeight/100,
    options: {
      floor: 1,
      ceil: 100,
      translate: formatToPercentage,
      showSelectionBar: true
    }
  };
  
  $ionicPopover.fromTemplateUrl('popoverSlider.html', {
      scope: $scope
  }).then(function(popover) {
      $scope.tooltipSlider = popover;
  });
  
  $scope.openSlider = function($event) {
    $scope.pslider = {
      value: $rootScope.$storage.voteWeight/100,
      options: {
        floor: 1,
        ceil: 100,
        translate: formatToPercentage,
        showSelectionBar: true
      }
    };
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $scope.tooltipSlider.show($event);
  };

  $scope.closeSlider = function() {
    $scope.tooltipSlider.hide();
  };

  $scope.$watch('pslider', function(newValue, oldValue){
    //console.log(newValue.value);
    if (newValue.value) {
      $rootScope.$storage.voteWeight = newValue.value*100;
    }
  }, true);


  $scope.options = {
    loop: false,
    speed: 500,
    /*pagination: false,*/
    showPager: false,
    slidesPerView: 3,
    spaceBetween: 20,
    breakpoints: {
      1024: {
          slidesPerView: 5,
          spaceBetween: 15
      },
      768: {
          slidesPerView: 4,
          spaceBetween: 10
      },
      640: {
          slidesPerView: 3,
          spaceBetween: 5
      },
      320: {
          slidesPerView: 3,
          spaceBetween: 3
      }
    }
  }


  $rootScope.$on('filter:change', function() {
    //$rootScope.$broadcast('show:loading');
    $rootScope.log($rootScope.$storage.filter);
    var type = $rootScope.$storage.filter || "trending";
    var tag = $rootScope.$storage.tag || "";
    console.log(type, $scope.limit, tag);
    $scope.fetchPosts(type, $scope.limit, tag);
  });

  $scope.filterChanged = function(t) {
    var fil = $scope.mymenu[t].custom;
    $rootScope.$storage.filter = fil;
    angular.forEach($scope.mymenu, function(v,k){
      if (v.custom == fil) {
        $rootScope.$storage.filterName = v.text;
      }
    });
    $scope.data = [];
    $scope.error = false;
    $rootScope.$broadcast('filter:change');
  }
  $scope.showFilter = function() {
    var filterSheet = $ionicActionSheet.show({
     buttons: $scope.mymenu,
     titleText: $filter('translate')('SORT_POST_BY'),
     cancelText: $filter('translate')('CANCEL'),
     cancel: function() {
        // add cancel code..
      },
     buttonClicked: function(index) {
        $scope.filterChanged(index);
        return true;
     }
    });
  }

  $ionicPopover.fromTemplateUrl('popoverT.html', {
      scope: $scope
  }).then(function(popover) {
    $scope.tooltip = popover;
  });

  $scope.openTooltip = function($event, d) {
    var tppv = Number(d.total_pending_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var p = Number(d.promoted.split(' ')[0])*$rootScope.$storage.currencyRate;
    var tpv = Number(d.total_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var ar = Number(d.total_payout_value.split(' ')[0]-d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var crp = Number(d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var texth = "<div class='row'><div class='col'><b>"+$filter('translate')('PAYOUT_CYCLE')+"</b></div><div class='col'>"+d.mode.replace('_',' ')+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('POTENTIAL_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tppv, 3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PROMOTED')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(p,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAST_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tpv,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('AUTHOR_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(ar,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('CURATION_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(crp,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAYOUT')+"</b></div><div class='col'>"+$filter('timeago')(d.cashout_time, true)+"</div></div>";
    $scope.tooltipText = texth;
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $scope.tooltip.show($event);
  };

  $scope.closeTooltip = function() {
      $scope.tooltip.hide();
  };

   //Cleanup the popover when we're done with it!
   $scope.$on('$destroy', function() {
      $scope.tooltip.remove();
   });

   // Execute action on hide popover
   $scope.$on('popover.hidden', function() {
      // Execute action
      $scope.tooltipText = undefined;
   });

   // Execute action on remove popover
   $scope.$on('popover.removed', function() {
      // Execute action
   });

  $ionicModal.fromTemplateUrl('templates/story.html', { scope: $scope  }).then(function(modal) {
      $scope.modalp = modal;
  });
  $scope.lastFocused;

  $rootScope.$on('openPostModal', function() {

    $rootScope.$broadcast('close:popover');

    $scope.spost = $rootScope.$storage.spost || $scope.spost;

    

    $timeout(function(){
      if (!$scope.spost.operation_type) {
        $scope.spost.operation_type = 'default';
      }
      $scope.tagsChange();

      $scope.modalp.show();
      /*angular.element("textarea").focus(function() {
        $scope.lastFocused = document.activeElement;
        //console.log(document);
      });*/
    }, 10);
    //$scope.modalp.show();
  });

  $rootScope.$on('closePostModal', function() {
    $scope.modalp.hide();
  });

  $scope.closePostModal = function() {
    //$scope.$broadcast('close:popover');
    $scope.modalp.hide();
  };


  $scope.cfocus = function(){
    $scope.lastFocused = document.activeElement;
  }
  //http://stackoverflow.com/questions/1064089/inserting-a-text-where-cursor-is-using-javascript-jquery
  $scope.insertText = function(text) {
    var input = $scope.lastFocused;
    //console.log(input);
    if (input == undefined) { return; }
    var scrollPos = input.scrollTop;
    var pos = 0;
    var browser = ((input.selectionStart || input.selectionStart == "0") ?
                   "ff" : (document.selection ? "ie" : false ) );
    if (browser == "ie") {
      input.focus();
      var range = document.selection.createRange();
      range.moveStart ("character", -input.value.length);
      pos = range.text.length;
    }
    else if (browser == "ff") { pos = input.selectionStart };

    var front = (input.value).substring(0, pos);
    var back = (input.value).substring(pos, input.value.length);
    input.value = front+text+back;
    pos = pos + text.length;
    if (browser == "ie") {
      input.focus();
      var range = document.selection.createRange();
      range.moveStart ("character", -input.value.length);
      range.moveStart ("character", pos);
      range.moveEnd ("character", 0);
      range.select();
    }
    else if (browser == "ff") {
      input.selectionStart = pos;
      input.selectionEnd = pos;
      input.focus();
    }
    input.scrollTop = scrollPos;
    //console.log(angular.element(input).val());
    angular.element(input).trigger('input');
  }


  $scope.showImg = function() {
   var hideSheet = $ionicActionSheet.show({
     buttons: [
       { text: $filter('translate')('CAPTURE_PICTURE') },
       { text: $filter('translate')('SELECT_PICTURE') },
       { text: $filter('translate')('SET_CUSTOM_URL') },
       { text: $filter('translate')('GALLERY') }
     ],
     titleText: $filter('translate')('INSERT_PICTURE'),
     cancelText: $filter('translate')('CANCEL'),
     cancel: function() {
        // add cancel code..
      },
     buttonClicked: function(index) {
        $scope.insertImage(index);
        return true;
     }
   });
  };
  $scope.insertImage = function(type) {
    var options = {};

    if (type == 0 || type == 1) {
      options = {
        quality: 50,
        destinationType: Camera.DestinationType.FILE_URI,
        sourceType: (type===0)?Camera.PictureSourceType.CAMERA:Camera.PictureSourceType.PHOTOLIBRARY,
        allowEdit: (type===0)?true:false,
        encodingType: Camera.EncodingType.JPEG,
        popoverOptions: CameraPopoverOptions,
        saveToPhotoAlbum: false
        //correctOrientation:true
      };
      $cordovaCamera.getPicture(options).then(function(imageData) {
        setTimeout(function() {
          ImageUploadService.uploadImage(imageData).then(function(result) {
            //var url = result.secure_url || '';
            var url = result.imageUrl || '';
            var final = " ![image](" + url + ")";
            /*if ($scope.spost.body) {
              $scope.spost.body += final;
            } else {
              $scope.spost.body = final;
            }*/
            $scope.insertText(final);
            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
              $cordovaCamera.cleanup();
            }
          },
          function(err) {
            $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('UPLOAD_ERROR'));
            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
              $cordovaCamera.cleanup();
            }
          });
        }, 10);
      }, function(err) {
        $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('CAMERA_CANCELLED'));
      });
    } else if (type == 2){
      $ionicPopup.prompt({
        title: $filter('translate')('SET_URL'),
        template: $filter('translate')('DIRECT_LINK_PICTURE'),
        inputType: 'text',
        inputPlaceholder: 'http://example.com/image.jpg'
      }).then(function(res) {
        $rootScope.log('Your url is' + res);
        if (res) {
          var url = res.trim();
          var final = " ![image](" + url + ")";
          /*if ($scope.spost.body) {
            $scope.spost.body += final;
          } else {
            $scope.spost.body = final;
          }*/
          $scope.insertText(final);
        }
      });
    } else {
      $scope.gallery = [];
      APIs.fetchImages($rootScope.$storage.user.username).then(function(res){
        var imgs = res.data;
        if (imgs.length>0){
          $scope.showgallery = true;
          $scope.gallery.images = imgs;
        } else {
          $scope.showgallery = false;
          $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('NO_IMAGE'));
          console.log('no images available')
        }
      });
    }
  };
  $scope.closeGallery = function(){
    $scope.showgallery = false;
  }
  $scope.manageGallery = function(){
    $rootScope.$broadcast('closePostModal');
    $state.go('app.images');
  }
  function slug(text) {
    return getSlug(text, {truncate: 128});
  };
  function createPermlink(title) {
    var permlink;
    var t = new Date();
    var timeformat = t.getFullYear().toString()+(t.getMonth()+1).toString()+t.getDate().toString()+"t"+t.getHours().toString()+t.getMinutes().toString()+t.getSeconds().toString()+t.getMilliseconds().toString()+"z";
    if (title && title.trim() !== '') {
      var s = slug(title);
      permlink = s.toString()+"-"+timeformat;
      if(permlink.length > 255) {
        // STEEMIT_MAX_PERMLINK_LENGTH
        permlink = permlink.substring(permlink.length - 255, permlink.length)
      }
      // only letters numbers and dashes shall survive
      permlink = permlink.toLowerCase().replace(/[^a-z0-9-]+/g, '')
      return permlink;
    }
  };
  //$scope.operation_type = 'default';
  $scope.spost = {};
  $scope.tagsChange = function() {
    $rootScope.log("tagsChange");
    $scope.spost.tags = $filter('lowercase')($scope.spost.tags);
    $scope.spost.category = $scope.spost.tags?$scope.spost.tags.split(" "):[];
    if ($scope.spost.category.length > 5) {
      $scope.disableBtn = true;
    } else {
      $scope.disableBtn = false;
    }
  }
  $scope.contentChanged = function (editor, html, text) {
    //console.log($scope.spost.body);
    //console.log('editor: ', editor, 'html: ', html, 'text:', text);
  };

  $scope.submitStory = function() {
    //console.log($scope.spost.body);
    $scope.tagsChange();
    if (!$scope.$$phase){
      $scope.$apply();
    }
    $rootScope.$broadcast('show:loading');
    if ($rootScope.$storage.user) {
      $scope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
      $scope.mylogin.setRoles(["posting"]);
      var loginSuccess = $scope.mylogin.checkKeys({
          accountName: $rootScope.$storage.user.username,
          password: $rootScope.$storage.user.password || null,
          auths: {
              posting: $rootScope.$storage.user.posting.key_auths
          },
          privateKey: $rootScope.$storage.user.privatePostingKey || null
        }
      );
      if (loginSuccess) {
        var tr = new window[$rootScope.$storage.chain+"JS"].TransactionBuilder();
        var permlink = createPermlink($scope.spost.title);
        var json = $filter("metadata")($scope.spost.body);
        angular.merge(json, {tags: $scope.spost.category, app: 'esteem/'+$rootScope.$storage.appversion, format: 'markdown+html' });

        if (!$scope.spost.operation_type) {
          $scope.spost.operation_type = 'default';
        }
        if ($scope.spost.operation_type !== 'default') {
          //console.log('NOT Default');
          tr.add_type_operation("comment", {
            parent_author: "",
            parent_permlink: $scope.spost.category[0],
            author: $rootScope.$storage.user.username,
            permlink: permlink,
            title: $scope.spost.title,
            body: $scope.spost.body,
            json_metadata: angular.toJson(json)
          });
          tr.add_type_operation("comment_options", {
            allow_curation_rewards: true,
            allow_votes: true,
            author: $rootScope.$storage.user.username,
            permlink: permlink,
            max_accepted_payout: $scope.spost.operation_type==='sp'?"1000000.000 "+$rootScope.$storage.platformdunit:"0.000 "+$rootScope.$storage.platformdunit,
            percent_steem_dollars: $scope.spost.operation_type==='sp'?0:10000
          });
        } else {
          //console.log('default');
          tr.add_type_operation("comment", {
            parent_author: "",
            parent_permlink: $scope.spost.category[0],
            author: $rootScope.$storage.user.username,
            permlink: permlink,
            title: $scope.spost.title,
            body: $scope.spost.body,
            json_metadata: angular.toJson(json)
          });
        }

        localStorage.error = 0;
        tr.process_transaction($scope.mylogin, null, true);
        $scope.replying = false;
        setTimeout(function() {
          $rootScope.$broadcast('hide:loading');
          if (localStorage.error == 1) {
            $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
          } else {
            //$scope.closePostModal();
            $rootScope.$broadcast('closePostModal');

            //$scope.menupopover.hide();
            $rootScope.$broadcast('close:popover');
            $scope.spost = {};
            $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_SUBMITTED'));
            //$scope.closeMenuPopover();
            $state.go("app.profile", {username: $rootScope.$storage.user.username});
          }
        }, 3000);
      } else {
        $rootScope.$broadcast('hide:loading');
        $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
      }
    } else {
      $rootScope.$broadcast('hide:loading');
      $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
    }
  }
  $scope.savePost = function() {
    console.log($scope.modalp);
    $rootScope.$storage.spost = $scope.spost;
    //adddraft
    var dr = {title:$scope.spost.title, body: $scope.spost.body, tags: $scope.spost.tags, post_type: $scope.spost.operation_type};
    APIs.addDraft($rootScope.$storage.user.username, dr).then(function(res){
      console.log(res.data);
      //$scope.drafts = res.data;
    });
    $rootScope.$broadcast('closePostModal');
    $rootScope.$broadcast('close:popover');
    $scope.modalp.hide();
    $rootScope.showMessage($filter('translate')('SAVED'), $filter('translate')('POST_LATER'));
  }
  $scope.clearPost = function() {
    $rootScope.$storage.spost = {};
    $scope.spost = {};
    $rootScope.showMessage($filter('translate')('CLEARED'), $filter('translate')('POST'));
  }


  $rootScope.$on('fetchPosts', function(){
    $scope.fetchPosts();
  });

  $rootScope.$on('fetchContent', function(event, args) {
    var post = args.any;
    //console.log(post);
    $scope.fetchContent(post.author, post.permlink);
  });

  $scope.votePost = function(post) {
    $rootScope.votePost(post, 'upvote', 'fetchContent');
    if (!$scope.$$phase) {
      $scope.$apply();
    }
  };

  $scope.downvotePost = function(post) {

    var confirmPopup = $ionicPopup.confirm({
      title: $filter('translate')('ARE_YOU_SURE'),
      template: $filter('translate')('FLAGGING_TEXT')
    });
    confirmPopup.then(function(res) {
      if(res) {
        $rootScope.log('You are sure');
        $rootScope.votePost(post, 'downvote', 'fetchContent');
      } else {
        $rootScope.log('You are not sure');
      }
    });

  };

  $scope.unvotePost = function(post) {
    $rootScope.votePost(post, 'unvote', 'fetchContent');
  };


  $rootScope.$on("user:logout", function(){
    $scope.fetchPosts();
    $rootScope.$broadcast('filter:change');
  });

  $scope.loadMore = function() {
    //$rootScope.$broadcast('show:loading');
    $scope.limit += 5;
    //if (!$scope.error) {
    $scope.fetchPosts(null, $scope.limit, null);
    //}
  };
  $scope.refresh = function(){
    $scope.limit = 10;
    //if (!$scope.error) {
    $scope.fetchPosts(null, $scope.limit, null);
    $scope.$broadcast('scroll.refreshComplete');
  }

  $scope.$on('$stateChangeSuccess', function() {
    $scope.loadMore();
  });

  $scope.moreDataCanBeLoaded = function(){
    return !$scope.error;
  }

  $rootScope.$on('changeView', function(){
    //$scope.menupopover.hide();
    $rootScope.$broadcast('close:popover');
    if (!$scope.$$phase){
      $scope.$apply();
    }
    if ($rootScope.$storage.view === 'card') {
      angular.forEach($scope.data, function(v,k){
        v.json_metadata = angular.fromJson(v.json_metadata);
      });
    }
  });

  function arrayObjectIndexOf(myArray, searchTerm, property) {
    var llen = myArray.length;
    for(var i = 0; i < llen; i++) {
        if (myArray[i][property] === searchTerm) return i;
    }
    return -1;
  }
  $scope.data = [];
  $scope.tempData = [];

  $scope.dataChanged = function(newValue) {
    if (newValue) {
      var lenn = newValue.length;
      var user = $rootScope.$storage.user || null;
      var view = $rootScope.$storage.view;

      if (user){
        for (var i = 0; i < lenn; i++) {
          if (newValue[i] && newValue[i].active_votes) {
            var len = newValue[i].active_votes.length-1;
            for (var j = len; j >= 0; j--) {
              if (newValue[i].active_votes[j].voter === user.username) {
                if (newValue[i].active_votes[j].percent > 0) {
                  newValue[i].upvoted = true;
                } else if (newValue[i].active_votes[j].percent < 0) {
                  newValue[i].downvoted = true;
                } else {
                  newValue[i].downvoted = false;
                  newValue[i].upvoted = false;
                }
              }
            }
          }
          if (view === 'card') {
            if (newValue[i].json_metadata){
              newValue[i].json_metadata = angular.fromJson(newValue[i].json_metadata);
            }
          }
        }
      } else {
        if (view === 'card') {
          for (var i = 0; i < lenn; i++) {
            if (newValue[i].json_metadata){
              newValue[i].json_metadata = angular.fromJson(newValue[i].json_metadata);
            }
          }
        }
      }
      return newValue;
    }
  }

  $scope.fetchContent = function(author, permlink) {
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_content", [author, permlink]).then(function(result){
        var len = result.active_votes.length;
        var user = $rootScope.$storage.user;
        if (user) {
          for (var j = len - 1; j >= 0; j--) {
            if (result.active_votes[j].voter === user.username) {
              if (result.active_votes[j].percent > 0) {
                result.upvoted = true;
              } else if (result.active_votes[j].percent < 0) {
                result.downvoted = true;
              } else {
                result.downvoted = false;
                result.upvoted = false;
              }
            }
          }
        }
        result.json_metadata = angular.fromJson(result.json_metadata);
        angular.forEach($scope.data, function(value, key) {
          if (value.permlink === result.permlink) {
            $scope.data[key] = result;
          }
        });
        $rootScope.$broadcast('hide:loading');
        if (!$scope.$$phase) {
          $scope.$apply();
        }
      });
    });
  }
  $scope.ifExists = function(xx){
    for (var i = 0; i < $scope.data.length; i++) {
      if ($scope.data[i].permlink === xx){
        return true;
      }
    }
    return false;
  }
  $scope.fetchPosts = function(type, limit, tag) {
    type = type || $rootScope.$storage.filter || "trending";
    tag = tag || $rootScope.$storage.tag || "";
    limit = 10;//limit || $scope.limit || 10;

    var params = {};

    if (type === "feed" && $rootScope.$storage.user) {
      params = {tag: $rootScope.$storage.user.username, limit: limit, filter_tags: []};
    } else {
      if ($rootScope.$storage.filter === "feed") {
        $rootScope.$storage.filter = "trending";
        type = "trending";
      }
      params = {tag: tag, limit: limit, filter_tags: []};
    }
    if ($scope.data && $scope.data.length>0) {
      params.start_author = $scope.data[$scope.data.length-1].author;
      params.start_permlink = $scope.data[$scope.data.length-1].permlink;
    }
    if ($scope.error) {
      //$rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('REQUEST_LIMIT_TEXT'));
      $scope.$broadcast('scroll.infiniteScrollComplete');
      $rootScope.$broadcast('hide:loading');
    } else {
      window.Api.initPromise.then(function(response) {
        $rootScope.log("fetching..."+type+" "+limit+" "+tag);
        if (typeof window.Api.database_api === "function") {
          /*window.Api.database_api().exec("get_state", ["/"+type]).then(function(response){
            console.log(response);
          });*/
          window.Api.database_api().exec("get_discussions_by_"+type, [params]).then(function(response){
            console.log(response);
            if (response.length <= 1) {
              $scope.error = true;
            }
            if (response) {
              for (var i = 0; i < response.length; i++) {
                response[i].json_metadata = response[i].json_metadata?angular.fromJson(response[i].json_metadata):response[i].json_metadata;
                var permlink = response[i].permlink;
                if (!$scope.ifExists(permlink)) {
                  var user = $rootScope.$storage.user || undefined;
                  if (user) {
                    //console.log('exist');
                    if (response[i] && response[i].active_votes) {
                      var len = response[i].active_votes.length-1;
                      for (var j = 0; j < len; j++) {
                        if (response[i].active_votes[j].voter === user.username) {
                          if (response[i].active_votes[j].percent > 0) {
                            response[i].upvoted = true;
                          } else if (response[i].active_votes[j].percent < 0) {
                            response[i].downvoted = true;
                          } else {
                            response[i].downvoted = false;
                            response[i].upvoted = false;
                          }
                        }
                      }
                    }
                  }
                  $scope.data.push(response[i]);
                }
              }
            }

            if (!$scope.$$phase) {
              $scope.$apply();
            }
            //console.log($scope.data.length);
            $scope.$broadcast('scroll.infiniteScrollComplete');
            $rootScope.$broadcast('hide:loading');
          });
        }
      });
    }
  };

  $scope.$on('$ionicView.loaded', function(){
    $scope.limit = 10;
    //$rootScope.$broadcast('show:loading');
    if (!$rootScope.$storage["socket"+$rootScope.$storage.chain]) {
      $rootScope.$storage["socket"+$rootScope.$storage.chain] = localStorage.socketUrl;
    }
    if (!$rootScope.$storage.view) {
      $rootScope.$storage.view = 'card';
    }
    if (!$rootScope.$storage.filter) {
      $rootScope.$storage.filter = "trending";
    }
    if (window.Api) {
      /*if (!angular.isDefined($rootScope.timeint)) {
        window.Api.initPromise.then(function(response) {
          $rootScope.log("Api ready:" + angular.toJson(response));
          $rootScope.timeint = $interval(function(){
            window.Api.database_api().exec("get_dynamic_global_properties", []).then(function(response){
              $rootScope.log("get_dynamic_global_properties "+ response.head_block_number);
              if ($rootScope.$storage.user) {
                $scope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
                $scope.mylogin.setRoles(["posting"]);
                var loginSuccess = $scope.mylogin.checkKeys({
                    accountName: $rootScope.$storage.user.username,
                    password: $rootScope.$storage.user.password || null,
                    auths: {
                        posting: $rootScope.$storage.user.posting.key_auths
                    },
                    privateKey: $rootScope.$storage.user.privatePostingKey || null
                  }
                );
                $rootScope.log("login "+loginSuccess);
              }
            });
          }, 15000);
          $rootScope.$broadcast('fetchPosts');
        });
      }*/
    }

    setTimeout(function() {
      $ionicScrollDelegate.$getByHandle('mainScroll').scrollTop();
    }, 10);
  });

  $scope.$on('$ionicView.beforeEnter', function(){
    if ($stateParams.tags) {
      $rootScope.$storage.tag = $stateParams.tags;
    }
    if (!angular.isDefined($rootScope.$storage.language)) {
      if(typeof navigator.globalization !== "undefined") {
          navigator.globalization.getPreferredLanguage(function(language) {
              $translate.use((language.value).split("-")[0]).then(function(data) {
                  console.log("SUCCESS -> " + data);
                  $rootScope.$storage.language = language.value.split('-')[0];
              }, function(error) {
                  console.log("ERROR -> " + error);
              });
          }, null);
      } else {
        $rootScope.$storage.language = 'en';
      }
    } else {
      $translate.use($rootScope.$storage.language);
    }

    $scope.activeMenu = $rootScope.$storage.filter || "trending";
    $scope.mymenu = $rootScope.$storage.user ? [{text: $filter('translate')('FEED'), custom:'feed'}, {text: $filter('translate')('TRENDING'), custom:'trending'}, {text: $filter('translate')('HOT'), custom:'hot'}, {text: $filter('translate')('NEW'), custom:'created'}, {text: $filter('translate')('ACTIVE'), custom:'active'}, {text: $filter('translate')('PROMOTED'), custom: 'promoted'}, {text: $filter('translate')('TRENDING_30'), custom:'trending30'}, {text:$filter('translate')('VOTES'), custom:'votes'}, {text: $filter('translate')('COMMENTS'), custom:'children'}, {text: $filter('translate')('PAYOUT'), custom: 'cashout'}] : [ {text: $filter('translate')('TRENDING'), custom:'trending'}, {text: $filter('translate')('HOT'), custom:'hot'}, {text: $filter('translate')('NEW'), custom:'created'}, {text: $filter('translate')('ACTIVE'), custom:'active'}, {text: $filter('translate')('PROMOTED'), custom: 'promoted'}, {text: $filter('translate')('TRENDING_30'), custom:'trending30'}, {text:$filter('translate')('VOTES'), custom:'votes'}, {text: $filter('translate')('COMMENTS'), custom:'children'}, {text: $filter('translate')('PAYOUT'), custom: 'cashout'}];

    angular.forEach($scope.mymenu, function(v,k){
      if (v.custom === $rootScope.$storage.filter) {
        $rootScope.$storage.filterName = v.text;
      }
    });

  });

})

app.controller('PostCtrl', function($scope, $stateParams, $rootScope, $interval, $ionicScrollDelegate, $ionicModal, $filter, $ionicActionSheet, $cordovaCamera, $ionicPopup, ImageUploadService, $ionicPlatform, $ionicSlideBoxDelegate, $ionicPopover, $filter, $state, APIs) {
  $scope.post = $rootScope.$storage.sitem;
  $scope.data = {};
  $scope.spost = {};
  $scope.replying = false;

  var formatToPercentage = function (value) {
    return value + '%';
  };

  $scope.pslider = {
    value: $rootScope.$storage.voteWeight/100,
    options: {
      floor: 1,
      ceil: 100,
      translate: formatToPercentage,
      showSelectionBar: true
    }
  };

  $ionicPopover.fromTemplateUrl('popoverSliderr.html', {
      scope: $scope
  }).then(function(popover) {
      $scope.tooltipSliderr = popover;
  });
  
  $scope.openSliderr = function($event) {
    $scope.pslider = {
      value: $rootScope.$storage.voteWeight/100,
      options: {
        floor: 1,
        ceil: 100,
        translate: formatToPercentage,
        showSelectionBar: true
      }
    };
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $scope.tooltipSliderr.show($event);
  };

  $scope.closeSliderr = function() {
    $scope.tooltipSliderr.hide();
  };

  $scope.$watch('pslider', function(newValue, oldValue){
    //console.log(newValue.value);
    if (newValue.value) {
      $rootScope.$storage.voteWeight = newValue.value*100;
    }
  }, true);


  $scope.isBookmarked = function() {
    var bookm = $rootScope.$storage.bookmark || undefined;
    if (bookm) {
      var len = bookm.length;
      for (var i = 0; i < len; i++) {
        if (bookm[i] && bookm[i].permlink === $rootScope.$storage.sitem.permlink) {
          return true;
        }
      }
    } else {
      return false;
    }
  };
  $scope.options = {
    loop: false,
    speed: 500,
    /*pagination: false,*/
    showPager: false,
    slidesPerView: 3,
    spaceBetween: 20,
    breakpoints: {
      1024: {
          slidesPerView: 5,
          spaceBetween: 15
      },
      768: {
          slidesPerView: 4,
          spaceBetween: 10
      },
      640: {
          slidesPerView: 3,
          spaceBetween: 5
      },
      320: {
          slidesPerView: 3,
          spaceBetween: 3
      }
    }
  }
  $scope.bookmark = function() {
    var book = $rootScope.$storage.bookmark;
    if ($scope.isBookmarked()) {
      var len = book.length;
      var id = undefined;
      for (var i = 0; i < len; i++) {
        if (book[i].permlink === $rootScope.$storage.sitem.permlink) {
          id = book[i]._id;
          book.splice(i, 1);
        }
      }
      if (id){
        APIs.removeBookmark(id,$rootScope.$storage.user.username).then(function(res){
          $rootScope.$storage.bookmark = book;
          $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_UNBOOKMARK'));
        });
      }
    } else {
      if (book) {
        var oo = { author:$rootScope.$storage.sitem.author,permlink:$rootScope.$storage.sitem.permlink};
        $rootScope.$storage.bookmark.push(oo);
        APIs.addBookmark($rootScope.$storage.user.username, oo ).then(function(res){
          $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_BOOKMARK'));
        });
      } else {
        var oo = { author:$rootScope.$storage.sitem.author,permlink:$rootScope.$storage.sitem.permlink};
        $rootScope.$storage.bookmark = [oo];

        APIs.addBookmark($rootScope.$storage.user.username, oo ).then(function(res){
          $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_BOOKMARK'));
        });
      }
      //$rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_BOOKMARK'));
    }
  };

  $scope.lastFocused;


  //http://stackoverflow.com/questions/1064089/inserting-a-text-where-cursor-is-using-javascript-jquery
  $scope.insertText = function(text) {
    var input = $scope.lastFocused;
    //console.log(input);
    if (input == undefined) { return; }
    var scrollPos = input.scrollTop;
    var pos = 0;
    var browser = ((input.selectionStart || input.selectionStart == "0") ?
                   "ff" : (document.selection ? "ie" : false ) );
    if (browser == "ie") {
      input.focus();
      var range = document.selection.createRange();
      range.moveStart ("character", -input.value.length);
      pos = range.text.length;
    }
    else if (browser == "ff") { pos = input.selectionStart };

    var front = (input.value).substring(0, pos);
    var back = (input.value).substring(pos, input.value.length);
    input.value = front+text+back;
    pos = pos + text.length;
    if (browser == "ie") {
      input.focus();
      var range = document.selection.createRange();
      range.moveStart ("character", -input.value.length);
      range.moveStart ("character", pos);
      range.moveEnd ("character", 0);
      range.select();
    }
    else if (browser == "ff") {
      input.selectionStart = pos;
      input.selectionEnd = pos;
      input.focus();
    }
    input.scrollTop = scrollPos;
    console.log(angular.element(input).val());
    angular.element(input).trigger('input');
  }

  $ionicPopover.fromTemplateUrl('popoverTr.html', {
      scope: $scope
   }).then(function(popover) {
      $scope.tooltip = popover;
   });

   $scope.openTooltip = function($event, d) {
    var tppv = Number(d.total_pending_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var p = Number(d.promoted.split(' ')[0])*$rootScope.$storage.currencyRate;
    var tpv = Number(d.total_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var ar = Number(d.total_payout_value.split(' ')[0]-d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var crp = Number(d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var texth = "<div class='row'><div class='col'><b>"+$filter('translate')('PAYOUT_CYCLE')+"</b></div><div class='col'>"+d.mode.replace('_',' ')+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('POTENTIAL_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tppv, 3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PROMOTED')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(p,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAST_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tpv,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('AUTHOR_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(ar,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('CURATION_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(crp,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAYOUT')+"</b></div><div class='col'>"+$filter('timeago')(d.cashout_time, true)+"</div></div>";
    $scope.tooltipText = texth;
    $scope.tooltip.show($event);
   };

   $scope.closeTooltip = function() {
      $scope.tooltip.hide();
   };

   //Cleanup the popover when we're done with it!
   $scope.$on('$destroy', function() {
      $scope.tooltip.remove();
   });

   // Execute action on hide popover
   $scope.$on('popover.hidden', function() {
      // Execute action
   });

   // Execute action on remove popover
   $scope.$on('popover.removed', function() {
      // Execute action
   });


  $scope.isImages = function() {
    if ($rootScope.$storage.sitem) {
      var len = $rootScope.$storage.sitem.json_metadata.image?$rootScope.$storage.sitem.json_metadata.image.length:0;
      if (len > 0) {
        $scope.images = $rootScope.$storage.sitem.json_metadata.image;
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  };
  $scope.zoomMin = 1;
  $scope.showImages = function(index) {
    $scope.activeSlide = index;
    $rootScope.log(angular.toJson($scope.images[index]));
    $scope.showGalleryModal('templates/gallery_images.html');
  };

  $scope.showGalleryModal = function(templateUrl) {
    $ionicModal.fromTemplateUrl(templateUrl, {
      scope: $scope
    }).then(function(modal) {
      $scope.modalg = modal;
      $scope.modalg.show();
    });
  }

  $scope.closeGalleryModal = function() {
    $scope.modalg.hide();
    $scope.modalg.remove()
  };

  $scope.updateSlideStatus = function(slide) {
    var zoomFactor = $ionicScrollDelegate.$getByHandle('scrollHandle' + slide).getScrollPosition().zoom;
    if (zoomFactor == $scope.zoomMin) {
      $ionicSlideBoxDelegate.enableSlide(true);
    } else {
      $ionicSlideBoxDelegate.enableSlide(false);
    }
  };

  $scope.showImg = function() {
   var hideSheet = $ionicActionSheet.show({
     buttons: [
       { text: $filter('translate')('CAPTURE_PICTURE') },
       { text: $filter('translate')('SELECT_PICTURE') },
       { text: $filter('translate')('SET_CUSTOM_URL') },
       { text: $filter('translate')('GALLERY') }
     ],
     titleText: $filter('translate')('INSERT_PICTURE'),
     cancelText: $filter('translate')('CANCEL'),
     cancel: function() {
        // add cancel code..
      },
     buttonClicked: function(index) {
        $scope.insertImage(index);
        return true;
     }
   });
  };
  $scope.insertImage = function(type) {
    var options = {};
    if ($scope.edit) {
      if (type == 0 || type == 1) {
        options = {
          quality: 50,
          destinationType: Camera.DestinationType.FILE_URI,
          sourceType: (type===0)?Camera.PictureSourceType.CAMERA:Camera.PictureSourceType.PHOTOLIBRARY,
          allowEdit: (type===0)?true:false,
          encodingType: Camera.EncodingType.JPEG,
          popoverOptions: CameraPopoverOptions,
          saveToPhotoAlbum: false
          //correctOrientation:true
        };
        $cordovaCamera.getPicture(options).then(function(imageData) {
          setTimeout(function() {
            ImageUploadService.uploadImage(imageData).then(function(result) {
              //var url = result.secure_url || '';
              var url = result.imageUrl || '';
              var final = " ![image](" + url + ")";
              $rootScope.log(final);
              /*if ($scope.spost.body) {
                $scope.spost.body += final;
              } else {
                $scope.spost.body = final;
              }*/
              $scope.insertText(final);
              if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                $cordovaCamera.cleanup();
              }
            },
            function(err) {
              $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('UPLOAD_ERROR'));
              if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                $cordovaCamera.cleanup();
              }
            });
          }, 10);
        }, function(err) {
          $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('CAMERA_CANCELLED'));
        });
      } else if (type == 2){
        $ionicPopup.prompt({
          title: $filter('translate')('SET_URL'),
          template: $filter('translate')('DIRECT_LINK_PICTURE'),
          inputType: 'text',
          inputPlaceholder: 'http://example.com/image.jpg'
        }).then(function(res) {
          $rootScope.log('Your url is' + res);
          if (res) {
            var url = res.trim();
            var final = " ![image](" + url + ")";
            $rootScope.log(final);
            /*if ($scope.spost.body) {
              $scope.spost.body += final;
            } else {
              $scope.spost.body = final;
            }*/
            $scope.insertText(final);
          }
        });
      } else {
        $scope.gallery = [];
        APIs.fetchImages($rootScope.$storage.user.username).then(function(res){
          var imgs = res.data;
          if (imgs.length>0){
            $scope.showgallery = true;
            $scope.gallery.images = imgs;
          } else {
            $scope.showgallery = false;
            $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('NO_IMAGE'));
            console.log('no images available')
          }
        });
      }
    } else {
      if (type == 0 || type == 1) {
        options = {
          quality: 50,
          destinationType: Camera.DestinationType.FILE_URI,
          sourceType: (type===0)?Camera.PictureSourceType.CAMERA:Camera.PictureSourceType.PHOTOLIBRARY,
          allowEdit: (type===0)?true:false,
          encodingType: Camera.EncodingType.JPEG,
          popoverOptions: CameraPopoverOptions,
          saveToPhotoAlbum: false
          //correctOrientation:true
        };
        $cordovaCamera.getPicture(options).then(function(imageData) {
          setTimeout(function() {
            ImageUploadService.uploadImage(imageData).then(function(result) {
              //var url = result.secure_url || '';
              var url = result.imageUrl || '';
              var final = " ![image](" + url + ")";
              $rootScope.log(final);
              /*if ($scope.data.comment) {
                $scope.data.comment += final;
              } else {
                $scope.data.comment = final;
              }*/
              $scope.insertText(final);
              if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                $cordovaCamera.cleanup();
              }
            },
            function(err) {
              $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('UPLOAD_ERROR'));
              if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                $cordovaCamera.cleanup();
              }
            });
          }, 10);
        }, function(err) {
          $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('CAMERA_CANCELLED'));
        });
      } else if (type == 2){
        $ionicPopup.prompt({
          title: $filter('translate')('SET_URL'),
          template: $filter('translate')('DIRECT_LINK_PICTURE'),
          inputType: 'text',
          inputPlaceholder: 'http://example.com/image.jpg'
        }).then(function(res) {
          $rootScope.log('Your url is' + res);
          if (res) {
            var url = res.trim();
            var final = " ![image](" + url + ")";
            $rootScope.log(final);
            /*if ($scope.data.comment) {
              $scope.data.comment += final;
            } else {
              $scope.data.comment = final;
            }*/
            $scope.insertText(final);
          }
        });
      } else {
        $scope.gallery = [];
        APIs.fetchImages($rootScope.$storage.user.username).then(function(res){
          var imgs = res.data;
          if (imgs.length>0){
            $scope.showgallery = true;
            $scope.gallery.images = imgs;
          } else {
            $scope.showgallery = false;
            $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('NO_IMAGE'));
            console.log('no images available')
          }
        });
      }
    }
  };

  $ionicModal.fromTemplateUrl('templates/story.html', {
    scope: $scope  }).then(function(modal) {
    $scope.pmodal = modal;
  });
  $scope.openPostModal = function() {
    //if(!$scope.pmodal) return;
    setTimeout(function() {
      $scope.pmodal.show();
      /*angular.element("textarea").focus(function() {
        $scope.lastFocused = document.activeElement;
        console.log(document);
      });*/
    }, 10);
  };

  $rootScope.$on('closePostModal', function(){
    $scope.pmodal.hide();
  });

  $scope.closeGallery = function(){
    $scope.showgallery = false;
  }
  $scope.manageGallery = function(){
    $scope.modal.hide();
    $state.go('app.images');
  }
  var dmp = new window.diff_match_patch();

  function createPatch(text1, text2) {
      if (!text1 && text1 === '') return undefined;
      var patches = dmp.patch_make(text1, text2);
      var patch = dmp.patch_toText(patches);
      return patch;
  }
  $scope.cfocus = function(){
    $scope.lastFocused = document.activeElement;
  }
  $scope.deletePost = function(xx) {
    $rootScope.log('delete post '+ angular.toJson(xx));
    var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('ARE_YOU_SURE'),
        template: $filter('translate')('DELETE_COMMENT')
    });
    confirmPopup.then(function(res) {
        if(res) {
            $rootScope.log('You are sure');
            $rootScope.$broadcast('show:loading');
            if ($rootScope.$storage.user) {
              $scope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
              $scope.mylogin.setRoles(["posting"]);
              var loginSuccess = $scope.mylogin.checkKeys({
                  accountName: $rootScope.$storage.user.username,
                  password: $rootScope.$storage.user.password || null,
                  auths: {
                      posting: $rootScope.$storage.user.posting.key_auths
                  },
                  privateKey: $rootScope.$storage.user.privatePostingKey || null
                }
              );
              if (loginSuccess) {
                var tr = new window[$rootScope.$storage.chain+"JS"].TransactionBuilder();

                tr.add_type_operation("delete_comment", {
                  author: xx.author,
                  permlink: xx.permlink
                });
                //$rootScope.log(my_pubkeys);
                localStorage.error = 0;
                tr.process_transaction($scope.mylogin, null, true);

                setTimeout(function() {
                  if (localStorage.error == 1) {
                    $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                  } else {
                    $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('DELETED_COMMENT'));
                    $state.go('app.posts');
                  }
                  $rootScope.$broadcast('hide:loading');
                }, 3000);
              } else {
                $rootScope.$broadcast('hide:loading');
              }
            } else {
              $rootScope.$broadcast('hide:loading');
              $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
            }
        } else {
          $rootScope.log('You are not sure');
        }
    });
  }
  $scope.edit = false;
  $scope.editPost = function(xx) {
    $scope.edit = true;
    $scope.openPostModal();
    angular.element("textarea").focus(function() {
      $scope.lastFocused = document.activeElement;
      console.log(document);
    });
    setTimeout(function() {
      if (!$scope.spost.body) {
        $scope.spost = xx;
        $scope.patchbody = xx.body;
      }
      $scope.spost.tags = angular.fromJson(xx.json_metadata).tags.join().replace(/\,/g,' ');
    }, 10);
  }

  $scope.submitStory = function() {
    if (!$scope.$$phase){
      $scope.$apply();
    }
    $rootScope.$broadcast('show:loading');
    if ($scope.edit) {
      var patch = createPatch($scope.patchbody, $scope.spost.body)
      // Putting body into buffer will expand Unicode characters into their true length
      if (patch && patch.length < new Buffer($scope.spost.body, 'utf-8').length) {
        $scope.spost.body2 = patch;
      }
      //$rootScope.log(patch);
    } else {
      $scope.spost.body2 = undefined;
    }

    if ($rootScope.$storage.user) {
      $scope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
      $scope.mylogin.setRoles(["posting"]);
      var loginSuccess = $scope.mylogin.checkKeys({
          accountName: $rootScope.$storage.user.username,
          password: $rootScope.$storage.user.password || null,
          auths: {
              posting: $rootScope.$storage.user.posting.key_auths
          },
          privateKey: $rootScope.$storage.user.privatePostingKey || null
        }
      );
      if (loginSuccess) {
        var tr = new window[$rootScope.$storage.chain+"JS"].TransactionBuilder();
        var permlink = $scope.spost.permlink;
        var jjson = $filter("metadata")($scope.spost.body);
        //console.log(jjson);
        //$scope.spost.tags = $filter('lowercase')($scope.spost.tags);
        var json = angular.merge(jjson, {tags: $scope.spost.tags.split(" "), app: 'esteem/'+$rootScope.$storage.appversion, format: 'markdown+html' });
        //console.log(json);
        tr.add_type_operation("comment", {
          parent_author: "",
          parent_permlink: $scope.spost.parent_permlink,
          author: $rootScope.$storage.user.username,
          permlink: $scope.spost.permlink,
          title: $scope.spost.title,
          body: $scope.spost.body2 || $scope.spost.body,
          json_metadata: angular.toJson(json)
        });
        //$rootScope.log(my_pubkeys);
        localStorage.error = 0;
        tr.process_transaction($scope.mylogin, null, true);
        $scope.replying = false;
        setTimeout(function() {
          $rootScope.$broadcast('hide:loading');
          if (localStorage.error == 1) {
            $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
          } else {
            //$scope.closePostModal();

            $rootScope.$broadcast('closePostModal');

            setTimeout(function() {
              $scope.spost = {};
              $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_SUBMITTED'));
            //$scope.closePostPopover();
              $state.go("app.profile", {username: $rootScope.$storage.user.username});
            }, 1);
          }
        }, 3000);
      } else {
        $rootScope.$broadcast('hide:loading');
        $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
      }
    } else {
      $rootScope.$broadcast('hide:loading');
      $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
    }
  }
  $scope.addImage = function(url) {
    $scope.data.comment += ' ![image]('+url+') ';
  }
  $scope.reply = function (xx) {
    //$rootScope.log(xx);
    if (!$scope.$$phase){
      $scope.$apply();
    }
    $rootScope.$broadcast('show:loading');
    if ($rootScope.$storage.user) {
      $scope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
      $scope.mylogin.setRoles(["posting"]);
      var loginSuccess = $scope.mylogin.checkKeys({
          accountName: $rootScope.$storage.user.username,
          password: $rootScope.$storage.user.password || null,
          auths: {
              posting: $rootScope.$storage.user.posting.key_auths
          },
          privateKey: $rootScope.$storage.user.privatePostingKey || null
        }
      );
      if (loginSuccess) {
        var tr = new window[$rootScope.$storage.chain+"JS"].TransactionBuilder();
        var t = new Date();
        var timeformat = t.getFullYear().toString()+(t.getMonth()+1).toString()+t.getDate().toString()+"t"+t.getHours().toString()+t.getMinutes().toString()+t.getSeconds().toString()+t.getMilliseconds().toString()+"z";
        var json = {tags: angular.fromJson($scope.post.json_metadata).tags[0] || ["esteem"] , app: 'esteem/'+$rootScope.$storage.appversion, format: 'markdown+html' };
        tr.add_type_operation("comment", {
          parent_author: $scope.post.author,
          parent_permlink: $scope.post.permlink,
          author: $rootScope.$storage.user.username,
          permlink: "re-"+$scope.post.author+"-"+$scope.post.permlink+"-"+timeformat,
          title: "",
          body: $scope.data.comment,
          json_metadata: angular.toJson(json)
        });
        localStorage.error = 0;
        tr.process_transaction($scope.mylogin, null, true);
        $scope.replying = false;
        setTimeout(function() {
          $rootScope.$broadcast('hide:loading');
          if (localStorage.error == 1) {
            $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
          } else {
            $scope.closeModal();
            $scope.data.comment = "";

            $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('COMMENT_SUBMITTED'));
            window.Api.initPromise.then(function(response) {
              window.Api.database_api().exec("get_content_replies", [$rootScope.$storage.sitem.author, $rootScope.$storage.sitem.permlink]).then(function(result){
                if (result)
                  $scope.comments = result;
                if (!$scope.$$phase) {
                  $scope.$apply();
                }
              });
            });
          }
        }, 3000);
      } else {
        $rootScope.$broadcast('hide:loading');
        $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
      }
    } else {
      $rootScope.$broadcast('hide:loading');
      $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
    }
  }
  $rootScope.$on("update:content", function(){
    $rootScope.log("update:content");
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_content_replies", [$scope.post.author, $scope.post.permlink]).then(function(result){
        //todo fix active_votes
        console.log(result);
        if (result) {
          /*angular.forEach(result, function(v,k){
            var len = v.active_votes.length;
            var user = $rootScope.$storage.user;
            if (user) {
              for (var j = len - 1; j >= 0; j--) {
                if (v.active_votes[j].voter === user.username) {
                  if (v.active_votes[j].percent > 0) {
                    v.upvoted = true;
                  } else if (v.active_votes[j].percent < 0) {
                    v.downvoted = true;
                  } else {
                    v.downvoted = false;
                    v.upvoted = false;
                  }
                }
              }
            }
          });*/
          $scope.comments = result;
          console.log(result);
        }

        $rootScope.$broadcast('hide:loading');
      });
    });
    $rootScope.$broadcast('hide:loading');
  });
  $ionicModal.fromTemplateUrl('templates/reply.html', {
    scope: $scope  }).then(function(modal) {
    $scope.modal = modal;
  });

  $scope.openModal = function(item) {
    //if(!$scope.modal) return;
    setTimeout(function() {
      $scope.modal.show();
    }, 5);
  };

  $scope.closeModal = function() {
    $scope.replying = false;
    $scope.modal.hide();
  };

  $scope.isreplying = function(cho, xx) {
    $scope.replying = xx;
    angular.merge($scope.post, cho);
    if (xx) {
      $scope.openModal();
    } else {
      $scope.closeModal();
    }
  };
  $scope.accounts = {};
  $scope.getContent = function(author, permlink) {
    var url = "/"+$stateParams.category+"/@"+author+"/"+permlink;
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_state", [url]).then(function(dd){
        //console.log(dd);
        var con = dd.content;
        var acon = dd.accounts;

        angular.forEach(con, function(v,k){
          v.comments = [];
        });
        //setTimeout(function() {
        angular.forEach(con, function(v,k){
          var vparent = v.parent_author==""?v.author:v.parent_author;
          var vperm = v.parent_author==""?v.permlink:v.parent_permlink;
          var keyy = vparent+"/"+vperm;
          if (v.parent_permlink!==v.category) {
            con[keyy].comments.push(v);  
          }
        });
        //console.log(acon);  
        //}, 1);
        angular.forEach(acon, function(v,k){
          //console.log(v.json_metadata);
          if (typeof v.json_metadata === 'string' || v.json_metadata instanceof String) {
            //console.log(v.json_metadata);
            if (v.json_metadata)
              v.json_metadata = angular.fromJson(v.json_metadata);
          }
        });
        var result = con[author+"/"+permlink];

        var len = result.active_votes.length;
        var user = $rootScope.$storage.user;
        if (user) {
          for (var j = len - 1; j >= 0; j--) {
            if (result.active_votes[j].voter === user.username) {
              if (result.active_votes[j].percent > 0) {
                result.upvoted = true;
              } else if (result.active_votes[j].percent < 0) {
                result.downvoted = true;
              } else {
                result.downvoted = false;
                result.upvoted = false;
              }
            }
          }
        }

        result.json_metadata = angular.fromJson(result.json_metadata);
        //$rootScope.$storage.sitem = result;
        //console.log(result);
        $rootScope.$broadcast('hide:loading');
        $scope.post = result;
        $rootScope.$storage.paccounts = acon;

        if (!$scope.$$phase) {
          $scope.$apply();
        }

      });
    });
    /*window.Api.database_api().exec("get_content", [author, permlink]).then(function(result){
      //console.log(result);
        var len = result.active_votes.length;
        var user = $rootScope.$storage.user;
        if (user) {
          for (var j = len - 1; j >= 0; j--) {
            if (result.active_votes[j].voter === user.username) {
              if (result.active_votes[j].percent > 0) {
                result.upvoted = true;
              } else if (result.active_votes[j].percent < 0) {
                result.downvoted = true;
              } else {
                result.downvoted = false;
                result.upvoted = false;
              }
            }
          }
        }
        result.json_metadata = angular.fromJson(result.json_metadata);
        $rootScope.$storage.sitem = result;
        console.log(result);
        $scope.post = result;
        //$ionicScrollDelegate.$getByHandle('mainScroll').scrollTop();
      $rootScope.$broadcast('hide:loading');
      //console.log($scope.post);
      if (!$scope.$$phase) {
        $scope.$apply();
      }
    });
    //$rootScope.$broadcast('hide:loading');
    */
  };
  $scope.fetchComments = function(){
    $rootScope.$broadcast('update:content');
  }
  $scope.$on('$ionicView.beforeEnter', function(){
    $rootScope.log('beforeEnter postctrl');
    //$rootScope.$broadcast('show:loading');
    if ($stateParams.category === '111') {
      var ttemp = $rootScope.$storage.sitem;
      $scope.post = ttemp;
      $rootScope.$broadcast('update:content');
    } else {
      $scope.getContent($stateParams.author, $stateParams.permlink);
      //$scope.post = $rootScope.$storage.sitem;
      //$rootScope.$broadcast('update:content');
    }
  });



  $scope.upvotePost = function(post) {
    $rootScope.votePost(post, 'upvote', 'getContent');
  };
  $rootScope.$on('getContent', function() {
    $scope.getContent($rootScope.$storage.sitem.author, $rootScope.$storage.sitem.permlink);
  });
  $scope.downvotePost = function(post) {
    var confirmPopup = $ionicPopup.confirm({
      title: $filter('translate')('ARE_YOU_SURE'),
      template: $filter('translate')('FLAGGING_TEXT')
    });
    confirmPopup.then(function(res) {
      if(res) {
        $rootScope.log('You are sure');
        $rootScope.votePost(post, 'downvote', 'getContent');
      } else {
        $rootScope.log('You are not sure');
      }
    });
  };
  $scope.unvotePost = function(post) {
    $rootScope.votePost(post, 'unvote', 'getContent');
  };


})
app.controller('BookmarkCtrl', function($scope, $stateParams, $rootScope, $state, APIs, $interval, $ionicScrollDelegate, $filter) {

  $scope.removeBookmark = function(index) {
    if ($rootScope.$storage.bookmark) {
      APIs.removeBookmark($rootScope.$storage.bookmark[index]._id,$rootScope.$storage.user.username).then(function(res){
        $rootScope.$storage.bookmark.splice(index,1);
        $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_UNBOOKMARK'));
      });
    }
  };

  $scope.$on('$ionicView.beforeEnter', function(){
    APIs.getBookmarks($rootScope.$storage.user.username).then(function(res){
      //console.log(res);
      $rootScope.$storage.bookmark = res.data;
    });
  });
});

app.controller('DraftsCtrl', function($scope, $stateParams, $rootScope, $state, APIs, $interval, $ionicScrollDelegate, $filter) {
  //JSON.stringify({
  $scope.removeDraft = function(_id) {
    APIs.removeDraft(_id,$rootScope.$storage.user.username).then(function(res){
      APIs.getDrafts($rootScope.$storage.user.username).then(function(res){
        //console.log(res);
        $scope.drafts = res.data;
      });
      $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_UNDRAFT'));
    });
  };

  $scope.$on('$ionicView.beforeEnter', function(){
    APIs.getDrafts($rootScope.$storage.user.username).then(function(res){
      //console.log(res);
      $scope.drafts = res.data;
    });
  });
});

app.controller('ImagesCtrl', function($scope, $stateParams, $rootScope, $state, APIs, $interval, $ionicScrollDelegate, $filter) {
  //JSON.stringify({
  $scope.removeImage = function(_id) {
    APIs.removeImage(_id,$rootScope.$storage.user.username).then(function(res){
      APIs.fetchImages($rootScope.$storage.user.username).then(function(res){
        //console.log(res);
        $scope.images = res.data;
      });
      $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('IMAGE_REMOVED'));
    });
  };
  $scope.copyImage = function(url){
    cordova.plugins.clipboard.copy(url);
  };
  $scope.$on('$ionicView.beforeEnter', function(){
    APIs.fetchImages($rootScope.$storage.user.username).then(function(res){
      //console.log(res);
      $scope.images = res.data;
    });
  });
});

app.controller('NotificationsCtrl', function($scope, $stateParams, $rootScope, $state, APIs, $interval, $ionicScrollDelegate) {

  $scope.removeNotification = function(index) {
    if ($rootScope.$storage.notifications) {
      $rootScope.$storage.notifications.splice(index,1);
    }
  };
})
app.controller('FollowCtrl', function($scope, $stateParams, $rootScope, $state, APIs, $interval, $ionicScrollDelegate) {
  $scope.searchu = {};

  $scope.$on('$ionicView.beforeEnter', function(){
    $scope.active = "followers";
    $scope.followers = [];
    $scope.following = [];
    $scope.limit = 100;
    $scope.tt = {ruser:"", duser:""};

    $scope.rfetching = function(){
      window.Api.initPromise.then(function(response) {
        window.Api.follow_api().exec("get_followers", [$rootScope.$storage.user.username, $scope.tt.ruser, "blog", $scope.limit]).then(function(res){
          if (res && res.length===$scope.limit) {
            $scope.tt.ruser = res[res.length-1].follower;
          }
          //console.log(res);
          var ll = res.length;
          for (var i = 0; i < ll; i++) {
            res[i].id += 1;
            $scope.followers.push(res[i]);
          }
          if (res.length < $scope.limit) {
            if (!$scope.$$phase){
              $scope.$apply();
            }
          } else {
            setTimeout($scope.rfetching, 5);
          }
        });
      });
    };

    $scope.dfetching = function(){
      window.Api.initPromise.then(function(response) {
        window.Api.follow_api().exec("get_following", [$rootScope.$storage.user.username, $scope.tt.duser, "blog", $scope.limit]).then(function(res){
          if (res && res.length===$scope.limit) {
            $scope.tt.duser = res[res.length-1].following;
          }
          var ll = res.length;

          //console.log(res);
          for (var i = 0; i < ll; i++) {
            res[i].id += 1;
            $scope.following.push(res[i]);
          }
          if (res.length<$scope.limit) {
            if (!$scope.$$phase){
              $scope.$apply();
            }
          } else {
            setTimeout($scope.dfetching, 5);
          }
        });
      });
    };

    $scope.rfetching();
    $scope.dfetching();

  });

  $scope.$on('$ionicView.leave', function(){
    /*if (angular.isDefined($scope.dfetching)){
      $interval.cancel($scope.dfetching);
      $scope.dfetching = undefined;
      $scope.following = undefined;
    }
    if (angular.isDefined($scope.rfetching)){
      $interval.cancel($scope.rfetching);
      $scope.rfetching = undefined;
      $scope.followers = undefined;
    }*/
  });
  $scope.isFollowed = function(x) {
    var len = $scope.following.length;
    for (var i = 0; i < len; i++) {
      if ($scope.following[i].following == x) {
        return true;
      }
    }
    return false;
  };
  $scope.isFollowing = function(x) {
    var len = $scope.followers.length;
    for (var i = 0; i < len; i++) {
      if ($scope.followers[i].follower == x) {
        return true;
      }
    }
    return false;
  };
  $scope.change = function(type){
    $scope.active = type;
    $rootScope.log(type);

    $ionicScrollDelegate.$getByHandle('listScroll').scrollTop();
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    //$scope.loadMore(type);
  }

  $scope.$on('current:reload', function(){
    $rootScope.log('current:reload');
    //$state.go($state.current, {}, {reload: true});
    $scope.followers = [];
    $scope.following = [];
    $scope.rfetching();
    $scope.dfetching();
  });

  $scope.unfollowUser = function(xx){
    $rootScope.following(xx, "unfollow");
  };
  $scope.followUser = function(xx){
    $rootScope.following(xx, "follow");
  };
  $scope.profileView = function(xx){
    $state.go('app.profile', {username: xx});
  };

})

app.controller('ProfileCtrl', function($scope, $stateParams, $rootScope, $ionicActionSheet, $cordovaCamera, ImageUploadService, $ionicPopup, $ionicSideMenuDelegate, $ionicHistory, $state, APIs, $ionicPopover, $filter) {

  var formatToPercentage = function (value) {
    return value + '%';
  };

  $scope.pslider = {
    value: $rootScope.$storage.voteWeight/100,
    options: {
      floor: 1,
      ceil: 100,
      translate: formatToPercentage,
      showSelectionBar: true
    }
  };

  $ionicPopover.fromTemplateUrl('popoverSliderrp.html', {
      scope: $scope
  }).then(function(popover) {
      $scope.tooltipSlider = popover;
  });
  
  $scope.openSlider = function($event) {
    $scope.pslider = {
      value: $rootScope.$storage.voteWeight/100,
      options: {
        floor: 1,
        ceil: 100,
        translate: formatToPercentage,
        showSelectionBar: true
      }
    };
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $scope.tooltipSlider.show($event);
  };

  $scope.closeSlider = function() {
    $scope.tooltipSlider.hide();
  };

  $scope.$watch('pslider', function(newValue, oldValue){
    //console.log(newValue.value);
    if (newValue.value) {
      $rootScope.$storage.voteWeight = newValue.value*100;
    }
  }, true);

  $scope.translationData = { platformname: $rootScope.$storage.platformname, platformpower: $rootScope.$storage.platformpower, platformsunit:"$1.00" };

  $scope.goBack = function() {
    var viewHistory = $ionicHistory.viewHistory();
    if (!viewHistory.backView) {
      $scope.openMenu();
    } else {
      $ionicHistory.goBack();
    }
  };
  $scope.followUser = function(xx){
    $rootScope.following(xx, "follow");
  };
  $scope.unfollowUser = function(xx){
    $rootScope.log(xx);
    $rootScope.following(xx, "unfollow");
  };

  $scope.$on('current:reload', function(){
    $state.go($state.current, {}, {reload: true});
  });

  $ionicPopover.fromTemplateUrl('popoverPTr.html', {
      scope: $scope
   }).then(function(popover) {
      $scope.tooltip = popover;
   });

   $scope.openTooltip = function($event, d) {
    var tppv = Number(d.total_pending_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var p = Number(d.promoted.split(' ')[0])*$rootScope.$storage.currencyRate;
    var tpv = Number(d.total_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var ar = Number(d.total_payout_value.split(' ')[0]-d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var crp = Number(d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var texth = "<div class='row'><div class='col'><b>"+$filter('translate')('PAYOUT_CYCLE')+"</b></div><div class='col'>"+d.mode.replace('_',' ')+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('POTENTIAL_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tppv, 3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PROMOTED')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(p,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAST_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tpv,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('AUTHOR_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(ar,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('CURATION_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(crp,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAYOUT')+"</b></div><div class='col'>"+$filter('timeago')(d.cashout_time, true)+"</div></div>";
    $scope.tooltipText = texth;
    $scope.tooltip.show($event);
   };

   $scope.closeTooltip = function() {
      $scope.tooltip.hide();
   };

   //Cleanup the popover when we're done with it!
   $scope.$on('$destroy', function() {
      $scope.tooltip.remove();
   });

   // Execute action on hide popover
   $scope.$on('popover.hidden', function() {
      // Execute action
   });

   // Execute action on remove popover
   $scope.$on('popover.removed', function() {
      // Execute action
   });

  $scope.showProfile = function() {
   var hideSheet = $ionicActionSheet.show({
     buttons: [
       { text: $filter('translate')('CAPTURE_PICTURE') },
       { text: $filter('translate')('SELECT_PICTURE') },
       { text: $filter('translate')('SET_CUSTOM_URL') },
     ],
     destructiveText: $filter('translate')('RESET'),
     titleText: $filter('translate')('MODIFY_PICTURE'),
     cancelText: $filter('translate')('CANCEL'),
     cancel: function() {
        // add cancel code..
      },
     buttonClicked: function(index) {
      if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
        $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
      } else {
        $scope.changeProfileInfo(index, 'profile');
      }
      return true;
     },
     destructiveButtonClicked: function(index){
      var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('ARE_YOU_SURE'),
        template: $filter('translate')('RESET_PICTURE_TEXT')
      });
      confirmPopup.then(function(res) {
        if(res) {
          if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
            $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
          } else {
            var update = {profile: {profile_image:""} };
            angular.merge(update, $rootScope.$storage.user.json_metadata);
            if (update.profilePicUrl) {delete update.profilePicUrl;}

            update.profile.profile_image = "";

            $rootScope.log('You are sure');
            if ($rootScope.$storage.user) {
              $scope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
              $scope.mylogin.setRoles(["active"]);
              var loginSuccess = $scope.mylogin.checkKeys({
                  accountName: $rootScope.$storage.user.username,
                  password: $rootScope.$storage.user.password || null,
                  auths: {
                    active: $rootScope.$storage.user.active.key_auths
                  },
                  privateKey: $rootScope.$storage.user.privateActiveKey || null
                }
              );
              //todo: if json_metadata already exist make sure to keep it.
              if (loginSuccess) {
                var tr = new window[$rootScope.$storage.chain+"JS"].TransactionBuilder();
                tr.add_type_operation("account_update", {
                  account: $rootScope.$storage.user.username,
                  memo_key: $rootScope.$storage.user.memo_key,
                  json_metadata: JSON.stringify(update)
                });
                localStorage.error = 0;
                tr.process_transaction($scope.mylogin, null, true);
                setTimeout(function() {
                  if (localStorage.error == 1) {
                    $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                  } else {
                    $rootScope.$broadcast('refreshLocalUserData');
                  }
                }, 3000);
              } else {
                $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
              }
              $rootScope.$broadcast('hide:loading');
            } else {
              $rootScope.$broadcast('hide:loading');
              $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
            }
          }
        } else {
          $rootScope.log('You are not sure');
        }
      });
      return true;
     }
   });
  };


  $scope.changeProfileInfo = function(type, which) {
    if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
      $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
    } else {
      var options = {};
      if (type == 0 || type == 1) {
        options = {
          quality: 50,
          destinationType: Camera.DestinationType.FILE_URI,
          sourceType: (type===0)?Camera.PictureSourceType.CAMERA:Camera.PictureSourceType.PHOTOLIBRARY,
          allowEdit: (type===0)?true:false,
          encodingType: Camera.EncodingType.JPEG,
          targetWidth: which==='profile'?500:1000,
          targetHeight: 500,
          popoverOptions: CameraPopoverOptions,
          saveToPhotoAlbum: false
          //correctOrientation:true
        };
        $cordovaCamera.getPicture(options).then(function(imageData) {
          ImageUploadService.uploadImage(imageData).then(function(result) {
            //var url = result.secure_url || '';
            var url = result.imageUrl || '';
            var update = { profile: { cover_image: "", profile_image: ""} };
            if (which === 'profile') {
              angular.merge(update, $rootScope.$storage.user.json_metadata);
              if (update.profilePicUrl) {delete update.profilePicUrl;}
              update.profile.profile_image = url;
            } else {
              angular.merge(update, $rootScope.$storage.user.json_metadata);
              update.profile.cover_image = url;
            }

            setTimeout(function() {
              $rootScope.$broadcast('show:loading');
              if ($rootScope.$storage.user) {
                $scope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
                $scope.mylogin.setRoles(["active"]);
                var loginSuccess = $scope.mylogin.checkKeys({
                    accountName: $rootScope.$storage.user.username,
                    password: $rootScope.$storage.user.password || null,
                    auths: {
                      active: $rootScope.$storage.user.active.key_auths
                    },
                    privateKey: $rootScope.$storage.user.privateActiveKey || null,
                  }
                );
                if (loginSuccess) {
                  var tr = new window[$rootScope.$storage.chain+"JS"].TransactionBuilder();
                  tr.add_type_operation("account_update", {
                    account: $rootScope.$storage.user.username,
                    memo_key: $rootScope.$storage.user.memo_key,
                    json_metadata: JSON.stringify(update)
                  });

                  localStorage.error = 0;

                  tr.process_transaction($scope.mylogin, null, true);

                  setTimeout(function() {
                    if (localStorage.error == 1) {
                      $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage);
                    } else {
                      $rootScope.$broadcast('refreshLocalUserData');
                    }
                  }, 3000);
                } else {
                  $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
                }
              $rootScope.$broadcast('hide:loading');
              } else {
                $rootScope.$broadcast('hide:loading');
                $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
              }
            }, 5);
            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
              $cordovaCamera.cleanup();
            }
          },
          function(err) {
            $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('UPLOAD_ERROR'));
            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
              $cordovaCamera.cleanup();
            }
          });
        }, function(err) {
          $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('CAMERA_CANCELLED'));
        });
      } else {
        $ionicPopup.prompt({
          title: $filter('translate')('SET_URL'),
          template: $filter('translate')('DIRECT_LINK_PICTURE'),
          inputType: 'text',
          inputPlaceholder: 'http://example.com/image.jpg'
        }).then(function(res) {
          $rootScope.log('Your url is'+ res);
          if (res) {
            var update = { profile: { profile_image: "", cover_image:"" } };
            if (which==="profile") {
              angular.merge(update, $rootScope.$storage.user.json_metadata);
              if (update.profilePicUrl) {delete update.profilePicUrl;}
              update.profile.profile_image = res;
            } else {
              angular.merge(update, $rootScope.$storage.user.json_metadata);
              update.profile.cover_image = res;
            }

            setTimeout(function() {
              if ($rootScope.$storage.user) {
                $scope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
                $scope.mylogin.setRoles(["active"]);
                var loginSuccess = $scope.mylogin.checkKeys({
                    accountName: $rootScope.$storage.user.username,
                    password: $rootScope.$storage.user.password || null,
                    auths: {
                      active: $rootScope.$storage.user.active.key_auths
                    },
                    privateKey: $rootScope.$storage.user.privateActiveKey || null,
                  }
                );
                if (loginSuccess) {
                  var tr = new window[$rootScope.$storage.chain+"JS"].TransactionBuilder();
                  tr.add_type_operation("account_update", {
                    account: $rootScope.$storage.user.username,
                    memo_key: $rootScope.$storage.user.memo_key,
                    json_metadata: JSON.stringify(update)
                  });
                  localStorage.error = 0;
                  tr.process_transaction($scope.mylogin, null, true);
                  setTimeout(function() {
                    if (localStorage.error == 1) {
                      $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                    } else {
                      //$scope.refreshLocalUserData();
                      $rootScope.$broadcast('refreshLocalUserData');
                    }
                  }, 3000);
                } else {
                  $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
                }
                $rootScope.$broadcast('hide:loading');
              } else {
                $rootScope.$broadcast('hide:loading');
                $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
              }
            }, 5);
          }
        });
      }
    }
  };

  $scope.showCover = function() {
   var hideSheet = $ionicActionSheet.show({
     buttons: [
       { text: $filter('translate')('CAPTURE_PICTURE') },
       { text: $filter('translate')('SELECT_PICTURE') },
       { text: $filter('translate')('SET_CUSTOM_URL') },
     ],
     destructiveText: $filter('translate')('RESET'),
     titleText: $filter('translate')('MODIFY_COVER_PICTURE'),
     cancelText: $filter('translate')('CANCEL'),
     cancel: function() {
        // add cancel code..
      },
     buttonClicked: function(index) {
      if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
        $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
      } else {
        $scope.changeProfileInfo(index, 'cover');
      }
      return true;
     },
     destructiveButtonClicked: function(index){
      var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('ARE_YOU_SURE'),
        template: $filter('translate')('RESET_COVER_PICTURE_TEXT')
      });
      confirmPopup.then(function(res) {
        if(res) {
          if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
            $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
          } else {
            var update = {profile: {cover_image:""} };
            angular.merge(update, $rootScope.$storage.user.json_metadata);
            update.profile.cover_image = "";

            $rootScope.log('You are sure');
            if ($rootScope.$storage.user) {
              $scope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
              $scope.mylogin.setRoles(["active"]);
              var loginSuccess = $scope.mylogin.checkKeys({
                  accountName: $rootScope.$storage.user.username,
                  password: $rootScope.$storage.user.password || null,
                  auths: {
                    active: $rootScope.$storage.user.active.key_auths
                  },
                  privateKey: $rootScope.$storage.user.privateActiveKey || null
                }
              );
              //todo: if json_metadata already exist make sure to keep it.
              if (loginSuccess) {
                var tr = new window[$rootScope.$storage.chain+"JS"].TransactionBuilder();
                tr.add_type_operation("account_update", {
                  account: $rootScope.$storage.user.username,
                  memo_key: $rootScope.$storage.user.memo_key,
                  json_metadata: JSON.stringify(update)
                });
                localStorage.error = 0;
                tr.process_transaction($scope.mylogin, null, true);
                setTimeout(function() {
                  if (localStorage.error == 1) {
                    $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                  } else {
                    $rootScope.$broadcast('refreshLocalUserData');
                  }
                }, 3000);
              } else {
                $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
              }
              $rootScope.$broadcast('hide:loading');
            } else {
              $rootScope.$broadcast('hide:loading');
              $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
            }
          }
        } else {
          $rootScope.log('You are not sure');
        }
      });
      return true;
     }
   });
  };


  $rootScope.$on('profileRefresh', function(){
    $scope.refresh();
  });
  $scope.upvotePost = function(post) {
    $rootScope.votePost(post, 'upvote', 'profileRefresh');
  };
  $scope.downvotePost = function(post) {
    var confirmPopup = $ionicPopup.confirm({
      title: $filter('translate')('ARE_YOU_SURE'),
      template: $filter('translate')('FLAGGING_TEXT')
    });
    confirmPopup.then(function(res) {
      if(res) {
        $rootScope.log('You are sure');
        $rootScope.votePost(post, 'downvote', 'profileRefresh');
      } else {
        $rootScope.log('You are not sure');
      }
    });
  };
  $scope.unvotePost = function(post) {
    $rootScope.votePost(post, 'unvote', 'profileRefresh');
  };

  $scope.isFollowing = function(xx) {
    if ($scope.following && $scope.following.indexOf(xx)!==-1) {
      return true;
    } else {
      return false;
    }
  };
  $scope.ifExists = function(xx){
    for (var i = 0; i < $scope.data.profile.length; i++) {
      if ($scope.data.profile[i].permlink === xx){
        return true;
      }
    }
    return false;
  }
  $scope.end = false;
  $scope.clen = 20;
  $scope.moreDataCanBeLoaded = function(){
    return ($scope.data.profile && $scope.data.profile.length>0) && !$scope.end;
  }

  $scope.loadmore = function() {
    //console.log('loadmore');
    var params = {tag: $stateParams.username, limit: 20};
    var len = $scope.data.profile?$scope.data.profile.length:0;

    //console.log($scope.data.profile);

    if (len>0) {
      params.start_author = $scope.data.profile[len-1].author;
      params.start_permlink = $scope.data.profile[len-1].permlink;

      if ($scope.end) {
        //$rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('REQUEST_LIMIT_TEXT'));
        $scope.$broadcast('scroll.infiniteScrollComplete');
        $rootScope.$broadcast('hide:loading');
      } else {
        //console.log(params);
        //$rootScope.log("fetching profile...blog 20 ");
        window.Api.initPromise.then(function(response) {
          if (typeof window.Api.database_api === "function") {
            if ($scope.active == 'blog') {
              window.Api.database_api().exec("get_discussions_by_blog", [params]).then(function(response){

                if (response) {
                  for (var j = 0; j < response.length; j++) {
                    var v = response[j];
                    v.json_metadata = v.json_metadata?angular.fromJson(v.json_metadata):v.json_metadata;
                    !$scope.$$phase?$scope.$apply():console.log('phased');
                    var found = false;
                    for (var i = $scope.data.profile.length-1; i >= 0; i--) {
                      if ($scope.data.profile[i].id === v.id){
                        found = true;
                        //console.log($scope.data.profile[i].id, v.id);
                      }
                    }
                    if (!found){
                      //console.log(v.id);
                      $scope.data.profile.push(v);
                    }
                    if (response.length <= 1) {
                      $scope.end = true;
                    } else {
                      $scope.end = false;
                    }
                  }
                }
              });
              $scope.$broadcast('scroll.infiniteScrollComplete');
            }
            if ($scope.active == 'posts') {
              window.Api.database_api().exec("get_discussions_by_comments", [params]).then(function(response){

                if (response) {
                  for (var j = 0; j < response.length; j++) {
                    var v = response[j];
                    v.json_metadata = v.json_metadata?angular.fromJson(v.json_metadata):v.json_metadata;
                    !$scope.$$phase?$scope.$apply():console.log('phased');
                    var found = false;
                    for (var i = $scope.data.profile.length-1; i >= 0; i--) {
                      if ($scope.data.profile[i].id === v.id){
                        found = true;
                        //console.log($scope.data.profile[i].id, v.id);
                      }
                    }
                    if (!found){
                      //console.log(v.id);
                      $scope.data.profile.push(v);
                    }
                    if (response.length <= 1) {
                      $scope.end = true;
                    } else {
                      $scope.end = false;
                    }
                  }
                }
              });
              $scope.$broadcast('scroll.infiniteScrollComplete');
            }
            if ($scope.active == 'recent-replies') {
              var pp = [$scope.data.profile[$scope.data.profile.length-1].author, $scope.data.profile[$scope.data.profile.length-1].permlink, 20];
              window.Api.database_api().exec("get_replies_by_last_update", [pp]).then(function(response){
                //console.log(response);
                if (response) {
                  for (var j = 0; j < response.length; j++) {
                    var v = response[j];
                    v.json_metadata = v.json_metadata?angular.fromJson(v.json_metadata):v.json_metadata;
                    !$scope.$$phase?$scope.$apply():console.log('phased');
                    var found = false;
                    for (var i = $scope.data.profile.length-1; i >= 0; i--) {
                      if ($scope.data.profile[i].id === v.id){
                        found = true;
                        //console.log($scope.data.profile[i].id, v.id);
                      }
                    }
                    if (!found){
                      //console.log(v.id);
                      $scope.data.profile.push(v);
                    }
                    if (response.length <= 1) {
                      $scope.end = true;
                    } else {
                      $scope.end = false;
                    }
                  }
                }
              });
              $scope.$broadcast('scroll.infiniteScrollComplete');
            }
            //console.log($scope.profile);
          }
        });
      }
    }

  }
  $scope.$on('$ionicView.beforeEnter', function(){
    $scope.user = {username: $stateParams.username};
    $scope.follower = [];
    $scope.following = [];
    $scope.limit = 100;
    $scope.tt = {duser: "", ruser: ""};

    $scope.refresh = function() {
      if (!$scope.active) {
        $scope.active = "blog";
      }
      if ($scope.active != "blog") {
        $scope.rest = "/"+$scope.active;
      } else {
        $scope.rest = "";
      }

      $scope.nonexist = false;
      window.Api.initPromise.then(function(response) {
        window.Api.database_api().exec("get_state", ["/@"+$stateParams.username+$scope.rest]).then(function(res){
          $scope.data = {profile: []};
          //console.log(res);
          if (Object.keys(res.content).length>0) {
            angular.forEach(res.content, function(v,k){
              v.json_metadata = v.json_metadata?angular.fromJson(v.json_metadata):v.json_metadata;
              if ($rootScope.$storage.user){
                if ($rootScope.$storage.user.username !== v.author) {
                  v.reblogged = true;
                }
                var len = v.active_votes.length;
                for (var j = len - 1; j >= 0; j--) {
                  if (v.active_votes[j].voter === $rootScope.$storage.user.username) {
                    if (v.active_votes[j].percent > 0) {
                      v.upvoted = true;
                    } else if (v.active_votes[j].percent < 0) {
                      v.downvoted = true;
                    } else {
                      v.upvoted = false;
                      v.downvoted = false;
                    }
                  }
                }
              }
              $scope.data.profile.push(v);
            });
            $scope.nonexist = false;
            if(!$scope.$$phase){
              $scope.$apply();
            }
          } else {
            $scope.nonexist = true;
          }
        });
      });
    };
    $scope.getFollows = function(r,d) {

      $scope.dfetching = function(){
        window.Api.initPromise.then(function(response) {
          window.Api.follow_api().exec("get_following", [$stateParams.username, $scope.tt.duser, "blog", $scope.limit]).then(function(res){
            if (res && res.length===$scope.limit) {
              $scope.tt.duser = res[res.length-1].following;
            }
            var len = res.length;
            for (var i = 0; i < len; i++) {
              $scope.following.push(res[i].following);
            }
            if (res.length<$scope.limit) {
              if (!$scope.$$phase) {
                $scope.$apply();
              }
            } else {
              setTimeout($scope.dfetching, 5);
            }
          });
        });
      };
      $scope.rfetching = function(){
        window.Api.initPromise.then(function(response) {
          window.Api.follow_api().exec("get_followers", [$stateParams.username, $scope.tt.ruser, "blog", $scope.limit]).then(function(res){
            if (res && res.length===$scope.limit) {
              $scope.tt.ruser = res[res.length-1].follower;
            }
            var len = res.length;
            for (var i = 0; i < len; i++) {
              $scope.follower.push(res[i].follower);
            }
            if (res.length<$scope.limit) {
              if (!$scope.$$phase) {
                $scope.$apply();
              }
            } else {
              setTimeout($scope.rfetching, 10);
            }
          });
        });
      };
      if (r) {
        $rootScope.log("rfetching");
        $scope.rfetching();

      }
      if (d) {
        $rootScope.log("dfetching");
        $scope.dfetching();
      }
    };
    $scope.getOtherUsersData = function() {
      //console.log("getOtherUsersData");
      window.Api.initPromise.then(function(response) {
        window.Api.database_api().exec("get_accounts", [[$stateParams.username]]).then(function(dd){
          dd = dd[0];
          if (dd && dd.json_metadata) {
            dd.json_metadata = angular.fromJson(dd.json_metadata);
          }
          angular.merge($scope.user, dd);
          //console.log(angular.toJson($scope.user));
          //console.log($scope.user.json_metadata.profile.cover_image);

          if ($rootScope.$storage.user) {
            $scope.css = ($rootScope.$storage.user.username === $scope.user.username && $rootScope.$storage.user.json_metadata.profile.cover_image) ? {'background': 'url('+$rootScope.$storage.user.json_metadata.profile.cover_image+')', 'background-size': 'cover', 'background-position':'fixed'} : ($rootScope.$storage.user.username !== $scope.user.username && ($scope.user.json_metadata && $scope.user.json_metadata.profile.cover_image)) ? {'background': 'url('+$scope.user.json_metadata.profile.cover_image+')', 'background-size': 'cover', 'background-position':'fixed'} : null;
          } else {
            $scope.css = null;
          }

        });
        window.Api.follow_api().exec("get_follow_count", [$stateParams.username]).then(function(res){
          //console.log(res);
          $scope.followdetails = res;
        });
      });
      $scope.getFollows(null, "d");
      if(!$scope.$$phase){
        $scope.$apply();
      }
    };

    $scope.refresh();
    if ($rootScope.$storage.user) {
      if ($rootScope.$storage.user.username !== $stateParams.username) {
        $scope.getOtherUsersData();
      } else {
          $rootScope.log("get follows counts");
          if ($rootScope.$storage.chain == "steem") {
            window.Api.initPromise.then(function(response) {
              window.Api.follow_api().exec("get_follow_count", [$stateParams.username]).then(function(res){
                //console.log(res);
                $scope.followdetails = res;
              });
            });
          } else {
            $scope.getFollows("r","d");
            setTimeout(function() {
              $scope.followdetails = {follower_count: $scope.follower.length, following_count: $scope.following.length}; 
              if (!$scope.$$phase) {
                $scope.$apply();
              } 
            }, 2000);            
          }
      }
    } else {
      if ($stateParams.username) {
        $scope.getOtherUsersData();
      }
    }

    //setTimeout(function() {
      $scope.css = ($rootScope.$storage.user&& $rootScope.$storage.user.username === $scope.user.username && $rootScope.$storage.user.json_metadata && $rootScope.$storage.user.json_metadata.profile && $rootScope.$storage.user.json_metadata.profile.cover_image) ? {'background': 'url('+$rootScope.$storage.user.json_metadata.profile.cover_image+')', 'background-size': 'cover', 'background-position':'fixed'} : ($rootScope.$storage.user && $rootScope.$storage.user.username !== $scope.user.username && ($scope.user.json_metadata && $scope.user.json_metadata.profile && $scope.user.json_metadata.profile.cover_image)) ? {'background': 'url('+$scope.user.json_metadata.profile.cover_image+')', 'background-size': 'cover', 'background-position':'fixed'} : null;
      //console.log($scope.css);
    //}, 1);

  });
  $scope.openMenu = function() {
    $ionicSideMenuDelegate.toggleLeft();
  }
  $scope.change = function(type){
    $scope.data = undefined;
    $scope.data = {profile: []};
    $scope.accounts = [];
    $scope.active = type;
    $scope.end = false;
    if (type != "blog") {
      $scope.rest = "/"+type;
    } else {
      $scope.rest = "";
    }
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_state", ["/@"+$stateParams.username+$scope.rest]).then(function(res){
        //console.log(res);
        if (res.content) {
          if (Object.keys(res.content).length>0) {
            angular.forEach(res.content, function(v,k){
              v.json_metadata = v.json_metadata?angular.fromJson(v.json_metadata):v.json_metadata;
              if ($rootScope.$storage.user){
                if ($rootScope.$storage.user.username !== v.author) {
                  v.reblogged = true;
                }
                var len = v.active_votes.length;
                for (var j = len - 1; j >= 0; j--) {
                  if (v.active_votes[j].voter === $rootScope.$storage.user.username) {
                    if (v.active_votes[j].percent > 0) {
                      v.upvoted = true;
                    } else if (v.active_votes[j].percent < 0) {
                      v.downvoted = true;
                    } else {
                      v.upvoted = false;
                      v.downvoted = false;
                    }
                  }
                }
              }
              $scope.data.profile.push(v);
            });
            $scope.nonexist = false;
          } else {
            $scope.nonexist = true;
          }
          if(!$scope.$$phase){
            $scope.$apply();
          }
        }
        if (type==="transfers" || type==="permissions") {
          for (var property in res.accounts) {
            if (res.accounts.hasOwnProperty(property)) {
              $scope.accounts = res.accounts[property];
              //$rootScope.log(angular.toJson(res.accounts[property].transfer_history));
              $scope.transfers = res.accounts[property].transfer_history;
              $scope.nonexist = false;
            }
          }
          if(!$scope.$$phase){
            $scope.$apply();
          }
        }
      });
    });
  }

})

app.controller('ExchangeCtrl', function($scope, $stateParams, $rootScope) {
  $scope.username = $stateParams.username;

  $scope.$on('$ionicView.beforeEnter', function(){
    $scope.active = 'buy';
    $scope.orders = [];
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_order_book", [15]).then(function(res){
        $scope.orders = res;
        if (!$scope.$$phase) {
          $scope.$apply();
        }
      });
    });
    $scope.change = function(type){
      $scope.active = type;
      if (type == "open"){
        window.Api.initPromise.then(function(response) {
          window.Api.database_api().exec("get_open_orders", [$stateParams.username]).then(function(res){
            $scope.openorders = res;
            if (!$scope.$$phase) {
              $scope.$apply();
            }
          });
        });
      }
      if (type == "history"){
        $scope.history = [];
        window.Api.initPromise.then(function(response) {
          window.Api.market_history_api().exec("get_recent_trades", [15]).then(function(r){
            $scope.recent_trades = r;
            if (!$scope.$$phase) {
              $scope.$apply();
            }
          });
        });
      }
    };
  });

});
app.controller('MarketCtrl', function($scope, $rootScope, $state, $ionicPopover, $ionicPopup, $filter, $translate, $ionicPlatform, $window) {

  $scope.requestApp = function(name) {
    $ionicPlatform.ready(function() {
      if (name == 'New') {
        window.open("mailto:info@esteem.ws?subject=Suggesting%20New%20App%20for%20Market%20Place&body=Hello!%0D%0A%0D%0AAppName:%0D%0AAppAuthor:%0D%0AAppLink:%0D%0A%0D%0A", "_system");
      }
      if (ionic.Platform.isIOS() || ionic.Platform.isIPad()) {
        if (name == 'SteemMonitor') {
          //cordova.plugins.market.open('id1158918690');
          window.open("itms-apps://itunes.apple.com/app/id1158918690", "_system");
        }
        if (name == 'SteemFest') {
          //cordova.plugins.market.open('id1171371708');
          window.open("itms-apps://itunes.apple.com/app/id1171371708", "_system");
        }
      } else {
        if (name == 'SteemMonitor') {
          //cordova.plugins.market.open('com.netsolutions.esteemwitness');
          window.open("market://details?id=com.netsolutions.esteemwitness", "_system");
        }
        if (name == 'SteemFest') {
          //cordova.plugins.market.open('com.netsolutions.steemfest');
          window.open("market://details?id=com.netsolutions.steemfest", "_system");
        }
      }
    });
  }

});

app.controller('SettingsCtrl', function($scope, $stateParams, $rootScope, $ionicHistory, $state, $ionicPopover, $ionicPopup, APIs, $filter, $translate, $window, $ionicSideMenuDelegate) {

   $ionicPopover.fromTemplateUrl('popover.html', {
      scope: $scope
   }).then(function(popover) {
      $scope.tooltip = popover;
   });

   $scope.openTooltip = function($event, d) {
      var texth = d;
      $scope.tooltipText = texth;
      $scope.tooltip.show($event);
   };

  function getDate(xx) {
    angular.forEach($rootScope.$storage.currencies, function(v,k){
      if (v.id == xx) {
        return true;
      }
    });
  }

  function searchObj(nameKey, myArray) {
    for (var i=0; i < myArray.length; i++) {
        if (myArray[i].id === nameKey) {
            return myArray[i];
        }
    }
  }

  $scope.changeCurrency = function(xx, ignore) {
    $rootScope.$broadcast('changedCurrency', {currency: xx, enforce: ignore});
  }
  $scope.changeChain = function() {
    $scope.restart = true;
    if ($rootScope.$storage.chain == 'steem'){
      $rootScope.$storage.platformname = "Steem";
      $rootScope.$storage.platformpower = "Steem Power";
      $rootScope.$storage.platformsunit = "Steem";
      $rootScope.$storage.platformdollar = "Steem Dollar";
      $rootScope.$storage.platformdunit = "SBD";
      $rootScope.$storage.platformpunit = "SP";
      $rootScope.$storage.platformlunit = "STEEM";
      $rootScope.$storage.socketsteem = "wss://steemd.steemit.com";
      $scope.socket = "wss://steemd.steemit.com";
    } else {
      $rootScope.$storage.platformname = "ГОЛОС";
      $rootScope.$storage.platformpower = "СИЛА ГОЛОСА";
      $rootScope.$storage.platformsunit = "Голос";
      $rootScope.$storage.platformdollar = "ЗОЛОТОЙ";
      $rootScope.$storage.platformdunit = "GBG";
      $rootScope.$storage.platformpunit = "СИЛА ГОЛОСА";
      $rootScope.$storage.platformlunit = "ГОЛОС";
      $rootScope.$storage.socketgolos = "wss://ws.golos.io/";
      //$scope.socket = "wss://golos.steem.ws";
      $scope.socket = "wss://ws.golos.io/";
    }
    $scope.changeCurrency($rootScope.$storage.currency, true);
  }
  $scope.restart = false;
  $scope.closeTooltip = function() {
    $scope.tooltip.hide();
  };

  //Cleanup the popover when we're done with it!
  $scope.$on('$destroy', function() {
    $scope.tooltip.remove();
  });

  $scope.changeLanguage = function(locale){
    setTimeout(function() {
      $translate.use(locale);
      if (!$scope.$$phase) {
        $scope.$apply();
      }
      //$window.location.reload(true);
    }, 1);
  }

  $scope.$on('$ionicView.beforeEnter', function(){
    $rootScope.$storage["socket"+$rootScope.$storage.chain] = localStorage.socketUrl;
    $scope.data = {};
    if (!$rootScope.$storage.voteWeight){
      $rootScope.$storage.voteWeight = 10000;
      $scope.vvalue = 100;
    } else {
      $scope.vvalue = $rootScope.$storage.voteWeight/100;
    }
    if(!$scope.$$phase){
      $scope.$apply();
    }
    $scope.slider = {
      value: $scope.vvalue,
      options: {
        floor: 1,
        ceil: 100
      }
    };

    if ($rootScope.$storage.pincode) {
      $scope.data = {pin: true};
    } else {
      $scope.data = {pin: false};
    }

    if ($rootScope.$storage.user && $rootScope.$storage.deviceid) {
      APIs.getSubscriptions($rootScope.$storage.deviceid).then(function(res){
        $rootScope.log(angular.toJson(res.data));
        angular.merge($scope.data, {vote: res.data[0].subscription.vote, follow: res.data[0].subscription.follow, comment: res.data[0].subscription.comment, mention: res.data[0].subscription.mention, resteem: res.data[0].subscription.resteem});
        if (!$scope.$$phase){
          $scope.$apply();
        }
      });
    }

    if (!$scope.$$phase){
      $scope.$apply();
    }
  });

  $scope.notificationChange = function() {
    $rootScope.$storage.subscription = {
      vote: $scope.data.vote,
      comment: $scope.data.comment,
      follow: $scope.data.follow,
      mention: $scope.data.mention,
      resteem: $scope.data.resteem,
      device: ionic.Platform.platform(),
      timestamp: $filter('date')(new Date(), 'medium'),
      appversion: '1.3.9'
    }
    APIs.updateSubscription($rootScope.$storage.deviceid, $rootScope.$storage.user.username, $rootScope.$storage.subscription).then(function(res){
      console.log(angular.toJson(res));
    });

  }

  $scope.$watch('slider', function(newValue, oldValue){
    //console.log(newValue.value);
    if (newValue.value) {
      $rootScope.$storage.voteWeight = newValue.value*100;
    }
  }, true);

  $scope.pinChange = function() {
    $rootScope.log("pinChange");
    if ($rootScope.$storage.pincode) {
      $rootScope.$broadcast("pin:check");
    } else {
      $rootScope.$broadcast("pin:new");
    }
  }

  $rootScope.$on("pin:correct", function(){
    $rootScope.log("pin:correct " + $scope.data.pin);
    if (!$scope.data.pin) {
        $rootScope.$storage.pincode = undefined;
    }
    if ($rootScope.$storage.pincode) {
      $scope.data.pin = true;
    } else {
      $scope.data.pin = false;
    }
    if (!$scope.$$phase){
      $scope.$apply();
    }
  });

  $rootScope.$on("pin:failed", function(){
    $rootScope.log("pin:failed");
    setTimeout(function() {
      if ($rootScope.$storage.pincode) {
        $scope.data.pin = true;
      } else {
        $scope.data.pin = false;
      }
      if (!$scope.$$phase){
        $scope.$apply();
      }
    }, 10);

  });
  $scope.logouts = function() {
    $rootScope.$storage.user = undefined;
    $rootScope.$storage.user = null;
    $rootScope.$storage.mylogin = undefined;
    $rootScope.$storage.mylogin = null;
    //make sure user credentials cleared.
    if ($rootScope.$storage.deviceid) {
      APIs.deleteSubscription($rootScope.$storage.deviceid).then(function(res){
        $ionicSideMenuDelegate.toggleLeft();
        $window.location.reload(true);
      });
    } else {
      $ionicSideMenuDelegate.toggleLeft();
      $window.location.reload(true);
    }
    $rootScope.$storage.filter = undefined;
    $rootScope.$storage.tag = undefined;

    $ionicHistory.clearCache();
    $ionicHistory.clearHistory();
    setTimeout(function() {
      ionic.Platform.exitApp(); // stops the app
    }, 100);
  };
  $scope.socket = $rootScope.$storage["socket"+$rootScope.$storage.chain];
  $scope.socketChange = function(xx){
    console.log(xx);
    $rootScope.$storage["socket"+$rootScope.$storage.chain] = xx;
    localStorage.socketUrl = xx;
    $scope.restart = true;
  }
  $scope.save = function(){
    if ($scope.restart) {
      var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('ARE_YOU_SURE'),
        template: $filter('translate')('UPDATE_REQUIRES_RESTART')
      });
      confirmPopup.then(function(res) {
        if(res) {
          $rootScope.log('You are sure');
          //$scope.logouts();
          $window.location.reload(true);  
        } else {
          $rootScope.log('You are not sure');
        }
      });
    } else {
      $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('SETTINGS_UPDATED'));
      $ionicHistory.nextViewOptions({
        disableBack: true
      });
      //$state.go('app.posts', {}, {reload: true});
      $window.location.reload(true);  
    }
  };

});
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/posts/controllers.js","/posts")
},{"buffer":11,"pBGvAp":74}],137:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){


var app = angular.module('steem', [
	'ionic',
	'ngStorage',
	'ngCordova',
  'rzModule',
  'ion-floating-menu',
  'pascalprecht.translate',
  'ja.qr'
]);

if (localStorage.getItem("socketUrl") === null) {
  localStorage.setItem("socketUrl", "wss://steemit.com/wspa");
}

window.steemRPC = require("steem-rpc");
window.Api = window.steemRPC.Client.get({url:localStorage.socketUrl}, true);
window.steemJS = require("steemjs-lib");
window.golosJS = require("golosjs-lib");
window.diff_match_patch = require('diff-match-patch');
window.getSymbol = require('currency-symbol-map');

require('./config')(app);
require('./services')(app);
require('./controllers')(app);


app.config(function($stateProvider, $urlRouterProvider, $ionicConfigProvider, $sceDelegateProvider, $logProvider, $compileProvider, $animateProvider, $translateProvider) {
  $stateProvider

  .state('app', {
    url: '/app',
    abstract: true,
    template: "<ion-side-menus enable-menu-with-back-views=\"false\">\n  <ion-side-menu-content drag-content=\"false\">\n    <ion-nav-bar class=\"bar-positive\">\n      <ion-nav-back-button>\n      </ion-nav-back-button>\n\n      <ion-nav-buttons side=\"left\">\n        <button class=\"button button-icon button-clear ion-navicon\" menu-toggle=\"left\">\n        </button>\n      </ion-nav-buttons>\n    </ion-nav-bar>\n    <ion-nav-view name=\"menuContent\"></ion-nav-view>\n  </ion-side-menu-content>\n\n  <ion-side-menu side=\"left\">\n    <!--<ion-header-bar class=\"bar-positive\" ng-if=\"!$root.$storage.user\">\n      <h1 class=\"title center\">eSteem</h1>\n    </ion-header-bar>-->\n    <ion-content>\n      <div ng-if=\"!$root.$storage.user\">\n        <center>\n          <p>\n            <img ng-src=\"img/about.png\" width=\"200\" />\n          </p>\n        </center>\n      </div>\n      <div ng-if=\"$root.$storage.user\" ng-style=\"$root.$storage.user.json_metadata.profile.cover_image ? mcss : null\">\n      <br>\n        <center>\n          <a menu-close href=\"#/app/profile/{{$root.$storage.user.username}}\" class=\"item-myavatar\" ng-if=\"$root.$storage.user\">\n            <span class=\"item-myavatar\" ng-if=\"!$root.$storage.user.json_metadata.user_image && !$root.$storage.user.json_metadata.profile.profile_image\"><img src=\"img/user_profile.png\"></span>\n            <img ng-src=\"{{$root.$storage.user.json_metadata.profile.profile_image || $root.$storage.user.json_metadata.user_image}}\" ng-if=\"$root.$storage.user.json_metadata.user_image || $root.$storage.user.json_metadata.profile.profile_image\" />\n          </a>\n          <div ng-class=\"{'footprofileinfomenu':$root.$storage.user.json_metadata.profile.cover_image}\">\n            <div class=\"h4\">@{{$root.$storage.user.username}}&nbsp;<div class=\"reputation\">{{$root.$storage.user.reputation|reputation:true|number:1}}</div></div>\n            <div ng-click=\"showMeExtra()\" class=\"padding\"><i class=\"icon ion-android-list\"></i>&nbsp;{{$root.$storage.user.post_count}}&nbsp;&nbsp;<i class=\"icon ion-arrow-graph-up-right\"></i>&nbsp;{{$root.$storage.user.voting_power/100|number:2}} <i class=\"icon pull-right\" ng-class=\"{'ion-arrow-down-b':!showExtra, 'ion-arrow-up-b':showExtra}\"></i></div>\n          </div>\n        </center>\n      </div>\n      <div ng-if=\"showExtra\">\n        <ion-list>\n          <ion-item menu-close class=\"item-icon-left\" ng-if=\"$root.$storage.users\" ng-repeat=\"user in $root.$storage.users\" ng-click=\"selectAccount(user)\" ng-class=\"{'active': (user.username==$root.$storage.user.username&&user.chain==$root.$storage.user.chain) }\">\n            <img class=\"icon logos\" ng-src=\"{{'img/'+user.chain+'_icon.png'}}\" />\n            {{user.username}}\n            <!--<span class=\"badge badge-assertive\">{{user.chain}}</span>-->\n          </ion-item>\n          <ion-item menu-close ng-click=\"openLogin()\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n            <i class=\"icon ion-plus-round\"></i>\n            {{'ADD_ACCOUNT'|translate}}\n          </ion-item>\n          <ion-item menu-close ng-click=\"openPostModal()\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n            <i class=\"icon ion-android-create\"></i>\n            {{'SUBMIT_A_STORY'|translate}}\n          </ion-item>\n          <ion-item menu-close href=\"#/app/profile/{{$root.$storage.user.username}}\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n            <i class=\"icon ion-person\"></i>\n            {{'PROFILE'|translate}}\n          </ion-item>\n          <ion-item menu-close href=\"#/app/follow\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n            <i class=\"icon ion-person-stalker\"></i>\n            {{'FOLLOW'|translate}}\n          </ion-item>\n          <ion-item menu-close ng-click=\"logout()\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n            <i class=\"icon ion-log-out\"></i>\n            {{'LOGOUT'|translate}}\n          </ion-item>\n        </ion-list>\n      </div>\n      <ion-list>\n        <ion-item menu-close ng-click=\"openLogin()\" class=\"item-icon-left\" ng-if=\"!$root.$storage.user\">\n          <i class=\"icon ion-log-in\"></i>\n          {{'LOGIN'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/posts/\" class=\"item-icon-left\">\n          <i class=\"icon ion-home\"></i>\n          {{'HOME'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/bookmark\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n          <i class=\"icon ion-bookmark\"></i>\n          {{'BOOKMARKS'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/drafts\" ng-if=\"$root.$storage.user\" class=\"item-icon-left\">\n          <i class=\"icon ion-compose\"></i>\n          {{'DRAFTS'|translate}}\n        </ion-item>\n        <!--<ion-item menu-close href=\"#/app/notifications\" class=\"item-icon-left\" ng-if=\"$root.$storage.notifications && $root.$storage.notifications.length>0\">\n          <i class=\"icon ion-bookmark\"></i>\n          {{'NOTIFICATIONS'|translate}}\n        </ion-item>-->\n        <ion-item menu-close href=\"#/app/send\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n          <i class=\"icon ion-android-send\"></i>\n          {{'TRANSFER'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/exchange/{{$root.$storage.user.username}}\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n          <i class=\"icon ion-arrow-swap\"></i>\n          {{'EXCHANGE'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/market\" class=\"item-icon-left\">\n          <i class=\"icon ion-cube\"></i>\n          {{'MARKETPLACE'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/settings\" class=\"item-icon-left\">\n          <i class=\"icon ion-android-settings\"></i>\n          {{'SETTINGS'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/about\" class=\"item-icon-left\">\n          <i class=\"icon ion-information\"></i>\n          {{'ABOUT'|translate}}\n        </ion-item>\n      </ion-list>\n    </ion-content>\n    <!-- align to the bottom of the page -->\n    <div style=\"position: absolute; bottom: 0px; width: 100%\" ng-if=\"$root.$storage.appversion\">\n        <div style=\"text-align: center; color:#ccc;\">\n          <p>{{$root.$storage.appversion}}</p>\n        </div>\n    </div>\n  </ion-side-menu>\n</ion-side-menus>\n",
    //templateUrl: 'templates/menu.html',
    controller: 'AppCtrl'
  })

  .state('app.settings', {
    url: '/settings',
    views: {
      'menuContent': {
        //templateUrl: 'templates/settings.html'
        template: "<ion-view view-cache=\"false\" view-title=\"{{'SETTINGS'|translate}}\">\n  <ion-content class=\"padding has-header settings\">\n    <br/>\n    <div class=\"item item-divider\">\n      {{'SECURITY'|translate}}\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"PIN_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i> {{'PIN_CODE'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.pin\" ng-change=\"pinChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    <div ng-if=\"$root.$storage.user\">\n    <div class=\"item item-divider\">\n      {{'NOTIFICATIONS'|translate}}\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"VOTE_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i> {{'VOTE'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.vote\" ng-change=\"notificationChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"COMMENT_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i> {{'COMMENT'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.comment\" ng-change=\"notificationChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"FOLLOW_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i> {{'FOLLOW'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.follow\" ng-change=\"notificationChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"MENTIONS_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i> {{'MENTIONS'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.mention\" ng-change=\"notificationChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"RESTEEM_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i> {{'RESTEEM'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.resteem\" ng-change=\"notificationChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    </div>\n    <div class=\"item item-divider\">\n      {{'CONFIGURATIONS'|translate}}\n    </div>\n\n    <div class=\"row\" ng-if=\"$root.$storage.user\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"VOTING_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i> {{'VOTING'|translate}} (%)</span>\n      </div>\n      <div class=\"col\">\n      <rzslider rz-slider-model=\"slider.value\" rz-slider-options=\"slider.options\"></rzslider>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col col-33\">\n        <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"LANGUAGES_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i> {{'LANGUAGES'|translate}}</span>\n      </div>\n      <div class=\"col\">\n        <select ng-model=\"$root.$storage.language\" ng-change='changeLanguage($root.$storage.language)'>\n          <option ng-repeat=\"option in $root.$storage.languages\" value=\"{{option.id}}\">{{option.name}}</option>\n        </select>\n        <!--<div class=\"capital\">{{$root.$storage.language}} <div class=\"pull-right\"><i class=\"icon ion-chevron-right\"></i></div></div>-->\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col col-33\">\n        <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"CURRENCY_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i> {{'CURRENCY'|translate}}</span>\n      </div>\n      <div class=\"col\">\n        <select ng-model=\"$root.$storage.currency\" ng-change='changeCurrency($root.$storage.currency)'>\n          <option ng-repeat=\"option in $root.$storage.currencies\" value=\"{{option.id}}\">{{option.name}}</option>\n        </select>\n        <!--<div class=\"capital\">{{$root.$storage.language}} <div class=\"pull-right\"><i class=\"icon ion-chevron-right\"></i></div></div>-->\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n        <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"CHAIN_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i> {{'CHAIN'|translate}}</span>\n      </div>\n      <div class=\"col\">\n        <select ng-model=\"$root.$storage.chain\" ng-change='changeChain($root.$storage.chain)'>\n          <option ng-repeat=\"option in $root.$storage.chains\" value=\"{{option.id}}\">{{option.name}}</option>\n        </select>\n        <!--<div class=\"capital\">{{$root.$storage.language}} <div class=\"pull-right\"><i class=\"icon ion-chevron-right\"></i></div></div>-->\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col col-33\">\n        <span class=\"slabel\" ng-click='openTooltip($event,\"<span class=\\\"bold\\\">{{\"SERVER_TEXT\"|translate}}:</span><br><span class=\\\"wrap\\\">[steemit] wss://steemd.steemit.com</span><br/><br/><span class=\\\"wrap\\\">[steem.ws] wss://node.steem.ws</span><br/><br/><span class=\\\"wrap\\\">[piston] wss://this.piston.rocks</span><br/><br/><span class=\\\"wrap\\\">[golos] wss://ws.golos.io</span><br/><br/><span class=\\\"wrap\\\">[golos.ws] wss://node.golos.ws</span>\n        \")'><i class=\"icon ion-ios-information-outline gray\"></i> {{'SERVER'|translate}}</span>\n      </div>\n      <div class=\"col\">\n        <input type=\"text\" placeholder=\"Server\" ng-model=\"socket\" style=\"width:100%;\" ng-change=\"socketChange(socket)\">\n      </div>\n    </div>\n\n    <!--<div class=\"row\">\n      <div class=\"col\">\n      </div>\n      <div class=\"col\">\n      </div>\n    </div>\n    <button class=\"button button-positive\" ng-click=\"changeLanguage('ru')\">Change RU</button>-->\n    <br/>\n    <script id = \"popover.html\" type=\"text/ng-template\">\n      <ion-popover-view>\n        <ion-content>\n          <div class=\"padding\" ng-bind-html=\"tooltipText\"></div>\n        </ion-content>\n      \n      </ion-popover-view>\n    </script>\n    <div class=\"tcenter\">\n      <button class=\"button button-positive\" ng-click=\"save()\">{{'SAVE_CHANGES'|translate}}</button>\n    </div>\n  </ion-content>\n</ion-view>\n",
        controller: 'SettingsCtrl'
      }
    }
  })

  .state('app.about', {
    url: '/about',
    views: {
      'menuContent': {
        //templateUrl: 'templates/settings.html'
        template: "<ion-view view-cache=\"false\" view-title=\"{{'ABOUT' | translate}} - v{{$root.$storage.appversion}}\">\n  <ion-content class=\"padding\">\n    <center><img src=\"img/about.png\"></center>\n    <p><b>eSteem</b> {{'ABOUT_2'|translate}} <div ng-bind-html=\"'ABOUT_11'|translate\"></div>\n    </p>\n    <p ng-if=\"$root.$storage.user\">{{\"FOUNDER\"|translate}} <a href=\"#app/profile/good-karma\">good-karma</a></p>\n    <div class=\"tcenter\" ng-if=\"$root.$storage.user\"><span ng-if=\"!$root.isWitnessVoted()\"><button class=\"button button-positive\" ng-click=\"$root.voteWitness()\">{{'ABOUT_8'|translate}}</button></span></div>\n    <p>\n    <b><u>{{'ABOUT_9'|translate}}</u></b>\n    <br><a href=\"mailto:info@esteem.ws?Subject=Feedback\">info@esteem.ws</a>\n    <br><a href=\"http://esteem.ws\">http://esteem.ws</a>\n    </p>\n    <p>\n        <b><u>{{'TRANSLATIONS'|translate}}</u></b><br>\n        Русский - <a href=\"#app/profile/testz\">testz</a>, <a href=\"#app/profile/on0tole\">on0tole</a><br>\n        Deutsch - <a href=\"#app/profile/dez1337\">dez1337</a>, <a href=\"#app/profile/homosapiens\">homosapiens</a>, <a href=\"#app/profile/uwelang\">uwelang</a><br>\n        Français - <a href=\"#app/profile/pickoum\">pickoum</a><br>\n        Español - <a href=\"#app/profile/dresden\">dresden</a>, <a href=\"#app/profile/pgarcgo\">pgarcgo</a><br>\n        Ελληνικά - <a href=\"#app/profile/liondani\">liondani</a>, <a href=\"#app/profile/steemychicken1\">steemychicken1</a><br>\n        Български - <a href=\"#app/profile/rossenpavlov\">rossenpavlov</a><br>\n        Nederlands - <a href=\"#app/profile/maxse\">maxse</a><br>\n        Magyar - <a href=\"#app/profile/tibonova\">tibonova</a><br>\n        Čeština - <a href=\"#app/profile/valtr\">valtr</a><br>\n        עברית‎ - <a href=\"#app/profile/bosrad\">bosrad</a><br>\n        Polski - <a href=\"#app/profile/knittybynature\">knittybynature</a><br>\n        Português - <a href=\"#app/profile/alamyrjunior\">alamyrjunior</a>, <a href=\"#app/profile/charlie777pt\">charlie777pt</a><br>\n        Português BR - <a href=\"#app/profile/charlie777pt\">charlie777pt</a><br>\n        Bahasa Indonesia - <a href=\"#app/profile/levycore\">levycore</a>, <a href=\"#app/profile/happyphoenix\">happyphoenix</a><br>\n        繁體中文 - <a href=\"#app/profile/deanliu\">deanliu</a><br>\n        简体中文 - <a href=\"#app/profile/huangdashuang\">huangdashuang</a>, <a href=\"#app/profile/oflyhigh\">oflyhigh</a><br>\n        Dolan - <a href=\"#app/profile/maxse\">maxse</a><br>\n        Svensk - <a href=\"#app/profile/acidyo\">acidyo</a>, <a href=\"#app/profile/the-ego-you\">the-ego-is-you</a><br>\n        <!--\n        malay-killuminatic\n        -->\n    </p>\n    <p>\n    <b><u>{{'ABOUT_10'|translate}}</u></b>\n    <br><a href=\"https://steem.io\">https://steem.io</a>\n    <br><a href=\"https://golos.io\">https://golos.io</a>\n    </p>\n  </ion-content>\n</ion-view>\n"
      }
    }
  })

	.state('app.market', {
		url: '/market',
		views: {
			'menuContent': {
				//templateUrl: 'templates/settings.html'
				template: "<ion-view view-cache=\"false\" view-title=\"{{'MARKETPLACE' | translate}}\">\n  <ion-content class=\"padding\">\n    <h4>{{'EXTERNAL_APPS'|translate}}</h4>\n    <div class=\"row\">\n      <div class=\"col\" ng-click=\"requestApp('SteemMonitor')\">\n        <center>\n          <img src=\"img/logo_steemmonitor.png\" alt=\"Steem Monitor\" width=\"100\">\n          <b>Steem Monitor</b>\n          <p class=\"gray\">{{'BY'|translate}} <a href=\"#app/profile/good-karma\">Feruz</a></p>\n        </center>\n      </div>\n      <div class=\"col\" ng-click=\"requestApp('SteemFest')\">\n        <center>\n          <img src=\"img/logo_steemfest.png\" alt=\"Steem Fest\" width=\"100\">\n          <b>Steem Fest</b>\n          <p class=\"gray\">{{'BY'|translate}} <a href=\"#app/profile/good-karma\">Feruz</a>, <a href=\"#app/profile/roelandp\">Roeland</a> &amp; <a href=\"#app/profile/cass\">Cass</a></p>\n        </center>\n      </div>\n    </div><br/>\n    <h4>{{'PLUGINS'|translate}}</h4>\n    <div class=\"row\">\n      <div class=\"col italic\">\n        <center>\n          {{'COMING_SOON'|translate}}...\n        </center>\n      </div>\n    </div>\n    <br/>\n    <h4>{{'SUGGEST'|translate}}</h4><br/>\n    <div class=\"row\">\n      <div class=\"col\" ng-click=\"requestApp('New')\">\n        <center>\n          <img src=\"img/plus.png\" alt=\"Suggest New\" width=\"100\">\n          <b>{{'NEW'|translate}}</b>\n        </center>\n      </div>\n      <div class=\"col\">\n      </div>\n    </div>\n  </ion-content>\n</ion-view>\n",
				controller: 'MarketCtrl'
			}
		}
	})

  .state('app.send', {
    url: '/send',
    views: {
      'menuContent': {
        //templateUrl: 'templates/settings.html'
        template: "<ion-view view-cache=\"false\" view-title=\"{{'TRANSFER'|translate}}\">\n  <ion-content class=\"padding\">\n    <div class=\"list\">\n      <div class=\"item item-input item-icon-right\">\n        <span class=\"input-label\">{{'TO'|translate}}</span>\n        <input type=\"text\" ng-model=\"data.username\" placeholder=\"{{'TO_DESC'|translate}}\" ng-change=\"changeUsername()\">\n        <i class=\"icon ion-ios-camera-outline\" ng-click=\"qrScan()\"></i>\n      </div>\n      <label class=\"item item-input item-select\">\n        <span class=\"input-label\">{{'ASSET'|translate}}</span>\n        <!--<select ng-model=\"data.type\" ng-change=\"typechange()\">\n            <option value=\"steem\">STEEM</option>\n            <option value=\"sbd\">SBD</option>\n            <option value=\"sp\">SP</option>\n        </select>-->\n        <select ng-model=\"data.type\" ng-options=\"item.type as item.name for item in data.types track by item.id\"></select>\n      </label>\n      <label class=\"item item-input\">\n        <span class=\"input-label\">{{'AMOUNT'|translate}}</span>\n        <input type=\"number\" placeholder=\"{{'AMOUNT'|translate}}\" step=\"0.001\" ng-model=\"data.amount\">\n      </label>\n      <label class=\"item item-input\" ng-if=\"data.type != 'sp'&&data.type != 'golosp'\">\n        <span class=\"input-label\">{{'MEMO'|translate}}</span>\n        <textarea ng-model=\"data.memo\" rows=\"3\" placeholder=\"{{'PUBLIC_MEMO'|translate}}\"></textarea>\n      </label>\n      <p class=\"item\" ng-if=\"balance\">{{'AVAILABLE'|translate}}: {{balance.balance}}, {{balance.sbd_balance}} <i class=\"icon ion-refresh pull-right\" ng-click=\"refresh()\"></i></p>\n      <br>\n      <center><button class=\"button button-positive\" ng-click=\"transfer()\">\n        {{'SEND'|translate}}\n      </button></center>\n      <br>\n      <center><qr text=\"$root.$storage.user.username\"></qr></center>\n      <center><i class=\"italic\">{{$root.$storage.user.username}}</i></center>\n    </div>\n  </ion-content>\n</ion-view>\n",
        controller: 'SendCtrl'
      }
    }
  })

  .state('app.follow', {
    url: '/follow',
    views: {
      'menuContent': {
        //templateUrl: 'templates/follow.html',
        template: "<ion-view view-cache=\"false\" view-title=\"{{'FOLLOW' | translate}}\">\n  <ion-content class=\"padding has-footer\" delegate-handle=\"listScroll\">\n    <div class=\"list list-inset\" ng-if=\"active=='followers'\">\n      <label class=\"item item-input\">\n        <i class=\"icon ion-search placeholder-icon\"></i>\n        <input type=\"text\" ng-model=\"searchu.follower\" placeholder=\"{{'SEARCH_FOLLOWERS' | translate}}\">\n      </label>\n    </div>\n    <div class=\"list list-inset\" ng-if=\"active=='following'\">\n      <label class=\"item item-input\">\n        <i class=\"icon ion-search placeholder-icon\"></i>\n        <input type=\"text\" ng-model=\"searchu.following\" placeholder=\"{{'SEARCH_FOLLOWING' | translate}}\">\n      </label>\n    </div>\n    <div class=\"list\" ng-if=\"active=='followers' && followers.length>0\">\n      <div class=\"item item-button-right\" ng-repeat=\"f in followers | filter:searchu  track by $index\">\n        <span ng-click=\"profileView(f.follower)\">{{f.follower}}</span>\n        <button class=\"button button-positive button-outline\" ng-if=\"!isFollowed(f.follower)\" ng-click=\"followUser(f.follower)\">\n        {{'FOLLOW_BACK' | translate}}\n        </button>\n        <button class=\"button button-positive\" ng-if=\"isFollowed(f.follower)\" ng-click=\"unfollowUser(f.follower)\">\n        {{'FOLLOWED' | translate}}\n        </button>\n      </div>\n    </div>\n    <div class=\"list\" ng-if=\"active=='following' && following.length>0\">\n      <div class=\"item item-button-right\" ng-repeat=\"f in following | filter:searchu  track by $index\">\n        <span ng-click=\"profileView(f.following)\">{{f.following}}</span>\n        <button class=\"button button-positive button-outline\" ng-if=\"!isFollowing(f.following)\" ng-click=\"unfollowUser(f.following)\">\n        {{'UNFOLLOW' | translate}}\n        </button>\n        <button class=\"button button-positive\" ng-if=\"isFollowing(f.following)\">\n        {{'FOLLOWING' | translate}}\n        </button>\n      </div>\n    </div>\n    <!--<ion-infinite-scroll on-infinite=\"loadMore()\" ng-if=\"lastd\" distance=\"2%\"></ion-infinite-scroll>-->\n  </ion-content>\n  <div class=\"bar profile bar-footer\">\n    <div class=\"button-bar\">\n      <a class=\"button button-large button-royal icon ion-ios-people\" ng-class=\"{'active':active=='followers'}\" ng-click=\"change('followers')\"> {{'FOLLOWERS' | translate}} <span ng-if=\"followers.length>0\">({{followers.length}})</span></a>\n      <a class=\"button button-royal icon ion-person-add\" ng-class=\"{'active':active=='following'}\" ng-click=\"change('following')\"> {{'FOLLOWED' | translate}} <span ng-if=\"following.length>0\">({{following.length}})</span></a>\n    </div>\n  </div>\n</ion-view>\n",
        controller: 'FollowCtrl'
      }
    }
  })


  .state('app.exchange', {
    url: '/exchange/:username',
    views: {
      'menuContent': {
      	template: "<ion-view view-cache=\"false\" view-title=\"{{'MARKET_VIEW' | translate}}\">\n  <ion-content class=\"padding has-footer exchange\">\n    <div class=\"\" ng-if=\"active=='buy'\">\n      <div class=\"row header\">\n        <div class=\"col\">{{'PRICE' | translate}}</div>\n        <div class=\"col\">{{'AMOUNT' | translate}}</div>\n        <div class=\"col\">{{'TOTAL' | translate}}</div>\n      </div>\n      <div class=\"row\" ng-repeat=\"(key, f) in orders.bids\">\n        <div class=\"col\">{{f.real_price|number:4}}</div>\n        <div class=\"col\">{{f.order_price.quote}}</div>\n        <div class=\"col\">{{f.order_price.base}}</div>\n      </div>\n    </div>\n    <div class=\"\" ng-if=\"active=='sell'\">\n      <div class=\"row header\">\n        <div class=\"col\">{{'PRICE' | translate}}</div>\n        <div class=\"col\">{{'AMOUNT' | translate}}</div>\n        <div class=\"col\">{{'TOTAL' | translate}}</div>\n      </div>\n      <div class=\"row\" ng-repeat=\"(key, f) in orders.asks\">\n        <div class=\"col\">{{f.real_price|number:4}}</div>\n        <div class=\"col\">{{f.order_price.quote}}</div>\n        <div class=\"col\">{{f.order_price.base}}</div>\n      </div>\n    </div>\n    <div class=\"\" ng-if=\"active=='open'\">\n      <p class=\"padding\" ng-if=\"openorders.length<1\">\n        {{'NOORDERS' | translate}} @{{username}}\n      </p>\n      <div ng-if=\"openorders.length>0\">\n        <div class=\"row header\">\n          <div class=\"col\">{{'PRICE' | translate}}</div>\n          <div class=\"col\">{{'AMOUNT' | translate}}</div>\n          <div class=\"col\">{{'TOTAL' | translate}}</div>\n        </div>\n        <div class=\"row\" ng-repeat=\"(key, f) in openorders\">\n          <div class=\"col\">{{f.real_price|number:4}}</div>\n          <div class=\"col\" ng-if=\"f.seller==$root.$storage.user.username\">{{f.sell_price.quote}}</div>\n          <div class=\"col\" ng-if=\"f.seller==$root.$storage.user.username\">{{f.sell_price.base}}</div>\n          <div class=\"col\" ng-if=\"f.buyer==$root.$storage.user.username\">{{f.buy_price.quote}}</div>\n          <div class=\"col\" ng-if=\"f.buyer==$root.$storage.user.username\">{{f.buy_price.base}}</div>\n        </div>\n      </div>\n    </div>\n    <div class=\"\" ng-if=\"active=='history'\">\n      <!--<p class=\"padding\">Nothing here, yet...</p>-->\n      <div ng-if=\"recent_trades.length>0\">\n        <div class=\"row header\">\n          <div class=\"col\">{{'DATE' | translate}}</div>\n          <div class=\"col\">{{'PRICE' | translate}}</div>\n          <div class=\"col\">{{$root.$storage.platformsunit}}</div>\n          <div class=\"col\">{{$root.$storage.platformdollar}}</div>\n        </div>\n        <div class=\"row\" ng-repeat=\"(key, f) in recent_trades\">\n          <div class=\"col\">{{f.date|timeago}}</div>\n          <div class=\"col\">{{f.current_pays.split(\" \")[0]/f.open_pays.split(\" \")[0]|number:6}}</div>\n          <div class=\"col\">{{f.current_pays.split(\" \")[0]|number:3}}</div>\n          <div class=\"col\">{{f.open_pays.split(\" \")[0]|number:3}}</div>\n        </div>\n      </div>\n    </div>\n  </ion-content>\n  <div class=\"profile bar bar-footer\">\n    <div class=\"button-bar\">\n      <a class=\"button button-large button-royal icon ion-arrow-down-a\" ng-class=\"{'active':active=='buy'}\" ng-click=\"change('buy')\"> {{'BUY' | translate}}</a>\n      <a class=\"button button-royal icon ion-arrow-up-a\" ng-class=\"{'active':active=='sell'}\" ng-click=\"change('sell')\"> {{'SELL' | translate}}</a>\n      <a class=\"button button-royal icon ion-flag\" ng-class=\"{'active':active=='open'}\" ng-click=\"change('open')\">{{'OPEN' | translate}}</a>\n      <a class=\"button button-royal icon ion-ios-clock\" ng-class=\"{'active':active=='history'}\"  ng-click=\"change('history')\">{{'HISTORY' | translate}}</a>\n    </div>\n  </div>\n</ion-view>\n",
        //templateUrl: 'templates/exchange.html',
        controller: 'ExchangeCtrl'
      }
    }
  })

  .state('app.profile', {
    url: '/profile/:username',
    views: {
      'menuContent': {
        //templateUrl: 'templates/profile.html',
        template: "<ion-view view-title=\"\" hide-nav-bar=\"true\" view-cache=\"false\"><!--ng-class=\"{'mpb':$root.$storage.user.json_metadata.profile.cover_image}\"-->\n  <ion-content class=\"has-footer\" overflow-scroll=\"true\">\n    <div class=\"bar bar-subheader mysubheader bar-positive\" ng-style=\"css||mcss\">\n      <button class=\"button button-icon button-clear ion-ios-arrow-back profilebtn\" on-tap=\"goBack()\"></button>\n      <button class=\"button button-outline button-light profilebtn_follow\" on-tap=\"followUser(user.username)\" ng-if=\"$root.$storage.user && $root.$storage.user.username != user.username && !isFollowing(user.username)\"><!--<i class=\"fa fa-user-plus fa-lg\"></i>-->{{'FOLLOW'|translate}}</button>\n      <button class=\"button button-clear profilebtn_follow button-icon ion-camera\" on-tap=\"showCover()\" ng-if=\"$root.$storage.user && $root.$storage.user.username === user.username\"></button>\n      <button class=\"button button-outline button-light profilebtn_follow\" on-tap=\"unfollowUser(user.username)\" ng-if=\"$root.$storage.user && $root.$storage.user.username != user.username && isFollowing(user.username)\"><!--button-icon button-clear<i class=\"fa fa-user-times fa-lg\"></i>-->{{'UNFOLLOW'|translate}}</button>&nbsp;\n      <div class=\"center\">\n          <div class=\"item-myavatar\" ng-if=\"$root.$storage.user && $root.$storage.user.username == user.username\">\n            <span class=\"item-myavatar\" ng-if=\"!($root.$storage.user.json_metadata.profile.profile_image||$root.$storage.user.json_metadata.user_image)\"><img src=\"img/user_profile.png\" on-tap=\"showProfile()\"></span>\n            <img ng-src=\"{{$root.$storage.user.json_metadata.profile.profile_image || $root.$storage.user.json_metadata.user_image}}\" ng-if=\"$root.$storage.user.json_metadata.user_image || $root.$storage.user.json_metadata.profile.profile_image\" on-tap=\"showProfile()\" />\n            <div class=\"footprofileinfo\">\n              <h4 class=\"center\">\n                <span class=\"light\">@{{$root.$storage.user.username}}</span>\n                &nbsp;\n                <div class=\"reputation\">{{$root.$storage.user.reputation|reputation}}\n                </div>\n              </h4>\n              <p>{{$root.$storage.user.json_metadata.profile.about}}</p>\n              <div class=\"padding\">\n                <i class=\"icon ion-android-list\"></i>&nbsp;\n                {{$root.$storage.user.post_count}}&nbsp;\n                |&nbsp;\n                <i class=\"icon ion-arrow-graph-up-right\"></i>&nbsp;\n                {{$root.$storage.user.voting_power/100|number:2}}&nbsp;\n                |&nbsp;<i class=\"icon ion-ios-people\"></i>&nbsp;\n                {{followdetails.follower_count}}&nbsp;\n                |&nbsp;<i class=\"ion-person-add\"></i>&nbsp;\n                {{followdetails.following_count}}\n              </div>\n              <p><span ng-if=\"$root.$storage.user.json_metadata.profile && $root.$storage.user.json_metadata.profile.location\">\n                <i class=\"icon ion-location\"></i>&nbsp;\n                {{$root.$storage.user.json_metadata.profile.location}}\n                &nbsp;\n              </span>&nbsp;\n              <span ng-if=\"$root.$storage.user.json_metadata.profile && $root.$storage.user.json_metadata.profile.website\">\n                <i class=\"icon ion-link\"></i>&nbsp;\n                <a on-tap=\"window.open('{{$root.$storage.user.json_metadata.profile.website}}', '_system');\" style=\"color:white!important;text-decoration: underline;\">WebSite</a>\n                &nbsp;\n              </span>\n              <span ng-if=\"$root.$storage.user.created\">\n                <i class=\"icon ion-calendar\"></i>&nbsp;\n                {{$root.$storage.user.created|date}}\n                &nbsp;\n              </span></p>\n            </div>\n          </div>\n          <div class=\"item-myavatar\" ng-if=\"$root.$storage.user.username !== user.username\">\n            <span class=\"item-myavatar\" ng-if=\"!(user.json_metadata.profile.profile_image||user.json_metadata.user_image)\"><img src=\"img/user_profile.png\" /></span>\n            <img ng-src=\"{{user.json_metadata.profile.profile_image || user.json_metadata.user_image}}\" ng-if=\"user.json_metadata.profile.profile_image || user.json_metadata.user_image\" />\n            <div class=\"footprofileinfo\">\n              <h4 class=\"center\"><span class=\"light\">@{{user.username}}</span>&nbsp;<div class=\"reputation\">{{user.reputation|reputation}}</div></h4>\n              <p>{{user.json_metadata.profile.about}}</p>\n              <div class=\"padding\"><i class=\"icon ion-android-list\"></i>&nbsp;{{user.post_count}}&nbsp;|&nbsp;<i class=\"icon ion-arrow-graph-up-right\"></i>&nbsp;{{user.voting_power/100|number:2}}&nbsp;|&nbsp;<i class=\"icon ion-ios-people\"></i>&nbsp;\n              {{followdetails.follower_count}}&nbsp;\n              |&nbsp;<i class=\"ion-person-add\"></i>&nbsp;\n              {{followdetails.following_count}}</div>\n              <p><span ng-if=\"user.json_metadata.profile && user.json_metadata.profile.location\">\n                <i class=\"icon ion-location\"></i>&nbsp;\n                {{user.json_metadata.profile.location}}\n                &nbsp;\n              </span>&nbsp;\n              <span ng-if=\"user.json_metadata.profile && user.json_metadata.profile.website\">\n                <i class=\"icon ion-link\"></i>&nbsp;\n                <a on-tap=\"window.open('{{user.json_metadata.profile.website}}', '_system');\" style=\"color:white!important;text-decoration: underline;\">WebSite</a>\n                &nbsp;\n              </span>\n              <span ng-if=\"user.created\">\n                <i class=\"icon ion-calendar\"></i>&nbsp;\n                {{user.created|date}}\n                &nbsp;\n              </span></p>\n            </div>\n          </div>\n      </div>\n    </div>\n    <div class=\"has-mysubheader\">\n        <div class=\"box blue\" ng-if=\"active!='wallet'||active!='permissions'\">\n          <p class=\"padding\" ng-if=\"nonexist\">{{'NOTHING_HERE'|translate}}</p>\n          <ion-list>\n            <!--<div ng-repeat=\"(key, playlist) in profile\" class=\"item wrap\" on-tap=\"open(playlist)\">\n            <h3 class=\"bold\">{{playlist.root_title}}</h3>\n            <span ng-bind-html=\"playlist.body.substring(0,100)|parseUrl\"></span>\n            </div>-->\n            <div class=\"item\" ng-repeat=\"playlist in data.profile | orderBy:'-created' | limitTo:25 track by $index\" ng-class=\"{'item-thumbnail-left': playlist.json_metadata.image}\">\n              <img ng-src=\"{{playlist.json_metadata.image[0]}}\" on-tap=\"open(playlist)\" ng-if=\"playlist.json_metadata.image\" onerror=\"this.src='img/noimage.png'\"/>\n                <div on-tap=\"open(playlist)\">\n                <div class=\"wrap\">\n                  <h2><i class=\"fa fa-money positive\" ng-if=\"playlist.promoted.split(' ')[0] !== '0.000'\"></i> <i class=\"fa fa-fire positive\" ng-if=\"playlist.percent_steem_dollars === 0\"></i>{{playlist.root_title}}</h2>\n                </div>\n                <div class=\"postdetails\"><i class=\"icon ion-android-time\"></i>&nbsp;{{playlist.created|timeago}}&nbsp;{{'BY'|translate}}&nbsp;<i class=\"icon ion-android-person\"></i>&nbsp;{{playlist.author}}&nbsp;<div class=\"reputation\">{{playlist.author_reputation|reputation|number:0}}</div></div>\n                </div>\n                <div class=\"row gray profile\">\n                  <div class=\"col\"><ion-spinner ng-if=\"playlist.invoting\"></ion-spinner>\n                  <i class=\"fa fa-chevron-circle-up fa-lg\" on-tap=\"upvotePost(playlist)\" ng-if=\"!playlist.upvoted\" on-hold=\"openSlider($event)\"></i><i class=\"fa fa-chevron-circle-up fa-lg positive\" on-tap=\"unvotePost(playlist)\" ng-if=\"playlist.upvoted\"></i>&nbsp;&nbsp;<span on-tap=\"$root.openInfo(playlist)\">{{playlist.net_votes}}</span>&nbsp;&nbsp;\n                   <!--<i class=\"fa fa-chevron-circle-down fa-lg\" on-tap=\"downvotePost(playlist)\" ng-if=\"!playlist.downvoted\"></i><i class=\"fa fa-chevron-circle-down fa-lg positive\" on-tap=\"unvotePost(playlist)\" ng-if=\"playlist.downvoted\"></i>--></div>\n                  <div class=\"col\" on-tap=\"openTooltip($event,playlist)\">&nbsp; <b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if=\"playlist.max_accepted_payout.split(' ')[0] === '0.000'\"><del>{{playlist | sumPostTotal:$root.$storage.currencyRate | number}}</del></span><span ng-if=\"playlist.max_accepted_payout.split(' ')[0] !== '0.000'\">{{playlist | sumPostTotal:$root.$storage.currencyRate | number}}</span></div>\n                  <div class=\"col\">&nbsp; <i class=\"icon ion-chatbubbles\"></i>&nbsp;{{playlist.children}}</div>\n                  <div class=\"col\" ng-if=\"playlist.author!==user.username && active!=='recent-replies'\">&nbsp; <i class=\"icon ion-arrow-return-right\"></i></div>\n                </div>\n            </div>\n          </ion-list>\n          <ion-infinite-scroll on-infinite=\"loadmore()\" ng-if=\"moreDataCanBeLoaded()\" distance=\"15%\"></ion-infinite-scroll>\n        </div>\n\n        <div class=\"padding\" ng-if=\"active=='transfers'\">\n          <p class=\"bold uppercase\">\n            {{'BALANCES'|translate}}\n          </p>\n          <div class=\"row\">\n            <div class=\"col col-67\">\n            {{$root.$storage.platformname}} <br><span class=\"gray wrap\">{{'PROFILE_1'|translate:translationData }}</span>\n            </div>\n            <div class=\"col col-33\">\n            {{accounts.balance | st | number}} {{$root.$storage.platformlunit}}\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col col-67\">\n            {{$root.$storage.platformpower}} <br><span class=\"gray wrap\">{{'PROFILE_2'|translate:translationData}}</span>\n            </div>\n            <div class=\"col col-33\">\n            {{accounts.vesting_shares | sp | number}} {{$root.$storage.platformpunit}}\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col col-67\">\n            {{$root.$storage.platformdollar}} <br><span class=\"gray wrap\">{{'PROFILE_3'|translate:translationData}}</span>\n            </div>\n            <div class=\"col col-33\">\n            {{accounts.sbd_balance | sbd | number}} {{$root.$storage.platformdunit}}\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col col-67\">\n            {{'ESTIMATED_VALUE'|translate}} <br><span class=\"gray wrap\">{{'PROFILE_4'|translate:translationData}}</span>\n            </div>\n            <div class=\"col col-33\">\n            {{$root.$storage.currency|getCurrencySymbol}} {{accounts.vesting_shares | sd:accounts.balance:accounts.sbd_balance | number}}\n            </div>\n          </div>\n          <p class=\"bold\">{{'TRANSACTION_HISTORY'|translate}}</p>\n          <div class=\"list list-inset\">\n            <div class=\"item\" ng-repeat=\"tr in transfers | orderBy:'-[0]' | limitTo:15 track by $index\">\n              <span>{{tr[1].timestamp | timeago}} - {{tr[1].op[0]}}</span>\n              <div ng-if=\"tr[1].op[0]=='comment_reward'\">{{tr[1].op[1].sbd_payout}} | {{tr[1].op[1].vesting_payout}}</div>\n              <div ng-if=\"tr[1].op[0]=='author_reward'\">{{tr[1].op[1].sbd_payout}} | {{tr[1].op[1].steem_payout}} | {{tr[1].op[1].vesting_payout}}</div>\n              <div ng-if=\"tr[1].op[0]=='curation_reward'\">{{tr[1].op[1].reward}} | {{tr[1].op[1].vesting_payout}}</div>\n              <div ng-if=\"tr[1].op[0]=='transfer'\">{{tr[1].op[1].amount}} | {{tr[1].op[1].memo}}</div>\n              <div ng-if=\"tr[1].op[0]=='transfer_to_vesting'\">{{tr[1].op[1].amount}} | {{tr[1].op[1].memo}}</div>\n              <div ng-if=\"tr[1].op[0]=='withdraw_vesting'\">{{tr[1].op[1].vesting_shares}} | {{tr[1].op[1].memo}}</div>\n              <p ng-if=\"tr[1].op[0]=='comment_reward'\">@{{tr[1].op[1].author}}/{{tr[1].op[1].permlink}}</p>\n              <p ng-if=\"tr[1].op[0]=='author_reward'\">@{{tr[1].op[1].author}}/{{tr[1].op[1].permlink}}</p>\n              <p ng-if=\"tr[1].op[0]=='curation_reward'\">@{{tr[1].op[1].comment_author}}/{{tr[1].op[1].comment_permlink}}</p>\n              <p ng-if=\"tr[1].op[0]=='transfer'\">{{'FROM'|translate}} {{tr[1].op[1].from}} {{'TO'|translate}}  {{tr[1].op[1].to}}</p>\n              <p ng-if=\"tr[1].op[0]=='transfer_to_vesting'\">{{'FROM'|translate}}  {{tr[1].op[1].from}} {{'TO'|translate}}  {{tr[1].op[1].to}}</p>\n              <p ng-if=\"tr[1].op[0]=='withdraw_vesting'\">{{tr[1].op[1].account}}</p>\n\n            </div>\n          </div>\n        </div>\n\n        <div class=\"box pink\" ng-if=\"active=='permissions'\">\n          <div class=\"list card\">\n            <div class=\"item\">\n              <h2><div class=\"bold\">{{'POSTING'|translate}}</div></h2>\n              <p class=\"wrap\">{{$root.$storage.user.posting.key_auths[0][0]}}</p>\n            </div>\n            <div class=\"item item-body\">\n              <center><qrcode class=\"full-image\" text=\"{{$root.$storage.user.posting.key_auths[0][0]}}\"></qrcode></center>\n              <p>\n                {{'PROFILE_5'|translate}}\n              </p>\n            </div>\n            <div class=\"item\">\n              <h2><div class=\"bold\">{{'OWNER'|translate}}</div></h2>\n              <p class=\"wrap\">{{$root.$storage.user.owner.key_auths[0][0]}}</p>\n            </div>\n            <div class=\"item item-body\">\n              <center><qrcode class=\"full-image\" text=\"{{$root.$storage.user.owner.key_auths[0][0]}}\"></qrcode></center>\n              <p>\n                {{'PROFILE_6'|translate}}\n              </p>\n            </div>\n            <div class=\"item\">\n              <h2><div class=\"bold\">{{'ACTIVE'|translate}}</div></h2>\n              <p class=\"wrap\">{{$root.$storage.user.active.key_auths[0][0]}}</p>\n            </div>\n            <div class=\"item item-body\">\n              <center><qrcode class=\"full-image\" text=\"{{$root.$storage.user.active.key_auths[0][0]}}\"></qrcode></center>\n              <p>\n                {{'PROFILE_7'|translate}}\n              </p>\n            </div>\n            <div class=\"item\">\n              <h2><div class=\"bold\">{{'MEMO'|translate}}</div></h2>\n              <p class=\"wrap\">{{$root.$storage.user.memo_key}}</p>\n            </div>\n            <div class=\"item item-body\">\n              <center><qrcode class=\"full-image\" text=\"{{$root.$storage.user.memo_key}}\"></qrcode></center>\n              <p>\n                {{'PROFILE_8'|translate}}\n              </p>\n            </div>\n          </div>\n        </div>\n    </div>\n    <script id = \"popoverPTr.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedPost\">\n        <ion-content>\n          <div class=\"padding\" ng-bind-html=\"tooltipText\"></div>\n        </ion-content>\n      </ion-popover-view>\n    </script>\n    <script id = \"popoverSliderrp.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedSlide\">\n        <ion-content>\n          <rzslider rz-slider-model=\"pslider.value\" rz-slider-options=\"pslider.options\"></rzslider>\n        </ion-content>\n      </ion-popover-view>\n    </script>\n  </ion-content>\n  <div class=\"profile bar bar-footer\">\n    <div class=\"button-bar\">\n      <!--<a class=\"button button-large button-positive icon ion-ios-heart\" ng-class=\"{'active':active=='feed'}\" on-tap=\"change('feed')\">&nbsp;Feeds</a>-->\n      <a class=\"button button-large button-positive icon ion-compose\" ng-class=\"{'active':active=='blog'}\" on-tap=\"change('blog')\">&nbsp;{{'BLOG'|translate}}</a>\n      <a class=\"button button-positive icon ion-document-text\" ng-class=\"{'active':active=='posts'}\" on-tap=\"change('posts')\">&nbsp;{{'POSTS'|translate}}</a>\n      <a class=\"button button-positive icon ion-chatbubbles\" ng-class=\"{'active':active=='recent-replies'}\" on-tap=\"change('recent-replies')\">&nbsp;{{'REPLIES'|translate}}</a>\n      <a class=\"button button-positive icon ion-card\" ng-class=\"{'active':active=='transfers'}\"  on-tap=\"change('transfers')\">&nbsp;{{'WALLET'|translate}}</a>\n      <!--<a class=\"button button-royal icon ion-lock-combination\" ng-class=\"{'active':active=='permissions'}\" on-tap=\"change('permissions')\">Keys</a>-->\n    </div>\n  </div>\n</ion-view>\n",
        controller: "ProfileCtrl"
      }
    }
  })

  .state('app.posts', {
    url: '/posts/:tags',
    views: {
      'menuContent': {
        //templateUrl: 'templates/posts.html',
        template: "<ion-view view-cache=\"false\">\n\t<ion-nav-bar class=\"bar-positive\">\n\t\t<ion-nav-back-button>\n  \t\t</ion-nav-back-button>\n\t    <ion-nav-buttons side=\"left\">\n\t      <button class=\"button button-icon button-clear ion-navicon\" ng-if=\"!$root.voiceOver\" menu-toggle=\"left\"></button>\n\t      <a href class=\"button button-icon button-clear ion-navicon\" ng-if=\"$root.voiceOver\" menu-toggle=\"left\">{{'MENU'|translate}}</a>\n\t    </ion-nav-buttons>\n\t    <ion-nav-title on-tap=\"showFilter()\">\n          <div class=\"page-title\">{{$root.$storage.filterName}} {{$root.$storage.tag}} &emsp; <i class=\"icon ion-arrow-down-b\"></i></div>\n        </ion-nav-title>\n\t    <ion-nav-buttons side=\"right\">\n\t      <!--<button class=\"button\" on-tap=\"testfunction()\">Test</button>-->\n\t      <button class=\"button button-icon ion-more\" ng-if=\"!$root.voiceOver\" on-tap=\"openMenuPopover($event)\"></button>\n\t      <a href class=\"button button-icon ion-more\" on-tap=\"openMenuPopover($event)\" ng-if=\"$root.voiceOver\">{{'OPTIONS'|translate}}</a>\n\t    </ion-nav-buttons>\n\t</ion-nav-bar>\n  <ion-content class=\"has-header\" scroll=\"true\" delegate-handle=\"mainScroll\" overflow-scroll=\"true\">\n\t\t<ion-refresher pulling-text=\"{{'PULL_DOWN_TO_REFRESH'|translate}}\" on-refresh=\"refresh()\">\n  \t</ion-refresher>\n  \t\t<div ng-if=\"$root.$storage.view=='compact' && data.length>0\" class=\"masonry-layout\">\n\t    \t<div ng-repeat=\"d in data track by $index\" class=\"masonry-layout__panel\">\n\t    \t   <div class=\"list masonry-layout__panel-content\">\n\t\t    \t<div class=\"item\">\n\t\t\t\t    <div on-tap=\"open(d)\">\n\t\t\t\t    <span ng-if=\"d.reblogged_by.length>0\"><i class=\"icon ion-arrow-return-right\"></i> {{'RESTEEMED_BY'|translate}} {{d.reblogged_by}}</span>\n\t\t\t\t    <p><h2><i class=\"fa fa-money positive\" ng-if=\"d.promoted.split(' ')[0] !== '0.000'\"></i>\n\t\t\t\t\t\t\t<i class=\"fa fa-fire positive\" ng-if=\"d.percent_steem_dollars === 0\"></i> {{d.title}}</h2></p>\n\t\t\t\t    <div class=\"row postdetails wrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{d.created|timeago}}&nbsp;{{'BY'|translate}}&nbsp;<b>{{d.author}}</b>&nbsp;<div class=\"reputation\">{{d.author_reputation|reputation|number:0}}</div> {{'IN'|translate}} {{d.category}} &middot; {{d.body|readingtime}} {{'MIN_READ'|translate}}</div></div>\n\t\t\t\t    </div>\n\t\t\t\t    <div class=\"row\">\n\t\t\t\t    <div class=\"col\">\n\t\t\t\t      <span ng-if=\"!$root.voiceOver\">\n\t\t\t\t      <a href=\"#\" class=\"subdued\" ng-if=\"!d.upvoted\" on-tap=\"votePost(d)\" on-hold=\"openSlider($event)\"><ion-spinner ng-if=\"d.invoting\"></ion-spinner><i class=\"fa fa-chevron-circle-up fa-lg\" ng-if=\"!d.invoting\"></i></a><a href=\"#\" class=\"subdued\" ng-if=\"d.upvoted\" on-tap=\"unvotePost(d)\"><ion-spinner ng-if=\"d.invoting\"></ion-spinner>\n\t\t\t\t\t\t\t\t<i class=\"fa fa-chevron-circle-up fa-lg positive\" ng-if=\"!d.invoting\"></i></a>&nbsp;<span class=\"gray\" on-tap=\"openTooltip($event,d)\"><b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if=\"d.max_accepted_payout.split(' ')[0] === '0.000'\"><del>0.000</del></span><span ng-if=\"d.max_accepted_payout.split(' ')[0] !== '0.000'\">{{d | sumPostTotal:$root.$storage.currencyRate | number}}</span></span></span>\n\t\t\t\t      <span ng-if=\"$root.voiceOver\">\n\t\t\t\t      <a href=\"#\" class=\"subdued\" ng-if=\"!d.upvoted\" on-tap=\"votePost(d)\" on-hold=\"openSlider($event)\"><ion-spinner ng-if=\"d.invoting\"></ion-spinner><i class=\"fa fa-chevron-circle-up fa-lg\" ng-if=\"!d.invoting\"></i>{{'UPVOTE'|translate}}</a><a href=\"#\" class=\"subdued\" ng-if=\"d.upvoted\" on-tap=\"unvotePost(d)\"><ion-spinner ng-if=\"d.invoting\"></ion-spinner>\n\t\t\t\t\t\t\t\t<i class=\"fa fa-chevron-circle-up fa-lg positive\" ng-if=\"!d.invoting\"></i>{{'UNVOTE'|translate}}</a>&nbsp;<span class=\"gray\" on-tap=\"openTooltip($event,d)\"><b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if=\"d.max_accepted_payout.split(' ')[0] === '0.000'\"><del>{{d | sumPostTotal:$root.$storage.currencyRate | number}}</del></span><span ng-if=\"d.max_accepted_payout.split(' ')[0] !== '0.000'\">{{d | sumPostTotal:$root.$storage.currencyRate | number}}</span></span></span>\n\t\t\t\t      </div>\n\t\t\t\t      <div class=\"col col-25 tright\">\n\t\t\t\t      <a href=\"#\" class=\"subdued\" on-tap=\"$root.openInfo(d)\"><i class=\"icon ion-person-stalker\"></i>&nbsp;{{d.net_votes}}</a>\n\t\t\t\t      </div>\n\t\t\t\t      <div class=\"col col-25 tright\">\n\t\t\t\t      <a href=\"#\" class=\"subdued\"><i class=\"icon ion-chatbubbles\"></i>&nbsp;{{d.children}}</a>\n\t\t\t\t      </div>\n\t\t\t\t      <div class=\"col col-10 tright\">\n\t\t\t\t      <a href=\"#\" class=\"subdued\" on-tap=\"$root.reBlog(s.author, s.permlink)\"><i class=\"icon ion-arrow-return-right\"></i>&nbsp;</a>\n\t\t\t\t      </div>\n\t\t\t\t    </div>\n\t\t\t  \t</div>\n\t\t\t  </div>\n\t\t\t</div>\n\t\t</div>\n\t\t<div ng-if=\"$root.$storage.view=='card' && data.length>0\" class=\"masonry-layout\">\n\t\t\t<div ng-repeat=\"ds in data track by $index\" class=\"masonry-layout__panel\">\n\t    \t   <div class=\"list card masonry-layout__panel-content\" ng-if=\"ds\">\n\n\t\t\t\t<div class=\"item\" on-tap=\"open(ds)\">\n\t\t\t\t\t<span ng-if=\"ds.reblogged_by.length>0\"><i class=\"icon ion-arrow-return-right\"></i> {{'RESTEEMED_BY'|translate}} {{ds.reblogged_by}}</span>\n\t\t\t\t    <h2><i class=\"fa fa-money positive\" ng-if=\"ds.promoted.split(' ')[0] !== '0.000'\"></i> <i class=\"fa fa-fire positive\" ng-if=\"ds.percent_steem_dollars === 0\"></i>{{ds.title}}</h2>\n\t\t\t\t    <div class=\"row postdetails wrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{ds.created|timeago}}&nbsp;{{'BY'|translate}}&nbsp;<b>{{ds.author}}</b>&nbsp;<div class=\"reputation\">{{ds.author_reputation|reputation|number:0}}</div> {{'IN'|translate}} {{ds.category}} &middot; {{ds.body|readingtime}} {{'MIN_READ'|translate}}</div></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"item-body\">\n\t\t\t\t    <img class=\"full-image\" ng-src=\"{{ds.json_metadata.image[0]}}\" on-tap=\"open(ds)\" ng-if=\"ds.json_metadata.image[0]\" onerror=\"this.src='img/noimage.png'\"/>\n\t\t\t\t    <div class=\"row\">\n\t\t\t\t\t    <div class=\"col\">\n\t\t\t\t\t      <span ng-if=\"!$root.voiceOver\">\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\" ng-if=\"!ds.upvoted\" on-tap=\"votePost(ds)\" on-hold=\"openSlider($event)\"><ion-spinner ng-if=\"ds.invoting\"></ion-spinner><i class=\"fa fa-chevron-circle-up fa-lg\" ng-if=\"!ds.invoting\"></i></a><a href=\"#\" class=\"subdued\" ng-if=\"ds.upvoted\" on-tap=\"unvotePost(ds)\"><ion-spinner ng-if=\"ds.invoting\"></ion-spinner>\n\t\t\t\t\t\t\t\t\t<i class=\"fa fa-chevron-circle-up fa-lg positive\" ng-if=\"!ds.invoting\"></i></a>&nbsp;<span class=\"gray\" on-tap=\"openTooltip($event,ds)\"><b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if=\"ds.max_accepted_payout.split(' ')[0] === '0.000'\"><del>{{ds | sumPostTotal:$root.$storage.currencyRate | number}}</del></span><span ng-if=\"ds.max_accepted_payout.split(' ')[0] !== '0.000'\">{{ds | sumPostTotal:$root.$storage.currencyRate | number}}</span></span>\n\t\t\t\t\t      </span>\n\t\t\t\t\t      <span ng-if=\"$root.voiceOver\">\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\" ng-if=\"!ds.upvoted\" on-tap=\"votePost(ds)\" on-hold=\"openSlider($event)\"><ion-spinner ng-if=\"ds.invoting\"></ion-spinner><i class=\"fa fa-chevron-circle-up fa-lg\" ng-if=\"!ds.invoting\"></i>{{'UPVOTE'|translate}}</a>\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\" ng-if=\"ds.upvoted\" on-tap=\"unvotePost(ds)\"><ion-spinner ng-if=\"ds.invoting\"></ion-spinner><i class=\"fa fa-chevron-circle-up fa-lg positive\" ng-if=\"!ds.invoting\"></i>{{'UNVOTE'|translate}}</a>&nbsp;<span class=\"gray\" on-tap=\"openTooltip($event,ds)\">\n\t\t\t\t\t\t\t\t\t<b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if=\"ds.max_accepted_payout.split(' ')[0] === '0.000'\"><del>0.000</del></span><span ng-if=\"ds.max_accepted_payout.split(' ')[0] !== '0.000'\">{{ds | sumPostTotal:$root.$storage.currencyRate | number}}</span></span>\n\t\t\t\t\t      </span>\n\t\t\t\t\t      </div>\n\t\t\t\t\t      <div class=\"col col-25 tright\">\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\" on-tap=\"$root.openInfo(ds)\"><i class=\"icon ion-person-stalker\"></i>&nbsp;{{ds.net_votes}}</a>\n\t\t\t\t\t      </div>\n\t\t\t\t\t      <div class=\"col col-25 tright\">\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\"><i class=\"icon ion-chatbubbles\"></i>&nbsp;{{ds.children}}</a>\n\t\t\t\t\t      </div>\n\t\t\t\t\t      <div class=\"col col-10 tright\">\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\" on-tap=\"$root.reBlog(ds.author, ds.permlink)\"><i class=\"icon ion-arrow-return-right\"></i>&nbsp;</a>\n\t\t\t\t\t      </div>\n\t\t\t\t      </div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n    <ion-infinite-scroll ng-if=\"moreDataCanBeLoaded()\" on-infinite=\"loadMore()\" distance=\"15%\"></ion-infinite-scroll>\n    <br>\n    <script id = \"popoverT.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedPost\">\n        <ion-content>\n          <div class=\"padding\" ng-bind-html=\"tooltipText\"></div>\n        </ion-content>\n      </ion-popover-view>\n    </script>\n    <script id = \"popoverSlider.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedSlide\">\n        <ion-content>\n          \t<rzslider rz-slider-model=\"pslider.value\" rz-slider-options=\"pslider.options\"></rzslider>\n        </ion-content>\n      </ion-popover-view>\n    </script>\n  </ion-content>\n</ion-view>\n",
        controller: 'PostsCtrl'
      }
    }
  })

  .state('app.bookmark', {
    url: '/bookmark',
    views: {
      'menuContent': {
        //templateUrl: 'templates/post.html',
        template: "<ion-view view-title=\"{{'BOOKMARKS' | translate}}\">\n  <ion-content class=\"has-header\">\n\t<ion-list ng-if=\"$root.$storage.bookmark\" can-swipe=\"true\">\n  \t\t<ion-item ng-repeat=\"item in $root.$storage.bookmark\" ng-click=\"$root.getContentAndOpen(item)\">\n\t\t    <p><h2>{{item.author}}</h2></p>\n        <p>{{item.permlink}}</p>\n\t\t    <div class=\"row postdetails twrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{item.created|timeago}}</div></div>\n\t\t    <ion-option-button class=\"button-assertive\" ng-click=\"removeBookmark($index)\">{{'REMOVE' | translate}}\n\t\t    </ion-option-button>\n    \t</ion-item>\n    </ion-list>\n    <p class=\"tcenter gray padding\" ng-if=\"$root.$storage.bookmark.length>0\">{{'SWIPE_LEFT'|translate}}</p>\n    <p class=\"tcenter gray padding\" ng-if=\"$root.$storage.bookmark.length==0\">{{'NOTHING_HERE'|translate}}</p>\n\n  </ion-content>\n</ion-view>\n",
        controller: 'BookmarkCtrl'
      }
    }
  })

	.state('app.drafts', {
    url: '/drafts',
    views: {
      'menuContent': {
        //templateUrl: 'templates/post.html',
        template: "<ion-view view-title=\"{{'DRAFTS' | translate}}\">\n  <ion-content class=\"has-header\">\n\t<ion-list ng-if=\"drafts\" can-swipe=\"true\">\n  \t\t<ion-item ng-repeat=\"item in drafts\" ng-click=\"$root.openDraft(item)\">\n\t\t    <p><h2>{{item.title}}</h2></p>\n\t\t\t    <div class=\"row postdetails twrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{item.created|timeago}}&nbsp;{{'TAGS' | translate}}:&nbsp;<b>{{item.tags}}</b></div></div>\n\t\t    <ion-option-button class=\"button-assertive\" ng-click=\"removeDraft(item._id)\">{{'REMOVE' | translate}}\n\t\t    </ion-option-button>\n    \t</ion-item>\n    </ion-list>\n    <p class=\"tcenter gray\" ng-if=\"drafts.length>0\">{{'SWIPE_LEFT'|translate}}</p>\n    <p class=\"tcenter gray\" ng-if=\"drafts.length==0\">{{'NOTHING_HERE'|translate}}</p>\n\n  </ion-content>\n</ion-view>\n",
        controller: 'DraftsCtrl'
      }
    }
  })

	.state('app.images', {
    url: '/images',
    views: {
      'menuContent': {
        //templateUrl: 'templates/post.html',
        template: "<ion-view view-title=\"{{'MANAGE' | translate}} {{'GALLERY' | translate}}\">\n  <ion-content class=\"has-header\">\n\t<ion-list ng-if=\"images\" can-swipe=\"true\">\n  \t\t<ion-item ng-repeat=\"item in images\" class=\"item-thumbnail-left\">\n        <img ng-src=\"{{item.url}}\"/>\n        <p><h2>{{item.url}}</h2></p>\n\t\t\t  <div class=\"row postdetails twrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{item.created|timeago}}&nbsp;</div></div>\n        <ion-option-button class=\"button-assertive\" ng-click=\"removeImage(item._id)\">{{'REMOVE' | translate}}\n\t\t    </ion-option-button>\n\t\t    <ion-option-button class=\"button-calm\" ng-click=\"copyImage(item.url)\">{{'COPY' | translate}}\n\t\t    </ion-option-button>\n    \t</ion-item>\n    </ion-list>\n    <p class=\"tcenter gray\" ng-if=\"images.length>0\">{{'SWIPE_LEFT'|translate}}</p>\n    <p class=\"tcenter gray\" ng-if=\"images.length==0\">{{'NOTHING_HERE'|translate}}</p>\n  </ion-content>\n</ion-view>\n",
        controller: 'ImagesCtrl'
      }
    }
  })

  .state('app.notifications', {
    url: '/notifications',
    views: {
      'menuContent': {
        //templateUrl: 'templates/post.html',
        template: "<ion-view view-title=\"{{'NOTIFICATIONS' | translate}}\">\n  <ion-content class=\"has-header\">\n\t<ion-list ng-if=\"$root.$storage.notifications\" can-swipe=\"true\">\n  \t\t<ion-item ng-repeat=\"item in $root.$storage.notifications | orderBy: '-created' \" ng-click=\"$root.getContentAndOpen(item)\">\n\t\t    <p><h2>{{item.title}}</h2></p>\n\t\t    <span>{{item.message}}</span>\n\t\t    <div class=\"row postdetails twrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{item.created|timeago}}&nbsp;{{'BY' | translate}}&nbsp;<b>{{item.author}}&nbsp;</b></div></div>\n\t\t    <ion-option-button class=\"button-assertive\" ng-click=\"removeNotification($index)\">{{'REMOVE' | translate}}\n\t\t    </ion-option-button>\n    \t</ion-item>\n    </ion-list>\n  </ion-content>\n</ion-view>\n",
        controller: 'NotificationsCtrl'
      }
    }
  })


  .state('app.post', {
    url: '/post/:category/:author/:permlink',
    views: {
      'menuContent': {
        //templateUrl: 'templates/post.html',
        template: "<ion-view view-title=\"\">\n\t<ion-nav-bar class=\"bar-positive\">\n\t\t<ion-nav-back-button>\n    \t</ion-nav-back-button>\n\t    <ion-nav-buttons side=\"left\">\n\t      <button class=\"button button-icon button-clear ion-navicon\" ng-if=\"!$root.voiceOver\" menu-toggle=\"left\"></button>\n        <a href class=\"button button-icon ion-more\" ng-if=\"$root.voiceOver\" menu-toggle=\"left\">{{'MENU'|translate}}</a>\n\t    </ion-nav-buttons>\n\t    <ion-nav-buttons side=\"right\">\n      <span ng-if=\"!$root.voiceOver\">\n        <button class=\"button button-icon button-clear\" on-tap=\"bookmark()\"><i class=\"icon\" ng-class=\"{'ion-ios-bookmarks':isBookmarked(), 'ion-ios-bookmarks-outline':!isBookmarked()}\"></i></button> &nbsp; \n\t      <button class=\"button button-icon button-clear ion-android-share-alt\" on-tap=\"share()\"></button>\n      </span>\n      <span ng-if=\"$root.voiceOver\">\n        <a href class=\"button button-icon button-clear\" on-tap=\"bookmark()\"><i class=\"icon\" ng-class=\"{'ion-ios-bookmarks':isBookmarked(), 'ion-ios-bookmarks-outline':!isBookmarked()}\"></i>{{'BOOKMARK'|translate}}</a> &nbsp; \n        <a href class=\"button button-icon button-clear ion-android-share-alt\" on-tap=\"share()\">{{'SHARE'|translate}}</a>\n      </span>\n\t    </ion-nav-buttons>\n\t</ion-nav-bar>\n  <ion-floating-menu menu-color=\"#387ef5\" menu-open-color=\"#387ef5\" has-footer=\"true\">\n    <ion-floating-item icon=\"ion-chatbubbles\" click=\"isreplying($root.$storage.sitem, true)\" ng-if=\"$root.$storage.user.username\" button-color=\"#387ef5\" icon-color=\"#fff\" text=\"{{'REPLY'|translate}}\" text-class=\"text-class\"></ion-floating-item>\n    <ion-floating-item icon=\"ion-android-arrow-dropup-circle\" click=\"upvotePost($root.$storage.sitem)\" button-color=\"#387ef5\" icon-color=\"#fff\" text=\"{{'UPVOTE'|translate}}\" text-class=\"text-class\"></ion-floating-item>\n    <ion-floating-item icon=\"ion-edit\" click=\"editPost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.mode!=='archived' && $root.$storage.sitem.author==$root.$storage.user.username\" button-color=\"#387ef5\" icon-color=\"#fff\" text=\"{{'EDIT'|translate}}\" text-class=\"text-class\"></ion-floating-item>\n    <ion-floating-item icon=\"ion-image\" click=\"showImages(0)\" ng-if=\"isImages()\" button-color=\"#387ef5\" icon-color=\"#fff\" text=\"{{'GALLERY'|translate}}\" text-class=\"text-class\"></ion-floating-item>\n    <ion-floating-item icon=\"ion-arrow-return-right\" ng-if=\"$root.$storage.user.username !== $root.$storage.sitem.author\" click=\"$root.reBlog($root.$storage.sitem.author, $root.$storage.sitem.permlink)\" button-color=\"#387ef5\" icon-color=\"#fff\" text=\"{{'REBLOG'|translate}}\" text-class=\"text-class\"></ion-floating-item>\n  </ion-floating-menu>\n  <ion-content class=\"padding has-header\" delegate-handle=\"mainScroll\" overflow-scroll=\"true\"><!---->\n    <div ng-if='$root.$storage.sitem'>\n    \t<p class=\"title h3\">{{$root.$storage.sitem.title}}</p>\n    \t<div class=\"stitle row gray\"><div class=\"col\">\n        <img class=\"round-avatar\" src=\"img/user_profile.png\" ng-src=\"{{$root.$storage.paccounts[$root.$storage.sitem.author].json_metadata.user_image||$root.$storage.paccounts[$root.$storage.sitem.author].json_metadata.profile.profile_image}}\" onerror=\"this.src=\\'img/user_profile.png\\'\" onabort=\"this.src=\\'img/user_profile.png\\'\" /> <b><a href=\"#/app/profile/{{$root.$storage.sitem.author}}\">{{$root.$storage.sitem.author}}</a></b>&nbsp;<div class=\"reputation\">{{$root.$storage.sitem.author_reputation|reputation|number:0}}</div>&middot;{{$root.$storage.sitem.created|timeago}} {{'IN'|translate}}&nbsp;{{$root.$storage.sitem.category}}</div><div class=\"pull-right\"><span ng-if=\"$root.voiceOver\"><i class=\"fa fa-flag\" on-tap=\"downvotePost($root.$storage.sitem)\" ng-if=\"!$root.$storage.sitem.downvoted\">{{'DOWNVOTE'|translate}}</i><i class=\"fa fa-flag positive\" on-tap=\"unvotePost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.downvoted\">{{'UNVOTE_DOWNVOTED'|translate}}</i></span><span ng-if=\"!$root.voiceOver\"><i class=\"fa fa-flag\" on-tap=\"downvotePost($root.$storage.sitem)\" ng-if=\"!$root.$storage.sitem.downvoted\"></i><i class=\"fa fa-flag positive\" on-tap=\"unvotePost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.downvoted\"></i></span></div></div>\n    \t<br><!---->\n      <div class=\"bodytext selectable\" ng-bind-html=\"$root.$storage.sitem.body | parseUrl \">\n      </div>\n\n      <div ng-if='$root.$storage.sitem.json_metadata.tags' class=\"tags\">\n        <div ng-repeat='tag in $root.$storage.sitem.json_metadata.tags'>\n          <span><div class=\"tag\" on-tap=\"openTag(tag, 5)\">{{tag}}</div></li>\n        </div>\n      </div>\n\n      <div class=\"row gray\">\n        <div class=\"col col-33\" ng-if=\"!$root.voiceOver\"><ion-spinner ng-if=\"$root.$storage.sitem.invoting\"></ion-spinner>\n        <i class=\"fa fa-chevron-circle-up fa-lg\" on-tap=\"upvotePost($root.$storage.sitem)\" ng-if=\"!$root.$storage.sitem.upvoted && !$root.$storage.sitem.invoting\" on-hold=\"openSliderr($event)\"></i><i class=\"fa fa-chevron-circle-up fa-lg positive\" on-tap=\"unvotePost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.upvoted && !$root.$storage.sitem.invoting\"></i>&nbsp;&nbsp;&nbsp;<span on-tap=\"$root.openInfo($root.$storage.sitem)\">{{$root.$storage.sitem.net_votes}}</span></div>\n\n        <div class=\"col col-33\" ng-if=\"$root.voiceOver\"><ion-spinner ng-if=\"$root.$storage.sitem.invoting\"></ion-spinner>\n        <i class=\"icon ion-android-arrow-dropup-circle\" on-tap=\"upvotePost($root.$storage.sitem)\" ng-if=\"!$root.$storage.sitem.upvoted\" on-hold=\"openSliderr($event)\">{{'UPVOTE'|translate}}</i><i class=\"icon ion-android-arrow-dropup-circle positive\" on-tap=\"unvotePost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.upvoted\">{{'UNVOTE_UPVOTED'|translate}}</i>&nbsp;&nbsp;&nbsp;<span on-tap=\"$root.openInfo($root.$storage.sitem)\">{{$root.$storage.sitem.net_votes}}</span></div>\n        <div class=\"col col-33\" on-tap=\"openTooltip($event,$root.$storage.sitem)\"><b>{{$root.$storage.currency|getCurrencySymbol}}</b> {{$root.$storage.sitem | sumPostTotal:$root.$storage.currencyRate | number}}</div>\n        <div class=\"col\"><i class=\"icon ion-chatbubbles\"></i>{{$root.$storage.sitem.children}}</div>\n        <div class=\"col\" on-tap=\"isreplying($root.$storage.sitem, true)\" ng-if=\"$root.$storage.user.username\"><i class=\"fa fa-reply\"></i></div>\n        <div class=\"col\" on-tap=\"editPost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.mode=='first_payout' && $root.$storage.sitem.author==$root.$storage.user.username\"><i class=\"fa  fa-pencil-square-o\"></i></div>\n        <div class=\"col\" on-tap=\"deletePost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.net_votes==0 && $root.$storage.sitem.author==$root.$storage.user.username\"><i class=\"fa fa-trash-o\"></i></div>\n      </div>\n      <ion-thread comments=\"post.comments\"></ion-thread>\n    </div>\n    <script id = \"popoverTr.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedPost\">\n        <ion-content>\n          <div class=\"padding\" ng-bind-html=\"tooltipText\"></div>\n        </ion-content>\n      \n      </ion-popover-view>\n    </script>\n    <script id = \"popoverSliderr.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedSlide\">\n        <ion-content class=\"padding\">\n          <rzslider rz-slider-model=\"pslider.value\" rz-slider-options=\"pslider.options\"></rzslider>\n        </ion-content>\n      </ion-popover-view>\n    </script>\n  </ion-content>\n</ion-view>\n",
        controller: 'PostCtrl'
      }
    }
  });
  // if none of the above states are matched, use this as the fallback
  $urlRouterProvider.otherwise('/app/posts/');
  $ionicConfigProvider.navBar.alignTitle('left')
  $ionicConfigProvider.backButton.text('').icon('ion-chevron-left');
  $ionicConfigProvider.views.swipeBackEnabled(false);
  $ionicConfigProvider.views.maxCache(2);

  $animateProvider.classNameFilter( /\banimated\b/ );
  $ionicConfigProvider.scrolling.jsScrolling(false);

  if (window.cordova) {
      $logProvider.debugEnabled(false);
      $compileProvider.debugInfoEnabled(false);
  }

  $translateProvider.translations('en-US', require('./locales/en')); //English
  $translateProvider.translations('ru-RU', require('./locales/ru-RU')); //Russian
  $translateProvider.translations('de-DE', require('./locales/de-DE')); //German
  $translateProvider.translations('fr-FR', require('./locales/fr-FR')); //French
  $translateProvider.translations('es-ES', require('./locales/es-ES')); //Spanish
  $translateProvider.translations('el-GR', require('./locales/el-GR')); //Greek
  $translateProvider.translations('bg-BG', require('./locales/bg-BG')); //Bulgarian
  $translateProvider.translations('nl-NL', require('./locales/nl-NL')); //Dutch
  $translateProvider.translations('hu-HU', require('./locales/hu-HU')); //Hungarian
  $translateProvider.translations('cs-CZ', require('./locales/cs-CZ')); //Czech
  $translateProvider.translations('he-IL', require('./locales/he-IL')); //Hebrew
  $translateProvider.translations('pl-PL', require('./locales/pl-PL')); //Polish
  $translateProvider.translations('pt-PT', require('./locales/pt-PT')); //Portuguese
  $translateProvider.translations('pt-BR', require('./locales/pt-BR')); //Portuguese Brazil
  $translateProvider.translations('id-ID', require('./locales/id-ID')); //Indonesian
  $translateProvider.translations('zh-TW', require('./locales/zh-TW')); //Chinese traditional
  $translateProvider.translations('zh-CN', require('./locales/zh-CN')); //Chinese simplified
  $translateProvider.translations('dolan', require('./locales/dol')); //Dolan
  $translateProvider.translations('sv-SE', require('./locales/sv-SE')); //Chinese simplified

  $translateProvider.useSanitizeValueStrategy(null);

  $translateProvider.preferredLanguage('en-US');
  $translateProvider.fallbackLanguage('en-US');

});

app.run(function($ionicPlatform, $rootScope, $localStorage, $interval, $ionicPopup, $ionicLoading, $cordovaSplashscreen, $ionicModal, $timeout, $cordovaToast, APIs, $state, $log, $ionicScrollDelegate, $filter, $translate) {
  $rootScope.$storage = $localStorage;
  $rootScope.log = function(message) {
    $log.info(message);
  };
  $ionicPlatform.ready(function() {
    // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
    // for form inputs)
    if (window.cordova && window.cordova.plugins.Keyboard) {
      cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
      cordova.plugins.Keyboard.disableScroll(true);
    }
    if (window.StatusBar) {
      // org.apache.cordova.statusbar required
      StatusBar.styleDefault();
    }
    if (!$rootScope.$storage.users) {
      $rootScope.$storage.users = [];
    }
    
    if (!$rootScope.$storage.socketgolos)
      $rootScope.$storage.socketgolos = "wss://ws.golos.io/";
    if (!$rootScope.$storage.socketsteem)
      $rootScope.$storage.socketsteem = "wss://steemd.steemit.com";


    if (!angular.isDefined($rootScope.$storage.language)) {
      if(typeof navigator.globalization !== "undefined") {
          navigator.globalization.getPreferredLanguage(function(language) {
              $translate.use(language.value).then(function(data) {
                  console.log("SUCCESS -> " + data);
                  $rootScope.$storage.language = language.value;
              }, function(error) {
                  console.log("ERROR -> " + error);
              });
          }, null);
      } else {
        $rootScope.$storage.language = 'en';
      }
    } else {
      $translate.use($rootScope.$storage.language);
    }
    if (!$rootScope.$storage.chain){
      $rootScope.$storage.platformname = "Steem";
      $rootScope.$storage.platformpower = "Steem Power";
      $rootScope.$storage.platformsunit = "Steem";
      $rootScope.$storage.platformdollar = "Steem Dollar";
      $rootScope.$storage.platformdunit = "SBD";
      $rootScope.$storage.platformpunit = "SP";
      $rootScope.$storage.platformlunit = "STEEM";
      $rootScope.$storage.chain = "steem";
      $rootScope.$storage.currency = "usd";
      $rootScope.$storage.currencyRate = 1;
    }
    $rootScope.$storage.languages = [
      {id:'en', name: 'English'}, 
      {id:'es-ES', name: 'Español'}, 
      {id:'el-GR', name: 'Ελληνικά'}, 
      {id:'fr-FR', name: 'Français'}, 
      {id:'de-DE', name: 'Deutsch'}, 
      {id:'ru-RU', name: 'Русский'}, 
      {id:'bg-BG', name: 'Български'}, 
      {id:'nl-NL', name: 'Nederlands'}, 
      {id:'hu-HU', name: 'Magyar'}, 
      {id:'cs-CZ', name: 'Čeština'}, 
      {id:'he-IL', name: 'עברית‎'}, 
      {id:'pl-PL', name: 'Polski‎'}, 
      {id:'pt-PT', name: 'Português'}, 
      {id:'pt-BR', name: 'Português BR'},
      {id:'sv-SE', name: 'Svensk'},
      {id:'id-ID', name: 'Bahasa Indonesia'}, 
      {id:'zh-CN', name: '繁體中文'}, 
      {id:'zh-TW', name: '简体中文'},
      {id:'dolan', name: 'Dolan'}
    ];

    $rootScope.$storage.chains = [{id:'steem', name: 'Steem'}, {id:'golos', name: 'Golos'}];

    if (!$rootScope.$storage.currencies) {
      $rootScope.$storage.currencies = [
        {id:'btc', name: 'BTC', rate: 0, date: "1/1/2016"}, 
        {id:'usd', name: 'USD', rate: 0, date: "1/1/2016"}, 
        {id:'eur', name: 'EUR', rate: 0, date: "1/1/2016"}, 
        {id:'rub', name: 'RUB', rate: 0, date: "1/1/2016"}, 
        {id:'gbp', name: 'GBP', rate: 0, date: "1/1/2016"}, 
        {id:'jpy', name: 'JPY', rate: 0, date: "1/1/2016"}, 
        {id:'krw', name: 'KRW', rate: 0, date: "1/1/2016"}, 
        {id:'inr', name: 'INR', rate: 0, date: "1/1/2016"}, 
        {id:'cny', name: 'CNY', rate: 0, date: "1/1/2016"}, 
        {id:'uah', name: 'UAH', rate: 0, date: "1/1/2016"}, 
        {id:'sek', name: 'SEK', rate: 0, date: "1/1/2016"}, 
        {id:'try', name: 'TRY', rate: 0, date: "1/1/2016"}
      ];
    }

    if (window.cordova) {
      if (ionic.Platform.isIPad() || ionic.Platform.isIOS()) {
        MobileAccessibility.isVoiceOverRunning(function(bool) {
          if (bool) {
              $rootScope.log("Screen reader: ON");
              $rootScope.voiceOver = bool;
              //$ionicConfigProvider.navBar.alignTitle('center');
          } else {
              $rootScope.log("Screen reader: OFF");
              $rootScope.voiceOver = bool;
              //$ionicConfigProvider.navBar.alignTitle('left');
          }
        });

      } else {
        $rootScope.voiceOver = false;
      }
    } else {
      $rootScope.voiceOver = false;
    }

    if (!$rootScope.$storage.view) {
      $rootScope.$storage.view = 'compact';
    }
    if (!$rootScope.$storage.filter) {
      $rootScope.$storage.filter = "trending";
    }
    if (navigator.splashscreen) {
      setTimeout(function() {
        navigator.splashscreen.hide();
      }, 1000);
    }
    $rootScope.log("app start ready");
    setTimeout(function() {
      if ($rootScope.$storage.pincode) {
        $rootScope.pincheck = true;
        $rootScope.$broadcast("pin:check");
      }
    }, 1000);
    $rootScope.showAlert = function(title, msg) {
      var alertPopup = $ionicPopup.alert({
        title: title,
        template: msg
      });
      if (msg.indexOf("error")>-1) {
        //window.Api.initPromise.then(function(response) {
        $rootScope.log("broadcast error");
        //});
      }
      return alertPopup/*.then(function(res) {
        $rootScope.log('Thank you ...');
      });*/
    };
    $rootScope.showMessage = function(title, msg) {
      if (title) {
        if (window.cordova) {
          $cordovaToast.showLongBottom(title+": "+msg).then(function(success) {
            // success
            $rootScope.log("toast"+success);
          }, function (error) {
            // error
            $rootScope.log("toast"+error);
          });
        } else {
          $rootScope.showAlert(title, msg);
        }
      }
    };
    $rootScope.$on('show:loading', function(event, args){
      $rootScope.log('show:loading');
      $ionicLoading.show({
        noBackdrop : true,
        template: '<ion-spinner icon="ripple" class="spinner-energized"></ion-spinner>'
      });
    });
    $rootScope.$on('hide:loading', function(event, args){
      $rootScope.log('hide:loading');
      setTimeout(function() {
        $ionicLoading.hide();
      }, 1000);
    });

    $rootScope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams){
      $rootScope.log("from "+fromState.name+" to "+toState.name);
    });

    $ionicPlatform.on('resume', function(){
      $rootScope.log("app resume");
      var steemRPC = require("steem-rpc");
      if (localStorage.getItem("socketUrl") === null) {
        localStorage.setItem("socketUrl", "wss://steemit.com/wspa");
      }
      window.Api = steemRPC.Client.get({url:localStorage.socketUrl}, true);
      window.steemJS = require("steemjs-lib");
      window.golosJS = require("golosjs-lib");

      //if (!angular.isDefined($rootScope.timeint)) {
      window.Api.initPromise.then(function(response) {
        $rootScope.log("Api ready state change: "+angular.toJson(response));
        $rootScope.timeint = $interval(function(){
          window.Api.database_api().exec("get_dynamic_global_properties", []).then(function(response){
            $rootScope.log("get_dynamic_global_properties " + response.head_block_number);
          });
        }, 15000);
      });
      //}
      window.FirebasePlugin.onNotificationOpen(function(data) {
        $rootScope.log(angular.toJson(data));
        if(data.tap){
          //Notification was received on device tray and tapped by the user.
          //console.log(JSON.stringify(data));
          if (data.author && data.permlink) {
            if (!$rootScope.$storage.pincode) {

              var alertPopup = $ionicPopup.confirm({
                title: data.title,
                template: data.body + $filter('translate')('OPENING_POST')
              });

              alertPopup.then(function(res) {
                $rootScope.log('Thank you for seeing alert from tray');
                if (res) {
                  setTimeout(function() {
                    $rootScope.getContentAndOpen({author:data.author, permlink:data.permlink});
                  }, 10);
                } else {
                  $rootScope.log("not sure to open alert");
                }
              });

            } else {
              $rootScope.$storage.notifData = {title:data.title, body: data.body, author: data.author, permlink: data.permlink};
              $rootScope.pinenabled = true;
            }
          }
        } else{
          //Notification was received in foreground. Maybe the user needs to be notified.
          //alert( JSON.stringify(data) );
          if (data.author && data.permlink) {
            $rootScope.showMessage(data.title, data.body+" "+data.permlink);
          } else {
            $rootScope.showMessage(data.title, data.body);
          }
        }
      }, function(error) {
          console.error(error);
      });

      if ($rootScope.$storage.pincode) {
        $rootScope.pincheck = true;
        $rootScope.$broadcast("pin:check");
      }

      if (window.cordova) {
        if (ionic.Platform.isIPad() || ionic.Platform.isIOS()) {

          MobileAccessibility.isVoiceOverRunning(function(bool) {
            if (bool) {
                $rootScope.log("Screen reader: ON");
                $rootScope.voiceOver = bool;
                //$ionicConfigProvider.navBar.alignTitle('center');
            } else {
                $rootScope.log("Screen reader: OFF");
                $rootScope.voiceOver = bool;
                //$ionicConfigProvider.navBar.alignTitle('left');
            }
          });
        } else {
          $rootScope.voiceOver = false;
        }
      } else {
        $rootScope.voiceOver = false;
      }

    });
    $ionicPlatform.on('pause', function(){
      $rootScope.log("app pause");
      if (angular.isDefined($rootScope.timeint)) {
        $rootScope.log("cancel interval");
        $interval.cancel($rootScope.timeint);
        $rootScope.timeint = undefined;
        window.Api.close();
      }
    });

    $ionicPlatform.on('offline', function(){
      $rootScope.log("app offline");
    });

    $rootScope.init = function() {
      $rootScope.passcode = "";
      if (!$rootScope.$$phase) {
        $rootScope.$apply();
      }
    };

    $rootScope.add = function(value) {
      $rootScope.pinerror = "";
      if($rootScope.passcode.length < 4) {
        $rootScope.passcode = $rootScope.passcode + value;
        if($rootScope.passcode.length == 4) {
          $timeout(function() {
            $rootScope.log("PIN "+$rootScope.passcode);
            if ($rootScope.pintype == 3) {
              if ($rootScope.$storage.pincode == $rootScope.passcode) {
                $rootScope.passcode = "";
                $rootScope.closePin();
              } else {
                $rootScope.pintry += 1;
                $rootScope.pinerror = $filter('translate')('NOT_MATCH')+"("+$rootScope.pintry+")";
                if ($rootScope.pintry>3) {
                  $rootScope.$storage.pincode = undefined;
                  $rootScope.pintry = 0;
                  $rootScope.$broadcast("pin:failed");
                  $rootScope.closePin();
                }
              }
            }
            if ($rootScope.pintype == 0) {
              $rootScope.log("type 0: set pin");
              if ($rootScope.$storage.pincode) {
                $rootScope.pincheck = true;
                $rootScope.$broadcast("pin:check");
                $rootScope.closePin();
              } else {
                $rootScope.$storage.pincode = $rootScope.passcode;
                $rootScope.pinsubtitle = $filter('translate')('CONFIRM_PIN');
                $rootScope.passcode = "";
                $rootScope.pintype = 3;
                $rootScope.pintry = 0;
              }
            }
            if ($rootScope.pintype == 1) {
              $rootScope.log("type 1: check pin");
              if ($rootScope.$storage.pincode == $rootScope.passcode){
                $rootScope.$broadcast('pin:correct');
                $rootScope.passcode = "";
                $rootScope.closePin();
              } else {
                $rootScope.pintry += 1;
                $rootScope.pinerror = $filter('translate')('INCORRECT')+"("+$rootScope.pintry+")";
                if ($rootScope.pintry>3) {
                  $rootScope.$storage.$reset();
                  $rootScope.closePin();
                }
              }
            }

          }, 50);
        }
      }
    };

    $rootScope.delete = function() {
      $rootScope.pinerror = "";
      if($rootScope.passcode.length > 0) {
        $rootScope.passcode = $rootScope.passcode.substring(0, $rootScope.passcode.length - 1);
      }
    }

    $ionicModal.fromTemplateUrl('templates/pincode.html', {
      scope: $rootScope
    }).then(function(modal) {
      $rootScope.pinmodal = modal;
    });
    $rootScope.closePin = function() {
      $rootScope.pinmodal.hide();
      if ($rootScope.pinenabled) {
        if ($rootScope.$storage.notifData) {
          var alertPopup = $ionicPopup.confirm({
            title: $rootScope.$storage.notifData.title,
            template: $rootScope.$storage.notifData.body + $filter('translate')('OPENING_POST')
          });
          alertPopup.then(function(res) {
            $rootScope.log('Thank you for seeing alert from tray');
            if (res) {
              $rootScope.getContentAndOpen({author:$rootScope.$storage.notifData.author, permlink:$rootScope.$storage.notifData.permlink});
              $rootScope.$storage.notifData = undefined;
            } else {
              $rootScope.log("not sure to open alert");
              $rootScope.$storage.notifData = undefined;
            }
            $rootScope.pinenabled = false;
          });
        }
      }
    };
    $rootScope.openPin = function(type) {
      $rootScope.passcode = "";
      if (type == 0) {
        $rootScope.pintype = 0;
        $rootScope.pintitle = $filter('translate')('SET_PIN');
        $rootScope.pinsubtitle = $filter('translate')('SET_PIN');
      }
      if (type == 1) {
        $rootScope.pintype = 1;
        $rootScope.pintry = 0;
        $rootScope.pintitle = $filter('translate')('ENTER_PIN');
        $rootScope.pinsubtitle = $filter('translate')('ENTER_PIN');
      }
      $rootScope.pinmodal.show();
    };
    $rootScope.$on("pin:new", function(){
      $rootScope.pincheck = false;
      $rootScope.openPin(0);
    });
    $rootScope.$on("pin:check", function(){
      $rootScope.pincheck = true;
      $rootScope.openPin(1);
    });


    $ionicModal.fromTemplateUrl('templates/info.html', {
      scope: $rootScope
      //animation: "null"
    }).then(function(modal) {
      $rootScope.infomodal = modal;
    });
    $rootScope.openInfo = function(xx) {
      $rootScope.voters = xx;
      $rootScope.infomodal.show();
    };

    $rootScope.closeInfo = function() {
      $rootScope.infomodal.hide();
      //$rootScope.infomodal.remove();
    };

    String.prototype.replaceAt=function(index, character) {
        return this.substr(0, index) + character + this.substr(index+character.length);
    }
		$rootScope.openDraft = function(item){
			item.operation_type = item.post_type;
			$rootScope.$storage.spost = item;
			$state.go('app.posts');
			$rootScope.$broadcast('openPostModal');
		}
    $rootScope.getContentAndOpen = function(item) {

      window.Api.initPromise.then(function(response) {
        window.Api.database_api().exec("get_content", [item.author, item.permlink]).then(function(result){
          var _len = result.active_votes.length;
          for (var j = _len - 1; j >= 0; j--) {
            if (result.active_votes[j].voter === $rootScope.$storage.user.username) {
              if (result.active_votes[j].percent > 0) {
                result.upvoted = true;
              } else if (result.active_votes[j].percent < 0) {
                result.downvoted = true;
              } else {
                result.downvoted = false;
                result.upvoted = false;
              }
            }
          }
          result.json_metadata = angular.fromJson(result.json_metadata);
          var item = result;
          $rootScope.$storage.sitem = item;
          setTimeout(function() {
            //$state.go('app.post');
            $state.go('app.post', {category: item.category, author: item.author, permlink: item.permlink});

          }, 5);

          if (!$rootScope.$$phase) {
            $rootScope.$apply();
          }
        });
      });
      $rootScope.$broadcast('hide:loading');
    };

    $rootScope.reBlog = function(author, permlink) {
      var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('ARE_YOU_SURE'),
        template: $filter('translate')('REBLOG_TEXT')
      });
      confirmPopup.then(function(res) {
        if(res) {
          $rootScope.log('You are sure');
          $rootScope.$broadcast('show:loading');
          if ($rootScope.$storage.user) {
              $rootScope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
              $rootScope.mylogin.setRoles(["posting"]);
              var loginSuccess = $rootScope.mylogin.checkKeys({
                  accountName: $rootScope.$storage.user.username,
                  password: $rootScope.$storage.user.password || null,
                  auths: {
                      posting: $rootScope.$storage.user.posting.key_auths
                  },
                  privateKey: $rootScope.$storage.user.privatePostingKey || null
                }
              );
              if (loginSuccess) {
                var tr = new window[$rootScope.$storage.chain+"JS"].TransactionBuilder();
                var json;

                json = ["reblog",{account:$rootScope.$storage.user.username, author:author, permlink:permlink}];

                tr.add_type_operation("custom_json", {
                  id: 'follow',
                  required_posting_auths: [$rootScope.$storage.user.username],
                  json: JSON.stringify(json)
                });
                localStorage.error = 0;
                tr.process_transaction($rootScope.mylogin, null, true);

                setTimeout(function() {
                  if (localStorage.error == 1) {
                    $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('REBLOG_TEXT')+" "+localStorage.errormessage)
                  } else {
                    //$scope.refreshFollowers();
                    $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('REBLOGGED_POST'));
                  }
                  $rootScope.$broadcast('hide:loading');
                }, 3000);
              } else {
                $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
              }
            $rootScope.$broadcast('hide:loading');
          } else {
            $rootScope.$broadcast('hide:loading');
            $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
          }
        } else {
          $rootScope.log('You are not sure');
        }
      });
    };

    $rootScope.votePost = function(post, type, afterward) {
      post.invoting = true;
      var tt = 1;
      if (type === "upvote") {
        tt = 1;
      }
      if (type === "downvote") {
        tt = -1;
      }
      if (type === "unvote") {
        tt = 0;
      }
      $rootScope.log('voting '+tt);

      if ($rootScope.$storage.user) {
        window.Api.initPromise.then(function(response) {
          $rootScope.log("Api ready:" + angular.toJson(response));
          $rootScope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
          $rootScope.mylogin.setRoles(["posting"]);
          var loginSuccess = $rootScope.mylogin.checkKeys({
              accountName: $rootScope.$storage.user.username,
              password: $rootScope.$storage.user.password || null,
              auths: {
                  posting: $rootScope.$storage.user.posting.key_auths
              },
              privateKey: $rootScope.$storage.user.privatePostingKey || null
            }
          );
          if (loginSuccess) {
            var tr = new window[$rootScope.$storage.chain+"JS"].TransactionBuilder();
            tr.add_type_operation("vote", {
                voter: $rootScope.$storage.user.username,
                author: post.author,
                permlink: post.permlink,
                weight: $rootScope.$storage.voteWeight*tt || 10000*tt
            });
            console.log(tr);
            localStorage.error = 0;
            tr.process_transaction($rootScope.mylogin, null, true);
            setTimeout(function() {
              post.invoting = false;
              if (localStorage.error == 1) {
                $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
              } else {
								if (tt>0){
									post.upvoted = true;
								} else if (tt<0) {
									post.downvoted = true;
								} else {
									post.upvoted = false;
									post.downvoted = false;
								}
                if (afterward === 'fetchContent') {
                  $rootScope.$broadcast(afterward, { any: {author: post.author, permlink: post.permlink} });
                } else {
                  $rootScope.$broadcast(afterward);
                }
              }
              $rootScope.$broadcast('hide:loading');

            }, 3000);
          } else {
            $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
            $rootScope.$broadcast('hide:loading');
            post.invoting = false;
          }
          $rootScope.$broadcast('hide:loading');
          if (!$rootScope.$$phase) {
            $rootScope.$apply();
          }
        });
      } else {
        $rootScope.$broadcast('hide:loading');
        post.invoting = false;
        $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
      }
    };

    $rootScope.isWitnessVoted = function() {
      if ($rootScope.$storage.user && $rootScope.$storage.user.witness_votes.indexOf("good-karma")>-1) {
        return true;
      } else {
        return false;
      }
    };
    $rootScope.voteWitness = function() {
        var confirmPopup = $ionicPopup.confirm({
          title: $filter('translate')('ARE_YOU_SURE'),
          template: $filter('translate')('VOTE_FOR_WITNESS')+" @good-karma"
        });
        confirmPopup.then(function(res) {
          if(res) {
            $rootScope.log('You are sure');
            $rootScope.$broadcast('show:loading');
            if ($rootScope.$storage.user) {
              if ($rootScope.$storage.user.password || $rootScope.$storage.user.privateActiveKey) {
                $rootScope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
                $rootScope.mylogin.setRoles(["active"]);
                var loginSuccess = $rootScope.mylogin.checkKeys({
                    accountName: $rootScope.$storage.user.username,
                    password: $rootScope.$storage.user.password || null,
                    auths: {
                        active: $rootScope.$storage.user.active.key_auths
                    },
                    privateKey: $rootScope.$storage.user.privateActiveKey || null
                  }
                );
                if (loginSuccess) {
                  var tr = new window[$rootScope.$storage.chain+"JS"].TransactionBuilder();
                  tr.add_type_operation("account_witness_vote", {
                      account: $rootScope.$storage.user.username,
                      approve: true,
                      witness: "good-karma"
                  });
                  localStorage.error = 0;

                  tr.process_transaction($rootScope.mylogin, null, true);

                  setTimeout(function() {
                    if (localStorage.error === 1) {
                      $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                    } else {
                      //$scope.refreshFollowers();
                      $rootScope.showMessage($filter('translate')('SUCCESS'),$filter('translate')('VOTED_FOR_WITNESS')+' @good-karma');
                      $rootScope.$broadcast('refreshLocalUserData');
                    }
                  }, 3000);
                } else {
                  $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
                }
              } else {
                $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
              }
              $rootScope.$broadcast('hide:loading');
            } else {
              $rootScope.$broadcast('hide:loading');
              $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
            }
          } else {
            $rootScope.log('You are not sure');
          }
        });
    };

    $rootScope.following = function(xx, mtype) {
      $rootScope.$broadcast('show:loading');
      $rootScope.log(xx);
      if ($rootScope.$storage.user) {
          $rootScope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
          $rootScope.mylogin.setRoles(["posting"]);
          var loginSuccess = $rootScope.mylogin.checkKeys({
              accountName: $rootScope.$storage.user.username,
              password: $rootScope.$storage.user.password || null,
              auths: {
                  posting: $rootScope.$storage.user.posting.key_auths
              },
              privateKey: $rootScope.$storage.user.privatePostingKey || null
            }
          );
          if (loginSuccess) {
            var tr = new window[$rootScope.$storage.chain+"JS"].TransactionBuilder();
            var json;
            if (mtype === "follow") {
              json = ['follow',{follower:$rootScope.$storage.user.username, following:xx, what: ["blog"]}];
            } else {
              json = ['follow',{follower:$rootScope.$storage.user.username, following:xx, what: []}];
            }

            tr.add_type_operation("custom_json", {
              id: 'follow',
              required_posting_auths: [$rootScope.$storage.user.username],
              json: angular.toJson(json)
            });
            localStorage.error = 0;
            tr.process_transaction($rootScope.mylogin, null, true);

            setTimeout(function() {
              if (localStorage.error == 1) {
                $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
              } else {
                //$scope.refreshFollowers();
                $rootScope.$broadcast('current:reload');
              }
            }, 3000);
          } else {
            $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
          }
        $rootScope.$broadcast('hide:loading');
      } else {
        $rootScope.$broadcast('hide:loading');
        $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
      }
    };

    setTimeout(function() {
      window.Api.initPromise.then(function(response) {
        window.Api.database_api().exec("get_feed_history", []).then(function(r){
        //$rootScope.log(r);
          $rootScope.$storage.base = r.current_median_history.base.split(" ")[0];
          window.Api.database_api().exec("get_dynamic_global_properties", []).then(function(r){
            $rootScope.log(r);
            $rootScope.$storage.steem_per_mvests = (Number(r.total_vesting_fund_steem.substring(0, r.total_vesting_fund_steem.length - 6)) / Number(r.total_vesting_shares.substring(0, r.total_vesting_shares.length - 6))) * 1e6;
          });
        });
      });
    }, 10);
    if (!angular.isDefined($rootScope.$storage.notifications)) {
      $rootScope.$storage.notifications = [];
    }
    $rootScope.$on('changedChain', function(){
      console.log('changeCHain');
      if ($rootScope.$storage.chain == 'steem'){
        $rootScope.$storage.platformname = "Steem";
        $rootScope.$storage.platformpower = "Steem Power";
        $rootScope.$storage.platformsunit = "Steem";
        $rootScope.$storage.platformdollar = "Steem Dollar";
        $rootScope.$storage.platformdunit = "SBD";
        $rootScope.$storage.platformpunit = "SP";
        $rootScope.$storage.platformlunit = "STEEM";
        $rootScope.$storage.socketsteem = "wss://steemd.steemit.com";
      } else {
        $rootScope.$storage.platformname = "ГОЛОС";
        $rootScope.$storage.platformpower = "СИЛА ГОЛОСА";
        $rootScope.$storage.platformsunit = "Голос";
        $rootScope.$storage.platformdollar = "ЗОЛОТОЙ";
        $rootScope.$storage.platformdunit = "GBG";
        $rootScope.$storage.platformpunit = "СИЛА ГОЛОСА";
        $rootScope.$storage.platformlunit = "ГОЛОС";
        $rootScope.$storage.socketgolos = "wss://ws.golos.io/";
        //$scope.socket = "wss://golos.steem.ws";
      }
      localStorage.socketUrl = $rootScope.$storage["socket"+$rootScope.$storage.chain];
    });
    function checkDate(date, ignore) {
      var eold = 86400000; //1 * 24 * 60 * 60 * 1000; //1 day old
      var now = new Date().getTime();
      var old = new Date(date).getTime();
      return ignore||now-old>=eold;
    }
    $rootScope.$on('changedCurrency', function(event, args){
      var xx = args.currency;
      var ignore = args.enforce;

      setTimeout(function() {
        console.log(xx);
        var resultObject = $rootScope.$storage.currencies.filter(function ( obj ) {
            return obj.id === xx;
        })[0];
        //searchObj(xx, $rootScope.$storage.currencies);
        if (checkDate(resultObject.date, ignore)) {
          if ($rootScope.$storage.chain == 'steem'){
            APIs.getCurrencyRate("USD", xx ).then(function(res){
              $rootScope.$storage.currencyRate = Number(res.data.query.results.rate.Rate);
              $rootScope.$storage.currencies.filter(function(obj){
                if (obj.id == xx) {
                  obj.rate = $rootScope.$storage.currencyRate;
                  obj.date = res.data.query.results.rate.Date==="N/A"?new Date() : res.data.query.results.rate.Date;
                }
              });
            });
          } else {
            APIs.getCurrencyRate("XAU", xx ).then(function(res){
              //XAU - 31.1034768g
              //GBG rate in mg. so exchangeRate/31103.4768
              $rootScope.$storage.currencyRate = Number(res.data.query.results.rate.Rate)/31103.4768;
              $rootScope.$storage.currencies.filter(function(obj){
                if (obj.id == xx) {
                  obj.rate = $rootScope.$storage.currencyRate;
                  obj.date = res.data.query.results.rate.Date==="N/A"?new Date() : res.data.query.results.rate.Date;
                }
              });
              //console.log($rootScope.$storage.currencyRate);
            });
          }
        } else {
          $rootScope.$storage.currencyRate = resultObject.rate;
        }
      }, 1);
    });

    if (window.cordova) {
      if (!ionic.Platform.isWindowsPhone()) {
        if (ionic.Platform.isIOS() || ionic.Platform.isIPad()) {
          //window.FirebasePlugin.grantPermission();
        }

        /*window.FirebasePlugin.getToken(function(token) {
            // save this server-side and use it to push notifications to this device
            $rootScope.log("device "+token);
            $rootScope.$storage.deviceid = token;
            if ($rootScope.$storage.user) {
              APIs.saveSubscription(token, $rootScope.$storage.user.username, { device: ionic.Platform.platform() }).then(function(res){
                $rootScope.log(angular.toJson(res));
              });
            } else {
              APIs.saveSubscription(token, "", { device: ionic.Platform.platform() }).then(function(res){
                $rootScope.log(angular.toJson(res));
              });
            }
        }, function(error) {
            console.error(error);
        });*/

        FCMPlugin.getToken(function(token){
          // save this server-side and use it to push notifications to this device
          $rootScope.log("device "+token);
          $rootScope.$storage.deviceid = token;
          if ($rootScope.$storage.user) {
            APIs.saveSubscription(token, $rootScope.$storage.user.username, { device: ionic.Platform.platform() }).then(function(res){
              $rootScope.log(angular.toJson(res));
            });
          } else {
            APIs.saveSubscription(token, "", { device: ionic.Platform.platform() }).then(function(res){
              $rootScope.log(angular.toJson(res));
            });
          }
        });

        /*window.FirebasePlugin.onTokenRefresh(function(token) {
          APIs.updateToken($rootScope.$storage.deviceid, token).then(function(res){
            console.log(angular.toJson(res));
            if (res.status) {
              $rootScope.$storage.deviceid = token  
            }
          });
          if (!$rootScope.$$phase){
            $rootScope.$apply();
          }
        }, function(error) {
          console.error(error);
        });*/
        FCMPlugin.onTokenRefresh(function(token){
          APIs.updateToken($rootScope.$storage.deviceid, token).then(function(res){
            console.log(angular.toJson(res));
            if (res.status) {
              $rootScope.$storage.deviceid = token  
            }
          });
          if (!$rootScope.$$phase){
            $rootScope.$apply();
          }
        });

        /*window.FirebasePlugin.onNotificationOpen(function(data) {
            $rootScope.log(angular.toJson(data));

            //console.log(angular.toJson(data));

            //$rootScope.$storage.notifications.push({title:data.title, message: data.body, author: data.author, permlink: data.permlink, created: new Date()});

            if(data.tap){
              //Notification was received on device tray and tapped by the user.
              if (data.author && data.permlink) {
                if (!$rootScope.$storage.pincode) {

                  var alertPopup = $ionicPopup.confirm({
                    title: data.title,
                    template: data.body + $filter('translate')('OPENING_POST')
                  });

                  alertPopup.then(function(res) {
                    $rootScope.log('Thank you for seeing alert from tray');
                    if (res) {
                      setTimeout(function() {
                        $rootScope.getContentAndOpen({author:data.author, permlink:data.permlink});
                      }, 10);
                    } else {
                      $rootScope.log("not sure to open alert");
                    }
                  });

                } else {
                  $rootScope.$storage.notifData = {title:data.title, body: data.body, author: data.author, permlink: data.permlink};
                  $rootScope.pinenabled = true;
                }
              }
            } else{
              //Notification was received in foreground. Maybe the user needs to be notified.
              //alert( JSON.stringify(data) );
              if (data.author && data.permlink) {
                $rootScope.showMessage(data.title, data.body+" "+data.permlink);
              } else {
                $rootScope.showMessage(data.title, data.body);
              }
            }
        }, function(error) {
            console.error(error);
        });
        */

        //FCMPlugin.onNotification( onNotificationCallback(data), successCallback(msg), errorCallback(err) )
        //Here you define your application behaviour based on the notification data.
        FCMPlugin.onNotification(function(data){
          $rootScope.log(angular.toJson(data));

            //console.log(angular.toJson(data));

            //$rootScope.$storage.notifications.push({title:data.title, message: data.body, author: data.author, permlink: data.permlink, created: new Date()});

            if(data.wasTapped){
              //Notification was received on device tray and tapped by the user.
              if (data.author && data.permlink) {
                if (!$rootScope.$storage.pincode) {

                  var alertPopup = $ionicPopup.confirm({
                    title: data.title,
                    template: data.body + $filter('translate')('OPENING_POST')
                  });

                  alertPopup.then(function(res) {
                    $rootScope.log('Thank you for seeing alert from tray');
                    if (res) {
                      setTimeout(function() {
                        $rootScope.getContentAndOpen({author:data.author, permlink:data.permlink});
                      }, 10);
                    } else {
                      $rootScope.log("not sure to open alert");
                    }
                  });

                } else {
                  $rootScope.$storage.notifData = {title:data.title, body: data.body, author: data.author, permlink: data.permlink};
                  $rootScope.pinenabled = true;
                }
              }
            } else{
              //Notification was received in foreground. Maybe the user needs to be notified.
              //alert( JSON.stringify(data) );
              if (data.author && data.permlink) {
                $rootScope.showMessage(data.title, data.body+" "+data.permlink);
              } else {
                $rootScope.showMessage(data.title, data.body);
              }
            }
        });
      }

    }

  });
});

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/posts/index.js","/posts")
},{"./config":135,"./controllers":136,"./locales/bg-BG":138,"./locales/cs-CZ":139,"./locales/de-DE":140,"./locales/dol":141,"./locales/el-GR":142,"./locales/en":143,"./locales/es-ES":144,"./locales/fr-FR":145,"./locales/he-IL":146,"./locales/hu-HU":147,"./locales/id-ID":148,"./locales/nl-NL":149,"./locales/pl-PL":150,"./locales/pt-BR":151,"./locales/pt-PT":152,"./locales/ru-RU":153,"./locales/sv-SE":154,"./locales/zh-CN":155,"./locales/zh-TW":156,"./services":157,"buffer":11,"currency-symbol-map":27,"diff-match-patch":29,"golosjs-lib":57,"pBGvAp":74,"steem-rpc":88,"steemjs-lib":111}],138:[function(require,module,exports){
module.exports={
  "HOME":"Начало",
  "LOGIN":"Вход",
  "LOGOUT":"Отписване",
  "PROFILE":"Профил",
  "FOLLOW":"Следване",
  "BOOKMARKS":"Любими",
  "TRANSFER":"Трансфер",
  "MARKET":"Пазар",
  "SETTINGS":"Настройки",
  "ABOUT":"За приложението",
  "ABOUT_1":"Всеки може да печели от публикуване на статии!",
  "ABOUT_2":"ползва {{platformname}}. Апликацията е създадена от",
  "ABOUT_3":"и е мобилно приложение с отворен код. Имате свободен достъп до съдържание за четене, коментари, гласуване, публикуване, управление на приходи за трансфер и т.н. функции, предлагани от {{platformname}} блокчейна на {{sitename}}.",
  "ABOUT_4":"1. Апликацията няма директен достъп до средствата на потребителя.",
  "ABOUT_5":"2. Апликацията предлага модел на сигурност за страна на клиента, с частни ключове, съхраняване на местно ниво и никога не се изпращат до сървъри.",
  "ABOUT_6":"3. Апликацията предлага прост и атрактивен потребителски интерфейс.",
  "ABOUT_7":"4. Апликацията никога не изисква от потребителят да въвежда лични данни.",
  "ABOUT_8":"Гласувайте за good-karma.",
  "ABOUT_9":"Контакт и обратна връзка:",
  "ABOUT_10":"Още информация",
  "REMOVE":"Премахни",
  "MARKET_VIEW":"Изглед на пазара",
  "PRICE":"Цена",
  "AMOUNT":"Сума",
  "TOTAL":"Общо",
  "NOORDERS":"Няма отворени заявки",
  "DATE":"Дата",
  "BUY":"Купи",
  "SELL":"Продай",
  "OPEN":"Отвори",
  "HISTORY":"История",
  "FOLLOW_BACK":"Следване обратно",
  "FOLLOWED":"Следван",
  "UNFOLLOW":"Спрете следенето",
  "FOLLOWING":"Следване",
  "FOLLOWERS":"Последователи",
  "SEARCH_FOLLOWERS":"Търси последователи",
  "SEARCH_FOLLOWING":"Търси следвани",
  "BY":"от",
  "IN":"в",
  "MENU":"Меню",
  "BOOKMARK":"Любими",
  "REBLOG":"Реблог",
  "UPVOTE":"Глас",
  "DOWNVOTE":"Негативен глас",
  "UNVOTE_DOWNVOTED":"Откажи негативния глас",
  "UNVOTE_UPVOTED":"Откажи гласа",
  "REPLY":"Отговор",
  "EDIT":"Редактиране",
  "POST_1":"Плъзнете на ляво, за да видите опциите",
  "POST_2":"Изберете някой коментар, за да видите под-коментари към тях.",
  "OPTIONS":"Настройки",
  "RESTEEMED_BY":"Препратено от",
  "NOTHING_HERE":"Все още нищо...",
  "BALANCES":"Баланси по сметка",
  "PROFILE_1":"{{platformname}} е разменяема криптовалута, която може да бъде трансферирана във всеки един момент. {{platformname}} може да бъде обърната в {{platformpower}} чрез процес нарчен Захранване.",
  "PROFILE_2":"{{platformpower}} влияе върху печалбите. Колкото повече има потребителя, системата го награждава повече когато гласува и публикува.",
  "PROFILE_3":"Около {{platformsunit}} на {{platformname}}.",
  "ESTIMATED_VALUE":"Приблизителна стойност",
  "PROFILE_4":"Приблизителната стойност се оценява на 7 дни от средна стойност на {{platformname}}.",
  "TRANSACTION_HISTORY":"История на транзакцийте",
  "POSTING":"Публикуване",
  "PROFILE_5":"Ключът за публикуване се използва за публикуване и гласуване. Трябва да бъде различен от Активния и Собствения ключ.",
  "OWNER":"Собственик",
  "PROFILE_6":"Собственият ключ е основният ключ на прфила и е необходим за промяна на другите ключове. Личният ключ или парола за ключа на собственика трябва се съхранява на сигурно място.",
  "ACTIVE":"Активни",
  "PROFILE_7":"Активният ключ се използва, за трансфери и даване поръчки в рамките на вътрешния пазар.",
  "MEMO":"Бележка",
  "PROFILE_8":"Ключът за бележка се използва за създаване и четене на бележки.",
  "BLOG":"Блог",
  "POSTS":"Статии",
  "REPLIES":"Отговори",
  "WALLET":"Портфейл",
  "TAG":"Таг",
  "USER":"Потребител",
  "CLOSE":"Затваряне",
  "TO":"За",
  "ASSET":"Актив",
  "SEND":"Прати",
  "SECURITY":"Сигурност",
  "AVAILABLE":"Наличност",
  "PUBLIC_MEMO":"Публична бележка",
  "TO_DESC":"Потребител, например good-karma",
  "PIN_CODE":"Пин-код",
  "PIN_TEXT":"Пин-кодът обезопасява данните ви в приложението. <br/><br/>Веднъж активиран, имате само 4 опита за да го отключите, ако сте забравили свотя пин-код или не сте го въвели правилно, апликацията ще премахне данните на потребителя при влизане. Можете повторно да влезнете и продължите да използвате приложението.",
  "NOTIFICATIONS":"Известия",
  "VOTE_TEXT":"Ще получите известие, когато някой гласува за ваша статия. <br/>Уведомленията включват Сила на глас както и предупредителни съобщения.",
  "VOTE":"Глас",
  "COMMENT_TEXT":"Ще получите известие, когато някой коментира вашите публикации или коментари!<br/> Известията също включват когато някой редактира своите коментари.",
  "COMMENT":"Коментар",
  "FOLLOW_TEXT":"Ще получите известие, когато някой ви следи или ще спре да ви следи!",
  "MENTIONS":"Споменавания",
  "MENTIONS_TEXT":"Ще получите известие, когато някой ви спомене в своя публикация или коментар!",
  "RESTEEM":"Споделяне",
  "RESTEEM_TEXT":"Ще получите известие, когато някой сподели ваш пост!",
  "CONFIGURATIONS":"Настройки",
  "VOTING":"Гласуване",
  "VOTING_TEXT":"Изберете в проценти силата на гласа ви.\n <br/><br/>Това ще определи размера въжнаграждения , които получават статиите, за които гласувате.",
  "SERVER":"Сървър",
  "SERVER_TEXT":"Препоръчително",
  "SAVE_CHANGES":"Запази",
  "VOTERS_INFO":"Информация за гласувалите",
  "WELCOME_BACK":"Здравей, отново!",
  "LOGIN_1":"Влезте с потребителско име и парола за да продължите.",
  "LOGIN_2":"Ключът за публикуване се използва за публикуване, коментиране, гласуване и следене.",
  "LOGIN_3":"Активният ключ се използва за трансфери и обновление на профилна снимка.",
  "LOGIN_4":"Потребителски идентификационни данни се съхраняват локално на устройствата ви. При изход пълномощията се отстраняват!",
  "DONT_HAVE":"Нямате профил?",
  "SIGN_UP_NOW":"Регистрирайте се сега!",
  "CANCEL":"Отказ",
  "ADVANCED":"Разширен режим",
  "ACTIVE_PRIKEY":"Активен личен ключ",
  "POSTING_PRIKEY":"Личен ключ за публикуване",
  "MASTER_PASS":"Основна парола",
  "USERNAME":"Потребителско име",
  "CARD_VIEW":"Картички",
  "COMPACT_VIEW":"Списъци",
  "SEARCH":"Търси",
  "SUBMIT_A_STORY":"Публикувайте нещо",
  "REPLYTO":"Отговор на",
  "POST":"Публикуване",
  "PREVIEW":"Преглед",
  "DEFAULT":"50% / 50%",
  "POWERUP":"Захранване 100%",
  "DECLINE_PAYOUT":"Отказ на възнаграждение",
  "SAVE_FOR_LATER":"Запазване за по-късно",
  "CLEAR":"Изчистване",
  "POST_CONTENT":"Коментар",
  "COMMENT_CONTENT":"Съдържание на коментара",
  "TITLE":"Заглавие",
  "TAGS":"Тагове",
  "NOT_MATCH":"Не съвпада",
  "CONFIRM_PIN":"Потвърдете пин-кода",
  "INCORRECT":"Грешно",
  "OPENING_POST":"Отваране на статия.",
  "SET_PIN":"Задайте пин-код.",
  "ENTER_PIN":"Въведете пин-код.",
  "ARE_YOU_SURE":"Сигурни ли сте?",
  "REBLOG_TEXT":"Споделянето е необратимо, искате ли да продължите?",
  "BROADCAST_ERROR":"Грешка при свързване, опитайте отново!",
  "SUCCESS":"Успех!",
  "REBLOGGED_POST":"Споделена публикация!",
  "LOGIN_FAIL":"Неуспешно влизане! Моля, уверете се, че сте влезли в системата с главната парола или с частен ключ за публикуване при влизане, ако сте избрали Разширен режим.",
  "LOGIN_FAIL_A":"Неуспешно влизане! Моля, уверете се, че сте влезли в системата с главната парола или с Активния частен ключ при влизане, ако сте избрали Разширен режим.",
  "WARNING":"Внимание",
  "VOTE_FOR_WITNESS":"Гласуване за witness",
  "VOTED_FOR_WITNESS":"Гласувано за witness",
  "AGO":"-",
  "FROM_NOW":"отпреди",
  "SECS":"сек",
  "A_MIN":"мин",
  "MINS":"мин",
  "AN_HOUR":"час",
  "HOURS":"часа",
  "A_DAY":"ден",
  "DAYS":"дни",
  "A_MONTH":"месец",
  "MONTHS":"месеца",
  "A_YEAR":"година",
  "YEARS":"години",
  "MIN_READ":"-минутно четене.",
  "DOWNVOTE_FLAG":"Отрицателен глас или слагане на флаг.",
  "CAPTURE_PICTURE":"Снимка",
  "SELECT_PICTURE":"Изберете снимка",
  "SET_CUSTOM_URL":"Задайте URL",
  "INSERT_PICTURE":"Добавете снимка",
  "ERROR":"Грешка",
  "UPLOAD_ERROR":"Грешка при качване",
  "CAMERA_CANCELLED":"Няма достъп до камерата.",
  "SET_URL":"Сложете URL",
  "DIRECT_LINK_PICTURE":"Директна връзка към снимката",
  "COMMENT_SUBMITTED":"Коментарът е публикуван!",
  "DELETE_COMMENT":"Изтриването на коментари е необратимо",
  "DELETED_COMMENT":"Изтрит коментар",
  "UPLOADING_PICTURE":"Качване на снимка",
  "UPLOAD_COMPLETED":"Качването приключи",
  "UPLOAD_FAILED":"Грешка при качване",
  "PASSWORD_INCORRECT":"Паролата или потребителското име са грешни",
  "INFO":"Информация",
  "QR_TEXT":"Поставете на QR код в полето за сканиране",
  "BALANCE_TEXT":"Уверете се, че имате достатъчна сума за трансфер!",
  "NONEXIST_USER":"Потребителят към, когото се опитвате да прехвърлите сумата не съществува!",
  "TRANSFER_TEXT":"Сигурни ли сте, че искате да преведете сумата?",
  "CONFIRMATION":"Потвърждаване",
  "TX_BROADCASTED":"Транзакцията се излъчва...",
  "FEED":"Поток",
  "TRENDING":"Тенденции",
  "HOT":"Горещи",
  "NEW":"Нови",
  "PROMOTED":"Промотирани",
  "VOTES":"Гласове",
  "PAYOUT":"Изплащане",
  "COMMENTS":"Коментари",
  "TRENDING_30":"Тенденции за последните 30 дни",
  "SORT_POST_BY":"Сортиране по:",
  "PAYOUT_CYCLE":"Цикъл на изплащане",
  "POTENTIAL_PAYOUT":"Потенциално изплащане",
  "PAST_PAYOUT":"Последно изплащане",
  "AUTHOR_PAYOUT":"Авторско възнаграждение",
  "CURATION_PAYOUT":"Възнаграждения от кураторство",
  "POST_SUBMITTED":"Статията е публикувана",
  "POST_LATER":"Публикувайте по-късно!",
  "SAVED":"Запазено",
  "CLEARED":"Изчистено",
  "FLAGGING_TEXT":"Слагането на флаг може да намали наградите и да свали статията от предните редици.<br><br>Флагът бива да се ползва при измами или плагятство, омразна реч, интернет троли, умишлено неправилно категоризирано съдържание и спам.",
  "REQUEST_LIMIT_TEXT":"Лимит за заявка е достигнат. Разгледайте други тенденции/тагове!",
  "POST_IS_UNBOOKMARK":"Статията е премахната от любими!",
  "POST_IS_BOOKMARK":"Статията е добавена в Любими!",
  "RESET":"Изчистване",
  "MODIFY_PICTURE":"Промяна на профилна снимка",
  "MODIFY_COVER_PICTURE":"Промяна на шаблонната снимка",
  "ACTIVE_KEY_REQUIRED_TEXT":"Моля, представете Активен частен ключ, ако сте избрали Разширен режим за вход!",
  "RESET_PICTURE_TEXT":"Това ще премахне профилната сникмка",
  "RESET_COVER_PICTURE_TEXT":"Това ще премахне шаблонната сникмка",
  "UPDATE_REQUIRES_RESTART":"Нужен е рестарт на сървъра!",
  "SETTINGS_UPDATED":"Настройките са обновени!",
  "LANGUAGES":"Език",
  "LANGUAGES_TEXT":"От тук се сменят езиците на апликацията.",
  "LOGIN_TO_X":"Тази операция изисква потребителя да влезете в профила с основна парола, с активен/публикуване ключ. Моля, влезте и опитайте отново.",
  "GALLERY":"Галерия",
  "TRANSLATIONS":"Преводачи",
  "SHARE":"Сподели",
  "MARKETPLACE":"Борса",
  "EXCHANGE":"Обмяна",
  "DRAFTS":"Чернови",
  "POST_IS_UNDRAFT":"Статията е премахната от черновите!",
  "POST_IS_DRAFT":"Статията е добавена в черновите!",
  "SWIPE_LEFT":"Пълзнете наляво за опции",
  "MANAGE":"Управление",
  "IMAGE_REMOVED":"Снимката е премахната",
  "COPY":"Копиране",
  "NO_IMAGE":"Все още не сте качили снимка!",
  "PULL_DOWN_TO_REFRESH":"Плъзнете надолу за опресняване",
  "EXTERNAL_APPS":"Външни апликации",
  "PLUGINS":"Добавки",
  "SUGGEST":"Предложете\n",
  "COMING_SOON":"Очаквайте скоро",
  "CHAIN":"Блокчейн",
  "CHAIN_TEXT":"От тук се избира блокчейн или базовата платформа.",
  "CURRENCY":"Валутa",
  "CURRENCY_TEXT":"Тук можете да промените валутата в която искате да виждате възнагражденията.",
  "ABOUT_11":"<br><b>Функции в eSteem</b><br>-Достъп до уникални статии на всякакви теми, които ви интересуват. <br>-Автотите получават възнагражения благодарение на гласовете от кураторите, които също получават дял от печалбите.<br>-Печелите от гласовете, които получават вашите статии, както и от кураторство. Давайки своя глас на други автори също печелите възнаграждение.<br>-Публикувайте вашите статии и ги съхранявайте безплатнo. Печелете възнаграждения от вашия блог.<br>-Пишете статий в движение. Имате опция за запазване на няколко чернови за по-късно публикуване.<br>-Запазете статии в \"Любими\", за да ги прочетете по-късно.<br>-Борса и теглене на приходи.<br>-Изпращане на средства към когото и да е автор, потребител, приятел, послефовател и тн.<br>-Следвайте интересни блогъри.<br>-Намерете вашите последователи и хора, които следите.<br>-Получаване на извастия. Подържайте връзка със своите последователи, следете дискустии, в които участвате.<br>-Търсене на интересни тагове/категории и автори. <br> -Персонализиране на вашия профил. <br>Много функции ще бъдат добавени. <br><br><b>Сигурност</b> <br>1. Апликацията няма директен достъп към вашите средства. <br>2. Апликацията предлага модел за сигурност от страна на потребителя. Частните ключове се съхраняват локално и никога не се изпращат към сървъри. Вие сте отговорни за запазването и съхрананието на вашите пароли. <br>3. Апликацията предлага опростен и привлекателен потребителски интерфейс. <br>4. Апликацията предлага допълнително ниво на сигурност с пин-код <br><br>eSteem подържа платформите Steem и Golos.<br>",
  "FOUNDER":"Основател и главен програмист",
  "ADD_ACCOUNT":"Добавяне на допълнителен профил",
  "PLATFORM":"Платформа"
}
},{}],139:[function(require,module,exports){
module.exports={
  "HOME":"Domů",
  "LOGIN":"Přihlášení",
  "LOGOUT":"Odhlášení",
  "PROFILE":"Profil",
  "FOLLOW":"Následuj",
  "BOOKMARKS":"Záložky",
  "TRANSFER":"Převod",
  "MARKET":"Trh",
  "SETTINGS":"Nastavení",
  "ABOUT":"O nás",
  "ABOUT_1":"kde kdokoliv může získat odměnu za svůj obsah!",
  "ABOUT_2":"je postaven na {{platformname}} platformě. Aplikaci vytvořil",
  "ABOUT_3":"a je to komunitní, open-source mobilní projekt. Nabízí přístup k obsahu pro čtení, komentování, hlasování, vystavování příspěvků, převod výdělků atd. poskytované {{platformname}} blockchainem a {{sitename}}.",
  "ABOUT_4":"1. Aplikace nemá přístup k uživatelovým fondům ani je nikdy nevlastní.",
  "ABOUT_5":"2. Aplikace nabízí bezpečnostní model na straně klienta. Privátní klíče jsou drženy lokálně a nikdy nejsou posílány žádným serverům.",
  "ABOUT_6":"3. Aplikace nabízí jednoduchá, atraktivní uživatelská rozhraní a zážitky.",
  "ABOUT_7":"4. Aplikace po uživatelích nikdy nepožaduje žádné osobní informace.",
  "ABOUT_8":"Hlasujte pro svědka good-karma",
  "ABOUT_9":"Kontakt/Zpětná vazba:",
  "ABOUT_10":"Více informací:",
  "REMOVE":"Odstranit",
  "MARKET_VIEW":"Zobrazení trhu",
  "PRICE":"Cena",
  "AMOUNT":"Suma",
  "TOTAL":"Celkem",
  "NOORDERS":"Žádné otevřené objednávky pro",
  "DATE":"Datum",
  "BUY":"Nákup",
  "SELL":"Prodej",
  "OPEN":"Otevřeno",
  "HISTORY":"Historie",
  "FOLLOW_BACK":"Sledovat",
  "FOLLOWED":"Sledován",
  "UNFOLLOW":"Přestat sledovat",
  "FOLLOWING":"Sledovaní",
  "FOLLOWERS":"Sledující",
  "SEARCH_FOLLOWERS":"Hledej sledující",
  "SEARCH_FOLLOWING":"Hledej sledované",
  "BY":"kým",
  "IN":"v",
  "MENU":"",
  "BOOKMARK":"Záložka",
  "REBLOG":"",
  "UPVOTE":"Hlasujte pro",
  "DOWNVOTE":"Hlasujte proti",
  "UNVOTE_DOWNVOTED":"Vraťte hlas proti",
  "UNVOTE_UPVOTED":"Vraťte hlas pro",
  "REPLY":"Odpovězte",
  "EDIT":"Upravte",
  "POST_1":"Pro zobrazení voleb přejeď vlevo na komentáře",
  "POST_2":"Pro zobrazení subkomentářů klepněte na komentáře",
  "OPTIONS":"Volby",
  "RESTEEMED_BY":"Resteemováno kým",
  "NOTHING_HERE":"Připravuje se",
  "BALANCES":"Zůstatky",
  "PROFILE_1":"{{platformname}}, obchodovatelné tokeny, které mohou být kdykoliv převedeny. {{platformname}} mohou být převedeny na {{platformpower}} v procesu zvaném powering up.",
  "PROFILE_2":"{{platformpower}}, vlivové tokeny, které posilují při dlouhodobém držení a hlasování o příspěvcích. Čím více jich někdo drží, tím více může ovlivnit odměny druhých a sám získat odměnu za správné hlasování.",
  "PROFILE_3":"Tokeny v ceně okolo {{platformsunit}} v {{platformname}}.",
  "ESTIMATED_VALUE":"Očekávaná cena",
  "PROFILE_4":"Očekávaná cena je založena na 7 denní průměrné ceně {{platformname}}.",
  "TRANSACTION_HISTORY":"Historie transakcí",
  "POSTING":"Odesílání",
  "PROFILE_5":"Odesílací klíč je používán pro odesílání příspěvků a hlasování. Měl by být rozdílný od aktivního a vlastnického klíče.",
  "OWNER":"Vlastník",
  "PROFILE_6":"Vlastnický klíč je hlavní klíč účtu a je požadován pro změnu ostatních účtů. Privátní klíč nebo heslo pro vlastnický klíč by měly být drženy pokud možno co nejvíce offline.",
  "ACTIVE":"Aktivní",
  "PROFILE_7":"Aktivní klíč se používá pro převody a zadání objednávek na vnitřním trhu.",
  "MEMO":"Poznámka",
  "PROFILE_8":"Poznámkový klíč se používá pro tvorbu a čtení poznámek.",
  "BLOG":"",
  "POSTS":"Příspěvky",
  "REPLIES":"Odpovědi",
  "WALLET":"Peněženka",
  "TAG":"Štítek",
  "USER":"Uživatel",
  "CLOSE":"Zavřít",
  "TO":"do",
  "ASSET":"Aktivum",
  "SEND":"Poslat",
  "SECURITY":"Zabezpečení",
  "AVAILABLE":"Dostupný",
  "PUBLIC_MEMO":"Veřejná poznámka",
  "TO_DESC":"Uživatel např. good-karma",
  "PIN_CODE":"Pin kód",
  "PIN_TEXT":"PIN kód pomáhá zabezpečit aplikaci a data. <br/><br/><b>Poznámka:</b> Jakmile je aktivní, máte maximálně 4 pokusy na odemčení. Pokud pin zapomenete nebo neuspějete, aplikace odstraní uživatelská data tohoto přihlášení. Můžete se opět přihlásit a pokračovat v práci.",
  "NOTIFICATIONS":"Oznámení",
  "VOTE_TEXT":"Pokud někdo hlasuje pro Váš příspěvek, obdržíte upozornění! <br/> <b>Poznámka:</b> Tato oznámení obsahují váhu hlasu (ať už je to hlas pro, proti, nebo odvolání hlasování).",
  "VOTE":"Hlasujte",
  "COMMENT_TEXT":"Pokud někdo komentuje Váš příspěvek nebo komentář, obdržíte oznámení! <br/> <b>Poznámka:</b> Upozornění je zasláno též pokud někdo <b>edituje</b> svůj komentář.",
  "COMMENT":"Poznámka",
  "FOLLOW_TEXT":"Obdržíte upozornění když vás někdo začne sledovat, nebo sledování zruší!",
  "MENTIONS":"Zmínky",
  "MENTIONS_TEXT":"Pokud vás někdo zmíní v příspěvku/komentáři, obdržíte upozornění!",
  "RESTEEM":"",
  "RESTEEM_TEXT":"Pokud někdo resteemuje váš příspěvek, dostanete oznámení.",
  "CONFIGURATIONS":"Konfigurace",
  "VOTING":"Hlasování",
  "VOTING_TEXT":"Váha hlasu nebo procento ovlivňuje hlasovací sílu aplikace, takže můžete regulovat výši odměny vašeho hlasování. <br/><br/><b>Poznámka:</b> To ovlivní váhu hlasu/procento i při hlasování proti a je to platné v celé aplikaci.",
  "SERVER":"",
  "SERVER_TEXT":"Doporučené",
  "SAVE_CHANGES":"Uložit změny",
  "VOTERS_INFO":"Informace o voliči",
  "WELCOME_BACK":"Vítejte zpět!",
  "LOGIN_1":"Pro pokračování se přihlašte svým uživatelským jménem a heslem.",
  "LOGIN_2":"Odesílací klíč je určen pro vystavovaní příspěvků, komentáře, hlasování, sledování.",
  "LOGIN_3":"Aktivní klíč je určen pro převody a aktualizaci profilového obrázku.",
  "LOGIN_4":"Uživatelovy přihlašovací údaje jsou drženy lokálně v přístroji. Po odhlášení jsou odstraněny!",
  "DONT_HAVE":"Nemáte účet?",
  "SIGN_UP_NOW":"Zřiďte si účet",
  "CANCEL":"Zrušit",
  "ADVANCED":"Pokročilý",
  "ACTIVE_PRIKEY":"Aktivní soukromý klíč",
  "POSTING_PRIKEY":"Odesílací soukromý klíč",
  "MASTER_PASS":"Hlavní heslo",
  "USERNAME":"Uživatelské jméno",
  "CARD_VIEW":"Zobrazení karta",
  "COMPACT_VIEW":"Zobrazení kompakt",
  "SEARCH":"Hledat",
  "SUBMIT_A_STORY":"Vlož článek",
  "REPLYTO":"Odpovězte",
  "POST":"Odeslat",
  "PREVIEW":"Náhled",
  "DEFAULT":"Nastavení 50% / 50%",
  "POWERUP":"100% Steem Power",
  "DECLINE_PAYOUT":"Odmítnou výplatu",
  "SAVE_FOR_LATER":"Uschovat na později",
  "CLEAR":"Vyčistit",
  "POST_CONTENT":"Odeslat obsah",
  "COMMENT_CONTENT":"Komentovat obsah",
  "TITLE":"Nadpis",
  "TAGS":"Štítky",
  "NOT_MATCH":"Neshoduje se",
  "CONFIRM_PIN":"Potvrďte PIN",
  "INCORRECT":"Nesprávný",
  "OPENING_POST":"úvodní příspěvek",
  "SET_PIN":"Nastavte PIN",
  "ENTER_PIN":"Vložte PIN",
  "ARE_YOU_SURE":"Určitě?",
  "REBLOG_TEXT":"Resteem je nevratný, přejete si pokračovat?",
  "BROADCAST_ERROR":"Chyba odeslání, zkuste znovu!",
  "SUCCESS":"Úspěch",
  "REBLOGGED_POST":"Reblogovaný příspěvek!",
  "LOGIN_FAIL":"Přihlášení selhalo! Ujistěte se, že jste se přihlásili hlavním heslem, nebo že jste při přihlášení zadali Odesílací klíč, pokud jste zvolili Pokročilý režim.",
  "LOGIN_FAIL_A":"Přihlášení selhalo! Ujistěte se, že jste se přihlásili hlavním heslem, nebo že jste při přihlášení zadali Aktivní klíč, pokud jste zvolili Pokročilý režim.",
  "WARNING":"Výstraha",
  "VOTE_FOR_WITNESS":"Hlasování o svědcích",
  "VOTED_FOR_WITNESS":"Hlasoval pro svědka",
  "AGO":"před",
  "FROM_NOW":"od teď",
  "SECS":"vteřiny",
  "A_MIN":"minuta",
  "MINS":"minuty",
  "AN_HOUR":"hodina",
  "HOURS":"hodiny",
  "A_DAY":"den",
  "DAYS":"dny",
  "A_MONTH":"měsíc",
  "MONTHS":"měsíce",
  "A_YEAR":"rok",
  "YEARS":"roky",
  "MIN_READ":"",
  "DOWNVOTE_FLAG":"Hlasujte proti nebo označte jako závadné",
  "CAPTURE_PICTURE":"Zachyťte obrázek",
  "SELECT_PICTURE":"Vyberte obrázek",
  "SET_CUSTOM_URL":"Nastavte zákaznické URL",
  "INSERT_PICTURE":"Vložte obrázek",
  "ERROR":"Chyba",
  "UPLOAD_ERROR":"Nahrajte chybu",
  "CAMERA_CANCELLED":"Fotoaparát zrušen",
  "SET_URL":"Nastavte URL",
  "DIRECT_LINK_PICTURE":"Přímý odkaz na obrázek",
  "COMMENT_SUBMITTED":"Komentář vložen!",
  "DELETE_COMMENT":"Mazání komentáře je nevratné...",
  "DELETED_COMMENT":"Odstraněný komentář",
  "UPLOADING_PICTURE":"Nahrávání obrázku",
  "UPLOAD_COMPLETED":"Nahrávání hotovo",
  "UPLOAD_FAILED":"Nahrávání selhalo",
  "PASSWORD_INCORRECT":"Heslo nebo jméno účtu bylo nesprávné",
  "INFO":"",
  "QR_TEXT":"QR kód umístěte do oblasti pro sken",
  "BALANCE_TEXT":"Ujistěte se, že máte dostatečný zůstatek pro transakci!",
  "NONEXIST_USER":"Uživatel, kterému se snažíte převést fondy neexistuje!",
  "TRANSFER_TEXT":"Jste si jisti, že si přejete provést převod?",
  "CONFIRMATION":"Potvrzení",
  "TX_BROADCASTED":"Transakce je odesílána",
  "FEED":"Zdroj",
  "TRENDING":"V trendu",
  "HOT":"Žhavé",
  "NEW":"Nové",
  "PROMOTED":"Propagované",
  "VOTES":"Hlasy",
  "PAYOUT":"Výplata",
  "COMMENTS":"Komentáře",
  "TRENDING_30":"V trendu po 30 dní",
  "SORT_POST_BY":"Roztřídit příspěvky dle",
  "PAYOUT_CYCLE":"Cyklus výplaty",
  "POTENTIAL_PAYOUT":"Potenciální výplata",
  "PAST_PAYOUT":"Minulá výplata",
  "AUTHOR_PAYOUT":"Autorská odměna",
  "CURATION_PAYOUT":"Kurátorská odměna",
  "POST_SUBMITTED":"Článek je odeslán!",
  "POST_LATER":"Uschovat pro pozdější odeslání!",
  "SAVED":"Uložený",
  "CLEARED":"Vyčištěno",
  "FLAGGING_TEXT":"Označení příspěvku za závadný může odebrat odměny a učinit tento materiál méně viditelným.<br><br>Toto označení by mělo být použito na následující: <ul><li>podvod nebo plagiátorství</li><li>projevy nenávisti nebo internetové trolování</li><li>záměrně chybná kategorizace obsahu nebo spam</li></ul>",
  "REQUEST_LIMIT_TEXT":"Limit požadavků dosažen. Zkontrolujte ostatní trendy/štítky!",
  "POST_IS_UNBOOKMARK":"Příspěvek je odstraněn ze záložek!",
  "POST_IS_BOOKMARK":"Příspěvek je přidán do záložek!",
  "RESET":"Resetovat",
  "MODIFY_PICTURE":"Upravit profilový obrázek",
  "MODIFY_COVER_PICTURE":"Upravit titulní obrázek",
  "ACTIVE_KEY_REQUIRED_TEXT":"Zadejte Aktivní soukromý klíč, pokud jste vybrali pokročilý mód přístupu!",
  "RESET_PICTURE_TEXT":"Tímto resetujete profilový obrázek uživatele!",
  "RESET_COVER_PICTURE_TEXT":"Tímto resetujete titulní obrázek uživatele!",
  "UPDATE_REQUIRES_RESTART":"Aktualizace serveru vyžaduje restart!",
  "SETTINGS_UPDATED":"Nastavení jsou aktualizována.",
  "LANGUAGES":"Jazyky",
  "LANGUAGES_TEXT":"Zde můžete změnit jazyk aplikace.",
  "LOGIN_TO_X":"Tato operace vyžaduje přihlášení uživatele hlavním heslem, Aktivním/Odesílacím klíčem. Prosím přihlašte se a opakujte pokus.",
  "GALLERY":"Galerie",
  "TRANSLATIONS":"Přeložili",
  "SHARE":"Akcie",
  "MARKETPLACE":"Trh",
  "EXCHANGE":"Burza",
  "DRAFTS":"Koncepty",
  "POST_IS_UNDRAFT":"Příspěvek je z konceptů odstraněn !",
  "POST_IS_DRAFT":"Příspěvek je přidán do konceptů!",
  "SWIPE_LEFT":"Pro zobrazení možností přejeď vlevo",
  "MANAGE":"Spravovat",
  "IMAGE_REMOVED":"Obraz je odstraněn",
  "COPY":"Kopírovat",
  "NO_IMAGE":"Dosud jste nenahrál žádný obraz.",
  "PULL_DOWN_TO_REFRESH":"Pro obnovení zatáhni dolů",
  "EXTERNAL_APPS":"Externí aplikace",
  "PLUGINS":"Přídavné moduly",
  "SUGGEST":"Návrh",
  "COMING_SOON":"Již brzy chystáme",
  "CHAIN":"",
  "CHAIN_TEXT":"",
  "CURRENCY":"",
  "CURRENCY_TEXT":"",
  "ABOUT_11":"",
  "FOUNDER":"",
  "ADD_ACCOUNT":"",
  "PLATFORM":""
}
},{}],140:[function(require,module,exports){
module.exports={
  "HOME":"Startseite",
  "LOGIN":"Anmelden",
  "LOGOUT":"Abmelden",
  "PROFILE":"Profil",
  "FOLLOW":"Folgen",
  "BOOKMARKS":"Lesezeichen",
  "TRANSFER":"Übertragen",
  "MARKET":"Markt",
  "SETTINGS":"Einstellungen",
  "ABOUT":"Info",
  "ABOUT_1":"die Plattform, bei der jeder für seine Inhalte vergütet wird!",
  "ABOUT_2":"wird unterstützt durch die {{platformname}} Plattform. Anwendung erstellt von",
  "ABOUT_3":"und ist eine mobile Open Source Anwendung, die durch die Community unterstützt wird. Die Anwendung erlaubt den Zugriff auf die Inhalte für das Lesen, Kommentieren, Abstimmen, Posten, Übertragen von Einkünften etc. Die Funktionen werden durch die {{platformname}} Blockchain und {{sitename}} bereitgestellt.",
  "ABOUT_4":"1. Die Anwendung greift niemals auf Ihre Mittel zu.",
  "ABOUT_5":"2. Die Anwendung nutzt ein Client-basiertes Sicherheitskonzept, dass auf Schlüsseln basiert, die lokal vorhanden sind und niemals an einen Server übertragen werden.",
  "ABOUT_6":"3. Die Anwendung bietet ein simples, attraktives Interface.",
  "ABOUT_7":"4. Die Anwendung fragt niemals nach persönlichen Daten.",
  "ABOUT_8":"Good-Karma als Zeuge abstimmen",
  "ABOUT_9":"Kontakt/Feedback:",
  "ABOUT_10":"Weitere Informationen:",
  "REMOVE":"Entfernen",
  "MARKET_VIEW":"Marktansicht",
  "PRICE":"Preis",
  "AMOUNT":"Menge",
  "TOTAL":"Gesamt",
  "NOORDERS":"Keine offenen Order",
  "DATE":"Datum",
  "BUY":"Kaufen",
  "SELL":"Verkaufen",
  "OPEN":"Offen",
  "HISTORY":"Historie",
  "FOLLOW_BACK":"Ebenfalls folgen",
  "FOLLOWED":"Sie folgen nun diesem Nutzer",
  "UNFOLLOW":"Nicht mehr folgen",
  "FOLLOWING":"Sie folgen diesem Nutzer",
  "FOLLOWERS":"Personen, die Ihnen folgen",
  "SEARCH_FOLLOWERS":"Durchsuchen der Nutzer, die Ihnen folgen",
  "SEARCH_FOLLOWING":"Durchsuchen der Nutzer, denen Sie folgen",
  "BY":"von",
  "IN":"in",
  "MENU":"Menü",
  "BOOKMARK":"Lesezeichen",
  "REBLOG":"Reblog",
  "UPVOTE":"Upvote",
  "DOWNVOTE":"Downvote",
  "UNVOTE_DOWNVOTED":"Downvote entfernen",
  "UNVOTE_UPVOTED":"Upvote entfernen",
  "REPLY":"Antworten",
  "EDIT":"Editieren",
  "POST_1":"Nach links wischen um Kommentare zu sehen",
  "POST_2":"Auf Kommentare tippen um dessen Antworten zu sehen",
  "OPTIONS":"Optionen",
  "RESTEEMED_BY":"Resteemed von",
  "NOTHING_HERE":"Hier gibt es noch nichts zu sehen...",
  "BALANCES":"Kontostand",
  "PROFILE_1":"{{platformname}}, handelbare Tokens die zu jeder Zeit übertragen werden können. {{platformname}} kann in {{platformpower}} konvertiert werden. Dieser Prozess heißt \"powering up\".",
  "PROFILE_2":"{{platformpower}}, tokens die sich automatisch vermehren, wenn Sie besessen werden und beeinflussen, wie viel Ihre Stimme wert ist. Desto mehr Sie besitzen, desto mehr Einfluss hat Ihre Stimme.",
  "PROFILE_3":"Tokens mit einem Wert von etwa {{platformsunit}} in {{platformname}}.",
  "ESTIMATED_VALUE":"Geschätzter Wert",
  "PROFILE_4":"Der geschätzte Wert basiert auf einem 7-Tage-Durchschnittswert von {{platformname}}.",
  "TRANSACTION_HISTORY":"Transaktions Historie",
  "POSTING":"Beitrag",
  "PROFILE_5":"Der \"posting key\" wird für das Veröffentlichen und Abstimmen benötigt. Er sollte sich vom \"active key\" und vom \"owner key\" unterscheiden.",
  "OWNER":"Besitzer",
  "PROFILE_6":"Der \"owner key\" ist der Hauptschlüssel für den Account und wird benötigt, um andere Schlüssel zu ändern. Der \"private key\" oder das Passwort sollten nur offline verfügbar sein.",
  "ACTIVE":"Aktiv",
  "PROFILE_7":"Der \"active key\" wird benutzt, um Übertragungen durchzuführen oder Gebote auf dem Markt zu platzieren.",
  "MEMO":"Notiz",
  "PROFILE_8":"Der \"memo key\" wird benötigt, um Memos zu lesen und zu speichern.",
  "BLOG":"Blog",
  "POSTS":"Beiträge",
  "REPLIES":"Antworten",
  "WALLET":"Brieftasche",
  "TAG":"Tag",
  "USER":"Benutzer",
  "CLOSE":"Schließen",
  "TO":"Empfänger",
  "ASSET":"Zusatz",
  "SEND":"Senden",
  "SECURITY":"Sicherheit",
  "AVAILABLE":"Verfügbar",
  "PUBLIC_MEMO":"Öffentliche Notiz",
  "TO_DESC":"Benutzer z.B. good-karma",
  "PIN_CODE":"Pin",
  "PIN_TEXT":"Der PIN dient der Sicherheit der Anwendung, sowie deren Daten. <br/><br/><b>Hinweis:</b> Nach Aktivierung stehen maximal 4 Anmeldeversuche zur Verfügung. Danach werden die Daten des aktuell angemeldeten Nutzers gelöscht und die Anwendung kann wieder normal genutzt werden.",
  "NOTIFICATIONS":"Benachrichtigungen",
  "VOTE_TEXT":"Sie werden informiert, sobald jemand für Ihre Beiträge abgestimmt hat! <br/> <b>Hinweis:</b> Die Notifikation gibt aufschluss über die Art der Abstimmung (Positiv, Negativ, wieder entfernt) und die Gewichtung der Stimme.",
  "VOTE":"Abstimmen",
  "COMMENT_TEXT":"Sie werden informiert, sobald jemand auf Ihre Beiträge oder Kommentare antwortet!<br/> <b>Hinweis:</b> Sie werden auch beim Ändern eines Beitrags/Kommentars erneut informiert.",
  "COMMENT":"Kommentar",
  "FOLLOW_TEXT":"Sie werden benachrichtigt, sobald Ihnen jemand folgt oder nicht mehr folgt!",
  "MENTIONS":"Erwähnungen",
  "MENTIONS_TEXT":"Sie werden benachrichtigt, sobald Sie von jemanden in Kommentaren oder Beitragen erwähnt werden!",
  "RESTEEM":"Rested",
  "RESTEEM_TEXT":"Sie werden benachrichtigt sobald jemand Ihren Post erneut veröffentlicht hat!",
  "CONFIGURATIONS":"Einstellungen",
  "VOTING":"Abstimmung",
  "VOTING_TEXT":"Das Gewicht / der prozentuale Anteil der Stimme beeinflusst die Menge der Vergütung für den Autor. <br/><br/><b>Hinweis:</b> Diese Einstellung ändert auch die Gewichtung/ den prozentualen Anteil für negative Stimmen. Diese Einstellung wird in der gesamten Anwendung verwendet.",
  "SERVER":"Server",
  "SERVER_TEXT":"Empfohlen",
  "SAVE_CHANGES":"Änderungen speichern",
  "VOTERS_INFO":"Abstimmungsinformationen",
  "WELCOME_BACK":"Willkommen zurück!",
  "LOGIN_1":"Melden Sie sich mit Ihrem Benutzernamen und Passwort an, um fortzufahren.",
  "LOGIN_2":"Der \"Posting key\" wird für das Veröffentlichen von Beitragen, Kommentaren und Abstimmungen, sowie dem Folgen von Nutzern benötigt.",
  "LOGIN_3":"Der \"Active key\" wird für die Übertragung und das aktualisieren des Profilbilds benötigt.",
  "LOGIN_4":"Zugangsdaten werden local im Gerät gespeichert und nach dem Logout gelöscht!",
  "DONT_HAVE":"Noch keinen Account?",
  "SIGN_UP_NOW":"Jetzt registrieren",
  "CANCEL":"Abbrechen",
  "ADVANCED":"Erweitert",
  "ACTIVE_PRIKEY":"Aktiver privater Zugangsschlüssel",
  "POSTING_PRIKEY":"Privater Zugangsschlüssel für das Veröffentlichen von Inhalten",
  "MASTER_PASS":"Master- /Haupt-Passwort",
  "USERNAME":"Benutzername",
  "CARD_VIEW":"Karten-Ansicht",
  "COMPACT_VIEW":"Kompaktansicht",
  "SEARCH":"Suchen",
  "SUBMIT_A_STORY":"Beitrag erstellen",
  "REPLYTO":"Antworten",
  "POST":"Veröffentlichen",
  "PREVIEW":"Vorschau",
  "DEFAULT":"Standard 50% / 50%",
  "POWERUP":"Power erhöhen mit 100%",
  "DECLINE_PAYOUT":"Auf die Auszahlung verzichten",
  "SAVE_FOR_LATER":"Für einen späteren Zeitpunkt speichern",
  "CLEAR":"LÖSCHEN",
  "POST_CONTENT":"Inhalt veröffentlichen",
  "COMMENT_CONTENT":"Inhalt kommentieren",
  "TITLE":"Titel",
  "TAGS":"Tags",
  "NOT_MATCH":"KEINE ÜBEREINSTIMMUNG",
  "CONFIRM_PIN":"PIN bestätigen",
  "INCORRECT":"FALSCH",
  "OPENING_POST":"öffne Beitrag",
  "SET_PIN":"Setzen Sie Ihren PIN",
  "ENTER_PIN":"Bitte geben Sie Ihren PIN ein",
  "ARE_YOU_SURE":"Sind Sie sicher?",
  "REBLOG_TEXT":"Das neu veröffentlichen kann nicht rückgängig gemacht werden, wollen Sie weiter machen?",
  "BROADCAST_ERROR":"Fehler beim veröffentlichen, bitte versuchen Sie es erneut!",
  "SUCCESS":"Erfolgreich",
  "REBLOGGED_POST":"Neu veröffentlicht!",
  "LOGIN_FAIL":"Anmeldung fehlgeschlagen! Bitte stellen Sie sich sicher, dass Sie das Master-Passwort oder, für den erweiterten Anmelde-Modus, den bereitgestellten \"Active private key\" verwenden.",
  "LOGIN_FAIL_A":"Anmeldung fehlgeschlagen! Bitte stellen Sie sich sicher, dass Sie das Master-Passwort oder, für den erweiterten Anmelde-Modus, den bereitgestellten \"Active private key\" verwenden.",
  "WARNING":"Warnung",
  "VOTE_FOR_WITNESS":"Für einen Witness abstimmen",
  "VOTED_FOR_WITNESS":"Erfolgreich für einen Witness abgestimmt",
  "AGO":"seit",
  "FROM_NOW":"ab jetzt",
  "SECS":"Sekunden",
  "A_MIN":"eine Minute",
  "MINS":"Minuten",
  "AN_HOUR":"eine Stunde",
  "HOURS":"Stunden",
  "A_DAY":"einen Tag",
  "DAYS":"Tage",
  "A_MONTH":"einen Monat",
  "MONTHS":"Monate",
  "A_YEAR":"ein Jahr",
  "YEARS":"Jahre",
  "MIN_READ":"min. lesen",
  "DOWNVOTE_FLAG":"Negativ bewerten oder markieren",
  "CAPTURE_PICTURE":"Bild aufnehmen",
  "SELECT_PICTURE":"Bild auswählen",
  "SET_CUSTOM_URL":"Eigene URL",
  "INSERT_PICTURE":"Bild einfügen",
  "ERROR":"Fehler",
  "UPLOAD_ERROR":"Upload fehlgeschlagen",
  "CAMERA_CANCELLED":"Kamera geschlossen",
  "SET_URL":"URL setzen",
  "DIRECT_LINK_PICTURE":"Direkter Link zum Bild",
  "COMMENT_SUBMITTED":"Kommentar abgegeben!",
  "DELETE_COMMENT":"Gelöschte Kommentare können nicht widerhergestellt werden...",
  "DELETED_COMMENT":"Kommentar gelöscht",
  "UPLOADING_PICTURE":"Bild wird hochgeladen",
  "UPLOAD_COMPLETED":"Hochladen abgeschlossen",
  "UPLOAD_FAILED":"Hochladen fehlgeschlagen",
  "PASSWORD_INCORRECT":"Passwort oder Benutzername nicht korrekt",
  "INFO":"Information",
  "QR_TEXT":"Platzieren Sie einen QR code innerhalb des Bereichs",
  "BALANCE_TEXT":"Stellen Sie sicher, dass Sie über ausreichende Mittel verfügen!",
  "NONEXIST_USER":"Sie verfügen nicht über ausreichende Mittel für diese Aktion!",
  "TRANSFER_TEXT":"Wollen Sie wirklich übertragen?",
  "CONFIRMATION":"Bestätigungen",
  "TX_BROADCASTED":"Die Transaktion wurde übertragen",
  "FEED":"Feed",
  "TRENDING":"Im Trend",
  "HOT":"Beliebt",
  "NEW":"Neu",
  "PROMOTED":"Beworben",
  "VOTES":"Stimmen",
  "PAYOUT":"Auszahlung",
  "COMMENTS":"Kommentare",
  "TRENDING_30":"Seit 30 Tagen im Trend",
  "SORT_POST_BY":"Sortieren der Posts nach:",
  "PAYOUT_CYCLE":"Auszahlungskreislauf",
  "POTENTIAL_PAYOUT":"Voraussichtliche Auszahlungen",
  "PAST_PAYOUT":"Vergangene Auszahlungen",
  "AUTHOR_PAYOUT":"Auszahlung an den Autor",
  "CURATION_PAYOUT":"Kurationsauszahlungen",
  "POST_SUBMITTED":"Post wurde veröffentlicht!",
  "POST_LATER":"Posts zur späteren Veröffentlichung!",
  "SAVED":"Gespeichert",
  "CLEARED":"Geleert",
  "FLAGGING_TEXT":"Das markieren eines Posts kann zum Verlust der Vergütung führen und verringert die Sichtbarkeit des Posts.<br><br>Sie sollten Posts nur unter markieren, wenn einer der folgenden Punkte zutrifft: <ul><li>Betrug oder Plagiat</li><li>Vulgäre Ausdrucke oder \"Trolling\"</li><li>Mutwillig falsch kategorisiert oder Spam</li></ul>",
  "REQUEST_LIMIT_TEXT":"Maximale Anzahl von Anfragen erreicht. Bitte schauen Sie sich andere trend/tags an!",
  "POST_IS_UNBOOKMARK":"Post von den Lesezeichen entfernt!",
  "POST_IS_BOOKMARK":"Post zu den Lesezeichen hinzugefügt!",
  "RESET":"Zurücksetzen",
  "MODIFY_PICTURE":"Profilbild ändern",
  "MODIFY_COVER_PICTURE":"Titelbild ändern",
  "ACTIVE_KEY_REQUIRED_TEXT":"Bitte tragen Sie den \"Active private key\" ein, wenn Sie den erweiterten Login Modus gewählt haben!",
  "RESET_PICTURE_TEXT":"Zurücksetzen des Profilbilds",
  "RESET_COVER_PICTURE_TEXT":"Zurücksetzen des Titelbilds.",
  "UPDATE_REQUIRES_RESTART":"Aufgrund eines Serverupdates muss ein die Anwendung neugestartet werden!",
  "SETTINGS_UPDATED":"Einstellungen aktualisiert!",
  "LANGUAGES":"Sprachen",
  "LANGUAGES_TEXT":"Hier kann die Sprache der Anwendung geändert werden.",
  "LOGIN_TO_X":"Für die gewünschte Operation müssen Sie angemeldet sein. Bitte melden Sie sich mit Ihrem Passwort oder dem \"active/posting\"-Schlüssel sein",
  "GALLERY":"Gallerie",
  "TRANSLATIONS":"Mitwirkende an der Übersetzung",
  "SHARE":"Teilen",
  "MARKETPLACE":"Marktplatz",
  "EXCHANGE":"Börse",
  "DRAFTS":"Entwürfe",
  "POST_IS_UNDRAFT":"Beitrag aus Entwürfen entfernt!",
  "POST_IS_DRAFT":"Beitrag zu Entwürfen hinzugefügt!",
  "SWIPE_LEFT":"Links wischen für Optionen",
  "MANAGE":"Verwalten",
  "IMAGE_REMOVED":"Bild entfernt",
  "COPY":"Kopieren",
  "NO_IMAGE":"Sie haben noch kein Foto hochgeladen!",
  "PULL_DOWN_TO_REFRESH":"Nach unten ziehen zum aktualisieren",
  "EXTERNAL_APPS":"Externe Apps",
  "PLUGINS":"Plug-Ins",
  "SUGGEST":"Vorschlagen",
  "COMING_SOON":"Kommt bald",
  "CHAIN":"Chain",
  "CHAIN_TEXT":"Hier kannst du die Blockchain oder die Standardplattform wechseln.",
  "CURRENCY":"Währung",
  "CURRENCY_TEXT":"Hier können Sie Ihre Standardwährung ändern. Sie sehen all Ihre Verdienste für Beiträge / Kommentare in dieser Standardwährung.",
  "ABOUT_11":"<br><b>Feature Liste</b><br>- Zugang erhalten zu einzigartigen Artikeln all der Themengebiete, die Sie gerne lesen möchten.<br>- Interagieren Sie mit den Autoren, in dem Sie die Beiträge kommentieren und mit anderen diskutieren.<br>- Stimmen Sie für Artikel um Autoren zu belohnen und selbst Curation Rewards zu verdienen.<br>- Veröffentlichen Sie Ihre Artikel, Blog Posts, die kostenlos gehosted werden und erhalten Sie Entgelt für Interagieren und gewinnen Sie zusätzlich Anhänger für Ihre Inhalte.<br>- Schreiben Sie Artikel von unterwegs. Speichern Sie eine Vielzahl von Entwürfen um diese später zu veröffentlichen.<br>- Bookmarken Sie Ihre Lieblingsartikel, um diese später zu lesen.<br>- Einnahmen tauschen oder auszahlen.<br>- Überweisen Sie Guthaben an Autoren, Nutzer, Freunde, Anhänger, etc.<br>- Folgen Sie interessanten Autoren, Bloggern.<br>- Durchsuchen Sie Inhalte Ihrer Follower und Autoren.<br>- Erhalten Sie Benachrichtigungen von Ihren Follower und Diskussionen, an denen Sie teilgenommen haben.<br>- Suchen Sie interessante Tags / Kategorien aller Artikel und Autoren.<br>- Personalisieren Sie Ihre Profil.<br>- Viele neue Features werden demnächst vorgestellt.<br><br><b>Sicherheit</b><br>1. App hat keinen Zugriff auf Ihre Einnahmen.<br>2. App bieten einfließt-side Sicherheits-Modell mit privaten Schlüsseln, die lokal gehostet und niemals an andere Server geschickt werden. Sie sind lediglich dafür verantwortlich Ihre Passwort zu sichern.<br>3. Die App bietet simples Nutzer Interface und attraktive User Erfahrungen<br>4. Die App beinhaltet eine zusätzliche Sicherheitsebene durch einen Pin-Code<br><br>eSteem unterstütz die Plattformen Steem sowie Golos.<br>",
  "FOUNDER":"Gründer und leitender Entwickler",
  "ADD_ACCOUNT":"Account hinzufügen",
  "PLATFORM":"Plattform"
}
},{}],141:[function(require,module,exports){
module.exports={
  "HOME":"hom",
  "LOGIN":"lgin",
  "LOGOUT":"lgootu",
  "PROFILE":"porfli",
  "FOLLOW":"fluw",
  "BOOKMARKS":"bkumakrz",
  "TRANSFER":"tarnsefr",
  "MARKET":"mrakte",
  "SETTINGS":"stetignz",
  "ABOUT":"abut",
  "ABOUT_1":"wer anyon cna eran rwardz fer thir cntnt!",
  "ABOUT_2":"iz pwered bi {{platformname}} paltfrom. app iz crated bi",
  "ABOUT_3":"and it iz opn-src, cmounti dirvne mbil prjct. it offezr cntnt accezs fer rdng, coemntng, vtoign, pstng, tarnsefr eranignz, etc. ftrz offered bi {{platformname}} blckchin and {{sitename}}.",
  "ABOUT_4":"1. app nver accezs or hlod otno uesr fndz.",
  "ABOUT_5":"2. app offezr a clnt-sid sceurti mdel, wtih pirvta kyez hsotde lcoail and nver snet tu ani srvrz.",
  "ABOUT_6":"3. app offezr smpl, atrtaciv uesr inetrfcz and exprncz.",
  "ABOUT_7":"4. app nver rqeuri usrz tu inpt ani presoanl infrmatn.",
  "ABOUT_8":"vot good-karma az witnsez",
  "ABOUT_9":"kontakt/fedbak:",
  "ABOUT_10":"mur inf:",
  "REMOVE":"rmov",
  "MARKET_VIEW":"mrakte veiw",
  "PRICE":"pirc",
  "AMOUNT":"aomutn",
  "TOTAL":"ttal",
  "NOORDERS":"no oepn odrezr fer",
  "DATE":"dat",
  "BUY":"bui",
  "SELL":"sel",
  "OPEN":"oepn",
  "HISTORY":"hstr",
  "FOLLOW_BACK":"fluw bak",
  "FOLLOWED":"flowed",
  "UNFOLLOW":"unfolow",
  "FOLLOWING":"floownig",
  "FOLLOWERS":"floowrez",
  "SEARCH_FOLLOWERS":"saerhc floowrez",
  "SEARCH_FOLLOWING":"saerhc floownig",
  "BY":"bi",
  "IN":"",
  "MENU":"mneu",
  "BOOKMARK":"bkmrk",
  "REBLOG":"rbelgo",
  "UPVOTE":"upvt",
  "DOWNVOTE":"dwnvot",
  "UNVOTE_DOWNVOTED":"unvt donwvoed",
  "UNVOTE_UPVOTED":"unvt upvoed",
  "REPLY":"rpli",
  "EDIT":"eidt",
  "POST_1":"siwp lfet on cmentz tu c optinz",
  "POST_2":"tap on cmentz tu c sub-cmntz",
  "OPTIONS":"optinz",
  "RESTEEMED_BY":"rseteemd bi",
  "NOTHING_HERE":"nthng hir, yet...",
  "BALANCES":"blancz",
  "PROFILE_1":"{{platformname}}, traedbal $$ dat cn b trnsfred anytiem. {{platformname}} cn b covnered 2 {{platformpower}} in a prcsz cled pwoernig up.",
  "PROFILE_2":"{{platformpower}}, ifnlunec $$ dat ern mur pwer fer hldng lnog tiem and votign on postz. teh mur u holdz teh mur u cna ifnlunec otherz rwardz and ern rwardz fer accurat votign.",
  "PROFILE_3":"$$ wrth abut {{platformsunit}} of {{platformname}}.",
  "ESTIMATED_VALUE":"esitmaed vlau",
  "PROFILE_4":"teh esitmaed vlau iz bsed on a 7 dai aevrga vlau of {{platformname}}.",
  "TRANSACTION_HISTORY":"transactn hstr",
  "POSTING":"pstng",
  "PROFILE_5":"teh pstng kei iz uesd fer pstng and vtoign. it sohudl b differnt frum teh actv and ownr kyez.",
  "OWNER":"ownr",
  "PROFILE_6":"teh ownr kei iz teh msatre kei fer teh accont and iz rqeuierd tu chng teh othr kyez. teh pirvta kei or psaswrod fer teh ownr kei sohudl b kpet offlni az mcuh az pssbl.",
  "ACTIVE":"actv",
  "PROFILE_7":"teh actv kei iz uesd tu maek trnasfrz and palc odrezr in teh itneranl mrakte.",
  "MEMO":"mmeo",
  "PROFILE_8":"teh mmeo kei iz uesd tu crat and raed mmoz.",
  "BLOG":"bolg",
  "POSTS":"pstz",
  "REPLIES":"rplies",
  "WALLET":"wlet",
  "TAG":"tagg",
  "USER":"uesr",
  "CLOSE":"cols",
  "TO":"to",
  "ASSET":"asst",
  "SEND":"snd",
  "SECURITY":"sceurti",
  "AVAILABLE":"aavilbal",
  "PUBLIC_MEMO":"pbulci mmeo",
  "TO_DESC":"uesr e.g. good-karma",
  "PIN_CODE":"pin cod",
  "PIN_TEXT":"pin cod hlpz yu tu scur app and ur dtaa. <br/><br/><b>note:</b> onc enbled, yu hev max 4 tirz tu unlk, if yu frgt pin or fial, app wil rmov lgogde in uesr dtaa. yu cna r-eloign and cntn usng app.",
  "NOTIFICATIONS":"notifikationz",
  "VOTE_TEXT":"yu wil get notfikatin wehn smoeno vtoz ur cntnt! <br/> <b>nt:</b> notifikationz icnldu vtoign wiegth az wel in alrt messig. (b it upvt, dwnvot, unvt).",
  "VOTE":"vot",
  "COMMENT_TEXT":"yu wil get notfikatin wehn smoeno cmentz on ur pstz or koments!<br/> <b>nt:</b> notifikationz icnldu wehn smoeno <b>dts</b> thir cmentz az wel.",
  "COMMENT":"cmoetn",
  "FOLLOW_TEXT":"yu wil get notfikatin wehn smoeno fluw or unfolow yu!",
  "MENTIONS":"mnetinoz",
  "MENTIONS_TEXT":"yu wil get notfikatin wehn smoeno mnetinoz yu in thir pst/cmnt!",
  "RESTEEM":"resteme",
  "RESTEEM_TEXT":"yu wil get notfikatin wehn smoeno rstmz ur psot!",
  "CONFIGURATIONS":"konfguratonz",
  "VOTING":"vtoign",
  "VOTING_TEXT":"vot wiegth or pecrenag affectz vtoign pwer on app, so yu cna rgulat ur vtoign rweadr. <br/><br/><b>note:</b> diz wil chng vtoign weight/percentag fer dwnvting az wel and it iz evreywer on app",
  "SERVER":"srevre",
  "SERVER_TEXT":"rcmnded",
  "SAVE_CHANGES":"sav cahnzg",
  "VOTERS_INFO":"vtoezr ifno",
  "WELCOME_BACK":"wlcum bak!",
  "LOGIN_1":"sgin in wtih ur usrnam and psaswrod tu cntn.",
  "LOGIN_2":"pstng kei iz uesd fer psot, cmoetn, vot, fluw.",
  "LOGIN_3":"actv kei iz uesd fer trnasfrz and porfli pcitru updt.",
  "LOGIN_4":"uesr crdntalz ar kpet lcoail on teh dvic. uopn lgootu crdntalz ar rmoved!",
  "DONT_HAVE":"dnt hev an accont?",
  "SIGN_UP_NOW":"sgin up now",
  "CANCEL":"cnacle",
  "ADVANCED":"avdanecd",
  "ACTIVE_PRIKEY":"actv pirvta kei",
  "POSTING_PRIKEY":"pstng pirvta kei",
  "MASTER_PASS":"mastr/man psaswrod",
  "USERNAME":"usrnam",
  "CARD_VIEW":"crad veiw",
  "COMPACT_VIEW":"cmpct veiw",
  "SEARCH":"saerhc",
  "SUBMIT_A_STORY":"sbumti a stri",
  "REPLYTO":"rpli tu",
  "POST":"psot",
  "PREVIEW":"prvew",
  "DEFAULT":"dfalt 50% / 50%",
  "POWERUP":"pwer up 100%",
  "DECLINE_PAYOUT":"dcelni pyaotu",
  "SAVE_FOR_LATER":"sav fer lter",
  "CLEAR":"",
  "POST_CONTENT":"psot cntnt",
  "COMMENT_CONTENT":"cmoetn cntnt",
  "TITLE":"ttil",
  "TAGS":"tegz",
  "NOT_MATCH":"not mtch",
  "CONFIRM_PIN":"cnfrm pin",
  "INCORRECT":"",
  "OPENING_POST":"opnng psot",
  "SET_PIN":"set pin",
  "ENTER_PIN":"entr pin",
  "ARE_YOU_SURE":"ar yu sur?",
  "REBLOG_TEXT":"rsetme iz irvrsbl, du yu wanan tu cntn?",
  "BROADCAST_ERROR":"braodcst eorr, tri agn!",
  "SUCCESS":"sccsz",
  "REBLOGGED_POST":"relboged psot!",
  "LOGIN_FAIL":"lgin fialde! plz maek sur yu hev lgogde in wtih msatre psaswrod or porviedd pstng pirvta kei on lgin if yu hev cuhsde avdanecd mod.",
  "LOGIN_FAIL_A":"lgin fialde! plz maek sur yu hev lgogde in wtih msatre psaswrod or porviedd actv pirvta kei on lgin if yu hev cohsne avdanecd mod.",
  "WARNING":"wrnng",
  "VOTE_FOR_WITNESS":"vtoign fer wtnsz",
  "VOTED_FOR_WITNESS":"vted fer wtnsz",
  "AGO":"",
  "FROM_NOW":"frum now",
  "SECS":"secz",
  "A_MIN":"",
  "MINS":"minz",
  "AN_HOUR":"an hrz",
  "HOURS":"hrz",
  "A_DAY":"a dai",
  "DAYS":"dyaz",
  "A_MONTH":"a mnth",
  "MONTHS":"mnotzh",
  "A_YEAR":"a yaer",
  "YEARS":"yarz",
  "MIN_READ":"min raed",
  "DOWNVOTE_FLAG":"dwnvot or falg",
  "CAPTURE_PICTURE":"cpatru pcitur",
  "SELECT_PICTURE":"silect pcitur",
  "SET_CUSTOM_URL":"set csutmo url",
  "INSERT_PICTURE":"isnetr pcitru",
  "ERROR":"eorr",
  "UPLOAD_ERROR":"ulpoda eorr",
  "CAMERA_CANCELLED":"cmaear cnaceeld",
  "SET_URL":"set url",
  "DIRECT_LINK_PICTURE":"drietc web lnik fer teh pcitru",
  "COMMENT_SUBMITTED":"cmoetn iz sumbited!",
  "DELETE_COMMENT":"dleetnig cmentz ar irvrsbl...",
  "DELETED_COMMENT":"dleted cmoetn",
  "UPLOADING_PICTURE":"upoladng pcitru",
  "UPLOAD_COMPLETED":"ulpoda copmleed",
  "UPLOAD_FAILED":"ulpoda fialde",
  "PASSWORD_INCORRECT":"teh psaswrod or accont nam waz icnorcet",
  "INFO":"ifno",
  "QR_TEXT":"palc a qr cod insd teh sacn aera",
  "BALANCE_TEXT":"maek sur yu hev eonuhg $$ fer transactn!",
  "NONEXIST_USER":"uesr yu ar tyrign tu tarnsefr $$, dsn't exst!",
  "TRANSFER_TEXT":"ar yu sur yu wanan tu tarnsefr?",
  "CONFIRMATION":"konfrmatin",
  "TX_BROADCASTED":"transactn iz bradcastd",
  "FEED":"fed",
  "TRENDING":"terndnig",
  "HOT":"hot",
  "NEW":"new",
  "PROMOTED":"pormoetd",
  "VOTES":"vtoz",
  "PAYOUT":"pyaotu",
  "COMMENTS":"cmentz",
  "TRENDING_30":"terndnig fer 30 dyaz",
  "SORT_POST_BY":"srot pstz by:",
  "PAYOUT_CYCLE":"pyaotu ccyl",
  "POTENTIAL_PAYOUT":"poetntal pyaotu",
  "PAST_PAYOUT":"psat pyaotu",
  "AUTHOR_PAYOUT":"atuhro pyaotu",
  "CURATION_PAYOUT":"cruatoin pyaotu",
  "POST_SUBMITTED":"psot iz sumbited!",
  "POST_LATER":"psot fer lter sbmsson!",
  "SAVED":"sved",
  "CLEARED":"clared",
  "FLAGGING_TEXT":"falggnig a psot cna rmov rwardz and maek diz mtaerail lsez visible.<br><br>th falg sohudl b uesd fer teh foolwig: <ul><li>fraut or plagiarism</li><li>hat spch or itnerent troling</li><li>intentional mskategorzed cntnt or spam</l></ul>",
  "REQUEST_LIMIT_TEXT":"rqust lmit rched. cehk out othr trnd/tegz!",
  "POST_IS_UNBOOKMARK":"psot iz rmoved frum bkumakrz!",
  "POST_IS_BOOKMARK":"psot iz addd tu bkumakrz!",
  "RESET":"rset",
  "MODIFY_PICTURE":"chng porfli pcitru",
  "MODIFY_COVER_PICTURE":"chng cver pcitru",
  "ACTIVE_KEY_REQUIRED_TEXT":"plz porvdi actv pirvta kei if yu hev cohsne avdanecd lgin mod!",
  "RESET_PICTURE_TEXT":"diz wil rset uesr porfli pcitru",
  "RESET_COVER_PICTURE_TEXT":"diz wil rset uesr cver pcitru",
  "UPDATE_REQUIRES_RESTART":"srevre updt rqurz rstrt!",
  "SETTINGS_UPDATED":"stetignz ar updated!",
  "LANGUAGES":"lnagugaz",
  "LANGUAGES_TEXT":"hir yu cna chng lngag of teh app.",
  "LOGIN_TO_X":"diz opreaton rqurz uesr tu b lgogde in wtih mian psaswrod, aktve/postng kei. plz lgin and tri agn.",
  "GALLERY":"glaeir",
  "TRANSLATIONS":"translatn kontrbutrz",
  "SHARE":"shre",
  "MARKETPLACE":"mrakte palc",
  "EXCHANGE":"exchng",
  "DRAFTS":"darfzt",
  "POST_IS_UNDRAFT":"psot iz rmoved frum darfzt!",
  "POST_IS_DRAFT":"psot iz addd tu darfzt!",
  "SWIPE_LEFT":"siwp lfet tu c optinz",
  "MANAGE":"mnag",
  "IMAGE_REMOVED":"iamg iz rmoved",
  "COPY":"cpoi",
  "NO_IMAGE":"yu hev not ulpoaedd ani iamg, yet!",
  "PULL_DOWN_TO_REFRESH":"pul dwon tu rfrsh",
  "EXTERNAL_APPS":"etxeranl appz",
  "PLUGINS":"plgnz",
  "SUGGEST":"sggst",
  "COMING_SOON":"cmoign sun",
  "CHAIN":"chin",
  "CHAIN_TEXT":"hir yu cna chng blckchin or dfalt paltfrom.",
  "CURRENCY":"",
  "CURRENCY_TEXT":"",
  "ABOUT_11":"",
  "FOUNDER":""
}
},{}],142:[function(require,module,exports){
module.exports={
  "HOME":"Αρχική",
  "LOGIN":"Είσοδος",
  "LOGOUT":"Αποσύνδεση",
  "PROFILE":"Προφίλ",
  "FOLLOW":"Ακολούθησε",
  "BOOKMARKS":"Σελιδοδείκτες",
  "TRANSFER":"Μεταφορά",
  "MARKET":"Ανταλακτήριο",
  "SETTINGS":"Ρυθμίσεις",
  "ABOUT":"Σχετικά",
  "ABOUT_1":"όπου ο καθένας μπορεί να κερδίσει απολαβές από το περιεχόμενό του!",
  "ABOUT_2":"είναι βασισμένο στην πλατφόρμα {{platformname}}. Δημιουργία εφαρμογής από",
  "ABOUT_3":"και είναι ανοιχτός κώδικας, κατευθυνόμενος από την κοινότητα.Προσφέρει, πρόσβαση σε περιεχόμενο για ανάγνωση, σχολιασμό, ψήφιση, ανάρτηση, μεταφορά απολαβών, κτλ. δυνατότητες τις οποίες προσφέρει το {{platformname}} blockchain και το {{sitename}}.",
  "ABOUT_4":"1. Η εφαρμογή δεν έχει ποτέ πρόσβαση ούτε κρατάει τα κεφάλαια των χρηστών.",
  "ABOUT_5":"2. Η εφαρμογή προσφέρει ένα μοντέλο ασφαλείας από την πλευρά του τερματικού του χρήστη, με τα ιδιωτικά κλειδιά να \"φιλοξενούνται\" τοπικά χωρίς ποτέ να αποστέλλονται σε οποιοδήποτε διακομιστή.",
  "ABOUT_6":"3. Η εφαρμογή προσφέρει απλό και ελκυστικό περιβάλλον χρήσης και εμπειρίας.",
  "ABOUT_7":"4, Η εφαρμογή δεν θα ζητήσει ποτέ προσωπικές πληροφορίες.",
  "ABOUT_8":"Ψήφισε good-karma για witness",
  "ABOUT_9":"Επικοινωνία/Παρατηρήσεις",
  "ABOUT_10":"Περισσότερες πληροφορίες:",
  "REMOVE":"Απομάκρυνση",
  "MARKET_VIEW":"Εποπτεία Αγοράς",
  "PRICE":"Τιμή",
  "AMOUNT":"Ποσό",
  "TOTAL":"Σύνολο",
  "NOORDERS":"Δεν υπάρχουν ανοιχτές εντολές για",
  "DATE":"Ημερομηνία",
  "BUY":"Αγορά",
  "SELL":"Πώληση",
  "OPEN":"Άνοιγμα",
  "HISTORY":"Ιστορικό",
  "FOLLOW_BACK":"Ανασκόπηση",
  "FOLLOWED":"Ακολουθείς",
  "UNFOLLOW":"Μη ακολουθείς",
  "FOLLOWING":"Ακολουθείς",
  "FOLLOWERS":"Σε ακολουθούν",
  "SEARCH_FOLLOWERS":"Ψάξε ποιοι σε ακολουθούν",
  "SEARCH_FOLLOWING":"Ψάξε ποιους ακολουθείς",
  "BY":"από",
  "IN":"σε",
  "MENU":"Κατάλογος επιλογών",
  "BOOKMARK":"Σελιδοδείκτης",
  "REBLOG":"Αναδημοσίευση",
  "UPVOTE":"Θετική ψήφος",
  "DOWNVOTE":"Αρνητική ψήφος",
  "UNVOTE_DOWNVOTED":"Επανέφερε Αρνητικά-ψηφισμένο",
  "UNVOTE_UPVOTED":"Επανέφερε Θετικά-ψηφισμένο",
  "REPLY":"Απάντηση",
  "EDIT":"Επεξεργασία",
  "POST_1":"Σύρε αριστερά τα σχόλια για να δεις επιλογές",
  "POST_2":"Ακούμπα τα σχόλια για να δεις υπό-σχόλια",
  "OPTIONS":"Επιλογές",
  "RESTEEMED_BY":"Αναδημοσίευση από",
  "NOTHING_HERE":"Τίποτα εδώ, ακόμα...",
  "BALANCES":"Διαθέσιμα",
  "PROFILE_1":"{{platformname}}, διαπραγματεύσιμες μάρκες, που μπορούν να μεταφερθούν οποιαδήποτε στιγμή. {{platformname}} μπορούν να μετατραπούν σε {{platformpower}} μέσω μίας διαδικασίας που ονομάζεται powering up. ",
  "PROFILE_2":"{{platformpower}}, μάρκες επιρροής που μπορούν να αποκτήσουν περισσότερη δύναμη, κρατώντας τις μακροπρόθεσμα και ψηφίζοντας αναρτήσεις. Όσες περισσότερες έχει στην κατοχή του κάποιος, τόσο περισσότερο μπορεί να επηρεάσει τις αμοιβές άλλων άλλα και τις δικές του.",
  "PROFILE_3":"Μάρκες αξίας περίπου {{platformsunit}} του {{platformname}}.",
  "ESTIMATED_VALUE":"Αξία κατά εκτίμηση ",
  "PROFILE_4":"Η αξία κατά εκτίμηση είναι βασισμένη στον εβδομαδιαίο μέσο όρο του{{platformname}}.",
  "TRANSACTION_HISTORY":"Ιστορικό Συναλλαγών",
  "POSTING":"Ανάρτηση",
  "PROFILE_5":"Ο κωδικός δημοσίευσης χρησιμοποιείται για δημοσιεύσεις και την δυνατότητα απόδοσης ψήφου. Θα πρέπει να είναι διαφορετικός από τον \"ενεργό\" κωδικό και το κωδικό \"ιδιοκτησίας\".",
  "OWNER":"Ιδιοκτήτης",
  "PROFILE_6":"Το κλειδί ιδιοκτησίας είναι το κεντρικό κλειδί του λογαριασμού και απαιτείται για να αλλάξει όλα τα υπόλοιπα κλειδιά. Θα πρέπει να κρατάτε εκτός σύνδεσης το ιδιωτικό κλειδί ή κωδικό του κλειδιού ιδιοκτησίας όσο αυτό είναι δυνατόν.",
  "ACTIVE":"Ενεργό",
  "PROFILE_7":"Το ενεργό κλειδί χρησιμοποιείται για εμβάσματα και εντολές αγοραπωλησιών στο εσωτερικό ανταλλακτήριο.",
  "MEMO":"Κλειδι - Μηνυμάτων",
  "PROFILE_8":"Το Κλειδί Μηνυμάτων χρησιμοποιείται για δημιουργία και ανάγνωση μηνυμάτων.",
  "BLOG":"Ιστολόγιο",
  "POSTS":"Αναρτήσεις",
  "REPLIES":"Απαντήσεις",
  "WALLET":"Πορτοφόλι",
  "TAG":"Ετικέτα",
  "USER":"Χρήστης",
  "CLOSE":"Κλείσιμο",
  "TO":"Σε",
  "ASSET":"Κεφάλαιο",
  "SEND":"Αποστολή",
  "SECURITY":"Ασφάλεια",
  "AVAILABLE":"Διαθέσιμο",
  "PUBLIC_MEMO":"Δημόσιο μήνυμα",
  "TO_DESC":"Χρήστης π.χ good-karma",
  "PIN_CODE":"Κωδικός PIN",
  "PIN_TEXT":"Κωδικός PIN σε βοηθάει να ασφαλίσεις την εφαρμογή και τα δεδομένα σου. <br/><br/><b>Σημείωση:</b> Άπαξ και ενεργοποιηθεί, έχεις max 4 προσπάθειες για ξεκλείδωμα. Αν ξεχάσεις τον κωδικό PIN ή αποτύχεις, η εφαρμογή θα καταργήσει τα στοιχεία εισόδου του χρήστη.Μπορείς να ξανά συνδεθείς και να συνεχίσεις να χρησιμοποιείς την εφαρμογή.",
  "NOTIFICATIONS":"Ειδοποιήσεις",
  "VOTE_TEXT":"Θα λάβεις ειδοποίηση όταν κάποιος ψηφίσει την ανάρτηση σου. <br/> <b>Σημείωση:</b> Οι ειδοποιήσεις συμπεριλαμβάνουν την βαρύτητα της ψήφου καθώς επίσης σε έκτακτα μηνύματα. (θετική ψήφο, αρνητική ψήφο, από-ψήφιση).",
  "VOTE":"Ψήφων",
  "COMMENT_TEXT":"Θα λάβεις ειδοποίηση όταν κάποιος σχολιάσει αναρτήσεις η σχόλια σου!<br/> <b>Σημείωση:</b> Οι ειδοποιήσεις συμπεριλαμβάνονται ακόμα και όταν κάποιος <b>επεξεργαστεί</b> τα σχόλια του.",
  "COMMENT":"Σχολίων",
  "FOLLOW_TEXT":"Θα λάβεις ειδοποίηση όταν κάποιος σε ακολουθήσει ή πάψει να σε ακολουθεί.",
  "MENTIONS":"Επισημάνσεων",
  "MENTIONS_TEXT":"Θα λάβεις ειδοποίηση όταν κάποιος σε αναφέρει σε ανάρτηση/σχόλιό του.",
  "RESTEEM":"Αναδημοσιεύσεων",
  "RESTEEM_TEXT":"Θα λάβεις ειδοποίηση όταν κάποιος αναδημοσιεύσει ανάρτησή σου.",
  "CONFIGURATIONS":"Ρυθμίσεις",
  "VOTING":"Ψηφοφορία",
  "VOTING_TEXT":"\"Βάρος\" ψήφου ή ποσοστό επηρεάζει την ισχύς ψήφου στην εφαρμογή, ώστε να ρυθμίζεις τις απολαβές ψήφων <br/><br/><b>Σημείωση:</b> Αυτό θα αλλάξει το \"βάρος\"/ποσοστό ψήφου για να ψηφίσεις επίσης αρνητικά και θα ισχύει παντού στην εφαρμογή",
  "SERVER":"Διακομιστής",
  "SERVER_TEXT":"Προτεινόμενα",
  "SAVE_CHANGES":"Αποθήκευση Αλλαγών",
  "VOTERS_INFO":"Πληροφορίες ψηφοφόρου",
  "WELCOME_BACK":"Καλώς ήρθες ξανά!",
  "LOGIN_1":"Συνδέσου με το όνομα χρήστη και κωδικό για να συνεχίσεις.",
  "LOGIN_2":"Το κλειδί δημοσίευσης χρησιμοποιείται για ανάρτηση, σχολιασμό, ψήφο και την δυνατότητα να ακολουθήσεις κάποιον.",
  "LOGIN_3":"Το ενεργό κλειδί χρησιμοποιείται για μεταφορές και αλλαγή φωτογραφίας του προφίλ.",
  "LOGIN_4":"Τα στοιχεία χρήστη αποθηκεύονται στη συσκευή τοπικά. Κατά την διάρκεια αποσύνδεσης τα στοιχεία διαγράφονται.",
  "DONT_HAVE":"Δεν έχεις λογαριασμό?",
  "SIGN_UP_NOW":"Κάνε εγγραφή τώρα",
  "CANCEL":"Ακύρωση",
  "ADVANCED":"Για προχωρημένους",
  "ACTIVE_PRIKEY":"Ενεργό ιδιωτικό κλειδί",
  "POSTING_PRIKEY":"Ιδιωτικό κλειδί δημοσίευσης",
  "MASTER_PASS":"Κυρίως/Πρωτεύων κωδικός",
  "USERNAME":"Όνομα Χρηστη",
  "CARD_VIEW":"Προβολή σε Καρτέλες",
  "COMPACT_VIEW":"Συνεπτυγμένη Προβολή",
  "SEARCH":"Αναζήτηση",
  "SUBMIT_A_STORY":"Ξεκίνα ανάρτηση",
  "REPLYTO":"Απάντησε σε",
  "POST":"Ανάρτησε",
  "PREVIEW":"Προεπισκόπηση",
  "DEFAULT":"Προεπιλογή 50% / 50%",
  "POWERUP":"Αύξηση Ισχύος 100%",
  "DECLINE_PAYOUT":"Απόρριψη Απολαβών",
  "SAVE_FOR_LATER":"ΑΠΟΘΉΚΕΥΣΕ ΓΙΑ ΑΡΓΟΤΕΡΑ",
  "CLEAR":"ΚΑΘΑΡΙΣΜΑ",
  "POST_CONTENT":"Ανάρτηση περιεχομένου",
  "COMMENT_CONTENT":"Σχολίασε περιεχόμενο",
  "TITLE":"Τίτλος",
  "TAGS":"Ετικέτες",
  "NOT_MATCH":"ΔΕ ΣΥΜΠΊΠΤΕΙ",
  "CONFIRM_PIN":"Επιβεβαίωσε PIN",
  "INCORRECT":"ΛΑΝΘΑΣΜΕΝΟ",
  "OPENING_POST":"Άνοιξε Ανάρτηση",
  "SET_PIN":"Όρισε PIN",
  "ENTER_PIN":"Εισαγωγή PIN",
  "ARE_YOU_SURE":"Είσαι σίγουρος?",
  "REBLOG_TEXT":"Η αναδημοσίευση είναι μη αναστρέψιμη, θέλεις να συνεχίσεις?",
  "BROADCAST_ERROR":"Λάθος μετάδοσης, προσπάθησε ξανά!",
  "SUCCESS":"Επιτυχές",
  "REBLOGGED_POST":"Αναδημοσιευμένη ανάρτηση!",
  "LOGIN_FAIL":"Η σύνδεση απέτυχε! Παρακαλώ εξακριβώστε αν συνδεθήκατε με τον κυρίως κωδικό ή δώσατε το ιδιωτικό κλειδί δημοσίευσης όταν επιλέξατε σύνδεση για προχωρημένους.",
  "LOGIN_FAIL_A":"Η σύνδεση απέτυχε! Παρακαλώ εξακριβώστε αν συνδεθήκατε με τον κυρίως κωδικό ή δώσατε το ενεργό κλειδί δημοσίευσης όταν επιλέξατε σύνδεση για προχωρημένους.",
  "WARNING":"Προειδοποίηση",
  "VOTE_FOR_WITNESS":"Ψήφισε για witness",
  "VOTED_FOR_WITNESS":"Ψηφίστηκε για witness",
  "AGO":"πριν",
  "FROM_NOW":"από τώρα",
  "SECS":"δευτ.",
  "A_MIN":"το λεπτό",
  "MINS":"λεπτά",
  "AN_HOUR":"μία ώρα",
  "HOURS":"ώρες",
  "A_DAY":"μία ημέρα",
  "DAYS":"μέρες",
  "A_MONTH":"ένα μήνα",
  "MONTHS":"μήνες",
  "A_YEAR":"ένα χρόνο",
  "YEARS":"χρόνια",
  "MIN_READ":"λεπτά ανάγνωσης",
  "DOWNVOTE_FLAG":"Ψήφισε αρνητικά ή κάνε Flag",
  "CAPTURE_PICTURE":"Αποθανάτισε Φωτογραφία",
  "SELECT_PICTURE":"Επέλεξε Φωτογραφία",
  "SET_CUSTOM_URL":"Καθόρισε προσαρμοσμένο URL",
  "INSERT_PICTURE":"Εισήγαγε Φωτογραφία",
  "ERROR":"Λάθος",
  "UPLOAD_ERROR":"Λάθος αποστολής",
  "CAMERA_CANCELLED":"Κάμερα Ακυρώθηκε",
  "SET_URL":"Καθόρισε URL",
  "DIRECT_LINK_PICTURE":"Άμεσος σύνδεσμος για την φωτογραφία",
  "COMMENT_SUBMITTED":"Το σχόλιο υποβλήθηκε!",
  "DELETE_COMMENT":"Η διαγραφή σχολίων είναι μη αναστρέψιμη...",
  "DELETED_COMMENT":"Διαγραμμένο σχόλιο",
  "UPLOADING_PICTURE":"Αποστολή Φωτογραφίας",
  "UPLOAD_COMPLETED":"Αποστολή Ολοκληρώθηκε",
  "UPLOAD_FAILED":"Αποστολή Απέτυχε",
  "PASSWORD_INCORRECT":"Ο κωδικός ή το όνομα λογαριασμού ήταν λανθασμένο",
  "INFO":"Πληροφορίες",
  "QR_TEXT":"Τοποθέτησε ένα QR κωδικό στην τοποθεσία σάρωσης",
  "BALANCE_TEXT":"Εξακρίβωσε ότι έχεις διαθέσιμα κεφάλαια για συναλλαγή!",
  "NONEXIST_USER":"Ο χρήστης που προσπαθείς να μεταφέρεις κεφάλαια, δεν υπάρχει!",
  "TRANSFER_TEXT":"Είστε σίγουρος ότι θέλετε να κάνετε μεταφορά?",
  "CONFIRMATION":"Επιβεβαίωση",
  "TX_BROADCASTED":"Η συναλλαγή μεταδόθηκε",
  "FEED":"Αναρτήσεις από χρήστες που ακολουθείς",
  "TRENDING":"Δημοφιλέστερες αναρτήσεις",
  "HOT":"Αναρτήσεις με υψηλή δραστηριότητα",
  "NEW":"Πρόσφατες αναρτήσεις",
  "PROMOTED":"Προωθούμενα",
  "VOTES":"Βάση ψήφων",
  "PAYOUT":"Βάση αποδοχών",
  "COMMENTS":"Βάση σχολίων",
  "TRENDING_30":"Δημοφιλέστερες αναρτήσεις 30 ημερών",
  "SORT_POST_BY":"Ταξινόμηση βάση:",
  "PAYOUT_CYCLE":"Κύκλος πληρωμής",
  "POTENTIAL_PAYOUT":"Πιθανές Αποδοχές",
  "PAST_PAYOUT":"Παλαιότερες Αποδοχές",
  "AUTHOR_PAYOUT":"Αποδοχές Συγγραφέα",
  "CURATION_PAYOUT":"Αποδοχές από Curation",
  "POST_SUBMITTED":"Η ανάρτηση υποβλήθηκε!",
  "POST_LATER":"Ανάρτηση για μελλοντική κοινοποίηση!",
  "SAVED":"Αποθηκεύτηκε",
  "CLEARED":"Σβήστηκε",
  "FLAGGING_TEXT":"Καταψηφίζοντας μια ανάρτηση μπορεί να της αφαιρέσει αμοιβές και να την κάνει λιγότερο ορατή.<br><br> Η καταψήφιση θα έπρεπε να χρησιμοποιείται για: <ul><li>Απάτη ή κλοπή πνευματικών δικαιώματων</li><li>Υβριστική γλώσσα και Trolling</li><li>Εσκεμμένη τοποθέτηση σε λάθος κατηγορία περιεχομένου ή Spam</li></ul>",
  "REQUEST_LIMIT_TEXT":"Το αίτημα έφτασε στο όριο του. Ελέγξτε άλλες ετικέτες/κατηγορίες",
  "POST_IS_UNBOOKMARK":"Η ανάρτηση απομακρύνθηκε από τους σελιδοδείκτες!",
  "POST_IS_BOOKMARK":"Η ανάρτηση προστέθηκε στους σελιδοδείκτες!",
  "RESET":"Επαναφορά αρχικών ρυθμίσεων",
  "MODIFY_PICTURE":"Επεξεργασία Φωτογραφίας Προφίλ",
  "MODIFY_COVER_PICTURE":"Επεξεργασία φωτογραφίας προφίλ",
  "ACTIVE_KEY_REQUIRED_TEXT":"Παρακαλώ δώσε Ενεργό/Active ιδιωτικό κλειδί εάν επέλεξες σύνδεση για προχωρημένους!",
  "RESET_PICTURE_TEXT":"Αυτό θα κάνει επαναφορά της φωτογραφίας του προφίλ",
  "RESET_COVER_PICTURE_TEXT":"Αυτό θα επαναφέρει την εικόνα χρήστη",
  "UPDATE_REQUIRES_RESTART":"Η αναβάθμιση του διακομιστή απαιτεί επανεκκίνηση!",
  "SETTINGS_UPDATED":"Οι ρυθμίσεις ενεργοποιήθηκαν!",
  "LANGUAGES":"Γλώσσες",
  "LANGUAGES_TEXT":"Εδώ μπορείς να αλλάξεις την γλώσσα της εφαρμογής.",
  "LOGIN_TO_X":"Αυτή η λειτουργία απαιτεί ο χρήστης να είναι συνδεδεμένος με τον κυριώς κωδικό active/posting key.Παρακαλώ συνδέσου και προσπάθησε ξανά.",
  "GALLERY":"Έκθεση",
  "TRANSLATIONS":"Συντελεστές μετάφρασης",
  "SHARE":"Μοιράσου\n",
  "MARKETPLACE":"Αγορά",
  "EXCHANGE":"Ανταλλακτήριο",
  "DRAFTS":"Πρόχειρα",
  "POST_IS_UNDRAFT":"Η δημοσίευση αφαιρέθηκε από το πρόχειρο",
  "POST_IS_DRAFT":"Η δημοσίευση προστέθηκε στο πρόχειρο",
  "SWIPE_LEFT":"Σύρε αριστέρα για να δεις τις επιλογές",
  "MANAGE":"Διαχείρηση",
  "IMAGE_REMOVED":"Η εικόνα αφαιρέθηκε",
  "COPY":"Αντιγραφή",
  "NO_IMAGE":"Δεν έχεις ανεβάσει εικόνα ακόμα",
  "PULL_DOWN_TO_REFRESH":"Σύρτε προς τα κάτω για ανανέωση",
  "EXTERNAL_APPS":"Εξωτερικές εφαρμογές",
  "PLUGINS":"Πρόσθετα",
  "SUGGEST":"Πρότεινε",
  "COMING_SOON":"Έρχεται σύντομα",
  "CHAIN":"Αλυσίδα",
  "CHAIN_TEXT":"Εδώ μπορείς να αλλάξεις την αλυσίδα των μπλοκ ή την προεπιλεγμένη πλατφόρμα.",
  "CURRENCY":"Νόμισμα",
  "CURRENCY_TEXT":"Εδώ μπορείτε να αλλάξετε το προεπιλεγμένο σας νόμισμα. Θα δείτε την ανταμοιβή της ανάρτησης/σχολίου σας σε αυτό το νόμισμα.",
  "ABOUT_11":"<br><b>Λίστα με τα χαρακτηριστικά</b> <br>-Πρόσβαση σε μοναδικά άρθρα σε οποιοδήποτε θέμα σας ενδιαφέρει. <br> -Πλησίασε συγγραφείς σχολιάζοντας, συζητώντας θέματα. <br>-Ψήφισε αναρτήσεις ώστε να ανταμειφθούν συγγραφείς και κέρδισε ανταμοιβές επιμέλειας. <br>-Δημοσίευσε τα άρθρα σου, ανάρτησε ποστ και φιλοξένησε τα δωρεάν καθώς επίσης λάβε ανταμοιβές συμμετέχοντας και κερδίζοντας οπαδούς. <br>-Γράψε άρθρα καθ οδόν και αποθήκευσε πολλαπλά πρόχειρα ποστ για μελλοντική δημοσίευση. <br>-Βάλε σελιδοδείκτες σε αγαπημένα άρθρα για να τα διαβάσετε αργότερα. <br>-Exchange ή να εξαργυρώσετε τα κέρδη σας. <br>-Στείλετε τα χρήματά σας σε συγγραφείς ή τους χρήστες, τους φίλους, τους οπαδούς, κλπ <br>-ακολουθούν ενδιαφέρουσες συγγραφέων, bloggers. <br> -Αναζήτηση σας οπαδούς και συγγραφείς που ακολουθούν. <br>-Πάρτε ειδοποιήσεις να μείνετε σε επαφή μαζί σας οι οπαδοί και οι συζητήσεις σας είναι που εμπλέκονται in. <br>-Αναζήτηση για ενδιαφέρουσες ετικέτες/κατηγορίες άρθρων, συντάκτες. <br> -Εξατομίκευση του προφίλ σας. <br>-Πολλά περισσότερα χαρακτηριστικά γνωρίσματα για να έρθει. <br><br><b>Ασφαλείας</b> <br>1. App ποτέ πρόσβαση ή να κρατήσουν τα κεφάλαια του χρήστη. <br>2. app προσφέρει ένα μοντέλο πλευράς προγράμματος-πελάτη ασφαλείας, με ιδιωτικά κλειδιά φιλοξενούνται τοπικά και ποτέ να αποστέλλονται σε όλους τους διακομιστές, είστε υπεύθυνοι για τη δημιουργία αντιγράφων ασφαλείας τους κωδικούς πρόσβασής σας. <br>3. app προσφέρει απλή, ελκυστική χρήστη διασυνδέσεις και εμπειρίες <br>4. Η εφαρμογή προσφέρει επιπλέον στρώμα της ασφάλειας με κωδικό pin <br><br>εκτίμηση υποστηρίζει πλατφόρμες Steem και Golos. <br>",
  "FOUNDER":"Ιδρυτής και επικεφαλής προγραμματιστής",
  "ADD_ACCOUNT":"Προσθήκη λογαριασμού",
  "PLATFORM":"Πλατφόρμα"
}
},{}],143:[function(require,module,exports){
module.exports={
	"HOME": "Home",
	"LOGIN": "Login",
	"LOGOUT": "Logout",
	"PROFILE": "Profile",
	"FOLLOW": "Follow",
	"BOOKMARKS": "Bookmarks",
	"TRANSFER": "Transfer",
	"MARKET": "Market",
	"SETTINGS": "Settings",
	"ABOUT": "About",
	"ABOUT_1": "where anyone can earn rewards for their content!",
	"ABOUT_2": "is social application where you get paid for blogging, commenting and curating.",
	"ABOUT_3": "and it is open-source, community driven mobile project. It offers content access for reading, commenting, voting, posting, transfer earnings, etc. features offered by {{platformname}} blockchain and {{sitename}}.",
	"ABOUT_4": "1. App never access or hold onto user funds.",
	"ABOUT_5": "2. App offers a client-side security model, with private keys hosted locally and never sent to any servers.",
	"ABOUT_6": "3. App offers simple, attractive user interfaces and experiences.",
	"ABOUT_7": "4. App never require users to input any personal information.",
	"ABOUT_8": "Vote good-karma as witness",
	"ABOUT_9": "Contact/Feedback:",
	"ABOUT_10": "More info:",
	"REMOVE": "Remove",
	"MARKET_VIEW": "Market View",
	"PRICE": "Price",
	"AMOUNT": "Amount",
	"TOTAL": "Total",
	"NOORDERS": "No open orders for",
	"DATE": "Date",
	"BUY": "Buy",
	"SELL": "Sell",
	"OPEN": "Open",
	"HISTORY": "History",
	"FOLLOW_BACK": "Follow back",
	"FOLLOWED": "Followed",
	"UNFOLLOW": "Unfollow",
	"FOLLOWING": "Following",
	"FOLLOWERS": "Followers",
	"SEARCH_FOLLOWERS": "Search followers",
	"SEARCH_FOLLOWING": "Search following",
	"BY": "by",
	"IN": "in",
	"MENU": "Menu",
	"BOOKMARK": "Bookmark",
	"REBLOG": "Reblog",
	"UPVOTE": "Upvote",
	"DOWNVOTE": "Downvote",
	"UNVOTE_DOWNVOTED": "Unvote Downvoted",
	"UNVOTE_UPVOTED": "Unvote upvoted",
	"REPLY": "Reply",
	"EDIT": "Edit",
	"POST_1": "Swipe left on comments to see options",
	"POST_2": "Tap on comments to see sub-comments",
	"OPTIONS": "Options",
	"RESTEEMED_BY": "Reblogged by",
	"FOLLOW": "Follow",
	"NOTHING_HERE": "Nothing here, yet...",
	"BALANCES": "Balances",
	"PROFILE_1": "{{platformname}}, tradeable tokens that may be transferred at anytime. {{platformname}} can be converted to {{platformpower}} in a process called powering up.",
	"PROFILE_2": "{{platformpower}}, influence tokens that earn more power for holding long term and voting on posts. The more one holds the more one can influence other’s rewards and earn rewards for accurate voting.",
	"PROFILE_3": "Tokens worth about {{platformsunit}} of {{platformname}}.",
	"ESTIMATED_VALUE": "Estimated Value",
	"PROFILE_4": "The estimated value is based on a 7 day average value of {{platformname}}.",
	"TRANSACTION_HISTORY": "Transaction History",
	"POSTING": "Posting",
	"PROFILE_5": "The posting key is used for posting and voting. It should be different from the active and owner keys.",
	"OWNER": "Owner",
	"PROFILE_6": "The owner key is the master key for the account and is required to change the other keys. The private key or password for the owner key should be kept offline as much as possible.",
	"ACTIVE": "Active",
	"PROFILE_7": "The active key is used to make transfers and place orders in the internal market.",
	"MEMO": "Memo",
	"PROFILE_8": "The memo key is used to create and read memos.",
	"BLOG": "Blog",
	"POSTS": "Posts",
	"REPLIES": "Replies",
	"WALLET": "Wallet",
	"TAG": "Tag",
	"USER": "User",
	"CLOSE": "Close",
	"USER": "User",
	"TO": "To",
	"ASSET": "Asset",
	"SEND": "Send",
	"SECURITY": "Security",
	"AVAILABLE": "Available",
	"PUBLIC_MEMO": "Public Memo",
	"TO_DESC": "User e.g. good-karma",
	"PIN_CODE": "Pin Code",
	"PIN_TEXT": "PIN code helps you to secure app and your data. <br/><br/><b>Note:</b> Once enabled, you have max 4 tries to unlock, if you forgot pin or fail, app will remove logged in user data. You can re-login and continue using app.",
	"NOTIFICATIONS": "Notifications",
	"VOTE_TEXT": "You will get notification when someone votes your content! <br/> <b>Note:</b> Notifications include voting weight as well in alert message. (be it up-vote, down-vote, un-vote).",
	"VOTE": "Vote",
	"COMMENT_TEXT": "You will get notification when someone comments on your posts or comments!<br/> <b>Note:</b> Notifications include when someone <b>edits</b> their comments as well.",
	"COMMENT": "Comment",
	"FOLLOW_TEXT": "You will get notification when someone Follow or Unfollow you!",
	"MENTIONS": "Mentions",
	"MENTIONS_TEXT": "You will get notification when someone mentions you in their post/comment!",
	"RESTEEM": "Reblog",
	"RESTEEM_TEXT": "You will get notification when someone reblogs your post!",
	"CONFIGURATIONS": "Configurations",
	"VOTING": "Voting",
	"VOTING_TEXT": "Vote weight or percentage affects voting power on app, so you can regulate your voting reward. <br/><br/><b>Note:</b> This will change voting weight/percentage for downvoting as well and it is everywhere on app",
	"SERVER": "Server",
	"SERVER_TEXT": "Recommended",
	"SAVE_CHANGES": "Save Changes",
	"VOTERS_INFO": "Voters info",
	"WELCOME_BACK": "Welcome back!",
	"LOGIN_1": "Sign in with your username and password to continue.",
	"LOGIN_2": "Posting key is used for post, comment, vote, follow.",
	"LOGIN_3": "Active key is used for transfers and profile picture update.",
	"LOGIN_4": "User credentials are kept locally on the device. Upon Logout credentials are removed!",
	"DONT_HAVE": "Don't have an account?",
	"SIGN_UP_NOW": "Sign up now",
	"CANCEL": "Cancel",
	"ADVANCED": "Advanced",
	"ACTIVE_PRIKEY": "Active private key",
	"POSTING_PRIKEY": "Posting private key",
	"MASTER_PASS": "Master/main password",
	"USERNAME": "Username",
	"CARD_VIEW": "Card view",
	"COMPACT_VIEW": "Compact view",
	"SEARCH": "Search",
	"SUBMIT_A_STORY": "Submit a story",
	"REPLYTO": "Reply to",
	"POST": "Post",
	"PREVIEW": "Preview",
	"DEFAULT": "Default 50% / 50%",
	"POWERUP": "Power Up 100%",
	"DECLINE_PAYOUT": "Decline Payout",
	"SAVE_FOR_LATER": "SAVE FOR LATER",
	"CLEAR": "CLEAR",
	"POST_CONTENT": "Post content",
	"COMMENT_CONTENT": "Comment content",
	"TITLE": "Title",
	"TAGS": "Tags",
	"NOT_MATCH": "NOT MATCH",
	"CONFIRM_PIN": "Confirm PIN",
	"INCORRECT": "INCORRECT",
	"OPENING_POST": "opening post",
	"SET_PIN": "Set PIN",
	"ENTER_PIN": "Enter PIN",
	"ARE_YOU_SURE": "Are you sure?",
	"REBLOG_TEXT": "Reblog is irreversible, do you want to continue?",
	"BROADCAST_ERROR": "Broadcast error, try again!",
	"SUCCESS": "Success",
	"REBLOGGED_POST": "Reblogged post!",
	"LOGIN_FAIL": "Login failed! Please make sure you have logged in with master password or provided Posting private key on Login if you have choosed Advanced mode.",
	"LOGIN_FAIL_A": "Login failed! Please make sure you have logged in with master password or provided Active private key on Login if you have chosen Advanced mode.",
	"WARNING": "Warning",
	"VOTE_FOR_WITNESS": "Voting for witness",
	"VOTED_FOR_WITNESS": "Voted for witness",
	"AGO": "ago",
	"FROM_NOW": "from now",
	"SECS": "secs",
	"A_MIN": "a min",
	"MINS": "mins",
	"AN_HOUR": "an hr",
	"HOURS": "hrs",
	"A_DAY": "a day",
	"DAYS": "days",
	"A_MONTH": "a month",
	"MONTHS": "months",
	"A_YEAR": "a year",
	"YEARS": "years",
	"MIN_READ": "min read",
	"DOWNVOTE_FLAG": "Downvote or Flag",
	"CAPTURE_PICTURE": "Capture Picture",
	"SELECT_PICTURE": "Select Picture",
	"SET_CUSTOM_URL": "Set Custom URL",
	"INSERT_PICTURE": "Insert Picture",
	"ERROR": "Error",
	"UPLOAD_ERROR": "Upload Error",
	"CAMERA_CANCELLED": "Camera Cancelled",
	"SET_URL": "Set URL",
	"DIRECT_LINK_PICTURE": "Direct web link for the picture",
	"COMMENT_SUBMITTED": "Comment is submitted!",
	"DELETE_COMMENT": "Deleting comments are irreversible...",
	"DELETED_COMMENT": "Deleted comment",
	"UPLOADING_PICTURE": "Uploading Picture",
	"UPLOAD_COMPLETED": "Upload Completed",
	"UPLOAD_FAILED": "Upload Failed",
	"PASSWORD_INCORRECT": "The password or account name was incorrect",
	"INFO": "Info",
	"QR_TEXT": "Place a QR code inside the scan area",
	"BALANCE_TEXT": "Make sure you have enough balance for transaction!",
	"NONEXIST_USER": "User you are trying to transfer fund, doesn't exist!",
	"TRANSFER_TEXT": "Are you sure you want to transfer?",
	"CONFIRMATION": "Confirmation",
	"TX_BROADCASTED": "Transaction is broadcasted",
	"FEED": "Feed",
	"TRENDING": "Trending",
	"HOT": "Hot",
	"NEW": "New",
	"PROMOTED": "Promoted",
	"VOTES": "Votes",
	"PAYOUT": "Payout",
	"COMMENTS": "Comments",
	"TRENDING_30": "Trending for 30 days",
	"SORT_POST_BY": "Sort Posts By:",
	"PAYOUT_CYCLE": "Payout Cycle",
	"POTENTIAL_PAYOUT": "Potential Payout",
	"PAST_PAYOUT": "Past Payout",
	"AUTHOR_PAYOUT": "Author Payout",
	"CURATION_PAYOUT": "Curation Payout",
	"POST_SUBMITTED": "Post is submitted!",
	"POST_LATER": "Post for later submission!",
	"SAVED": "Saved",
	"CLEARED": "Cleared",
	"FLAGGING_TEXT": "Flagging a post can remove rewards and make this material less visible.<br><br>The flag should be used for the following: <ul><li>Fraud or Plagiarism</li><li>Hate Speech or Internet Trolling</li><li>Intentional miscategorized content or Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Request limit reached. Check out other trend/tags!",
	"POST_IS_UNBOOKMARK": "Post is removed from bookmarks!",
	"POST_IS_BOOKMARK": "Post is added to bookmarks!",
	"RESET": "Reset",
	"MODIFY_PICTURE": "Modify Profile Picture",
	"MODIFY_COVER_PICTURE": "Modify Cover Picture",
	"ACTIVE_KEY_REQUIRED_TEXT": "Please provide Active private key if you have chosen Advanced login mode!",
	"RESET_PICTURE_TEXT": "This will reset user profile picture",
	"RESET_COVER_PICTURE_TEXT": "This will reset user cover picture",
	"UPDATE_REQUIRES_RESTART": "Server update requires Restart!",
	"SETTINGS_UPDATED": "Settings are updated!",
	"LANGUAGES": "Languages",
	"LANGUAGES_TEXT": "Here you can change language of the app.",
	"LOGIN_TO_X": "This operation requires user to be logged in with main password, active/posting key. Please login and try again.",
	"GALLERY": "Gallery",
	"TRANSLATIONS": "Translation contributors",
	"SHARE": "Share",
	"MARKETPLACE": "Market Place",
	"EXCHANGE": "Exchange",
	"DRAFTS": "Drafts",
	"POST_IS_UNDRAFT": "Post is removed from drafts!",
	"POST_IS_DRAFT": "Post is added to drafts!",
	"SWIPE_LEFT": "Swipe left to see options",
	"MANAGE": "Manage",
	"IMAGE_REMOVED": "Image is removed",
	"COPY": "Copy",
	"NO_IMAGE": "You have not uploaded any image, yet!",
	"PULL_DOWN_TO_REFRESH": "Pull down to refresh",
	"EXTERNAL_APPS": "External Apps",
	"PLUGINS": "Plugins",
	"SUGGEST": "Suggest",
	"COMING_SOON": "Coming soon",
	"CHAIN": "Chain",
	"CHAIN_TEXT": "Here you can change blockchain or default platform.",
	"CURRENCY": "Currency",
	"CURRENCY_TEXT": "Here you can change your default currency. You will see post/comment reward value in this currency.",
	"ABOUT_11": "<br><b>Feature list</b><br>- Access unique articles in any subject you are interested reading.<br>- Engage with authors by commenting, discussing topics.<br>- Voting for posts to reward author as well as earn curation reward.<br>- Publish your articles, blog posts and host them for free and earn rewards by engaging and gain followers.<br>- Write articles on go, save multiple drafts of the post for later publication.<br>- Bookmark favorite articles to read later.<br>- Exchange or cash out your earnings.<br>- Send your funds to any authors or users, friends, followers, etc.<br>- Follow interesting authors, bloggers.<br>- Search your followers and authors you are following.<br>- Get notifications to stay in touch with your followers and discussions you are involved in.<br>- Search for interesting tags/categories of articles, authors.<br>- Personalize your profile.<br>- Many more features to come.<br><br><b>Security</b><br>1. App never access or hold onto user funds.<br>2. App offer a client-side security model, with private keys hosted locally and never sent to any servers, you are responsible to backing up your passwords.<br>3. App offers simple, attractive user interfaces and experiences<br>4. App offers extra layer of security with pin-code<br><br>eSteem supports Steem and Golos platforms.<br>",
	"FOUNDER": "Founder and Lead developer",
	"ADD_ACCOUNT": "Add account",
	"PLATFORM": "Platform"
}

},{}],144:[function(require,module,exports){
module.exports={
  "HOME":"Inicio",
  "LOGIN":"Iniciar Sesión",
  "LOGOUT":"Cerrar Sesión",
  "PROFILE":"Perfil",
  "FOLLOW":"Seguir",
  "BOOKMARKS":"Marcadores",
  "TRANSFER":"Transferir",
  "MARKET":"Mercado",
  "SETTINGS":"Ajustes",
  "ABOUT":"Acerca de",
  "ABOUT_1":"donde todo el mundo puede obtener ganancias por su contenido",
  "ABOUT_2":"provisto por la plataforma {{platformname}}. App creada por",
  "ABOUT_3":"es un proyecto de móvil impulsado por la comunidad, de código abierto. Ofrece acceso al contenido para su lectura, comentarios, votos, publicaciones, transferencia de ganancias, etc; características ofrecidas por la cadena de bloques {{platformname}} y {{sitename}}.",
  "ABOUT_4":"1. La App nunca accede o retiene fondos de los usuarios.",
  "ABOUT_5":"2. La App ofrece un modelo de seguridad del cliente con contraseñas privadas almacenadas localmente y que no son nunca enviadas a ningún servidor.",
  "ABOUT_6":"3. La App ofrece una experiencia y una interfaz simple y atractica.",
  "ABOUT_7":"4. La App nunca pide que los usuarios introduzcan ninguna información personal.",
  "ABOUT_8":"Vota a good-karma como testigo",
  "ABOUT_9":"Contacto/Sugerencias",
  "ABOUT_10":"Más información",
  "REMOVE":"Eliminar",
  "MARKET_VIEW":"Vista de Mercado",
  "PRICE":"Precio",
  "AMOUNT":"Cantidad",
  "TOTAL":"",
  "NOORDERS":"Sin órdenes abiertas para",
  "DATE":"Fecha",
  "BUY":"Comprar",
  "SELL":"Vender",
  "OPEN":"Abrir",
  "HISTORY":"Historial",
  "FOLLOW_BACK":"Devolver Seguimiento",
  "FOLLOWED":"Seguido",
  "UNFOLLOW":"Dejar de Seguir",
  "FOLLOWING":"Siguiendo",
  "FOLLOWERS":"Seguidores",
  "SEARCH_FOLLOWERS":"Buscar seguidores",
  "SEARCH_FOLLOWING":"Buscar seguidos",
  "BY":"por",
  "IN":"en",
  "MENU":"Menú",
  "BOOKMARK":"Marcador",
  "REBLOG":"Rebloguear",
  "UPVOTE":"Voto Positivo",
  "DOWNVOTE":"Voto Negativo",
  "UNVOTE_DOWNVOTED":"Deshacer Voto Negativo",
  "UNVOTE_UPVOTED":"Deshacer Voto Positivo",
  "REPLY":"Responder",
  "EDIT":"Editar",
  "POST_1":"Desliza a la izquierda en los comentarios para ver las opciones",
  "POST_2":"Pulsa en los comentarios para ver los subcomentarios",
  "OPTIONS":"Opciones",
  "RESTEEMED_BY":"Resteemed por",
  "NOTHING_HERE":"Nada por aquí aún...",
  "BALANCES":"Saldos",
  "PROFILE_1":"{{platformname}}, fichas comerciables que pueden ser transferidas en cualquier momento. {{platformname}} pueden ser convertidas a {{platformpower}} en un proceso llamado power up.",
  "PROFILE_2":"{{platformpower}}, fichas de influencia que consiguen más poder por mantenerlas a largo plazo y votar en los posts. Cuantas más tengas más influencia tendrás en las recompensas que le das al resto de usuarios y más recompensas obtendrás por tus votos.",
  "PROFILE_3":"Valor de las fichas {{platformsunit}} de {{platformname}}.",
  "ESTIMATED_VALUE":"Valor Estimado",
  "PROFILE_4":"El valor estimado se basa en un valor promedio de 7 días de {{platformname}}.",
  "TRANSACTION_HISTORY":"Historial de Transacciones",
  "POSTING":"Publicación",
  "PROFILE_5":"La clave de publicación es utilizada para publicar y votar. Tiene que ser diferente a la clave activa y a la clave de propietario.",
  "OWNER":"Propietario",
  "PROFILE_6":"La clave de propietario es la clave maestra de la cuenta y se requiere para cambiar las otras claves. La clave o contraseña privada de la clave de propietario debería ser mantenida \"offline\" tanto como sea posible.",
  "ACTIVE":"Activa",
  "PROFILE_7":"La clave activa se utiliza para hacer transferencias y hacer pedidos en el mercado interno.",
  "MEMO":"Memorándum",
  "PROFILE_8":"La clave de memorándums se utiliza para crear y leer memorándums.",
  "BLOG":"",
  "POSTS":"Publicaciones",
  "REPLIES":"Respuestas",
  "WALLET":"Monedero",
  "TAG":"Etiqueta",
  "USER":"Usuario",
  "CLOSE":"Cerrar",
  "TO":"A",
  "ASSET":"Posesión de Capital",
  "SEND":"Enviar",
  "SECURITY":"Seguridad",
  "AVAILABLE":"Disponible",
  "PUBLIC_MEMO":"Memorándum Público",
  "TO_DESC":"Usuario ej. good-karma",
  "PIN_CODE":"Código Pin",
  "PIN_TEXT":"El código PIN te ayuda a dar seguridad a la app y a tus datos.\n<br/><br/><b>Nota:</b> Una vez activado, tienes un máximo de 4 intentos para desbloquearlo; si te olvidas de tu pin o fallas, la app eliminará los registros en los datos de usuario. Puedes volver a iniciar sesión y continuar usando la app.",
  "NOTIFICATIONS":"Notificaciones",
  "VOTE_TEXT":"Recibirás una notificación cuando alguien vote tu contenido! <br/> <b>Nota:</b> Las notificaciones incluyen también el peso de la votación en el mensaje de alerta. (ya sea por votación positiva, votación negativa, deshacer votación).",
  "VOTE":"Votar",
  "COMMENT_TEXT":"Recibirás una notificación cuando alguien comente en tus publicaciones o comentarios!<br/> <b>Note:</b> Las notificaciones incluyen cuando alguien <b>edita</b> sus comentarios también.",
  "COMMENT":"Comentar",
  "FOLLOW_TEXT":"Recibirás una notificación cuando alguien te siga o te deje de seguir!",
  "MENTIONS":"Menciones",
  "MENTIONS_TEXT":"Recibirás una notificación cuando alguien te mencione en su publicación/comentario!",
  "RESTEEM":"",
  "RESTEEM_TEXT":"Recibirás una notificación cuando alguien haga resteem a tu publicación",
  "CONFIGURATIONS":"Configuraciones",
  "VOTING":"Voto",
  "VOTING_TEXT":"El peso o porcentaje del voto afecta al poder de votación en la app, de tal manera que puedes regular tu recompensa de votación. <br/><br/><b>Nota:</b> Esto cambiará también el peso/porcentaje del voto a la hora de hacer un voto negativo",
  "SERVER":"Servidor",
  "SERVER_TEXT":"Recomendado",
  "SAVE_CHANGES":"Guardar Cambios",
  "VOTERS_INFO":"Info de votantes",
  "WELCOME_BACK":"Bienvenido!",
  "LOGIN_1":"Regístrate con tu nombre de usuario y contraseña para continuar.",
  "LOGIN_2":"La clave de publicación se usa para publicar, comentar, votar, seguir.",
  "LOGIN_3":"La clave activa se usa para las transferencias y la actualización de la foto de perfil.",
  "LOGIN_4":"Las credenciales del usuario se guardan localmente en el dispositivo. Al cerrar la sesión las credenciales son eliminadas!",
  "DONT_HAVE":"No tienes una cuenta?",
  "SIGN_UP_NOW":"Regístrate ahora",
  "CANCEL":"Cancelar",
  "ADVANCED":"Avanzado",
  "ACTIVE_PRIKEY":"Clave activa privada",
  "POSTING_PRIKEY":"Clave de publicación privada",
  "MASTER_PASS":"Contraseña maestra/principal",
  "USERNAME":"Nombre de Usuario",
  "CARD_VIEW":"Vista de casillas",
  "COMPACT_VIEW":"Vista compacta",
  "SEARCH":"Buscar",
  "SUBMIT_A_STORY":"Publicar un artículo",
  "REPLYTO":"Responder a",
  "POST":"Publicar",
  "PREVIEW":"Previsualización",
  "DEFAULT":"Por defecto 50% / 50%",
  "POWERUP":"Potenciación 100%",
  "DECLINE_PAYOUT":"Rechazar Pago",
  "SAVE_FOR_LATER":"GUARDAR PARA MÁS TARDE",
  "CLEAR":"BORRAR",
  "POST_CONTENT":"Publicar contenido",
  "COMMENT_CONTENT":"Comentar contenido",
  "TITLE":"Título",
  "TAGS":"Etiquetas",
  "NOT_MATCH":"NO COINCIDE",
  "CONFIRM_PIN":"Confirmar PIN",
  "INCORRECT":"INCORRECTO",
  "OPENING_POST":"Post inicial",
  "SET_PIN":"Establecer PIN",
  "ENTER_PIN":"Introducir PIN",
  "ARE_YOU_SURE":"Estás seguro?",
  "REBLOG_TEXT":"Resteemear es irreversible, quieres continuar?",
  "BROADCAST_ERROR":"Error de transmisión, inténtalo de nuevo!",
  "SUCCESS":"Conseguido",
  "REBLOGGED_POST":"Publicación Reblogueada",
  "LOGIN_FAIL":"Inicio de sesión fallido! Por favor asegúrate de que has iniciado sesión con tu contraseña maestra o con la clave de Publicación privada proporcionada en el apartado Iniciar Sesión si elegiste el Modo Avanzado.",
  "LOGIN_FAIL_A":"Inicio de sesión fallido! Por favor asegúrate de que has iniciado sesión con tu contraseña maestra o con la clave Activa privada en el apartado Iniciar Sesión si elegiste el Modo Avanzado.",
  "WARNING":"Advertencia",
  "VOTE_FOR_WITNESS":"Votar a testigo",
  "VOTED_FOR_WITNESS":"Votado a testigo",
  "AGO":"hace",
  "FROM_NOW":"desde ahora",
  "SECS":"segundos",
  "A_MIN":"un minuto",
  "MINS":"minutos",
  "AN_HOUR":"una hora",
  "HOURS":"horas",
  "A_DAY":"un día",
  "DAYS":"días",
  "A_MONTH":"un mes",
  "MONTHS":"meses",
  "A_YEAR":"un año",
  "YEARS":"años",
  "MIN_READ":"minutos de lectura",
  "DOWNVOTE_FLAG":"Votar Negativamente o Marcar Como Inapropiado",
  "CAPTURE_PICTURE":"Tomar foto",
  "SELECT_PICTURE":"Seleccionar Imagen",
  "SET_CUSTOM_URL":"Establecer URL personalizada",
  "INSERT_PICTURE":"Insertar Imagen",
  "ERROR":"",
  "UPLOAD_ERROR":"Error al Cargar",
  "CAMERA_CANCELLED":"Cámara Cancelada",
  "SET_URL":"Establecer URL",
  "DIRECT_LINK_PICTURE":"Enlace web directo a la imagen",
  "COMMENT_SUBMITTED":"El comentario se ha entregado!",
  "DELETE_COMMENT":"Eliminar comentarios es irreversible...",
  "DELETED_COMMENT":"Eliminar comentario",
  "UPLOADING_PICTURE":"Subiendo Imagen",
  "UPLOAD_COMPLETED":"Subida Completada",
  "UPLOAD_FAILED":"La subida ha fallado",
  "PASSWORD_INCORRECT":"La contraseña o el nombre de cuenta son incorrectos",
  "INFO":"Información",
  "QR_TEXT":"Coloca el código QR dentro de la zona de escaneo",
  "BALANCE_TEXT":"Asegúrate de que tienes suficiente saldo para la transacción!",
  "NONEXIST_USER":"El usuario al que estás intentando transferir fondos no existe!",
  "TRANSFER_TEXT":"Estás seguro de que quieres hacer la transferencia?",
  "CONFIRMATION":"Confirmación",
  "TX_BROADCASTED":"Transacción transmitida",
  "FEED":"Inicio",
  "TRENDING":"Tendencias",
  "HOT":"Caliente",
  "NEW":"Nuevo",
  "PROMOTED":"Promocionado",
  "VOTES":"Votos",
  "PAYOUT":"Pago",
  "COMMENTS":"Comentarios",
  "TRENDING_30":"Siendo Tendencia durante 30 días",
  "SORT_POST_BY":"Ordenar Publicaciones Por",
  "PAYOUT_CYCLE":"Ciclo de Pago",
  "POTENTIAL_PAYOUT":"Pago Potencial",
  "PAST_PAYOUT":"Pago Pasado",
  "AUTHOR_PAYOUT":"Pago de Autor",
  "CURATION_PAYOUT":"Pago de Curación",
  "POST_SUBMITTED":"La publicación fue enviada!",
  "POST_LATER":"Publicación para posterior presentación!",
  "SAVED":"Guardado",
  "CLEARED":"Borrado",
  "FLAGGING_TEXT":"Marcar como inapropiada una publicación puede eliminar las recompensas y hacer que el material marcado sea menos visible.<br><br> Marcar como inapropiado debe utilizarse en los siguientes casos: <ul><li>Fraude o Plagio</li><li>Discursos de Odio o Actitudes de Provocación y Molestia Constantes</li><li>Contenido categrizado mal intencionadamente o Spam</li></ul>",
  "REQUEST_LIMIT_TEXT":"Límite de solicitud alcanzado. Revisa otras etiquetas/tendencias!",
  "POST_IS_UNBOOKMARK":"Publicación eliminada de los marcadores!",
  "POST_IS_BOOKMARK":"Publicación añadida a marcadores!",
  "RESET":"Reiniciar",
  "MODIFY_PICTURE":"Modificar Foto de Perfil",
  "MODIFY_COVER_PICTURE":"Modificar Foto de Portada",
  "ACTIVE_KEY_REQUIRED_TEXT":"Por favor proporciona la clave Activa privada si has elegido el modo de Inicio de Sesión Avanzado!",
  "RESET_PICTURE_TEXT":"Esto reiniciará la foto de perfil del usuario",
  "RESET_COVER_PICTURE_TEXT":"Esto reiniciará la foto de portada del usuario",
  "UPDATE_REQUIRES_RESTART":"La actualización del servidor requiere un reinicio!",
  "SETTINGS_UPDATED":"Ajustes actualizados!",
  "LANGUAGES":"Idiomas",
  "LANGUAGES_TEXT":"Aquí puedes cambiar el idioma de la app",
  "LOGIN_TO_X":"Esta operación requiere que el usuario inicie sesión con la contraseña maestra/principal, clave activa/publicar. Por favor inicia sesión y vuelve a intentarlo.",
  "GALLERY":"Galería",
  "TRANSLATIONS":"Colaboradores de traducciones",
  "SHARE":"Compartir",
  "MARKETPLACE":"Mercado",
  "EXCHANGE":"Cambio",
  "DRAFTS":"Borradores",
  "POST_IS_UNDRAFT":"¡La publicación se ha eliminado de borradores!",
  "POST_IS_DRAFT":"¡La publicación se ha añadido a borradores!",
  "SWIPE_LEFT":"Deslice hacia la izquierda para ver las opciones",
  "MANAGE":"Gestionar",
  "IMAGE_REMOVED":"La foto se ha eliminado",
  "COPY":"Copiar",
  "NO_IMAGE":"¡Aún no has subido ninguna foto!",
  "PULL_DOWN_TO_REFRESH":"Tire hacia abajo para actualizar",
  "EXTERNAL_APPS":"Apps externas",
  "PLUGINS":"",
  "SUGGEST":"Sugerir",
  "COMING_SOON":"Muy pronto",
  "CHAIN":"",
  "CHAIN_TEXT":"Aquí puedes cambiar la blockchain o la plataforma por defecto.",
  "CURRENCY":"",
  "CURRENCY_TEXT":"",
  "ABOUT_11":"",
  "FOUNDER":"",
  "ADD_ACCOUNT":"",
  "PLATFORM":""
}
},{}],145:[function(require,module,exports){
module.exports={
  "HOME":"Accueil",
  "LOGIN":"Connexion",
  "LOGOUT":"Déconnexion",
  "PROFILE":"Profil",
  "FOLLOW":"Suivre",
  "BOOKMARKS":"Signets",
  "TRANSFER":"Transfert",
  "MARKET":"Marché",
  "SETTINGS":"Paramètres",
  "ABOUT":"A propos",
  "ABOUT_1":"où n'importe qui peut gagner des récompenses pour son contenu!",
  "ABOUT_2":"est supporté par la plate-forme {{platformname}}. Application créée par",
  "ABOUT_3":"Il s'agit d'un projet pour la communauté mobile et il est open-source. Il offre un accès pour lire, commenter, voter, poster, afficher le transfert de récompense, etc. Toutes les fonctionnalités offertes par {{sitename}} et la blockchain {{platformname}}.",
  "ABOUT_4":"1. L'application n'a jamais accès aux fonds de l'utilisateur.",
  "ABOUT_5":"2. L'application offre un modèle de sécurité à ses client, avec des clés privées hébergées localement et jamais envoyées à aucun serveurs.",
  "ABOUT_6":"3. L'application offre une interface simple et des expériences attrayantes aux utilisateurs.",
  "ABOUT_7":"4. L'application ne demande jamais à ce que les utilisateurs saisissent des informations personnelles.",
  "ABOUT_8":"Votez pour good-karma comme témoin",
  "ABOUT_9":"Contact/Réaction:",
  "ABOUT_10":"Plus d'infos:",
  "REMOVE":"Supprimer",
  "MARKET_VIEW":"Vue du marché",
  "PRICE":"Prix",
  "AMOUNT":"Montant",
  "TOTAL":"",
  "NOORDERS":"Pas d'ordres ouverts pour",
  "DATE":"",
  "BUY":"Achat",
  "SELL":"Vente",
  "OPEN":"Ouvert",
  "HISTORY":"Historique",
  "FOLLOW_BACK":"Suivre",
  "FOLLOWED":"Abonné",
  "UNFOLLOW":"Désabonner",
  "FOLLOWING":"",
  "FOLLOWERS":"",
  "SEARCH_FOLLOWERS":"Chercher followers",
  "SEARCH_FOLLOWING":"Chercher following",
  "BY":"par",
  "IN":"dans",
  "MENU":"",
  "BOOKMARK":"Signet",
  "REBLOG":"",
  "UPVOTE":"",
  "DOWNVOTE":"",
  "UNVOTE_DOWNVOTED":"Retirer Downvote",
  "UNVOTE_UPVOTED":"Retirer Upvote",
  "REPLY":"Répondre",
  "EDIT":"Editer",
  "POST_1":"Glisser vers la gauche sur les commentaires pour voir les options",
  "POST_2":"Appuyez sur les commentaires pour voir les sous-commentaires",
  "OPTIONS":"",
  "RESTEEMED_BY":"Resteem par",
  "NOTHING_HERE":"Rien ici encore...",
  "BALANCES":"Soldes",
  "PROFILE_1":"Les {{platformname}}, jetons négociables qui peuvent être transférés à tout moment. Le {{platformname}} peut être converti en {{platformpower}} dans un processus appelé power-up.",
  "PROFILE_2":"{{platformpower}}, jetons d'influence, vous gagnez plus de Steem Power en le concervant à long terme et en votant sur les postes. Plus on le conserve, plus on a d'influence sur les récompenses des autres et dans l'obtention de récompense pour un vote en particulier.",
  "PROFILE_3":"Jetons d'une valeur d'environ {{platformsunit}} de {{platformname}}.",
  "ESTIMATED_VALUE":"Valeur estimée",
  "PROFILE_4":"La valeur estimée est calculée sur une moyenne de 3.5 jours de la valeur du {{platformname}}.",
  "TRANSACTION_HISTORY":"Historique des Transactions",
  "POSTING":"Poste",
  "PROFILE_5":"La clé de post est utilisée pour poster et voter. Elle doit être différente des clés actives et propriétaires.",
  "OWNER":"Propriétaire",
  "PROFILE_6":"La clé propriétaire est la clé principale du compte et est requise pour changer les autres clés. La clé privée ou le mot de passe de la clé propriétaire doivent être mis hors ligne autant que possible.",
  "ACTIVE":"",
  "PROFILE_7":"La clé active est utilisée pour effectuer des transferts et passer des ordres dans le marché intérieur.",
  "MEMO":"Mémo",
  "PROFILE_8":"La clé mémo permet de créer et de lire des mémos.",
  "BLOG":"",
  "POSTS":"",
  "REPLIES":"Réponses",
  "WALLET":"Portefeuille",
  "TAG":"",
  "USER":"Utilisateur",
  "CLOSE":"Fermer",
  "TO":"à",
  "ASSET":"Type",
  "SEND":"Envoyer",
  "SECURITY":"Sécurité",
  "AVAILABLE":"Disponible",
  "PUBLIC_MEMO":"Mémo publique",
  "TO_DESC":"Utilisateur par ex. good-karma",
  "PIN_CODE":"Code PIN",
  "PIN_TEXT":"Le code PIN vous aide à sécuriser l'application et vos données. <br/><br/><b>Note:</b> Une fois activé, vous avez 4 tentatives maximum pour déverrouiller, si vous avez oublié le pin ou si vous échouez, l'application supprimera les données utilisateur enregistrées. Vous pouvez vous reconnecter et continuer à utiliser l'application.",
  "NOTIFICATIONS":"",
  "VOTE_TEXT":"Vous recevrez une notification quand quelqu'un votera pour un des vos contenus! <br/> <b>Note:</b> Les notifications incluent le poids du vote dans le message d'alerte. (Qu'il s'agisse d'un upvote, d' un downvote ou d'un vote retiré).",
  "VOTE":"",
  "COMMENT_TEXT":"Vous recevrez une notification quand quelqu'un commentera un des vos posts ou un de vos commentaires!<br/> <b>Note:</b> Les notifications incluent quand quelqu'un <b>édite</b> ses propres commentaires aussi.",
  "COMMENT":"Commentaire",
  "FOLLOW_TEXT":"Vous recevrez une notification quand quelqu'un s'abonnera ou se désabonnera de vous!",
  "MENTIONS":"",
  "MENTIONS_TEXT":"Vous recevrez une notification quand quelqu'un vous mentionnera dans un post/commentaire!",
  "RESTEEM":"",
  "RESTEEM_TEXT":"Vous recevrez une notification quand quelqu'un resteem votre post!",
  "CONFIGURATIONS":"",
  "VOTING":"Vote",
  "VOTING_TEXT":"Le poids ou le pourcentage du vote affecte le pouvoir de vote dans l'application, de telle manière vous pouvez régler votre récompense de vote. <br/><br/><b>Note:</b> Cela changera le poids/pourcentage du vote pour le downvote partout dans l'application",
  "SERVER":"Serveur",
  "SERVER_TEXT":"Recommandé",
  "SAVE_CHANGES":"Sauvegarder les changements",
  "VOTERS_INFO":"Info vote",
  "WELCOME_BACK":"Bienvenue à nouveau!",
  "LOGIN_1":"Connectez-vous avec votre nom d'utilisateur et votre mot de passe pour continuer.",
  "LOGIN_2":"La clé de posts est utilisée pour poster, commenter, voter, suivre.",
  "LOGIN_3":"La clé active est utilisée pour les transferts et la mise à jour de l'image de profil.",
  "LOGIN_4":"Les informations d'identification de l'utilisateur sont conservées localement sur votre appareil. Lors de la déconnexion elles sont supprimées!",
  "DONT_HAVE":"Pas encore de compte?",
  "SIGN_UP_NOW":"Enregistrez-vous maintenant",
  "CANCEL":"Supprimer",
  "ADVANCED":"Avancé",
  "ACTIVE_PRIKEY":"Clé privée active",
  "POSTING_PRIKEY":"Clé privée de posts",
  "MASTER_PASS":"Mot de passe principal",
  "USERNAME":"Nom d'utilisateur",
  "CARD_VIEW":"Vue thuile",
  "COMPACT_VIEW":"Vue compacte",
  "SEARCH":"Rechercher",
  "SUBMIT_A_STORY":"Proposer un post",
  "REPLYTO":"Répondre à",
  "POST":"",
  "PREVIEW":"Aperçu",
  "DEFAULT":"Par défaut 50% / 50%",
  "POWERUP":"",
  "DECLINE_PAYOUT":"Refuser le payement",
  "SAVE_FOR_LATER":"Sauvegarder pour plus tard",
  "CLEAR":"Effacer",
  "POST_CONTENT":"Poster le contenu",
  "COMMENT_CONTENT":"Commenter",
  "TITLE":"Titre",
  "TAGS":"",
  "NOT_MATCH":"Pas de concordance",
  "CONFIRM_PIN":"Confirmer PIN",
  "INCORRECT":"",
  "OPENING_POST":"Ouverture du post",
  "SET_PIN":"Configurer PIN",
  "ENTER_PIN":"Entrer PIN",
  "ARE_YOU_SURE":"Vous êtes sur?",
  "REBLOG_TEXT":"Resteem est irréversible, voulez-vous continuer?",
  "BROADCAST_ERROR":"Erreur de diffusion, essayer à nouveau!",
  "SUCCESS":"Réussite",
  "REBLOGGED_POST":"Post reblogé!",
  "LOGIN_FAIL":"Echec de la connexion! Veuillez vous assurer d'avoir ouvert une session avec le mot de passe principal ou votre clé privée de post si vous avez choisi le mode avancé.",
  "LOGIN_FAIL_A":"Échec de la connexion! Veuillez vous assurer d'avoir ouvert une session avec le mot de passe principal ou avoir fourni une clé privée active lors de la connexion si vous avez choisi le mode Avancé.",
  "WARNING":"Attention",
  "VOTE_FOR_WITNESS":"Vote pour témoin",
  "VOTED_FOR_WITNESS":"a voté pour témoin",
  "AGO":"depuis",
  "FROM_NOW":"à partir de maintenant",
  "SECS":"Secondes",
  "A_MIN":"une min",
  "MINS":"",
  "AN_HOUR":"une heure",
  "HOURS":"h",
  "A_DAY":"un jour",
  "DAYS":"jours",
  "A_MONTH":"un mois",
  "MONTHS":"mois",
  "A_YEAR":"une année",
  "YEARS":"années",
  "MIN_READ":"min temps lecture",
  "DOWNVOTE_FLAG":"Downvote",
  "CAPTURE_PICTURE":"Capturer Image",
  "SELECT_PICTURE":"Sélectionner Image",
  "SET_CUSTOM_URL":"Configurer URL personnalisée",
  "INSERT_PICTURE":"Insérer Image",
  "ERROR":"Erreur",
  "UPLOAD_ERROR":"Erreur téléchargement",
  "CAMERA_CANCELLED":"Caméra supprimée",
  "SET_URL":"Configurer URL",
  "DIRECT_LINK_PICTURE":"Lien direct pour l'image",
  "COMMENT_SUBMITTED":"Commentaire envoyé!",
  "DELETE_COMMENT":"La suppression des commentaires est irréversible.",
  "DELETED_COMMENT":"Commentaire supprimé",
  "UPLOADING_PICTURE":"Téléchargement de l'image",
  "UPLOAD_COMPLETED":"Téléchargement terminé",
  "UPLOAD_FAILED":"Téléchargement échoué",
  "PASSWORD_INCORRECT":"Mot de passe ou nom d'utilisateur incorrect",
  "INFO":"",
  "QR_TEXT":"Placer le QR code dans la zone de scan",
  "BALANCE_TEXT":"Soyez sur d'avoir un solde suffisant pour la transaction!",
  "NONEXIST_USER":"L'utilisateur auquel vous essayez d'envoyer des fonds n'existe pas!",
  "TRANSFER_TEXT":"Etes-vous sur de vouloir transférer?",
  "CONFIRMATION":"",
  "TX_BROADCASTED":"La transaction est diffusée",
  "FEED":"Suivis",
  "TRENDING":"Tendance",
  "HOT":"",
  "NEW":"Nouveau",
  "PROMOTED":"Promu",
  "VOTES":"",
  "PAYOUT":"Paiement",
  "COMMENTS":"Commentaires",
  "TRENDING_30":"Tendance depuis 30 jours",
  "SORT_POST_BY":"Classer posts par:",
  "PAYOUT_CYCLE":"Cycle de Paiement",
  "POTENTIAL_PAYOUT":"Paiement potentiel",
  "PAST_PAYOUT":"Paiement passé",
  "AUTHOR_PAYOUT":"Paiement auteur",
  "CURATION_PAYOUT":"Paiement votes",
  "POST_SUBMITTED":"Post envoyé!",
  "POST_LATER":"Soumettre le post plus tard!",
  "SAVED":"Sauvegardé",
  "CLEARED":"Supprimé",
  "FLAGGING_TEXT":"Downvote un post peut enlever les récompenses et rendre celui-ci moins visible.<br><br>Le Downvote devrait être utilisé pour ceci: <ul><li>Fraude ou Plagiarisme</li><li>Trolls ou discours de haine</li><li>Contenu inapproprié intentionnel ou Spam</li></ul>",
  "REQUEST_LIMIT_TEXT":"Limite atteinte. Découvrez d'autres tags/tendances!",
  "POST_IS_UNBOOKMARK":"Post enlevé des signets!",
  "POST_IS_BOOKMARK":"Post ajouté au signets!",
  "RESET":"Réinitialiser",
  "MODIFY_PICTURE":"Modifier l'image du profil",
  "MODIFY_COVER_PICTURE":"Modifier l'image de couverture",
  "ACTIVE_KEY_REQUIRED_TEXT":"SVP, veuillez indiquer la clé privée active si vous avez choisi le mode de connexion avancé.",
  "RESET_PICTURE_TEXT":"Ceci va réinitialiser l'image profil de l'utilisateur",
  "RESET_COVER_PICTURE_TEXT":"Ceci va réinitialiser l'image de couverture de l'utilisateur",
  "UPDATE_REQUIRES_RESTART":"La mise à jour du serveur nécessite un redémarrage!",
  "SETTINGS_UPDATED":"Paramètres mis à jour!",
  "LANGUAGES":"Langues",
  "LANGUAGES_TEXT":"Vous pouvez changer ici la langue de l'application",
  "LOGIN_TO_X":"Cette opération requiert que l'utilisateur soit connecté avec le mot de passe principal, la clé de post/clé active. Veuillez vous connecter et réessayer.",
  "GALLERY":"Gallerie",
  "TRANSLATIONS":"Contributeurs de traduction",
  "SHARE":"Partage",
  "MARKETPLACE":"Marché",
  "EXCHANGE":"Echange",
  "DRAFTS":"Brouillons",
  "POST_IS_UNDRAFT":"Post supprimé des brouillons!",
  "POST_IS_DRAFT":"Post ajouté aux brouillons!",
  "SWIPE_LEFT":"Glisser vers la gauche pour voir les options",
  "MANAGE":"Gérer",
  "IMAGE_REMOVED":"Image enlevée",
  "COPY":"copié",
  "NO_IMAGE":"Vous n'avez pas encore télécharger d'images pour le moment!",
  "PULL_DOWN_TO_REFRESH":"Tirez vers le bas pour rafraîchir",
  "EXTERNAL_APPS":"Apps externe",
  "PLUGINS":"",
  "SUGGEST":"Suggestion",
  "COMING_SOON":"Bientôt",
  "CHAIN":"",
  "CHAIN_TEXT":"Ici vous pouvez changer pour la blockchain ou la plate-forme par défaut.",
  "CURRENCY":"",
  "CURRENCY_TEXT":"",
  "ABOUT_11":"",
  "FOUNDER":"",
  "ADD_ACCOUNT":"",
  "PLATFORM":""
}
},{}],146:[function(require,module,exports){
module.exports={
  "HOME":"עמוד הבית",
  "LOGIN":"כניסה",
  "LOGOUT":"יציאה",
  "PROFILE":"פרופיל",
  "FOLLOW":"לעקוב",
  "BOOKMARKS":"סימניות",
  "TRANSFER":"העברה",
  "MARKET":"שוק",
  "SETTINGS":"אפשרויות",
  "ABOUT":"מידע",
  "ABOUT_1":"מקום שבו כל אחד יכול להרוויח בזכות התכנים שלו!",
  "ABOUT_2":"מופעל על ידי {{platformname}}. האפילקציה נכתבה על ידי",
  "ABOUT_3":"והוא פתוח, ומונע על ידי הקהילה. הוא מציע גישה לקריאה, לכתיבת תגובות, ללייקים, להעברת כספים וכו'. הפעולות מוצעות על ידי הבלוקצ'יין של {{platformname}} ועל ידי {{sitename}}",
  "ABOUT_4":"1. לאפליקציה אין גישה לכספים של המשתמש.",
  "ABOUT_5":"2. האפליקציה היא בטוחה, כשהקוד הפרטי שמור מקומית ולא נשלח לשרתים חיצוניים.",
  "ABOUT_6":"3. האפליקציה מציעה גישה פשוטה ונוחה למשתמש.",
  "ABOUT_7":"4. האפליקציה לא מבקשת ממשתמשים מידע פרטי.",
  "ABOUT_8":"הצביעו ל-good-karma בתור עד",
  "ABOUT_9":"צור קשר",
  "ABOUT_10":"מידע נוסף:",
  "REMOVE":"הסרה",
  "MARKET_VIEW":"צפה בשוק",
  "PRICE":"מחיר",
  "AMOUNT":"כמות",
  "TOTAL":"סך הכל",
  "NOORDERS":"אין הזמנות פתוחות עבור",
  "DATE":"תאריך",
  "BUY":"קנייה",
  "SELL":"מכירה",
  "OPEN":"פתיחה",
  "HISTORY":"היסטוריה",
  "FOLLOW_BACK":"לעקוב",
  "FOLLOWED":"עוקב",
  "UNFOLLOW":"להפסיק לעקוב",
  "FOLLOWING":"עוקב",
  "FOLLOWERS":"עוקבים",
  "SEARCH_FOLLOWERS":"חיפוש בעוקבים אחריי",
  "SEARCH_FOLLOWING":"חיפוש במי שאני עוקב אחריו",
  "BY":"על ידי",
  "IN":"בתוך",
  "MENU":"תפריט",
  "BOOKMARK":"סימניה",
  "REBLOG":"עשו ריבלוג",
  "UPVOTE":"לייק",
  "DOWNVOTE":"אנלייק",
  "UNVOTE_DOWNVOTED":"ביטול אנלייק",
  "UNVOTE_UPVOTED":"ביטול לייק",
  "REPLY":"להשיב",
  "EDIT":"עריכה",
  "POST_1":"החלק את התגוה שמאלה לצפייה באפשרויות",
  "POST_2":"לחץ על תגובה כדי לראות תתי-תגובות",
  "OPTIONS":"אפשרויות",
  "RESTEEMED_BY":"עשו ריסטים",
  "NOTHING_HERE":"אין פה כלום עדיין...",
  "BALANCES":"כספים",
  "PROFILE_1":"{{platformname}}, מטבעות שניתנים להעברה בכל עת. ניתן להמיר {{platformname}} ל-{{platformpower}} בעזרת תהליך שנקרא פאוור-אפ.",
  "PROFILE_2":"{{platformpower}}, מטבעות השפעה שמוסיפים לכם כוח בהצבעה. ככל שיש לכם יותר, תוכלי להשפיע יותר על התשלום של פוסטים ותוכלו להרוויח רווחים גדולים יותר בהצבעה.",
  "PROFILE_3":"מטבעות ששויים {{platformsunit}} של {{platformname}}.",
  "ESTIMATED_VALUE":"ערך מוערך",
  "PROFILE_4":"הערך חושב על ידי ממוצע מחירים ב-7 הימים האחרונים של {{platformname}}.",
  "TRANSACTION_HISTORY":"היסטוריית פעולות",
  "POSTING":"העלאת פוסט",
  "PROFILE_5":"מפתח הפוסטים נועד לכתיבת פוסטים וללייקים. עליו להיות שונה מהמפתח הפעיל וממפתח המשתמש.",
  "OWNER":"בעלים",
  "PROFILE_6":"מפתח המשתמש הוא המפתח הראשי לחשבון והוא נחוץ על מנת לשנות מפתחות אחרים. המפתח הפרטי או הסיסמא לקבלת מפתח המשתמש חייבים להיות שמורים מחוץ לאתר.",
  "ACTIVE":"פעיל",
  "PROFILE_7":"המפתח הפעיל נועד לביצוע הברות כספים ולביצוע הזמנות בשוק הפנימי.",
  "MEMO":"הערה",
  "PROFILE_8":"מפתח התזיכירם נועד לכתיבת וקריאת תזכירים.",
  "BLOG":"בלוג",
  "POSTS":"פוסטים",
  "REPLIES":"תגובות",
  "WALLET":"ארנק",
  "TAG":"טאגים",
  "USER":"משתמש",
  "CLOSE":"סגור",
  "TO":"אל",
  "ASSET":"נכס",
  "SEND":"לשלוח",
  "SECURITY":"בטיחות",
  "AVAILABLE":"פנוי",
  "PUBLIC_MEMO":"הערה פומבית",
  "TO_DESC":"משתמש, לדוגמא good-karma",
  "PIN_CODE":"קוד",
  "PIN_TEXT":"קוד עוזר לכם לאבטח את האפילקציה ואת המידע שלכם. הערה: ברגע שהופעל, אפשר לנסות לפתוח עד 4 פעמים. אם שכחתם את הקוד, האפליקציה תמחק את המידע של המשתמש. תוכל להיכנס מחדש ולהשתמש באפליקציה.",
  "NOTIFICATIONS":"הודעות",
  "VOTE_TEXT":"תקבול הודעה כשמישהו יעשה לכם לייק! הערה: ההודעות יכללו גם את משקל הלייק (בין אם לייק, אנלייק, או ביטול לייק).",
  "VOTE":"להצביע",
  "COMMENT_TEXT":"תקבלו הודעה כשמישהו יגיב לפוסטים או לתגובות שלכם! הערה: תקבלו הודעה גם כשמישהו יערוך את התגובה שלו.",
  "COMMENT":"תגובה",
  "FOLLOW_TEXT":"תקבל הודעה כשמישהו יעקוב או יפסיק לעקוב אחריך!",
  "MENTIONS":"תזכורים",
  "MENTIONS_TEXT":"תקבל הודעה כשמישהו יזכיר אותך בפוסט או בתגובה!",
  "RESTEEM":"ריסטיים",
  "RESTEEM_TEXT":"תקבלו הודעה כשמישהו יעשה ריסטים לפוסט שלכם!",
  "CONFIGURATIONS":"קונפיגורציות",
  "VOTING":"הצבעות",
  "VOTING_TEXT":"משקל הלייק נותן לכם לשלוט בגודל הגמול שתקבלו. הערה: פעולה זו תשנה גם את המשקל עבור אנלייק",
  "SERVER":"שרת",
  "SERVER_TEXT":"מומלץ",
  "SAVE_CHANGES":"לשמור שינויים",
  "VOTERS_INFO":"מידע על מצביעים",
  "WELCOME_BACK":"ברוכים השבים!",
  "LOGIN_1":"היכנסו בעזרת שם המשתמש והסיסמא על מנת להמשיך.",
  "LOGIN_2":"מפתח הפוסטים נועד לכתיבת פוסטים ותגובות, וללייקים.",
  "LOGIN_3":"המפתח הפעיל נועד להעברות ולעדכון תמונת הפרופיל.",
  "LOGIN_4":"המידע על המשתמש שמור מקומית על המכשיר. כשמתנתקים המידע נמחק!",
  "DONT_HAVE":"אין לכם חשבון משתמש?",
  "SIGN_UP_NOW":"הרשמו עכשיו",
  "CANCEL":"ביטול",
  "ADVANCED":"מתקדם",
  "ACTIVE_PRIKEY":"מפתח פעיל",
  "POSTING_PRIKEY":"מפתח פוסטים",
  "MASTER_PASS":"מפתח ראשי",
  "USERNAME":"שם משתמש",
  "CARD_VIEW":"תצוגת כרטיסים",
  "COMPACT_VIEW":"תצוגה קומפקטית",
  "SEARCH":"חיפוש",
  "SUBMIT_A_STORY":"כתבו פוסט",
  "REPLYTO":"השיבו ל-",
  "POST":"פוסט",
  "PREVIEW":"תצוגה מקדימה",
  "DEFAULT":"ברירת מחדך 50% / 50%",
  "POWERUP":"פאוור-אפ 100%",
  "DECLINE_PAYOUT":"סרבו לתשלום",
  "SAVE_FOR_LATER":"שמרו למאוחר יותר",
  "CLEAR":"ניקוי",
  "POST_CONTENT":"תוכן הפוסט",
  "COMMENT_CONTENT":"תוכן התגובה",
  "TITLE":"כותרת",
  "TAGS":"טאגים",
  "NOT_MATCH":"לא מתאים",
  "CONFIRM_PIN":"אשר קוד",
  "INCORRECT":"שגוי",
  "OPENING_POST":"פותח פוסט",
  "SET_PIN":"קבעו קוד",
  "ENTER_PIN":"הזינו קוד",
  "ARE_YOU_SURE":"בטוחים?",
  "REBLOG_TEXT":"אי אפשר לבטל ריסטים, תרצו להמשיך?",
  "BROADCAST_ERROR":"בעיית תקשורת, נסה שוב!",
  "SUCCESS":"הצלחה",
  "REBLOGGED_POST":"עשיתם לפוסט ריבלוג!",
  "LOGIN_FAIL":"הכניסה נכשלה! אנא ודאו שנכנסתם עם הסיסמא הראשית או שהזנתם את מפתח הפוסטים אם ניסיתם להיכנס במצב מתקדמת.",
  "LOGIN_FAIL_A":"הכניסה נכשלה! אנא ודאו שנכנסתם עם הסיסמא הראשית או שהזנתם את המפתח הפעיל אם ניסיתם להיכנס במצב מתקדמת.",
  "WARNING":"אזהרה",
  "VOTE_FOR_WITNESS":"הצבעה לעד",
  "VOTED_FOR_WITNESS":"הצבעה לעד בוצעה",
  "AGO":"לפני",
  "FROM_NOW":"מעכשיו",
  "SECS":"שניות",
  "A_MIN":"דקה",
  "MINS":"דקות",
  "AN_HOUR":"שעה",
  "HOURS":"שעות",
  "A_DAY":"יום",
  "DAYS":"ימים",
  "A_MONTH":"חודש",
  "MONTHS":"חודשים",
  "A_YEAR":"שנה",
  "YEARS":"שנים",
  "MIN_READ":"דקות קריאה",
  "DOWNVOTE_FLAG":"עשו אנלייק",
  "CAPTURE_PICTURE":"צלמו תמונה",
  "SELECT_PICTURE":"בחר תמונה",
  "SET_CUSTOM_URL":"קבעו כתובת אישית",
  "INSERT_PICTURE":"הכנסה תמונה",
  "ERROR":"שגיאה",
  "UPLOAD_ERROR":"שגיאה בהעלאה",
  "CAMERA_CANCELLED":"מצלמה בוטלה",
  "SET_URL":"קבעו קישור",
  "DIRECT_LINK_PICTURE":"קישור לתמונה",
  "COMMENT_SUBMITTED":"התגובה נשלחה!",
  "DELETE_COMMENT":"אי אפשר לשחזר תגובה שנמחקה...",
  "DELETED_COMMENT":"תגובה נמחקה",
  "UPLOADING_PICTURE":"מעלה תמונה",
  "UPLOAD_COMPLETED":"תמונה הועלתה",
  "UPLOAD_FAILED":"העלאה נכשלה",
  "PASSWORD_INCORRECT":"הסיסמה או שם המתשמש שגויים",
  "INFO":"מידע",
  "QR_TEXT":"שימו קוד QR בתוך אזור הקריאה",
  "BALANCE_TEXT":"בדקו שיש לכם מספיק כספים להעברה!",
  "NONEXIST_USER":"המשתמש שאליו ניסיתם להעביר כספים לא קיים!",
  "TRANSFER_TEXT":"בטוח שתרצו להעביר את הכספים?",
  "CONFIRMATION":"אישור",
  "TX_BROADCASTED":"הפעולה נשלחה",
  "FEED":"פיד",
  "TRENDING":"מצליח",
  "HOT":"חם",
  "NEW":"חדש",
  "PROMOTED":"מקודמים",
  "VOTES":"לייקים",
  "PAYOUT":"תשלום",
  "COMMENTS":"תגובות",
  "TRENDING_30":"חמים ב-30 הימים האחרונים",
  "SORT_POST_BY":"מיינו לפי:",
  "PAYOUT_CYCLE":"זמן תשלום",
  "POTENTIAL_PAYOUT":"תשלום עתידי",
  "PAST_PAYOUT":"תשלום עבר",
  "AUTHOR_PAYOUT":"תשלום לכותב",
  "CURATION_PAYOUT":"תשלום למשגיחים",
  "POST_SUBMITTED":"הפוסט נשלח!",
  "POST_LATER":"לשלוח מאוחר יותר",
  "SAVED":"נשמר",
  "CLEARED":"נוקה",
  "FLAGGING_TEXT":"אנלייק לפוסט מחסיר מהתשלום והופך אותו לפחות נראה. אנלייק מיועד למקרים הבאים: העתקה, גזענות, דברי שנאה, טרולינג, ספאם",
  "REQUEST_LIMIT_TEXT":"הגעתם לגבול מספר הבקשות. בדקו טאגים אחרים!",
  "POST_IS_UNBOOKMARK":"הפוסט הוסר מהסימניות!",
  "POST_IS_BOOKMARK":"הפוסט נשמר בסימניות!",
  "RESET":"איתחול",
  "MODIFY_PICTURE":"לשנות תמונת פרופיל",
  "MODIFY_COVER_PICTURE":"לשנות תמונת כותרת",
  "ACTIVE_KEY_REQUIRED_TEXT":"אנא הוסיפו מפתח פעיל אם תרצו להיכנס למצב מתקדם!",
  "RESET_PICTURE_TEXT":"תמונת הפרופיל תאותחל",
  "RESET_COVER_PICTURE_TEXT":"תמונת הכותרת תאותחל",
  "UPDATE_REQUIRES_RESTART":"עדכון השרת דורש אתחול!",
  "SETTINGS_UPDATED":"ההגדרות עודכנו!",
  "LANGUAGES":"שפות",
  "LANGUAGES_TEXT":"כאן ניתן לשנות את השפה.",
  "LOGIN_TO_X":"פעולה זו דורשת מהמשתמש להיות רשום עם הסיסמא הראשית והמפתח הפעיל או מפתח הפסוט. אנא כנסו ונסו שנית.",
  "GALLERY":"גלריה",
  "TRANSLATIONS":"מתרגמים",
  "SHARE":"שתף",
  "MARKETPLACE":"השוק",
  "EXCHANGE":"מסחר",
  "DRAFTS":"טיוטות",
  "POST_IS_UNDRAFT":"הפוסט הוסר מהטיוטות!",
  "POST_IS_DRAFT":"הפוסט התווסף לטיוטות!",
  "SWIPE_LEFT":"החליקו שמאלה בשביל אפשרויות",
  "MANAGE":"ניהול",
  "IMAGE_REMOVED":"התמונה הוסרה",
  "COPY":"העתק",
  "NO_IMAGE":"עוד לא העלית תמונה!",
  "PULL_DOWN_TO_REFRESH":"משכו למטה כדי לרענן",
  "EXTERNAL_APPS":"יישומים חיצוניים",
  "PLUGINS":"תוספות",
  "SUGGEST":"הצע לקריאה",
  "COMING_SOON":"בקרוב",
  "CHAIN":"שרשרת",
  "CHAIN_TEXT":"כאן תוכלו לשנות בלוקצ'יין או את ברירת המחדל",
  "CURRENCY":"מטבע",
  "CURRENCY_TEXT":"כאן תוכלו לשנות את מטבע ברירת המחדל שלכם. השווי של פוסט\\תגובה יופיע במטבע זה.",
  "ABOUT_11":"<br><b>רשימת שימושים בפלטפורמה</b> <br>-גישה למאמרים יחודיים בכל נושא שתהיו מעוניינים לקרוא. <br> -התחברו לכותבים דרך תגובות ודיונים. <br>-הצבעה עבור פוסטים להענקת גמול, והרווחת גמול עבור הצבעות. <br>-פרסמו מאמרים ופוסטים, הרוויחו תגמולים ומצאו אנשים שיעקבו אחרי הבלוג שלכם. <br>-כתיבת מאמרים דינמית, שמירת קבות של הפוסט לפרסום מאוחר יותר. <br>- שמרו מאמרים לקריאה במועד מאוחר יותר. <br>- פדו את הרווחים שלכם. <br>-שלחו כספים לחברים או למשתמשים אחרים <br>- עקבו אחרי סופרים ובלוגרים מעניינים. <br> -חיפוש בעוקבים שלכם ובמי שעוקב אחריכם. <br>-קבלו הודעות על מנת להישאר בעניינים עם עוקבים ועם ודיונים שאתם מערובים בהם. <br>-חיפוש תגיות/קטגוריות מעניינות של מאמרים וכותבים. <br> -התאמה אישית של הפרופיל שלך. <br>-עוד הרבה פונקציות בדרך. <br><br><b>אבטחה</b> <br>1. לאפליקציה אין גישה לכספי המשתמש. <br>2. האפליקציה מציעה מודל אבטחה בצד הלקוח, עם מפתחות פרטיים השמורים באופן מקומי ושאינם נשלחים לשרתים, אתם אחראים לגיבוי הסיסמאות שלכם. <br>3. האפליקציה מציעה ממשק וחוויה אטרקטיבית למשתמש <br>4. האפליקציה מציעה שכבה נוספת של ביטחון עם קוד <br><br> eSteem תומך בפלטפורמות Steem ו-Golos. <br>",
  "FOUNDER":"מייסד ומפתח ראשי",
  "ADD_ACCOUNT":"הוסף משתמש",
  "PLATFORM":"פלטפורמה"
}
},{}],147:[function(require,module,exports){
module.exports={
  "HOME":"Kezdőlap",
  "LOGIN":"Bejelentkezés",
  "LOGOUT":"Kijelentkezés",
  "PROFILE":"Profil",
  "FOLLOW":"Követés",
  "BOOKMARKS":"Könyvjelzők",
  "TRANSFER":"Átutalás",
  "MARKET":"Piac",
  "SETTINGS":"Beállítások",
  "ABOUT":"Rólunk",
  "ABOUT_1":"ahol bárki kaphat jutalmakat a tartalmaiért!",
  "ABOUT_2":"a {{platformname}} platform üzemelteti. Az alkalmazás készítője",
  "ABOUT_3":"és nyílt forráskódú, közösség által működtetett projekt. Támogatja a tartalomhozzáférést olvasásért, a hozzászólást, szavazást, posztolást, fizetség átutalását, stb. funkciókat, amiket a {{platformname}} blokklánc és a {{sitename}} kínálnak.",
  "ABOUT_4":"1. Az alkalmazás soha nem fér hozzá vagy tárolja a felhasználók pénzét.",
  "ABOUT_5":"2. Az alkalmazás kliens oldali biztonsági modellt kínál, a privát kulcsok helybeni tárolásával, amik soha nem kerülnek elküldésre semmilyen szerverre.",
  "ABOUT_6":"3. Az alkalmazás egyszerű, tetszetős felhasználói felületet és -élményt nyújt.",
  "ABOUT_7":"4. Az alkalmazás soha nem kéri a felhasználókat a személyes adataik megadására.",
  "ABOUT_8":"Szavazz good-karma -ra mint tanú",
  "ABOUT_9":"Kapcsolat/Visszajelzés:",
  "ABOUT_10":"Több infó:",
  "REMOVE":"Eltávolítás",
  "MARKET_VIEW":"Piac Nézet",
  "PRICE":"Ár",
  "AMOUNT":"Összeg",
  "TOTAL":"Összesen",
  "NOORDERS":"Nincs nyitott megbízás",
  "DATE":"Dátum",
  "BUY":"Vétel",
  "SELL":"Eladás",
  "OPEN":"Nyitás",
  "HISTORY":"Történet",
  "FOLLOW_BACK":"Visszakövetés",
  "FOLLOWED":"Követve",
  "UNFOLLOW":"Követés megszüntetése",
  "FOLLOWING":"Követettek",
  "FOLLOWERS":"Követők",
  "SEARCH_FOLLOWERS":"Követők keresése",
  "SEARCH_FOLLOWING":"Követettek keresése",
  "BY":"által",
  "IN":"itt:",
  "MENU":"Menü",
  "BOOKMARK":"Könyvjelzők",
  "REBLOG":"Újrablogolás",
  "UPVOTE":"Felszavazás",
  "DOWNVOTE":"Leszavazás",
  "UNVOTE_DOWNVOTED":"Leszavazás eltávolítása",
  "UNVOTE_UPVOTED":"Felszavazás eltávolítása",
  "REPLY":"Válasz",
  "EDIT":"Szerkesztés",
  "POST_1":"Csúsztass balra a hozzászólásokon, hogy lásd az opciókat",
  "POST_2":"Koppints a hozzászólásokon, hogy lásd az al-hozzászólásokat",
  "OPTIONS":"Opciók",
  "RESTEEMED_BY":"Újraosztva általa:",
  "NOTHING_HERE":"Semmi sincs itt még...",
  "BALANCES":"Egyenlegek",
  "PROFILE_1":"{{platformname}}, eladható tokenek, amelyeket át lehet utalni bármikor.\n{{platformname}} konvertálható {{platformpower}} -é egy folyamatban, amit feltöltésnek nevezünk.",
  "PROFILE_2":"{{platformpower}}, befolyásoló tokenek, amik több erőt kapnak a hosszú távú birtoklásukért és a posztok felszavazásáért. Minél többet birtokol belőle valaki, annál jobban tudja befolyásolni mások jutalmait és kap több jutalmat az alapos szavazásért.",
  "PROFILE_3":"Tokenek, amik körülbelül {{platformsunit}} -nyi {{platformname}} -et érnek.",
  "ESTIMATED_VALUE":"Becsült Érték",
  "PROFILE_4":"A becsült érték a {{platformname}} 7 napos átlagos értékén alapszik.",
  "TRANSACTION_HISTORY":"Átutalás Történet",
  "POSTING":"Posztolás",
  "PROFILE_5":"A posztoló kulcs posztolásra és szavazásra használatos. Különbözőnek kell lennie az aktív és a tulajdonosi kulcsoktól.",
  "OWNER":"Tulajdonos",
  "PROFILE_6":"A tulajdonos kulcs egy mesterkulcs a számlához és kötelező a többi kulcs megváltoztatásához. A tulajdonosi kulcs privát kulcsát vagy jelszavát titokban és offline kell tartani, amennyire csak lehetséges.",
  "ACTIVE":"Aktív",
  "PROFILE_7":"Az aktív kulcs használatos az átutalások indításához és a megbízások bejegyzéséhez a belső piacon.",
  "MEMO":"Feljegyzés",
  "PROFILE_8":"A feljegyzés kulcs használatos feljegyzések készítésére és olvasására.",
  "BLOG":"",
  "POSTS":"Posztok",
  "REPLIES":"Válaszok",
  "WALLET":"Tárca",
  "TAG":"Címke",
  "USER":"Felhasználó",
  "CLOSE":"Bezár",
  "TO":"Neki",
  "ASSET":"Vagyontárgy",
  "SEND":"Küld",
  "SECURITY":"Biztonság",
  "AVAILABLE":"Rendelkezésre áll",
  "PUBLIC_MEMO":"Nyilvános feljegyzés",
  "TO_DESC":"Felhasználó, pl. good-karma",
  "PIN_CODE":"PIN-kód",
  "PIN_TEXT":"A PIN-kód segít hogy megóvd az alkalmazásod és az adataid. <br/><br/><b>Megjegyzés:</b> Miután alkalmazva van, max. 4 próbálkozási lehetőséged van hogy felnyisd; ha elfelejted a PIN-t vagy hibázol, az alkalmazás el fogja távolítani minden bejelentkezett felhasználói adatot. Vissza tudsz jelentkezni és folytathatod az alkalmazás használatát.",
  "NOTIFICATIONS":"Értesítések",
  "VOTE_TEXT":"Értesítéseket kapsz, amikor valaki szavaz a bejegyzésedre! br/> <b>Megjegyzés:</b> Az értesítések tartalmazzák a szavazás súlyozását a figyelmeztető üzenetben is (Legyen az felszavazás, leszavazás vagy szavazat visszavonása).",
  "VOTE":"Szavazás",
  "COMMENT_TEXT":"Értesítést kapsz ha valaki hozzászól a posztodhoz vagy a hozzászólásodhoz! <br/> <b>Megjegyzés:</b> Az értesítések tartalmazzák azt is, amikor valaki <b>szerkeszti</b> a hozzászólásait.",
  "COMMENT":"Hozzászólás",
  "FOLLOW_TEXT":"Értesítést kapsz, amikor valaki Követ téged vagy Visszavonja a követést!",
  "MENTIONS":"Említések",
  "MENTIONS_TEXT":"Értesítéseket kapsz, amikor valaki megemlít téged egy posztban/hozzászólásban!",
  "RESTEEM":"",
  "RESTEEM_TEXT":"Értesítést kapsz, amikor valaki resteemeli a posztodat!",
  "CONFIGURATIONS":"Konfiguráció",
  "VOTING":"Szavazás",
  "VOTING_TEXT":"A szavazat súlyozása vagy százaléka a szavazati erőre van kihatással az alkalmazásban, így szabályozni tudod a szavazási jutalmaid. <br/><br/><b>Megjegyzés:</b> Ez a leszavazás szavazati erejét/százalékát is meg fogja változtatni és mindenütt érvényes az alkalmazáson belül.",
  "SERVER":"Szerver",
  "SERVER_TEXT":"Ajánlott",
  "SAVE_CHANGES":"Változtatások Mentése",
  "VOTERS_INFO":"Infó a szavazókról",
  "WELCOME_BACK":"Üdv újra!",
  "LOGIN_1":"A folytatáshoz jelentkezz be a felhasználóneveddel és jelszavaddal.",
  "LOGIN_2":"A posztoló kulcs a posztokhoz, hozzászólásokhoz, szavazáshoz és követéshez használatos.",
  "LOGIN_3":"Az aktív kulcs az utalásokhoz és a profilkép frissítéséhez használatos.",
  "LOGIN_4":"A felhasználó bejelentkezési adatai helyileg vannak tárolva a készüléken. Kijelentkezéskor a bejelentkezési adatok eltávolítódnak!",
  "DONT_HAVE":"Nincs még fiókod?",
  "SIGN_UP_NOW":"Regisztrálj most",
  "CANCEL":"Mégse",
  "ADVANCED":"Haladó",
  "ACTIVE_PRIKEY":"Aktív privát kulcs",
  "POSTING_PRIKEY":"Posztoló privát kulcs",
  "MASTER_PASS":"Mester/fő jelszó",
  "USERNAME":"Felhasználónév",
  "CARD_VIEW":"Kártya nézet",
  "COMPACT_VIEW":"Kompakt nézet",
  "SEARCH":"Keresés",
  "SUBMIT_A_STORY":"Cikk beküldése",
  "REPLYTO":"Válasz neki",
  "POST":"Poszt",
  "PREVIEW":"Előnézet",
  "DEFAULT":"Alapértelmezett 50% / 50%",
  "POWERUP":"Feltöltés 100%",
  "DECLINE_PAYOUT":"Kifizetés Elutasítása",
  "SAVE_FOR_LATER":"MENTÉS KÉSŐBBRE",
  "CLEAR":"TÖRLÉS",
  "POST_CONTENT":"Tartalom posztolása",
  "COMMENT_CONTENT":"Hozzászólás tartalomhoz",
  "TITLE":"Cím",
  "TAGS":"Címkék",
  "NOT_MATCH":"NEM ILLIK ÖSSZE",
  "CONFIRM_PIN":"PIN megerősítése",
  "INCORRECT":"NEM MEGFELELŐ",
  "OPENING_POST":"nyitó poszt",
  "SET_PIN":"PIN beállítása",
  "ENTER_PIN":"PIN megadása",
  "ARE_YOU_SURE":"Biztos vagy benne?",
  "REBLOG_TEXT":"A resteem visszavonhatatlan, biztos vagy benne?",
  "BROADCAST_ERROR":"Terjesztési hiba, próbáld újra.",
  "SUCCESS":"Siker",
  "REBLOGGED_POST":"Újrablogolt poszt!",
  "LOGIN_FAIL":"A belépés nem sikerült! Kérlek győződj meg róla, hogy a mesterjelszavaddal léptél be vagy megadtad a Posztoló privát kulcsot, ha a Haladó módot választottad Bejelentkezéskor.",
  "LOGIN_FAIL_A":"A belépés nem sikerült! Kérlek győződj meg róla, hogy a mesterjelszavaddal léptél be vagy megadtad az Aktív privát kulcsot, ha a Haladó módot választottad Bejelentkezéskor.",
  "WARNING":"Figyelmeztetés",
  "VOTE_FOR_WITNESS":"Szavazás tanúra",
  "VOTED_FOR_WITNESS":"Szavaztál tanúra",
  "AGO":"óta",
  "FROM_NOW":"mostantól",
  "SECS":"másodperc",
  "A_MIN":"egy perc",
  "MINS":"percek",
  "AN_HOUR":"egy óra",
  "HOURS":"óra",
  "A_DAY":"egy nap",
  "DAYS":"napok",
  "A_MONTH":"egy hónap",
  "MONTHS":"hónapok",
  "A_YEAR":"egy év",
  "YEARS":"évek",
  "MIN_READ":"perc olvasás",
  "DOWNVOTE_FLAG":"Leszavazás vagy Jelentés",
  "CAPTURE_PICTURE":"Kép Készítés",
  "SELECT_PICTURE":"Kép Kiválasztás",
  "SET_CUSTOM_URL":"Egyedi URL Beállítás",
  "INSERT_PICTURE":"Kép Beillesztés",
  "ERROR":"Hiba",
  "UPLOAD_ERROR":"Feltöltési Hiba",
  "CAMERA_CANCELLED":"Kamera Törölve",
  "SET_URL":"URL beállítás",
  "DIRECT_LINK_PICTURE":"Direkt web link a képhez",
  "COMMENT_SUBMITTED":"A hozászólás elküldve!",
  "DELETE_COMMENT":"A hozzászólások törlése visszavonhatatlan...",
  "DELETED_COMMENT":"Törölt hozzászólás",
  "UPLOADING_PICTURE":"Kép feltöltése",
  "UPLOAD_COMPLETED":"Feltöltés Kész",
  "UPLOAD_FAILED":"Feltöltés Meghiúsult",
  "PASSWORD_INCORRECT":"A jelszó vagy felhasználónév hibás volt",
  "INFO":"Infó",
  "QR_TEXT":"Helyezz egy QR-kódot a leolvasási területbe",
  "BALANCE_TEXT":"Győződj meg róla, hogy elegendő egyenleged van az utaláshoz!",
  "NONEXIST_USER":"A felhasználó, akinek utalni próbálsz, nem létezik!",
  "TRANSFER_TEXT":"Biztos vagy benne, hogy utalni akarsz?",
  "CONFIRMATION":"Megerősítés",
  "TX_BROADCASTED":"A tranzakció közvetítve",
  "FEED":"Hírfolyam",
  "TRENDING":"Népszerű",
  "HOT":"Forró",
  "NEW":"Új",
  "PROMOTED":"Támogatott",
  "VOTES":"Szavazatok",
  "PAYOUT":"Kifizetés",
  "COMMENTS":"Hozzászólások",
  "TRENDING_30":"Népszerű 30 napra",
  "SORT_POST_BY":"Posztok rendezése:",
  "PAYOUT_CYCLE":"Kifizetési Ciklus",
  "POTENTIAL_PAYOUT":"Lehetséges Kifizetés",
  "PAST_PAYOUT":"Régi Kifizetés",
  "AUTHOR_PAYOUT":"Szerzői Kifizetés",
  "CURATION_PAYOUT":"Kurátori Kifizetés",
  "POST_SUBMITTED":"A poszt beküldve!",
  "POST_LATER":"Poszt későbbi beküldésre!",
  "SAVED":"Mentve",
  "CLEARED":"Törölve",
  "FLAGGING_TEXT":"Egy poszt jelentése el tudja távolítani a jutalmakat és kevésbé láthatóvá teszi ezt az anyagot.<br><br>A jelentést a következőkre kellene használni: <ul><li>Csalás vagy Plagizálás</li><li>Gyűlölet beszéd vagy Internet Trollkodás</li><li>Tudatosan félrekategorizált tartalom vagy Spam</li></ul>",
  "REQUEST_LIMIT_TEXT":"Kérési limit elérve. Nézz meg más trendet/címkét!",
  "POST_IS_UNBOOKMARK":"A poszt eltávolítva a könyvjelzők közül!",
  "POST_IS_BOOKMARK":"A poszt hozzáadva a könyvjelzőkhöz!",
  "RESET":"Visszaállítás",
  "MODIFY_PICTURE":"Profilkép Módosítása",
  "MODIFY_COVER_PICTURE":"Borítókép Módosítása",
  "ACTIVE_KEY_REQUIRED_TEXT":"Kérlek add meg az Aktív privát kulcsot, ha a Haladó belépési módot választottad!",
  "RESET_PICTURE_TEXT":"Ez vissza fogja állítani a profilképet",
  "RESET_COVER_PICTURE_TEXT":"Ez vissza fogja állítani a borítóképet",
  "UPDATE_REQUIRES_RESTART":"A szerver frissítése megköveteli az Újraindítást.",
  "SETTINGS_UPDATED":"Beállítások frissítve!",
  "LANGUAGES":"Nyelvek",
  "LANGUAGES_TEXT":"Itt tudod megváltoztatni az alkalmazás nyelvét.",
  "LOGIN_TO_X":"Ez a művelet megköveteli, hogy a felhasználó a fő jelszavával, aktív/posztoló kulcsával legyen bejelentkezve. Kérlek lépj be és próbáld újra.",
  "GALLERY":"Galéria",
  "TRANSLATIONS":"A fordítás közreműködői",
  "SHARE":"Megosztás",
  "MARKETPLACE":"Piactér",
  "EXCHANGE":"Váltó",
  "DRAFTS":"Piszkozat",
  "POST_IS_UNDRAFT":"A bejegyzés eltávolítva a piszkozatokból!",
  "POST_IS_DRAFT":"A bejegyzés hozzáadva a piszkozatokhoz!",
  "SWIPE_LEFT":"Csúsztass balra az opciókért",
  "MANAGE":"Kezelés",
  "IMAGE_REMOVED":"Kép törölve",
  "COPY":"Másolás",
  "NO_IMAGE":"Még nem töltöttél fel semmilyen képet!",
  "PULL_DOWN_TO_REFRESH":"Húzd le a frissítéshez",
  "EXTERNAL_APPS":"Külső Alkalmazások",
  "PLUGINS":"Beépülők",
  "SUGGEST":"Javasol",
  "COMING_SOON":"Hamarosan megjelenik",
  "CHAIN":"Lánc",
  "CHAIN_TEXT":"Itt tudsz blokkláncot vagy alapértelmezett felületet cserélni.",
  "CURRENCY":"",
  "CURRENCY_TEXT":"",
  "ABOUT_11":"",
  "FOUNDER":"",
  "ADD_ACCOUNT":"",
  "PLATFORM":""
}
},{}],148:[function(require,module,exports){
module.exports={
  "HOME":"Beranda",
  "LOGIN":"Masuk",
  "LOGOUT":"Keluar",
  "PROFILE":"Profil",
  "FOLLOW":"Ikuti",
  "BOOKMARKS":"",
  "TRANSFER":"",
  "MARKET":"",
  "SETTINGS":"Setelan",
  "ABOUT":"Tentang",
  "ABOUT_1":"Siapapun bisa mendapatkan keuntungan dari konten",
  "ABOUT_2":"Applikasi dibuat oleh",
  "ABOUT_3":"dan ini adalah open source, proyek mobile berbasis masyarakat. Ini menawarkan akses konten untuk membaca, berkomentar, voting, posting, mentransfer pendapatan, dll fitur yang ditawarkan oleh {{platformname}} blockchain dan {{sitename}}.",
  "ABOUT_4":"1. App tidak pernah mengakses atau memegang dana pengguna.",
  "ABOUT_5":"2. App menawarkan model keamanan client-side, dengan kunci pribadi host secara lokal dan tidak pernah dikirim ke server.",
  "ABOUT_6":"3. App menawarkan sederhana, user interface yang menarik dan pengalaman.",
  "ABOUT_7":"4. App tidak pernah mengharuskan pengguna untuk memasukkan informasi pribadi apapun.",
  "ABOUT_8":"Pilih good-karma sebagai witness",
  "ABOUT_9":"Kontak/Saran:",
  "ABOUT_10":"Info lebih lanjut:",
  "REMOVE":"Menghapus",
  "MARKET_VIEW":"Pasar",
  "PRICE":"Harga",
  "AMOUNT":"Jumlah",
  "TOTAL":"",
  "NOORDERS":"No open order untuk",
  "DATE":"Tanggal",
  "BUY":"Beli",
  "SELL":"Jual",
  "OPEN":"Buka",
  "HISTORY":"Riwayat",
  "FOLLOW_BACK":"",
  "FOLLOWED":"",
  "UNFOLLOW":"",
  "FOLLOWING":"Mengikuti",
  "FOLLOWERS":"Pengikut",
  "SEARCH_FOLLOWERS":"Mencari Pengikut",
  "SEARCH_FOLLOWING":"Mencari Mengikuti",
  "BY":"oleh",
  "IN":"dalam",
  "MENU":"",
  "BOOKMARK":"",
  "REBLOG":"",
  "UPVOTE":"",
  "DOWNVOTE":"",
  "UNVOTE_DOWNVOTED":"Batalkan Downvote\n",
  "UNVOTE_UPVOTED":"Batalkan Upvoted\n",
  "REPLY":"Balas",
  "EDIT":"",
  "POST_1":"Geser ke kiri pada komentar untuk melihat opsi",
  "POST_2":"Ketuk pada komentar untuk melihat sub-komentar",
  "OPTIONS":"Opsi",
  "RESTEEMED_BY":"Resteemed Oleh",
  "NOTHING_HERE":"Tidak ada di sini...",
  "BALANCES":"Saldo",
  "PROFILE_1":"{{Platformname}}, token tradeable yang dapat ditransfer kapan saja. {{Platformname}} dapat dikonversi ke {{kekuatan platform yang}} dalam proses yang disebut powering up.",
  "PROFILE_2":"{{Platformpower}}, mempengaruhi token yang mendapatkan lebih banyak kekuatan untuk memegang jangka panjang dan suara pada posting. Semakin satu memegang lebih satu dapat mempengaruhi imbalan lain dan mendapatkan imbalan untuk voting akurat.",
  "PROFILE_3":"Token bernilai sekitar {{platformsunit}} dari {{platformname}}.",
  "ESTIMATED_VALUE":"Perkiraan Nilai",
  "PROFILE_4":"Nilai estimasi ini didasarkan pada nilai rata-rata 7 hari {{platformname}}.",
  "TRANSACTION_HISTORY":"Sejarah Transaksi",
  "POSTING":"Postingan",
  "PROFILE_5":"Kunci postingan digunakan untuk posting dan voting. Ini harus berbeda dari tombol aktif dan pemilik.",
  "OWNER":"Pemilik",
  "PROFILE_6":"Kunci pemilik adalah kunci master untuk account dan diperlukan untuk mengubah kunci lainnya. Kunci pribadi atau password untuk kunci pemilik harus disimpan secara offline sebanyak mungkin.",
  "ACTIVE":"Aktif",
  "PROFILE_7":"Kunci aktif digunakan untuk melakukan transfer dan tempat order di pasar internal.",
  "MEMO":"",
  "PROFILE_8":"Kunci memo digunakan untuk membuat dan membaca memo.",
  "BLOG":"",
  "POSTS":"Post",
  "REPLIES":"Balasan",
  "WALLET":"Dompet",
  "TAG":"",
  "USER":"",
  "CLOSE":"Tutup",
  "TO":"Kepada",
  "ASSET":"Aset",
  "SEND":"Kirim",
  "SECURITY":"Keamanan",
  "AVAILABLE":"Tersedia",
  "PUBLIC_MEMO":"Memo publik",
  "TO_DESC":"",
  "PIN_CODE":"Kode Pin",
  "PIN_TEXT":"Kode PIN membantu Anda untuk mengamankan aplikasi dan data Anda. <br/><br/> <b>Catatan:</b> Setelah diaktifkan, Anda memiliki max 4 mencoba untuk membuka, jika Anda lupa pin atau gagal, aplikasi akan hapus login data pengguna. Anda dapat login kembali dan terus menggunakan aplikasi.",
  "NOTIFICATIONS":"Notifikasi",
  "VOTE_TEXT":"Anda akan mendapatkan notifikasi ketika seseorang memberikan suara konten Anda! <br/> <b>Catatan:</b> Pemberitahuan termasuk suara berat serta dalam pesan peringatan. (Baik itu up-vote, down-vote, un-vote).",
  "VOTE":"Voting",
  "COMMENT_TEXT":"Anda akan mendapatkan notifikasi ketika seseorang komentar pada posting atau komentar!<br/> <b>Catatan:</b> Pemberitahuan termasuk ketika seseorang <b>Sunting</b> komentar mereka juga.",
  "COMMENT":"Komentar",
  "FOLLOW_TEXT":"Anda akan mendapatkan notifikasi ketika seseorang Follow atau Unfollow Anda!",
  "MENTIONS":"Menyebutkan",
  "MENTIONS_TEXT":"Anda akan mendapatkan pemberitahuan bila seseorang menyebutkan Anda dalam postingan mereka/komentar!",
  "RESTEEM":"",
  "RESTEEM_TEXT":"Anda akan mendapatkan notifikasi ketika seseorang resteems posting Anda!\n",
  "CONFIGURATIONS":"Konfigurasi",
  "VOTING":"",
  "VOTING_TEXT":"Kekuatan Voting atau persentase mempengaruhi hak suara pada aplikasi, sehingga Anda dapat mengatur reward Voting Anda. <br/><br/><b>Catatan:</b> ini akan mengubah kekuatan voting/persentase untuk downvoting juga dan itu adalah di mana-mana pada aplikasi",
  "SERVER":"",
  "SERVER_TEXT":"Direkomendasikan",
  "SAVE_CHANGES":"Simpan perubahan",
  "VOTERS_INFO":"",
  "WELCOME_BACK":"Selamat Datang kembali!",
  "LOGIN_1":"Masuk dengan nama pengguna dan password untuk melanjutkan.",
  "LOGIN_2":"Posting kunci digunakan untuk posting, komentar, voting, follow.",
  "LOGIN_3":"Active kunci digunakan untuk transfer dan memperbarui gambar profil.",
  "LOGIN_4":"kredensial pengguna disimpan secara lokal pada perangkat. Setelah Keluar kredensial dihapus!",
  "DONT_HAVE":"Tidak memiliki akun?",
  "SIGN_UP_NOW":"Daftar Sekarang",
  "CANCEL":"Batal",
  "ADVANCED":"Lanjutan",
  "ACTIVE_PRIKEY":"Kunci aktif pribadi",
  "POSTING_PRIKEY":"Kunci Posting Pribadi",
  "MASTER_PASS":"Master/password utama",
  "USERNAME":"Nama Pengguna",
  "CARD_VIEW":"",
  "COMPACT_VIEW":"",
  "SEARCH":"Cari",
  "SUBMIT_A_STORY":"",
  "REPLYTO":"Balas ke",
  "POST":"posting",
  "PREVIEW":"",
  "DEFAULT":"",
  "POWERUP":"",
  "DECLINE_PAYOUT":"",
  "SAVE_FOR_LATER":"SIMPAN UNTUK NANTI",
  "CLEAR":"BERSIHKAN",
  "POST_CONTENT":"Posting konten",
  "COMMENT_CONTENT":"Konten komentar",
  "TITLE":"Judul",
  "TAGS":"",
  "NOT_MATCH":"TIDAK COCOK",
  "CONFIRM_PIN":"Konfirmasi Pin",
  "INCORRECT":"SALAH",
  "OPENING_POST":"Post pembukaan",
  "SET_PIN":"",
  "ENTER_PIN":"Masukan PIN",
  "ARE_YOU_SURE":"Apakah anda yakin?",
  "REBLOG_TEXT":"Resteem ireversibel, apakah Anda ingin melanjutkan?",
  "BROADCAST_ERROR":"Siaran error, coba lagi!",
  "SUCCESS":"Sukses",
  "REBLOGGED_POST":"",
  "LOGIN_FAIL":"Gagal masuk! Pastikan Anda telah login dengan password master atau tersedia Posting kunci pribadi pada Login jika Anda telah choosed mode Advanced.",
  "LOGIN_FAIL_A":"Gagal masuk! Pastikan Anda telah login dengan password master atau disediakan kunci pribadi Aktif di Login jika Anda telah memilih mode Advanced.",
  "WARNING":"Peringatan",
  "VOTE_FOR_WITNESS":"Voting untuk witness",
  "VOTED_FOR_WITNESS":"Voted untuk witness",
  "AGO":"lalu",
  "FROM_NOW":"dari sekarang",
  "SECS":"detik",
  "A_MIN":"semenit",
  "MINS":"menit",
  "AN_HOUR":"sejam",
  "HOURS":"jam",
  "A_DAY":"sehari",
  "DAYS":"hari",
  "A_MONTH":"sebulan",
  "MONTHS":"bulan",
  "A_YEAR":"setahun",
  "YEARS":"tahun",
  "MIN_READ":"min baca",
  "DOWNVOTE_FLAG":"",
  "CAPTURE_PICTURE":"Ambil Gambar",
  "SELECT_PICTURE":"Pilih Gambar",
  "SET_CUSTOM_URL":"",
  "INSERT_PICTURE":"Masukan Gambar",
  "ERROR":"",
  "UPLOAD_ERROR":"",
  "CAMERA_CANCELLED":"Kamera Dibatalkan",
  "SET_URL":"",
  "DIRECT_LINK_PICTURE":"Direct web link utuk Gambar",
  "COMMENT_SUBMITTED":"Komentar disampaikan!",
  "DELETE_COMMENT":"Menghapus komentar adalah ireversibel...",
  "DELETED_COMMENT":"Menghapus komentar",
  "UPLOADING_PICTURE":"Upload Gambar",
  "UPLOAD_COMPLETED":"Upload Selesai",
  "UPLOAD_FAILED":"Upload Gagal",
  "PASSWORD_INCORRECT":"Password atau nama akun tidak benar",
  "INFO":"",
  "QR_TEXT":"Tempatkan kode QR di dalam area pindai",
  "BALANCE_TEXT":"Pastikan Anda memiliki saldo yang cukup untuk transaksi!",
  "NONEXIST_USER":"Pengguna yang Anda ccoba untuk mentransfer dana, tidak ada!",
  "TRANSFER_TEXT":"Apakah Anda yakin Anda ingin mentransfer?",
  "CONFIRMATION":"Konfirmasi",
  "TX_BROADCASTED":"Transaksi disiarkan",
  "FEED":"Umpan",
  "TRENDING":"",
  "HOT":"",
  "NEW":"Baru",
  "PROMOTED":"Promosi",
  "VOTES":"Vote",
  "PAYOUT":"Dibayar",
  "COMMENTS":"Komentar",
  "TRENDING_30":"Trending 30 Hari",
  "SORT_POST_BY":"Urutkan Postingan:",
  "PAYOUT_CYCLE":"",
  "POTENTIAL_PAYOUT":"Potensi Pembayaran",
  "PAST_PAYOUT":"Pembayaran terakhir",
  "AUTHOR_PAYOUT":"Pembayaran Penulis",
  "CURATION_PAYOUT":"Pembayaran Kurasi",
  "POST_SUBMITTED":"Post ditayangkan!",
  "POST_LATER":"Posting untuk diajukan nanti!",
  "SAVED":"Disimpan",
  "CLEARED":"Dibersihkan",
  "FLAGGING_TEXT":"Flagging postingan dapat menghapus imbalan dan membuat bahan ini kurang terlihat <br> bendera harus digunakan untuk berikut: <ul><li>Penipuan atau Plagiarisme</li><li>Kata kasar atau Internet Trolling </li><li>Konten Disengaja dikategorikan atau Spam</li> </ul>",
  "REQUEST_LIMIT_TEXT":"Batas permintaan tercapai. Lihat tren/tag lainnya!",
  "POST_IS_UNBOOKMARK":"Posting dihilangkan dari bookmark!",
  "POST_IS_BOOKMARK":"Posting ditambahkan ke bookmark!",
  "RESET":"Setel Ulang",
  "MODIFY_PICTURE":"Modifikasi gambar Profil",
  "MODIFY_COVER_PICTURE":"Memodifikasi Sampul gambar",
  "ACTIVE_KEY_REQUIRED_TEXT":"Harap memberikan kunci pribadi Active jika Anda telah memilih modus masuk Lanjutan!",
  "RESET_PICTURE_TEXT":"Ini akan menyetel ulang gambar profil",
  "RESET_COVER_PICTURE_TEXT":"Ini akan mereset gambar sampul",
  "UPDATE_REQUIRES_RESTART":"Update server memerlukan Restart!",
  "SETTINGS_UPDATED":"Pengaturan diperbarui!",
  "LANGUAGES":"Bahasa",
  "LANGUAGES_TEXT":"Di sini Anda dapat mengubah bahasa aplikasi.",
  "LOGIN_TO_X":"Operasi ini mengharuskan pengguna untuk login dengan password utama, aktif/postingan kunci. Silahkan login dan coba lagi.",
  "GALLERY":"Galeri",
  "TRANSLATIONS":"Kontributor terjemahan",
  "SHARE":"Bagikan\n",
  "MARKETPLACE":"",
  "EXCHANGE":"",
  "DRAFTS":"draft",
  "POST_IS_UNDRAFT":"Posting akan dihapus dari draft!",
  "POST_IS_DRAFT":"Posting ditambahkan ke draft!",
  "SWIPE_LEFT":"Geser ke kiri untuk melihat opsi",
  "MANAGE":"Mengelola\n",
  "IMAGE_REMOVED":"Gambar dihapus",
  "COPY":"copy",
  "NO_IMAGE":"Anda belum mengunggah gambar apapun, belum!",
  "PULL_DOWN_TO_REFRESH":"Tarik ke bawah untuk menyegarkan",
  "EXTERNAL_APPS":"\n External Apps",
  "PLUGINS":"",
  "SUGGEST":"Saran",
  "COMING_SOON":"",
  "CHAIN":"Chain\n",
  "CHAIN_TEXT":"Di sini Anda dapat mengubah blockchain atau platform default.\nChain_Text",
  "CURRENCY":"",
  "CURRENCY_TEXT":"",
  "ABOUT_11":"",
  "FOUNDER":"",
  "ADD_ACCOUNT":"",
  "PLATFORM":""
}
},{}],149:[function(require,module,exports){
module.exports={
  "HOME":"",
  "LOGIN":"Inloggen",
  "LOGOUT":"Uitloggen",
  "PROFILE":"Profiel",
  "FOLLOW":"Volgen",
  "BOOKMARKS":"Bladwijzers",
  "TRANSFER":"Overdracht",
  "MARKET":"Markt",
  "SETTINGS":"Instellingen",
  "ABOUT":"Over",
  "ABOUT_1":"waar iedereen een beloning kan verdienen!",
  "ABOUT_2":"mede mogelijk gemaakt door {{platformname}} platform. App gemaakt door",
  "ABOUT_3":"en het is een open-source, community gedreven project. Het biedt mogelijkheden tot lezen, reageren, stemmen, berichten plaatsen, inkomsten overschrijven, etc. functies aangeboden door {{platformname}} blockchain and {{sitename}}.",
  "ABOUT_4":"1. De app heeft geen toegang tot fondsen van de gebruiker.",
  "ABOUT_5":"2. De app biedt een beveiligingsmodel aan de kant van de gebruiker, met privésleutels die lokaal worden opgeslagen en nooit naar servers worden verzonden.",
  "ABOUT_6":"3. De app biedt simpele, aantrekkelijke gebruikersomgevingen en ervaringen.",
  "ABOUT_7":"4. De app vraagt u nooit om persoonlijke informatie.",
  "ABOUT_8":"Stem op good-karma als witness",
  "ABOUT_9":"",
  "ABOUT_10":"Meer informatie:",
  "REMOVE":"Verwijderen",
  "MARKET_VIEW":"Markt Weergave",
  "PRICE":"Prijs",
  "AMOUNT":"Bedrag",
  "TOTAL":"Totaal",
  "NOORDERS":"Geen open opdrachten voor",
  "DATE":"Datum",
  "BUY":"Kopen",
  "SELL":"Verkopen",
  "OPEN":"",
  "HISTORY":"Geschiedenis",
  "FOLLOW_BACK":"Terugvolgen",
  "FOLLOWED":"Gevolgd",
  "UNFOLLOW":"Ontvolgen",
  "FOLLOWING":"Volgend",
  "FOLLOWERS":"Volgers",
  "SEARCH_FOLLOWERS":"Zoek volgers",
  "SEARCH_FOLLOWING":"Zoek volgenden",
  "BY":"door",
  "IN":"",
  "MENU":"",
  "BOOKMARK":"Bladwijzer",
  "REBLOG":"Herblog",
  "UPVOTE":"",
  "DOWNVOTE":"",
  "UNVOTE_DOWNVOTED":"Downvote weghalen",
  "UNVOTE_UPVOTED":"Upvote weghalen",
  "REPLY":"Reageer",
  "EDIT":"Aanpassen",
  "POST_1":"Swipe naar links op een reactie om opties te zien",
  "POST_2":"Tik op een reactie om sub-reactie te zien",
  "OPTIONS":"Opties",
  "RESTEEMED_BY":"Hersteemed door",
  "NOTHING_HERE":"Nog niets te zien hier...",
  "BALANCES":"Tegoeden",
  "PROFILE_1":"{{platformname}}, ruilbare valuta die altijd overgemaakt kan worden. {{platformname}} kan worden omgevormd naar {{platformpower}} in een proces genaamd powering up.",
  "PROFILE_2":"{{platformpower}}, invloedsvaluta die meer kracht verdienen door het op lange termijn te bewaren en door het stemmen op verhalen. Hoe meer u vasthoudt, hoe meer invloed u heeft op andermans opbrengsten.",
  "PROFILE_3":"Eenheden zijn ongeveer {{platformsunit}} {{platformname}} waard.",
  "ESTIMATED_VALUE":"Geschatte waarde",
  "PROFILE_4":"De geschatte waarde wordt gebaseerd op een gemiddelde van waarde van {{platformname}} over 7 dagen.",
  "TRANSACTION_HISTORY":"Transactiegeschiedenis",
  "POSTING":"Plaatsen",
  "PROFILE_5":"De posting sleutel wordt gebruikt voor het plaatsen van posts en voor het stemmen op posts. Deze zou anders moeten zijn dan de actieve- en eigennaarssleutels.",
  "OWNER":"Eigenaar",
  "PROFILE_6":"De eigenaarssleutel is de hoofdsleutel voor het account en is nodig om andere sleutels aan te passen. De privésleutel of wachtwoord voor de eigenaarssleutel zou zo veel mogelijk offline gelaten moeten worden.",
  "ACTIVE":"Actief",
  "PROFILE_7":"De actieve sleutel wordt gebruikt om transacties en bestellingen te doen in de interne markt.",
  "MEMO":"",
  "PROFILE_8":"De memo sleutel wordt gebruikt voor het maken en lezen van memo's.",
  "BLOG":"",
  "POSTS":"",
  "REPLIES":"Reacties",
  "WALLET":"Portemonnee",
  "TAG":"",
  "USER":"Gebruiker",
  "CLOSE":"Sluiten",
  "TO":"Naar",
  "ASSET":"Activum",
  "SEND":"Verzenden",
  "SECURITY":"Beveiliging",
  "AVAILABLE":"Beschikbaar",
  "PUBLIC_MEMO":"Publiekelijke memo",
  "TO_DESC":"Gebruiker bijv. good-karma",
  "PIN_CODE":"Pincode",
  "PIN_TEXT":"PIN code helpt u uw app en gegevens te beschermen. <br/><br/><b>Opmerking:</b> Eenmaal ingesteld heeft u maximaal 4 kansen, wanneer u de PIN bent vergeten of u het 4 keer verkeerd heeft ingevoerd zal de app uw gebruikersgegevens verwijderen. U kunt dan opnieuw inloggen om de app weer te kunnen gebruiken.",
  "NOTIFICATIONS":"Notificaties",
  "VOTE_TEXT":"U krijgt een notificatie wanneer iemand op uw content stemt.<br/> <b>Opmerking:</b> Notificaties inclusief zwaarte van vote en een alert. (zij het een up-vote, down-vote, un-vote).",
  "VOTE":"",
  "COMMENT_TEXT":"U krijgt een notificatie wanneer iemand op u reageert. <br/> <b>Opmerking:</b> Notificaties wanneer iemand zijn comment <b>aanpast</b> worden ook weergeven.",
  "COMMENT":"Commentaar",
  "FOLLOW_TEXT":"U krijgt een notificatie wanneer iemand u volgt of stopt met volgen!",
  "MENTIONS":"Vernoemingen",
  "MENTIONS_TEXT":"U krijgt een notificatie wanneer iemand u noemt in zijn of haar post/reactie!",
  "RESTEEM":"Hersteem",
  "RESTEEM_TEXT":"U krijgt een notificatie wanneer iemand uw post hersteemed!",
  "CONFIGURATIONS":"Configuraties",
  "VOTING":"Stemmen",
  "VOTING_TEXT":"Stemzwaarte of percentages hebben invloed op Stemkracht in de app, zodat u uw stemopbrengsten kun reguleren. <br/><br/><b>Opmerking:</b> Dit zal uw stemkracht/percentage voor het naar beneden stemmen ook aantasten en het is overal in de app",
  "SERVER":"",
  "SERVER_TEXT":"Aangeraden",
  "SAVE_CHANGES":"Wijzigingen opslaan",
  "VOTERS_INFO":"Stemmers informatie",
  "WELCOME_BACK":"Welkom terug!",
  "LOGIN_1":"Log in met uw gebruikersnaam en wachtwoord om verder te gaan.",
  "LOGIN_2":"Posting sleutel wordt gebruikt voor het plaatsen van berichten, commentaar, stemmen en het volgen van gebruikers.",
  "LOGIN_3":"Actieve sleutel wordt gebruikt voor overmaken en profielfoto aanpassingen.",
  "LOGIN_4":"Gebruikersgegevens worden lokaal op uw apparaat opgeslagen. Bij het uitloggen worden de gegevens verwijderd!",
  "DONT_HAVE":"Heeft u geen account?",
  "SIGN_UP_NOW":"Meld je nu aan",
  "CANCEL":"Annuleren",
  "ADVANCED":"Geavanceerd",
  "ACTIVE_PRIKEY":"Actieve primaire sleutel",
  "POSTING_PRIKEY":"Posting privé sleutel",
  "MASTER_PASS":"Belangrijkste wachtwoord",
  "USERNAME":"Gebruikersnaam",
  "CARD_VIEW":"Kaart weergave",
  "COMPACT_VIEW":"Compacte weergave",
  "SEARCH":"Zoeken",
  "SUBMIT_A_STORY":"Plaats een verhaal",
  "REPLYTO":"Reageer op",
  "POST":"",
  "PREVIEW":"Voorbeeld",
  "DEFAULT":"Standaard 50% / 50%",
  "POWERUP":"",
  "DECLINE_PAYOUT":"Uitbetaling afwijzen",
  "SAVE_FOR_LATER":"OPSLAAN VOOR LATER",
  "CLEAR":"LEEGMAKEN",
  "POST_CONTENT":"Plaats bericht",
  "COMMENT_CONTENT":"Reageer op bericht",
  "TITLE":"Titel",
  "TAGS":"Labels",
  "NOT_MATCH":"MATCHEN NIET",
  "CONFIRM_PIN":"Bevestig PIN",
  "INCORRECT":"",
  "OPENING_POST":"Bericht openen",
  "SET_PIN":"Instellen PIN",
  "ENTER_PIN":"Invoeren PIN",
  "ARE_YOU_SURE":"Weet u het zeker?",
  "REBLOG_TEXT":"Hersteemen is definitief, wilt u doorgaan?",
  "BROADCAST_ERROR":"Verzendfout, probeer opnieuw!",
  "SUCCESS":"Succesvol",
  "REBLOGGED_POST":"Bericht gereblogd!",
  "LOGIN_FAIL":"Inloggen mislukt! Controleer of u heeft geprobeerd in te loggen met uw hoofdwachtwoord of Posting privésleutel als u voor geavanceerde modus heeft gekozen.",
  "LOGIN_FAIL_A":"Inloggen mislukt! Controleer of u heeft geprobeerd in te loggen met uw hoofdwachtwoord of privésleutel als u voor geavanceerde modus heeft gekozen.",
  "WARNING":"Waarschuwing",
  "VOTE_FOR_WITNESS":"Stemmen als getuige",
  "VOTED_FOR_WITNESS":"Gestemd voor getuige",
  "AGO":"geleden",
  "FROM_NOW":"vanaf nu",
  "SECS":"seconden",
  "A_MIN":"een minuut",
  "MINS":"minuten",
  "AN_HOUR":"een uur",
  "HOURS":"uren",
  "A_DAY":"een dag",
  "DAYS":"dagen",
  "A_MONTH":"een maand",
  "MONTHS":"maanden",
  "A_YEAR":"een jaar",
  "YEARS":"jaren",
  "MIN_READ":"min. leestijd",
  "DOWNVOTE_FLAG":"Omlaag stemmen of aangeven",
  "CAPTURE_PICTURE":"Neem foto",
  "SELECT_PICTURE":"Selecteer foto",
  "SET_CUSTOM_URL":"Stel aangepast URL in",
  "INSERT_PICTURE":"Foto invoegen",
  "ERROR":"Fout",
  "UPLOAD_ERROR":"Upload fout",
  "CAMERA_CANCELLED":"Camera geannuleerd",
  "SET_URL":"Stel URL in",
  "DIRECT_LINK_PICTURE":"Directe web link voor de foto",
  "COMMENT_SUBMITTED":"Commentaar is ingediend!",
  "DELETE_COMMENT":"Het verwijderen van comments is definitief...",
  "DELETED_COMMENT":"Verwijderd commentaar",
  "UPLOADING_PICTURE":"Foto is aan het uploaden",
  "UPLOAD_COMPLETED":"Upload geslaagd",
  "UPLOAD_FAILED":"Upload mislukt",
  "PASSWORD_INCORRECT":"Het wachtwoord of gebruikersnaam is fout",
  "INFO":"",
  "QR_TEXT":"Plaats een QR code in het scangebied",
  "BALANCE_TEXT":"Controleer of u genoeg fondsen heeft voor de transactie!",
  "NONEXIST_USER":"De gebruiker naar wie u probeert over te maken, bestaat niet!",
  "TRANSFER_TEXT":"Weet u zeker te wil overmaken?",
  "CONFIRMATION":"Bevestiging",
  "TX_BROADCASTED":"Transactie is verstuurd",
  "FEED":"",
  "TRENDING":"",
  "HOT":"Heet",
  "NEW":"Nieuw",
  "PROMOTED":"Gepromoot",
  "VOTES":"Stemmen",
  "PAYOUT":"Uitbetaling",
  "COMMENTS":"Commentaar",
  "TRENDING_30":"Trending voor 30 dagen",
  "SORT_POST_BY":"Sorteer posts op:",
  "PAYOUT_CYCLE":"Uitbetalingscyclus",
  "POTENTIAL_PAYOUT":"Potentiële uitbetaling",
  "PAST_PAYOUT":"Verleden uitbetaling",
  "AUTHOR_PAYOUT":"Uitbetaling auteur",
  "CURATION_PAYOUT":"Uitbetaling voor stemmen",
  "POST_SUBMITTED":"Post is doorgevoerd!",
  "POST_LATER":"Plaatsen voor later!",
  "SAVED":"Opgeslagen",
  "CLEARED":"Leeggemaakt",
  "FLAGGING_TEXT":"Een post flaggen of naar beneden stemmen kan de opbrengsten van de post weghalen en het bericht minder zichtbaar maken.<br><br>De flag mag alleen in de volgende gevallen gebruikt worden: <ul><li>Fraude or Plagiaat</li><li>Haatspraak of Trolling</li><li>Met intentie in verkeerde categorie geplaatst of Spam</li></ul>",
  "REQUEST_LIMIT_TEXT":"Limiet verzoek bereikt. Bekijk ook andere trends/tags!",
  "POST_IS_UNBOOKMARK":"Post is van bladwijzers verwijderd!",
  "POST_IS_BOOKMARK":"Post is aan bladwijzers toegevoegd!",
  "RESET":"",
  "MODIFY_PICTURE":"Pas profielfoto aan",
  "MODIFY_COVER_PICTURE":"Pas omslagfoto aan",
  "ACTIVE_KEY_REQUIRED_TEXT":"Gelieve een actieve sleutel aan te leveren wanneer u kiest voor geavanceerde inlogmodus!",
  "RESET_PICTURE_TEXT":"Dit zal de profielfoto van de gebruiker resetten",
  "RESET_COVER_PICTURE_TEXT":"Dit zal de omslagfoto van de gebruiker resetten",
  "UPDATE_REQUIRES_RESTART":"Server update vereist restart!",
  "SETTINGS_UPDATED":"Instellingen zijn verwerkt!",
  "LANGUAGES":"Talen",
  "LANGUAGES_TEXT":"Hier kunt u de taal van de app veranderen.",
  "LOGIN_TO_X":"Om dit te doen dient u in te loggen met uw hoofdwachtwoord, actieve/posting key. Log alstublieft in en probeer opnieuw.",
  "GALLERY":"Gallerij",
  "TRANSLATIONS":"Vertalingsbijdragers",
  "SHARE":"Delen",
  "MARKETPLACE":"Marktplaats",
  "EXCHANGE":"Beurs",
  "DRAFTS":"Concepten",
  "POST_IS_UNDRAFT":"Post is uit concepten verwijderd!",
  "POST_IS_DRAFT":"Post toegevoegd aan concepten!",
  "SWIPE_LEFT":"Swipe naar links voor opties",
  "MANAGE":"Beheer",
  "IMAGE_REMOVED":"Afbeelding is verwijderd",
  "COPY":"Kopiëren",
  "NO_IMAGE":"Je hebt nog geen afbeelding geupload.",
  "PULL_DOWN_TO_REFRESH":"Trek naar beneden op te verversen",
  "EXTERNAL_APPS":"Externe applicaties",
  "PLUGINS":"",
  "SUGGEST":"Suggereer",
  "COMING_SOON":"Binnenkort beschikbaar",
  "CHAIN":"Ketting",
  "CHAIN_TEXT":"Hier kunt u veranderen naar blockchain of standaard platform",
  "CURRENCY":"",
  "CURRENCY_TEXT":"",
  "ABOUT_11":"",
  "FOUNDER":"",
  "ADD_ACCOUNT":"",
  "PLATFORM":""
}
},{}],150:[function(require,module,exports){
module.exports={
  "HOME":"Strona główna",
  "LOGIN":"Zaloguj",
  "LOGOUT":"Wyloguj",
  "PROFILE":"Profil",
  "FOLLOW":"Obserwuj",
  "BOOKMARKS":"Zakładki",
  "TRANSFER":"Przelew",
  "MARKET":"Giełda",
  "SETTINGS":"Ustawienia",
  "ABOUT":"O Nas",
  "ABOUT_1":"gdzie każdy może zdobywać wynagrodzenie za swoje wpisy!",
  "ABOUT_2":"funkcjonuje w oparciu o patformę {{platformname}}. Aplikacja jest stworzona przez",
  "ABOUT_3":"i jest ona otwartym i prowadzonym przez społeczność projektem. Oferuje dostęp do czytania, komentowania, oddawania głosu na treści oraz udostępniania wpisów, a także na zarządzanie zarobkami oraz innymi dostępnymi opcjami oferowanymi przez łańcuch bloków {{platformname}} i {{sitename}}.",
  "ABOUT_4":"Aplikacja nigdy nie ma dostępu i nie przetrzymuje środków finansowych użytkownika.",
  "ABOUT_5":"Aplikacja oferuje model bezpieczeństwa po stronie klienta, gdzie klucze prywatne są przechowywane lokalnie i nigdy nie są przesyłane na jakiekolwiek serwery.",
  "ABOUT_6":"Aplikacja oferuje łatwy i przyjemny w obsłudze interfejs.",
  "ABOUT_7":"Aplikacja nigdy nie wymaga podania danych osobowych od swoich użytkowników.",
  "ABOUT_8":"Zagłosuj na good-karma na świadka",
  "ABOUT_9":"Kontakt/Opinie",
  "ABOUT_10":"Więcej informacji:",
  "REMOVE":"Usuń",
  "MARKET_VIEW":"Widok na giełdę",
  "PRICE":"Cena",
  "AMOUNT":"Ilość",
  "TOTAL":"Suma",
  "NOORDERS":"Brak przekazów w toku dla",
  "DATE":"Data",
  "BUY":"Kup",
  "SELL":"Sprzedaj",
  "OPEN":"W toku",
  "HISTORY":"Historia",
  "FOLLOW_BACK":"Obserwuj również",
  "FOLLOWED":"Obserwowany",
  "UNFOLLOW":"Przestań obserwować",
  "FOLLOWING":"Obserwujesz",
  "FOLLOWERS":"Obserwują cię",
  "SEARCH_FOLLOWERS":"Szukaj wśród obserwujących",
  "SEARCH_FOLLOWING":"Szukaj wśród obserwowanych",
  "BY":"przez",
  "IN":"w",
  "MENU":"",
  "BOOKMARK":"Zakładki",
  "REBLOG":"Rebloguj",
  "UPVOTE":"Głos za",
  "DOWNVOTE":"Głos przeciw",
  "UNVOTE_DOWNVOTED":"Anuluj głos przeciw",
  "UNVOTE_UPVOTED":"Anuluj głos za",
  "REPLY":"Odpowiedź",
  "EDIT":"Edytuj",
  "POST_1":"Przeciągnij komentarz w lewo, aby zobaczyć dostępne opcje",
  "POST_2":"Naciśnij na komentarze, aby rozwinąć",
  "OPTIONS":"Opcje",
  "RESTEEMED_BY":"Resteemowany przez",
  "NOTHING_HERE":"Na razie nic tu nie ma...",
  "BALANCES":"Salda",
  "PROFILE_1":"{{platformname}} wymienialne tokeny, które mogą być przetransferowane w dowolnym momencie. {{platformname}} mogą być wymienione na {{platformpower}} w procesie zwanym Power-up.\n",
  "PROFILE_2":"{{platformpower}} tokeny wpływu, które umożliwiają na zdobywanie większej ilości mocy za trzymanie ich dłuoterminowo oraz za głosowanie na wpisy. Im więcej się ich posiada, tym bardziej wpływa się na wynagrodzenie innych wpisów i na zdobywanie nagród związane z oddaniem głosu.",
  "PROFILE_3":"Tokeny warte około {{platformsunit}} platformy {{platformname}}.",
  "ESTIMATED_VALUE":"Szacowana wartość",
  "PROFILE_4":"Wartość jest szacowana na podstawie średniej wartości z 7-miu dni.",
  "TRANSACTION_HISTORY":"Historia transakcji",
  "POSTING":"Udostępnianie",
  "PROFILE_5":"Klucz udostępnienia jest używany przy udostępnianiu wpisów i oddawaniu głosów. Powinien być inny niż klucz aktywny i klucz własności.",
  "OWNER":"Właściciel",
  "PROFILE_6":"Klucz własności jest kluczem głównym konta i jest wymagany do zmiany pozostałych kluczy. Klucz prywatny lub hasło do klucza własności powinno być trzymane offline, gdy jest to tylko możliwe.",
  "ACTIVE":"Aktywny",
  "PROFILE_7":"Klucz aktywny jest używany do wykonywania przelewów i składania zamówień na wewnętrznej giełdzie.",
  "MEMO":"Notatka",
  "PROFILE_8":"Klucz notatki jest użyty, aby sporządzać i czytać notatki.",
  "BLOG":"",
  "POSTS":"Wpisy",
  "REPLIES":"Odpowiedzi",
  "WALLET":"Portfel",
  "TAG":"Etykieta",
  "USER":"Użytkownik",
  "CLOSE":"Zamknij",
  "TO":"Do",
  "ASSET":"Kapitał",
  "SEND":"Wyślij",
  "SECURITY":"Bezpieczeństwo",
  "AVAILABLE":"Dostępny",
  "PUBLIC_MEMO":"Notatka publiczna",
  "TO_DESC":"Użytkownik np. good-karma",
  "PIN_CODE":"Kod PIN",
  "PIN_TEXT":"Kod PIN pozwala Ci zabezpieczyć aplikację oraz twoje dane. <br/><br/> <b>Uwaga:</> Masz maksymalnie 4 próby aby wpisać poprawne hasło i odblokować konto, jeżeli zapomniałeś kodu PIN lub wpisałeś złe hasło więcej razy, aplikacja usunie wszystkie dane użytkownika. Możesz się wtedy zalogować ponownie i kontynuować użytkowanie aplikacji.",
  "NOTIFICATIONS":"Powiadomienia",
  "VOTE_TEXT":"Otrzymasz powiadomienie, gdy ktoś odda głos na twój wpis! <br/><b>Uwaga:</b>Powiadomienia zawierają także typ głosu (tzn. głos za, głos przeciw, anuluj głos).",
  "VOTE":"Zagłosuj",
  "COMMENT_TEXT":"Otrzymasz powadomienie, gdy ktoś skomentuje twój wpis lub komentarz!<br/> <b>Uwaga:</b>Zostaniesz również powiadomiony, gdy ktoś <b>edytuje</b> swój komentarz.",
  "COMMENT":"Komentarz",
  "FOLLOW_TEXT":"Otrzymasz powiadomienie, gdy ktoś zacznie lub przestanie cię obserwować!",
  "MENTIONS":"Wzmianki",
  "MENTIONS_TEXT":"Zostaniesz powiadomiony, gdy ktoś wspomni cię w swoim wpisie/komentarzu!",
  "RESTEEM":"Resteemuj",
  "RESTEEM_TEXT":"Otrzymasz powiadomienie, gdy ktoś resteemuje twój wpis!",
  "CONFIGURATIONS":"Konfiguracje",
  "VOTING":"Oddanie głosu",
  "VOTING_TEXT":"Moc lub procent głosu wpływa na moc oddanego głosu i umożliwia ci na regulowanie swojego wynagrodzenia za oddane głosy. <br/><br/><b>Uwaga:</b> Zmiana wpłynie na moc/procent głosu całej aplikacji, dotyczy to również głosów oddanych przeciw",
  "SERVER":"Serwer",
  "SERVER_TEXT":"Rekomendowane",
  "SAVE_CHANGES":"Zachowaj zmiany",
  "VOTERS_INFO":"Głosowali",
  "WELCOME_BACK":"Witaj ponownie!",
  "LOGIN_1":"Aby kontynuować, zaloguj się przy użyciu loginu i hasła.",
  "LOGIN_2":"Klucz udostępniający jest używany do udostępniania wpisów, komentowania, głosowania i śledzenia.",
  "LOGIN_3":"Klucz aktywny używany jest do wykonywania przelewów i zmian zdjęcia profilowego.",
  "LOGIN_4":"Dane użytkownika są trzymane lokalnie przy użycia twojego urządzenia. Po wylogowaniu dane zostają usunięte!",
  "DONT_HAVE":"Nie masz jeszcze konta?",
  "SIGN_UP_NOW":"Załóż konto",
  "CANCEL":"Anuluj",
  "ADVANCED":"Zaawansowane",
  "ACTIVE_PRIKEY":"Klucz aktywny prywatny",
  "POSTING_PRIKEY":"Klucz udostępniający prywatny",
  "MASTER_PASS":"Hasło główne",
  "USERNAME":"Login",
  "CARD_VIEW":"Widok karty",
  "COMPACT_VIEW":"Widok kompaktowy",
  "SEARCH":"Szukaj",
  "SUBMIT_A_STORY":"Opublikuj treść",
  "REPLYTO":"Odpowiedz",
  "POST":"Opublikuj",
  "PREVIEW":"Podgląd",
  "DEFAULT":"Standardowe 50% / 50%",
  "POWERUP":"",
  "DECLINE_PAYOUT":"Odmów wynagrodzenia",
  "SAVE_FOR_LATER":"ZACHOWAJ NA PÓŹNIEJ",
  "CLEAR":"WYCZYŚĆ",
  "POST_CONTENT":"Opublikuj wpis",
  "COMMENT_CONTENT":"Skomentuj",
  "TITLE":"Tytuł",
  "TAGS":"Etykiety",
  "NOT_MATCH":"BRAK ZGODNOŚCI",
  "CONFIRM_PIN":"Powtórz PIN",
  "INCORRECT":"NIEPOPRAWNY",
  "OPENING_POST":"otwieranie wpisu",
  "SET_PIN":"Ustaw PIN",
  "ENTER_PIN":"Podaj PIN",
  "ARE_YOU_SURE":"Czy jesteś pewien?",
  "REBLOG_TEXT":"Resteemowanie jest nieodwracalne, czy chcesz kontynuować?",
  "BROADCAST_ERROR":"Błąd połączenia, spróbuj ponownie!",
  "SUCCESS":"Zakończono powodzeniem",
  "REBLOGGED_POST":"Rebloguj wpis!",
  "LOGIN_FAIL":"Błąd logowania! Upewnij się czy zalogowałeś się przy użyciu klucza głównego lub czy użyłeś aktywnego klucza prywatnego przy logowaniu w trybie zaawansowanym.",
  "LOGIN_FAIL_A":"Błąd logowania! Upewnij się czy zalogowałeś się przy użyciu klucza głównego lub czy użyłeś prywatnego klucza udostępniającego przy logowaniu w trybie zaawansowanym.",
  "WARNING":"Uwaga",
  "VOTE_FOR_WITNESS":"Głosujesz na świadka",
  "VOTED_FOR_WITNESS":"Zagłosowałeś na świadka",
  "AGO":"temu",
  "FROM_NOW":"od teraz",
  "SECS":"sekund(y)",
  "A_MIN":"minutę",
  "MINS":"minut(y)",
  "AN_HOUR":"godzinę",
  "HOURS":"godzin(y)",
  "A_DAY":"dzień",
  "DAYS":"dni",
  "A_MONTH":"miesiąc",
  "MONTHS":"miesięcy",
  "A_YEAR":"rok",
  "YEARS":"lat(a)",
  "MIN_READ":"minut temu zostało przeczytane",
  "DOWNVOTE_FLAG":"Głosuj przeciw lub oflaguj",
  "CAPTURE_PICTURE":"Zrób zdjęcie",
  "SELECT_PICTURE":"Wybierz obraz",
  "SET_CUSTOM_URL":"Ustaw wybrany URL",
  "INSERT_PICTURE":"Wstaw obraz",
  "ERROR":"Błąd",
  "UPLOAD_ERROR":"Błąd przy wrzucaniu pliku",
  "CAMERA_CANCELLED":"Aparat nieaktywna",
  "SET_URL":"Ustaw URL",
  "DIRECT_LINK_PICTURE":"Bezpośredni link na stronę ze zdjęciem",
  "COMMENT_SUBMITTED":"Komentarz został opublikowany!",
  "DELETE_COMMENT":"Usunięcie komentarzy jest nieodwracalne...",
  "DELETED_COMMENT":"Usuń komentarz",
  "UPLOADING_PICTURE":"Wstaw zdjęcie",
  "UPLOAD_COMPLETED":"Wstawienie zakończone",
  "UPLOAD_FAILED":"Wrzucenie nie powiodło się",
  "PASSWORD_INCORRECT":"Nieprawidłowy login lub hasło",
  "INFO":"Informacja",
  "QR_TEXT":"Umieść kod QR w obrębie pola skanowania",
  "BALANCE_TEXT":"Upewnij się, czy masz wystarczającą ilość środków aby wykonać transakcję!",
  "NONEXIST_USER":"Użytkownik do którego próbujesz przesłać środki, nie istnieje!",
  "TRANSFER_TEXT":"Czy na pewno chcesz wysłać środki?",
  "CONFIRMATION":"Potwierdzenie",
  "TX_BROADCASTED":"Transakcja w toku",
  "FEED":"Aktualności",
  "TRENDING":"Trendy",
  "HOT":"Na topie",
  "NEW":"Nowe",
  "PROMOTED":"Promowane",
  "VOTES":"Ilość głosów",
  "PAYOUT":"Przychód",
  "COMMENTS":"Ilość Komentarzy",
  "TRENDING_30":"Trendy z 30 dni",
  "SORT_POST_BY":"Uporządkuj według:",
  "PAYOUT_CYCLE":"Cykl przychodu",
  "POTENTIAL_PAYOUT":"Potencjalny przychód",
  "PAST_PAYOUT":"Wcześniej wypłacono",
  "AUTHOR_PAYOUT":"Przychód autora",
  "CURATION_PAYOUT":"Przychód za mecenat",
  "POST_SUBMITTED":"Wpis został opublikowany!",
  "POST_LATER":"Opublikuj wpis później!",
  "SAVED":"Zapamiętaj",
  "CLEARED":"Wyczyść",
  "FLAGGING_TEXT":"Oflagowanie wpisu może spowodować usunięcie wynagrodzenia i zmniejszenie jego widoczności.<br><br>Flaga powinna być użyta w sytuacjach takich jak: <ul><li>Oszustwo lub Plagiat</li><li>Mowę nienawiści lub Internetowy trolling</li><li>Wpis celowo źle skatagoryzowany lub Spam</li></ul>",
  "REQUEST_LIMIT_TEXT":"Limit został osiągnięty. Sprawdź inne etykiety/trendy!",
  "POST_IS_UNBOOKMARK":"Wpis został usunięty z zakładek!",
  "POST_IS_BOOKMARK":"Wpis został dodany do zakładek!",
  "RESET":"Zresetuj",
  "MODIFY_PICTURE":"Zmodyfikuj zdjęcie profilowe",
  "MODIFY_COVER_PICTURE":"Zmień zdjęcie w tle",
  "ACTIVE_KEY_REQUIRED_TEXT":"Podaj aktywny klucz prywatny jeśli wybrałeś tryb zaawansowanego logowania!",
  "RESET_PICTURE_TEXT":"Spowoduje zresetowanie zdjęcia profilowego",
  "RESET_COVER_PICTURE_TEXT":"Spowoduje zresetowanie zdjęcia w tle",
  "UPDATE_REQUIRES_RESTART":"Aktualizacja serwera wymaga zresetowania!",
  "SETTINGS_UPDATED":"Ustawienia zostały zaktualizowane",
  "LANGUAGES":"Język",
  "LANGUAGES_TEXT":"Tu możesz zmienić język aplikacji.",
  "LOGIN_TO_X":"Ta operacja wymaga zalogowania hasłem głównym, kluczem akytwnym/udostępniającym. Zaloguj się i spróbuj ponownie.",
  "GALLERY":"Galeria",
  "TRANSLATIONS":"Przetłumaczyli",
  "SHARE":"Poleć",
  "MARKETPLACE":"Sklep",
  "EXCHANGE":"Wymiana",
  "DRAFTS":"Wersje robocze",
  "POST_IS_UNDRAFT":"Wpis został usunięty z roboczych!",
  "POST_IS_DRAFT":"Wpis został zapisany jako wersja robocza!",
  "SWIPE_LEFT":"Przeciągnij w lewo, aby zobaczyć opcje",
  "MANAGE":"Zarządzaj",
  "IMAGE_REMOVED":"Obraz został usunięty",
  "COPY":"Kopiuj",
  "NO_IMAGE":"Nie opublikowałeś jeszcze żadnego obrazu!",
  "PULL_DOWN_TO_REFRESH":"Przeciągnij w dół, aby odświeżyć.",
  "EXTERNAL_APPS":"Aplikacje zewnętrzne",
  "PLUGINS":"Pluginy",
  "SUGGEST":"Zasugeruj",
  "COMING_SOON":"Już wkrótce",
  "CHAIN":"Łańcuch",
  "CHAIN_TEXT":"Tutaj możesz zmienić łańcuch bloków lub domyślną platformę.",
  "CURRENCY":"",
  "CURRENCY_TEXT":"",
  "ABOUT_11":"",
  "FOUNDER":"",
  "ADD_ACCOUNT":"",
  "PLATFORM":""
}
},{}],151:[function(require,module,exports){
module.exports={
  "HOME":"Página Inicial",
  "LOGIN":"Entrar",
  "LOGOUT":"Sair",
  "PROFILE":"Perfil",
  "FOLLOW":"Seguir",
  "BOOKMARKS":"Favoritos",
  "TRANSFER":"Transferir",
  "MARKET":"Mercado",
  "SETTINGS":"Configurações",
  "ABOUT":"Sobre",
  "ABOUT_1":"onde qualquer um pode ganhar recompensas pelo seu conteúdo",
  "ABOUT_2":"é patrocinado pela plataforma {{platformname}}. Aplicativo criado por",
  "ABOUT_3":"e é código-aberto, projecto orientado para a comunidade móvel. Oferece acesso ao conteúdo para leitura, comentários, votos, publicar, tranferir ganhos etc. Caraterísticas oferecidas pel {{platformname}} blockchain e {{sitename}}.",
  "ABOUT_4":"1. O aplicativo nunca acessa ou guarda o dinheiro dos usuários.",
  "ABOUT_5":"2. A App ofereçe um modelo seguro do lado-cliente, com chaves privadas, guardadas localmente e nunca envida a outros servidores.",
  "ABOUT_6":"3. O Aplicativo oferece simplicidade, interfaces de usuário e experiências atrativas.",
  "ABOUT_7":"4. O Aplicativo requer que os usuários insiram informações pessoais.",
  "ABOUT_8":"Vote bom-karma como testemunha",
  "ABOUT_9":"Contato/Comentários",
  "ABOUT_10":"Mais informações:",
  "REMOVE":"Remover",
  "MARKET_VIEW":"Visão do Mercado",
  "PRICE":"Preço",
  "AMOUNT":"Quantidade",
  "TOTAL":"",
  "NOORDERS":"Sem ordens abertas para",
  "DATE":"Data",
  "BUY":"Comprar",
  "SELL":"Vender",
  "OPEN":"Abrir",
  "HISTORY":"Hitórico",
  "FOLLOW_BACK":"Seguir de volta",
  "FOLLOWED":"Seguido",
  "UNFOLLOW":"Deixar de seguir",
  "FOLLOWING":"Seguindo",
  "FOLLOWERS":"Seguidores",
  "SEARCH_FOLLOWERS":"Procurar seguidores",
  "SEARCH_FOLLOWING":"Procurar quem estou seguindo",
  "BY":"por",
  "IN":"no",
  "MENU":"",
  "BOOKMARK":"Favoritos",
  "REBLOG":"Repostar",
  "UPVOTE":"Upvote ",
  "DOWNVOTE":"",
  "UNVOTE_DOWNVOTED":"Cancelar Downvote",
  "UNVOTE_UPVOTED":"Cancelar Upvote",
  "REPLY":"Responder",
  "EDIT":"Editar",
  "POST_1":"Deslize para esquerda nos comentários para ver as opções",
  "POST_2":"Toque nos comentários para ver os sub-comentários",
  "OPTIONS":"Opções",
  "RESTEEMED_BY":"Repostado por",
  "NOTHING_HERE":"Nada por aqui, ainda...",
  "BALANCES":"Balanço",
  "PROFILE_1":"{{platformname}}, provas transacionáveis que podem ser transferidas em qualquer altura. {{platformname}} podem ser convertidas {{platformpower}} num processo chamado poder abaixo.",
  "PROFILE_2":"{{platformpower}}, provas de influencia par ganhar mais poder por guardar a longo prazo e votar nas publicações. Quanto mais se possui mais se pode influenciar as recompensas a outros e ganhar mais recompensas por votar.",
  "PROFILE_3":"Provas valendo cerca de {{platformsunit}} de {{platformname}}.",
  "ESTIMATED_VALUE":"Valor estimado",
  "PROFILE_4":"O valor estimado é baseado numa média do valor de 7 dias de {{platformname}}.",
  "TRANSACTION_HISTORY":"Histórico de Transações",
  "POSTING":"Postando",
  "PROFILE_5":"A chave de postagem é usada para postar e votar. Ela deverá ser diferente da chave de ativação e da chave de proprietário.",
  "OWNER":"Proprietário",
  "PROFILE_6":"A chave de proprietário é a chave mestra para conta e é exigida para mudar as outras chaves. Uma chave privada ou senha para a chave de proprietário deverá ser mantida offline assim que possível.",
  "ACTIVE":"Ativo",
  "PROFILE_7":"A chave de ativação é usada para fazer transferências e colocar ordens no mercado interno.",
  "MEMO":"Anotações",
  "PROFILE_8":"A chave de anotações é usada para criar e ler anotações.",
  "BLOG":"",
  "POSTS":"Postagens",
  "REPLIES":"Respostas",
  "WALLET":"Carteira",
  "TAG":"",
  "USER":"Usuário",
  "CLOSE":"Fechado",
  "TO":"Para",
  "ASSET":"Ativo",
  "SEND":"Enviar",
  "SECURITY":"Segurança",
  "AVAILABLE":"Disponível",
  "PUBLIC_MEMO":"Memorando Público",
  "TO_DESC":"Utilizador ex: good-karma",
  "PIN_CODE":"Código Pin",
  "PIN_TEXT":"Código Pin ajuda você a assegurar o aplicativo e suas informações. <br/><br/> Uma vez ativado, você terá no máximo 4 tentativas para destravar, se voce esquecero pin ou errar, o aplicativo irá remover suas informações de usuário. Você pode entrar de novo e continuar a usar o aplicativo.",
  "NOTIFICATIONS":"Notificações",
  "VOTE_TEXT":"Você receberá uma notificação quando alguém voter no seu conteúdo! Notificações também incluem peso de voto no alerta da mensagem.) seja voto positivo, voto negativo, voto nulo).",
  "VOTE":"Votar",
  "COMMENT_TEXT":"Você receberá notificação quando alguém comentar nas suas postagens ou comentários.<br/> Notificações incluem quando alguém edita os comentários também.",
  "COMMENT":"Comentar",
  "FOLLOW_TEXT":"Você receberá uma notificação quando alguém Seguir ou Deixar de seguir você!",
  "MENTIONS":"Menções",
  "MENTIONS_TEXT":"Você receberá uma notificação quando alguém mencionar você em alguma postagem ou comentário!",
  "RESTEEM":"",
  "RESTEEM_TEXT":"Irá receber notificação quando alguem republicar a sua publicaçã!",
  "CONFIGURATIONS":"Configurações",
  "VOTING":"Votando",
  "VOTING_TEXT":"O peso de voto ou percentagem afeta o poder de voto na app, por isso pode regular o seu recompensa de voto <br/><br/><b>Nota:</b> Isto irá modificar o pseso/percentagem para votar para baixo também e em todo o lado na App",
  "SERVER":"Servidor",
  "SERVER_TEXT":"Recomendado",
  "SAVE_CHANGES":"Salvar mudanças",
  "VOTERS_INFO":"Informações dos eleitores",
  "WELCOME_BACK":"Bem vindo de Volta!",
  "LOGIN_1":"Conecte-se com seu nome de usuário e senha para continuar.",
  "LOGIN_2":"Chave de postagem é usada para postar, comentar, votar, seguir.",
  "LOGIN_3":"Chave de ativação é usada para tranferências e atualização de fotos de perfil.",
  "LOGIN_4":"As credenciais do utilizador são guardadas localmente no seu aparelho. Depis de desligar as suas cerdenciais são removidas!",
  "DONT_HAVE":"Não possui uma conta?\n",
  "SIGN_UP_NOW":"Cadastre-se agora",
  "CANCEL":"Cancelar",
  "ADVANCED":"Avançado",
  "ACTIVE_PRIKEY":"Chave de ativação privada",
  "POSTING_PRIKEY":"Chave de postagem privada",
  "MASTER_PASS":"Senha Mestra/Principal",
  "USERNAME":"Usuário",
  "CARD_VIEW":"Visão de Cartão",
  "COMPACT_VIEW":"Vista compacta",
  "SEARCH":"Procurar",
  "SUBMIT_A_STORY":"Postar uma história",
  "REPLYTO":"Responder para",
  "POST":"Postagem",
  "PREVIEW":"Vizualização",
  "DEFAULT":"Padrão 50% / 50%",
  "POWERUP":"Força Total 100%",
  "DECLINE_PAYOUT":"Recusar Pagamento",
  "SAVE_FOR_LATER":"Guardar pra mais tarde",
  "CLEAR":"Terminado",
  "POST_CONTENT":"Conteúdo da postagem",
  "COMMENT_CONTENT":"Conteúdo do comentário",
  "TITLE":"Título",
  "TAGS":"",
  "NOT_MATCH":"Não condiz",
  "CONFIRM_PIN":"Confirmar Pin",
  "INCORRECT":"Incorreto",
  "OPENING_POST":"Abrindo postagem",
  "SET_PIN":"Configure PIN",
  "ENTER_PIN":"Entrar com Pin",
  "ARE_YOU_SURE":"Você tem certeza?",
  "REBLOG_TEXT":"Republicar é irreversível, quer mesmo continuar?",
  "BROADCAST_ERROR":"Erro de difusão, tente novamente!",
  "SUCCESS":"Sucesso",
  "REBLOGGED_POST":"Publucação republicada",
  "LOGIN_FAIL":"Login falhou! por favor certifique-se que está conetado com a senha master ou a chave publicação privada no Login se escolheu o modo avançado.",
  "LOGIN_FAIL_A":"Login falhou! por favor certifique-se que está conetado com a senha master ou a chave ativa privada no Login se escolheu o modo avançado.",
  "WARNING":"Cuidado",
  "VOTE_FOR_WITNESS":"Votando por uma Testemunha",
  "VOTED_FOR_WITNESS":"Votou por uma Testemunha",
  "AGO":"atrás",
  "FROM_NOW":"de agora",
  "SECS":"segs",
  "A_MIN":"um minuto",
  "MINS":"",
  "AN_HOUR":"uma hora",
  "HOURS":"horas",
  "A_DAY":"um dia",
  "DAYS":"dias",
  "A_MONTH":"um mês",
  "MONTHS":"meses",
  "A_YEAR":"um ano",
  "YEARS":"anos",
  "MIN_READ":"ler min",
  "DOWNVOTE_FLAG":"Vote abaixo ou bandeire",
  "CAPTURE_PICTURE":"Capturar imagem",
  "SELECT_PICTURE":"Escolher uma imagem",
  "SET_CUSTOM_URL":"Configure URL costumizada",
  "INSERT_PICTURE":"Inserir uma imagem",
  "ERROR":"Erro",
  "UPLOAD_ERROR":"Erro no carregamento",
  "CAMERA_CANCELLED":"Camera cancelada",
  "SET_URL":"Configural URL",
  "DIRECT_LINK_PICTURE":"Link web direto para a imagem",
  "COMMENT_SUBMITTED":"Comentário postado!",
  "DELETE_COMMENT":"Deletar comentários é irreversível",
  "DELETED_COMMENT":"Comentário deletado",
  "UPLOADING_PICTURE":"Carregabdo imagem",
  "UPLOAD_COMPLETED":"Carregamento compeleto",
  "UPLOAD_FAILED":"Carregamento falhou",
  "PASSWORD_INCORRECT":"A senha ou nome da conta estão incorretos",
  "INFO":"Informações",
  "QR_TEXT":"Ponha o código QR dentro da área de scan",
  "BALANCE_TEXT":"Certifique-se que possui saldo suficiente para a transação!",
  "NONEXIST_USER":"O utilizador para quem está a tentar transferir fundos, não existe",
  "TRANSFER_TEXT":"Tem certeza que quer transferir?",
  "CONFIRMATION":"Confirmação",
  "TX_BROADCASTED":"Transação foi difundida",
  "FEED":"",
  "TRENDING":"Tendencia",
  "HOT":"Quente",
  "NEW":"Novidades",
  "PROMOTED":"Promovidos",
  "VOTES":"Votos",
  "PAYOUT":"Pagamento",
  "COMMENTS":"Comentários",
  "TRENDING_30":"Tendencia a 30 dias",
  "SORT_POST_BY":"Ordenar publicações por:",
  "PAYOUT_CYCLE":"Ciclo de Pagamento",
  "POTENTIAL_PAYOUT":"Pagamento em potencial",
  "PAST_PAYOUT":"Último Pagamento",
  "AUTHOR_PAYOUT":"Pagamento do Autor",
  "CURATION_PAYOUT":"Pagamento de curadoria",
  "POST_SUBMITTED":"Postagem enviada!",
  "POST_LATER":"Publique para futura submissão",
  "SAVED":"Salvo",
  "CLEARED":"Limpo",
  "FLAGGING_TEXT":"Por Bandeira numa publicação pode remover recompensas e tornar o material menos visivel.<br><br>A bandeira dev ser usada para : <ul><li>Fraude ou Plagiarismo</li><li>Discurso de ódio ou Internet Trolling</li><li>Categorização mal feita intencionalmente ou Spam</li></ul>",
  "REQUEST_LIMIT_TEXT":"Limite de pedidos atingido. verifique outro assunto/etiqueta!",
  "POST_IS_UNBOOKMARK":"Postagem removida dos favoritos!",
  "POST_IS_BOOKMARK":"Postagem adicionada aos favoritos!",
  "RESET":"Reiniciar",
  "MODIFY_PICTURE":"Modificar foto de perfil",
  "MODIFY_COVER_PICTURE":"Modificar foto de capa",
  "ACTIVE_KEY_REQUIRED_TEXT":"Por favor fornaça a chave de activação privada que escolheu, Modo de Login Avançado",
  "RESET_PICTURE_TEXT":"Isto reconfigura a imagem do perfil ultizador",
  "RESET_COVER_PICTURE_TEXT":"Isto reconfigura a imagem do ultizador",
  "UPDATE_REQUIRES_RESTART":"Atualização do server obriga a Reiniciar!",
  "SETTINGS_UPDATED":"Configurações foram atualizadas",
  "LANGUAGES":"Línguas",
  "LANGUAGES_TEXT":"Aqui pode mudar a língua da App",
  "LOGIN_TO_X":"Est operação obriga que o utilizador estaja ligado com a senha prinipal, chave activação/publicação",
  "GALLERY":"Galeria",
  "TRANSLATIONS":"Tradutores que contribuiram",
  "SHARE":"Partilhar",
  "MARKETPLACE":"Mercado",
  "EXCHANGE":"Cambio",
  "DRAFTS":"Rascunhos",
  "POST_IS_UNDRAFT":"Postagem removida dos Rascunhos!",
  "POST_IS_DRAFT":"Postagem adicionada a Rascunhos!",
  "SWIPE_LEFT":"Role para a esquerda para opções",
  "MANAGE":"Gerir",
  "IMAGE_REMOVED":"Image. removida",
  "COPY":"Copiar",
  "NO_IMAGE":"Não carregou nenhuma imagem, ainda",
  "PULL_DOWN_TO_REFRESH":"Carregue para refrescar",
  "EXTERNAL_APPS":"Apps Externas",
  "PLUGINS":"",
  "SUGGEST":"Sugira",
  "COMING_SOON":"Brevemente",
  "CHAIN":"",
  "CHAIN_TEXT":"Aqui pode escolher blockchain ou a plataforma por defeito",
  "CURRENCY":"",
  "CURRENCY_TEXT":"",
  "ABOUT_11":"",
  "FOUNDER":"",
  "ADD_ACCOUNT":"",
  "PLATFORM":""
}
},{}],152:[function(require,module,exports){
module.exports={
  "HOME":"Página Inicial",
  "LOGIN":"Entrar",
  "LOGOUT":"Sair",
  "PROFILE":"Perfil",
  "FOLLOW":"Seguir",
  "BOOKMARKS":"Favoritos",
  "TRANSFER":"Transferir",
  "MARKET":"Mercado",
  "SETTINGS":"Configurações",
  "ABOUT":"Sobre",
  "ABOUT_1":"Onde qualquer um pode ganhar recompensas pelo seu conteúdo",
  "ABOUT_2":"É patrocinado pela plataforma {{platformname}}. Aplicativo criado por",
  "ABOUT_3":"e é código-aberto, projecto orientado para a comunidade móvel. Oferece acesso ao conteúdo para leitura, comentários, votos, publicar, tranferir ganhos etc. Carateristicas oferecidas por {{platformname}} blockchain and {{sitename}}.",
  "ABOUT_4":"1. O aplicativo nunca acessa ou guarda o dinheiro dos utilizadores.",
  "ABOUT_5":"2. A App oferece um modelo seguro do lado-cliente, com chaves privadas, guardadas localmente e nunca enviada para outros servidores.",
  "ABOUT_6":"3. O Aplicativo oferece simplicidade, interfaces de utilizador e experiências atrativas.",
  "ABOUT_7":"4. O Aplicativo requer que os utilizadores insiram informações pessoais.",
  "ABOUT_8":"Vote bom-karma como testemunha",
  "ABOUT_9":"Contato/Comentários",
  "ABOUT_10":"Mais informações:",
  "REMOVE":"Remover",
  "MARKET_VIEW":"Visão do Mercado",
  "PRICE":"Preço",
  "AMOUNT":"Quantidade",
  "TOTAL":"",
  "NOORDERS":"Sem ordens abertas para",
  "DATE":"Data",
  "BUY":"Comprar",
  "SELL":"Vender",
  "OPEN":"Abrir",
  "HISTORY":"Hitórico",
  "FOLLOW_BACK":"Seguir de volta",
  "FOLLOWED":"Seguido",
  "UNFOLLOW":"Deixar de seguir",
  "FOLLOWING":"Seguindo",
  "FOLLOWERS":"Seguidores",
  "SEARCH_FOLLOWERS":"Procurar seguidores",
  "SEARCH_FOLLOWING":"Procurar quem estou a seguir",
  "BY":"por",
  "IN":"no",
  "MENU":"",
  "BOOKMARK":"Favoritos",
  "REBLOG":"Repostar",
  "UPVOTE":"Upvote ",
  "DOWNVOTE":"",
  "UNVOTE_DOWNVOTED":"Cancelar Downvote",
  "UNVOTE_UPVOTED":"Cancelar Upvote",
  "REPLY":"Responder",
  "EDIT":"Editar",
  "POST_1":"Deslize para esquerda nos comentários para veras opções",
  "POST_2":"Toque nos comentários para ver os sub-comentários",
  "OPTIONS":"Opções",
  "RESTEEMED_BY":"Repostado por",
  "NOTHING_HERE":"Nada por aqui, ainda...",
  "BALANCES":"Balanço",
  "PROFILE_1":"{{platformname}}, provas transacionáveis que podem ser transferidas em qualquer altura. {{platformname}} podem ser convertidas {{platformpower}} num processo chamado poder abaixo.",
  "PROFILE_2":"{{platformpower}}, tokens de influencia para ganhar mais poder para guardar a longo prazo e votar nas publicações. Quanto mais se possui mais se pode influenciar as recompensas para outros e ganhar mais recompensas por votar.",
  "PROFILE_3":"Provas que valem cerca de {{platformsunit}} de {{platformname}}.",
  "ESTIMATED_VALUE":"Valor estimado",
  "PROFILE_4":"O valor estimado é baseado numa média do valor de 7 dias de {{platformname}}.",
  "TRANSACTION_HISTORY":"Histórico de Transação",
  "POSTING":"Publicando",
  "PROFILE_5":"A chave de publicação é usada para publicar e votar. Ela deve ser diferente da chave de ativação e da chave de proprietário.",
  "OWNER":"Proprietário",
  "PROFILE_6":"A chave de proprietário é a chave mestra para conta e é exigida para mudar as outras chaves. Uma chave privada ou senha para a chave de proprietário deverá ser mantida offline assim que possível.",
  "ACTIVE":"Ativo",
  "PROFILE_7":"A chave de ativação é usada para fazer transferências e colocar ordens no mercado interno.",
  "MEMO":"Anotações",
  "PROFILE_8":"A chave de anotações é usada para criar e ler anotações.",
  "BLOG":"",
  "POSTS":"Publicações",
  "REPLIES":"Respostas",
  "WALLET":"Carteira",
  "TAG":"",
  "USER":"Utilizador",
  "CLOSE":"Fechado",
  "TO":"Para",
  "ASSET":"Ativo",
  "SEND":"Enviar",
  "SECURITY":"Segurança",
  "AVAILABLE":"Disponível",
  "PUBLIC_MEMO":"Memorando Público",
  "TO_DESC":"Utilizador ex: good-karma",
  "PIN_CODE":"Código Pin",
  "PIN_TEXT":"Código Pin ajuda a assegurar o aplicativo e suas informações. <br/><br/> Uma vez ativado, terá no máximo 4 tentativas para destravar, se esquecer o pin ou errar, o aplicativo irá remover suas informações de utilizador. Pode entrar de novo e continuar a usar o aplicativo.",
  "NOTIFICATIONS":"Notificações",
  "VOTE_TEXT":"Você receberá uma notificação quando alguém votar no seu conteúdo! Notificações também incluem peso de voto no alerta da mensagem.) seja voto positivo, voto negativo, voto nulo).",
  "VOTE":"Votar",
  "COMMENT_TEXT":"Recebe uma notificação quando alguém comentar nas suas publicações ou comentários.<br/> Notificações incluem quando alguém edita os comentários também.",
  "COMMENT":"Comentar",
  "FOLLOW_TEXT":"Recebe sempre uma notificação quando alguém Seguir ou Deixar de segui-lo!",
  "MENTIONS":"Menções",
  "MENTIONS_TEXT":"Recebe sempre uma notificação quando alguém o mencionar nalguma publicação ou comentário!",
  "RESTEEM":"",
  "RESTEEM_TEXT":"Irá receber notificação quando alguem republicar a sua publicaçã!",
  "CONFIGURATIONS":"Configurações",
  "VOTING":"Votando",
  "VOTING_TEXT":"O peso de voto ou percentagem afeta o poder de voto na app, por isso pode regular o seu recompensa de voto <br/><br/><b>Nota:</b> Isto irá modificar o peso/percentagem para votar para baixo também e em todo o lado na App",
  "SERVER":"Servidor",
  "SERVER_TEXT":"Recomendado",
  "SAVE_CHANGES":"Salvar mudanças",
  "VOTERS_INFO":"Informações dos eleitores",
  "WELCOME_BACK":"Bem vindo de Volta!",
  "LOGIN_1":"Conecte-se com seu nome de utilizador e senha para continuar.",
  "LOGIN_2":"Chave de publicação é usada para publicar, comentar, votar, seguir.",
  "LOGIN_3":"Chave de ativação é usada para tranferências e atualização de fotos de perfil.",
  "LOGIN_4":"As credenciais do utilizador são guardadas localmente no seu aparelho. Depis de desligar as suas credenciais são removidas",
  "DONT_HAVE":"Não possui conta?\n",
  "SIGN_UP_NOW":"Registe-se agora",
  "CANCEL":"Cancelar",
  "ADVANCED":"Avançado",
  "ACTIVE_PRIKEY":"Chave de ativação privada",
  "POSTING_PRIKEY":"Chave de publicação privada",
  "MASTER_PASS":"Senha Mestra/Principal",
  "USERNAME":"Utilizador",
  "CARD_VIEW":"Visão de Cartão",
  "COMPACT_VIEW":"Vista compacta",
  "SEARCH":"Procurar",
  "SUBMIT_A_STORY":"Publicar uma história",
  "REPLYTO":"Responder para",
  "POST":"Publicação",
  "PREVIEW":"Vizualizar",
  "DEFAULT":"Padrão 50% / 50%",
  "POWERUP":"Força Total 100%",
  "DECLINE_PAYOUT":"Recusar Pagamento",
  "SAVE_FOR_LATER":"Guardar pra mais tarde",
  "CLEAR":"Terminado",
  "POST_CONTENT":"Conteúdo da publicação",
  "COMMENT_CONTENT":"Conteúdo do comentário",
  "TITLE":"Título",
  "TAGS":"",
  "NOT_MATCH":"Não condiz",
  "CONFIRM_PIN":"Confirmar Pin",
  "INCORRECT":"Incorreto",
  "OPENING_POST":"Abrindo postagem",
  "SET_PIN":"Configure PIN",
  "ENTER_PIN":"Entrar com Pin",
  "ARE_YOU_SURE":"Tem a certeza?",
  "REBLOG_TEXT":"Republicar é irreversível, quer mesmo continuar",
  "BROADCAST_ERROR":"Erro de difusão, tente novamente!",
  "SUCCESS":"Sucesso",
  "REBLOGGED_POST":"Publicação republicada",
  "LOGIN_FAIL":"Login falhou! por favor certifique-se que está ligado com a senha master ou a chave publicação privada no Login se escolheu o modo avançado.",
  "LOGIN_FAIL_A":"Login falhou! por favor certifique-se que está conetado com a senha master ou a chave ativa privada no Login se escolheu o modo avançado.",
  "WARNING":"Cuidado",
  "VOTE_FOR_WITNESS":"Votando por uma Testemunha",
  "VOTED_FOR_WITNESS":"Votou por uma Testemunha",
  "AGO":"atrás",
  "FROM_NOW":"de agora",
  "SECS":"segs",
  "A_MIN":"um minuto",
  "MINS":"",
  "AN_HOUR":"uma hora",
  "HOURS":"horas",
  "A_DAY":"um dia",
  "DAYS":"dias",
  "A_MONTH":"um mês",
  "MONTHS":"meses",
  "A_YEAR":"um ano",
  "YEARS":"anos",
  "MIN_READ":"ler min",
  "DOWNVOTE_FLAG":"Vote para baixo ou bandeira",
  "CAPTURE_PICTURE":"Capturar imagem",
  "SELECT_PICTURE":"Escolher uma imagem",
  "SET_CUSTOM_URL":"Configure URL costumizada",
  "INSERT_PICTURE":"Inserir uma imagem",
  "ERROR":"Erro",
  "UPLOAD_ERROR":"Erro no carregamento",
  "CAMERA_CANCELLED":"Camera cancelada",
  "SET_URL":"Configurarl URL",
  "DIRECT_LINK_PICTURE":"Link web direto para a imagem",
  "COMMENT_SUBMITTED":"Comentário publicado!",
  "DELETE_COMMENT":"Apagar comentários é irreversível",
  "DELETED_COMMENT":"Comentário apagado",
  "UPLOADING_PICTURE":"Carregando imagem",
  "UPLOAD_COMPLETED":"Carregamento completo",
  "UPLOAD_FAILED":"Carregamento falhou",
  "PASSWORD_INCORRECT":"A senha ou nome da conta são incorretos",
  "INFO":"Informações",
  "QR_TEXT":"Ponha o código QR dentro da área de scan",
  "BALANCE_TEXT":"Certifique-se que possui saldo suficiente para a transação!",
  "NONEXIST_USER":"O utilizador para quem está a tentar transferir fundos, não existe",
  "TRANSFER_TEXT":"Tem certeza que quer transferir?",
  "CONFIRMATION":"Confirmação",
  "TX_BROADCASTED":"Transação foi difundida",
  "FEED":"",
  "TRENDING":"Tendencia",
  "HOT":"Quente",
  "NEW":"Novidades",
  "PROMOTED":"Promovidos",
  "VOTES":"Votos",
  "PAYOUT":"Pagamento",
  "COMMENTS":"Comentários",
  "TRENDING_30":"Tendencia a 30 dias",
  "SORT_POST_BY":"Ordenar publicações por:",
  "PAYOUT_CYCLE":"Ciclo de Pagamento",
  "POTENTIAL_PAYOUT":"Pagamento em potencial",
  "PAST_PAYOUT":"Último Pagamento",
  "AUTHOR_PAYOUT":"Pagamento do Autor",
  "CURATION_PAYOUT":"Pagamento de curadoria",
  "POST_SUBMITTED":"Publicação enviada!",
  "POST_LATER":"Publique para futura submissão",
  "SAVED":"Salvo",
  "CLEARED":"Limpo",
  "FLAGGING_TEXT":"Por uma bandeira numa publicação pode remover recompensas e tornar o material menos visivel.<br><br>A bandeira deve ser usada para : <ul><li>Fraude ou Plagiarismo</li><li>Discurso de ódio ou Internet Trolling</li><li>Categorização mal feita intencionalmente ou Spam</li></ul>",
  "REQUEST_LIMIT_TEXT":"Limite de pedidos atingido. verifique outro assunto/etiqueta!",
  "POST_IS_UNBOOKMARK":"Publicação removida dos favoritos!",
  "POST_IS_BOOKMARK":"Publicação adicionada aos favoritos!",
  "RESET":"Reiniciar",
  "MODIFY_PICTURE":"Modificar a fotografia de perfil",
  "MODIFY_COVER_PICTURE":"Modificar fotografia da capa",
  "ACTIVE_KEY_REQUIRED_TEXT":"Por favor insira a chave de activação privada que escolheu, Modo de Login Avançado",
  "RESET_PICTURE_TEXT":"Isto reconfigura a imagem do perfil ultizador",
  "RESET_COVER_PICTURE_TEXT":"Isto reconfigura a imagem do ultizador",
  "UPDATE_REQUIRES_RESTART":"Atualização do server obriga a Reiniciar!",
  "SETTINGS_UPDATED":"Configurações foram atualizadas",
  "LANGUAGES":"Língua",
  "LANGUAGES_TEXT":"Aqui pode mudar a língua da App",
  "LOGIN_TO_X":"Esta operação obriga que o utilizador estaja ligado com a senha principal, chave activação/publicação",
  "GALLERY":"Galeria",
  "TRANSLATIONS":"Tradutores que contribuiram",
  "SHARE":"Partilhar",
  "MARKETPLACE":"Mercado",
  "EXCHANGE":"Câmbio",
  "DRAFTS":"Rascunhos",
  "POST_IS_UNDRAFT":"Publicação removida dos Rascunhos!",
  "POST_IS_DRAFT":"Puplicação adicionada a Rascunhos!",
  "SWIPE_LEFT":"Role para a esquerda para opções",
  "MANAGE":"Gerir",
  "IMAGE_REMOVED":"Imagem removida",
  "COPY":"Copiar",
  "NO_IMAGE":"Não carregou nenhuma imagem, ainda",
  "PULL_DOWN_TO_REFRESH":"Carregue para refrescar",
  "EXTERNAL_APPS":"Apps Externas",
  "PLUGINS":"",
  "SUGGEST":"Sugira",
  "COMING_SOON":"Brevemente",
  "CHAIN":"",
  "CHAIN_TEXT":"Aqui pode escolher blockchain ou a plataforma por defeito",
  "CURRENCY":"",
  "CURRENCY_TEXT":"",
  "ABOUT_11":"",
  "FOUNDER":"",
  "ADD_ACCOUNT":"",
  "PLATFORM":""
}
},{}],153:[function(require,module,exports){
module.exports={
  "HOME":"Домой",
  "LOGIN":"Войти",
  "LOGOUT":"Выйти",
  "PROFILE":"Профиль",
  "FOLLOW":"Подписаться",
  "BOOKMARKS":"Закладки",
  "TRANSFER":"Перевести средства",
  "MARKET":"Рынок",
  "SETTINGS":"Настройки",
  "ABOUT":"О программе",
  "ABOUT_1":"где каждый может получать вознаграждение за свои контент!",
  "ABOUT_2":"основано на платформе {{platformname}}. Приложение создано",
  "ABOUT_3":"и является мобильным проектом с открытым исходным кодом управляемым сообществом. Приложение предоставляет доступ к контенту для чтения, комментирования, голосования и размещения, предоставляет возможность перевода средств и другие функции, предлагаемые блокчейном {{platformname}} и сервисом {{sitename}}.",
  "ABOUT_4":"1. Приложение не имеет доступа к денежным средствам пользователя и не удерживает их;",
  "ABOUT_5":"2. Приложение использует модель безопасности на стороне клиента, закрытые ключи хранятся локально и никогда не передаются на сервера;",
  "ABOUT_6":"3. Приложение предоставляет простой и привлекательный пользовательский интерфейс;",
  "ABOUT_7":"4. Приложение никогда не требует пользователя ввести какие-либо персональные данные.",
  "ABOUT_8":"Проголосовать за делегата good-karma",
  "ABOUT_9":"Контакты/Обратная связь:",
  "ABOUT_10":"Дополнительная информация:",
  "REMOVE":"Удалить",
  "MARKET_VIEW":"Обзор рынка",
  "PRICE":"Цена",
  "AMOUNT":"Сумма",
  "TOTAL":"Всего",
  "NOORDERS":"Нет открытых ордеров у",
  "DATE":"Дата",
  "BUY":"Купить",
  "SELL":"Продать",
  "OPEN":"Открыть",
  "HISTORY":"История",
  "FOLLOW_BACK":"Подписаться взаимно",
  "FOLLOWED":"Подписки",
  "UNFOLLOW":"Отписаться",
  "FOLLOWING":"Подписка",
  "FOLLOWERS":"Подписаны",
  "SEARCH_FOLLOWERS":"Поиск подписчиков",
  "SEARCH_FOLLOWING":"Поиск подписанных",
  "BY":"от",
  "IN":"в",
  "MENU":"Меню",
  "BOOKMARK":"Закладка",
  "REBLOG":"Репост",
  "UPVOTE":"Голос За",
  "DOWNVOTE":"Голос Против",
  "UNVOTE_DOWNVOTED":"Снять Голос Против",
  "UNVOTE_UPVOTED":"Снять Голос За",
  "REPLY":"Ответить",
  "EDIT":"Редактировать",
  "POST_1":"Проведите пальцем влево на комментарии, чтобы увидеть варианты",
  "POST_2":"Нажмите на комментарии, чтобы увидеть вложенные комментарии",
  "OPTIONS":"Параметры",
  "RESTEEMED_BY":"Репостнуто",
  "NOTHING_HERE":"Здесь пока ничего нет...",
  "BALANCES":"Балансы",
  "PROFILE_1":"{{platformname}}, перемещаемые цифровые токены, которые могут быть переданы в любое время. {{platformname}} может быть конвертирован в {{platformpower}}, этот процесс называется «усиление {{platformname}}-а».",
  "PROFILE_2":"{{platformpower}}, неперемещаемые цифровые токены, их количество увеличивается при долгосрочном хранении и голосовании за посты. Чем их у Вас больше, тем сильней Вы влияете на вознаграждение за посты других и тем больше Вы получаете вознаграждение за свое голосование.",
  "PROFILE_3":"Токены стоят примерно {{platformsunit}} в {{platformname}} эквиваленте.",
  "ESTIMATED_VALUE":"Ориентировочная стоимость",
  "PROFILE_4":"Ориентировочная стоимость основана на 7-дневной средней стоимости {{platformname}}.",
  "TRANSACTION_HISTORY":"История транзакций",
  "POSTING":"Постинг",
  "PROFILE_5":"Постинг ключ используется для постинга и голосования. Он должен отличаться от активного ключа и ключа владельца.",
  "OWNER":"Владелец",
  "PROFILE_6":"Ключ владельца является мастер ключом для аккаунта и требуется для изменения других ключей. Закрытый ключ или пароль от ключа владельца должен храниться офлайн, насколько это возможно.",
  "ACTIVE":"Активный",
  "PROFILE_7":"Активный ключ используется для перевода средств и размещения ордеров на внутреннем рынке.",
  "MEMO":"Примечание",
  "PROFILE_8":"Ключ для примечаний используется для создания и чтения примечаний.",
  "BLOG":"Блог",
  "POSTS":"Посты",
  "REPLIES":"Ответы",
  "WALLET":"Кошелек",
  "TAG":"Тег",
  "USER":"Пользователь",
  "CLOSE":"Закрыть",
  "TO":"Кому",
  "ASSET":"Актив",
  "SEND":"Отправить",
  "SECURITY":"Безопасность",
  "AVAILABLE":"Доступно",
  "PUBLIC_MEMO":"Общедоступное примечание",
  "TO_DESC":"Пользователь, например good-karma",
  "PIN_CODE":"PIN-код",
  "PIN_TEXT":"PIN-код поможет Вам защитить приложение и Ваши данные. <br/><br/><b>Примечание:</b> После включения, у Вас есть максимум 4 попытки разблокировать приложение, если Вы забыли PIN-код или ошиблись в его наборе, приложение удалит данные вошедшего в систему пользователя. Вы можете повторно выполнить вход и продолжить использовать приложение.",
  "NOTIFICATIONS":"Уведомления",
  "VOTE_TEXT":"Вы получите уведомление, когда кто то голосует за Ваш контент! <br/><b>Примечание:</b> Уведомления отображают вес голоса в сообщении (будь то Голос За, Голос Против, снятие Голоса).",
  "VOTE":"Голосование",
  "COMMENT_TEXT":"Вы получите уведомление, когда кто-то прокомментирует Ваши посты или комментарии!<br/> <b>Примечание:</b> Вы также получите уведомление, если кто-то <b>отредактирует</b> свой комментарий.",
  "COMMENT":"Комментарий",
  "FOLLOW_TEXT":"Вы получите уведомление, когда кто-то подпишется или отпишется от Вас!",
  "MENTIONS":"Упоминания",
  "MENTIONS_TEXT":"Вы получите уведомление, когда кто-то упомянет Вас в своем посте/комментарий!",
  "RESTEEM":"Репосты",
  "RESTEEM_TEXT":"Вы получите уведомление, когда кто-то сделает репост Вашего поста!",
  "CONFIGURATIONS":"Конфигурация",
  "VOTING":"Голосовать",
  "VOTING_TEXT":"Вес голоса в процентах влияет на силу голоса в приложении, так что Вы можете регулировать награду при голосовании. <br/><br/><b>Примечание:</b> Это также изменит вес Голоса Против",
  "SERVER":"Сервер",
  "SERVER_TEXT":"Рекомендованный",
  "SAVE_CHANGES":"Сохранить изменения",
  "VOTERS_INFO":"Информация о проголосовавших",
  "WELCOME_BACK":"Добро пожаловать!",
  "LOGIN_1":"Чтобы продолжить, войдите с Вашим именем пользователя и паролем.",
  "LOGIN_2":"Постинг ключ используется для написания постов, комментариев, голосования и подписок.",
  "LOGIN_3":"Активный ключ используется для перевода средств и обновления изображения в профиле.",
  "LOGIN_4":"Учетные данные пользователя хранятся локально на устройстве. При Выходе учетные данные будут удалены!",
  "DONT_HAVE":"Не зарегистрированы?",
  "SIGN_UP_NOW":"Зарегистрироваться сейчас",
  "CANCEL":"Отмена",
  "ADVANCED":"Расширенный режим",
  "ACTIVE_PRIKEY":"Активный закрытый ключ",
  "POSTING_PRIKEY":"Постинг закрытый ключ",
  "MASTER_PASS":"Мастер/основной пароль",
  "USERNAME":"Имя пользователя",
  "CARD_VIEW":"Карточки",
  "COMPACT_VIEW":"Компактный",
  "SEARCH":"Поиск",
  "SUBMIT_A_STORY":"Добавить статью",
  "REPLYTO":"Ответить на",
  "POST":"Пост",
  "PREVIEW":"Предварительный просмотр",
  "DEFAULT":"По умолчанию 50% / 50%",
  "POWERUP":"Заплатить 100% в {{platformpower}}",
  "DECLINE_PAYOUT":"Отказаться от выплаты",
  "SAVE_FOR_LATER":"СОХРАНИТЬ ДЛЯ ПОСЛЕДУЮЩЕГО ИСПОЛЬЗОВАНИЯ",
  "CLEAR":"ОЧИСТИТЬ",
  "POST_CONTENT":"Содержание поста",
  "COMMENT_CONTENT":"Содержание комментария",
  "TITLE":"Заголовок",
  "TAGS":"Теги",
  "NOT_MATCH":"НЕ СОВПАДЕНИЙ",
  "CONFIRM_PIN":"Подтвердите PIN-код",
  "INCORRECT":"НЕПРАВИЛЬНО",
  "OPENING_POST":"открытие поста",
  "SET_PIN":"Установите PIN-код",
  "ENTER_PIN":"Введите PIN-код",
  "ARE_YOU_SURE":"Вы уверены?",
  "REBLOG_TEXT":"Репост является необратимым, Вы хотите продолжить?",
  "BROADCAST_ERROR":"Не удалось транслировать, попробуйте еще раз!",
  "SUCCESS":"Успешно",
  "REBLOGGED_POST":"Репостнутый пост!",
  "LOGIN_FAIL":"Ошибка входа! Пожалуйста, убедитесь, что вы вошли в систему с мастер паролем или указали закрытый Постинг ключ при входе в систему в расширенном режиме.",
  "LOGIN_FAIL_A":"Ошибка входа! Пожалуйста, убедитесь, что вы вошли в систему с мастер паролем или указали закрытый Активный ключ при входе в систему в расширенном режиме.",
  "WARNING":"Предупреждение",
  "VOTE_FOR_WITNESS":"Голосовать за делегата",
  "VOTED_FOR_WITNESS":"Проголосовали за делегата",
  "AGO":"назад",
  "FROM_NOW":"с этого момента",
  "SECS":"секунд",
  "A_MIN":"минута",
  "MINS":"минут(ы)",
  "AN_HOUR":"час",
  "HOURS":"часа(ов)",
  "A_DAY":"день",
  "DAYS":"дня(ей)",
  "A_MONTH":"месяц",
  "MONTHS":"месяца(ев)",
  "A_YEAR":"год",
  "YEARS":"года",
  "MIN_READ":"мин чтения",
  "DOWNVOTE_FLAG":"Голос Против или флаг",
  "CAPTURE_PICTURE":"Захват изображения",
  "SELECT_PICTURE":"Выбор изображения",
  "SET_CUSTOM_URL":"Задать пользовательский URL",
  "INSERT_PICTURE":"Вставить изображение",
  "ERROR":"Ошибка",
  "UPLOAD_ERROR":"Ошибка при загрузке",
  "CAMERA_CANCELLED":"Захват изображения отменен",
  "SET_URL":"Вставить ссылку",
  "DIRECT_LINK_PICTURE":"Прямая ссылка на изображение",
  "COMMENT_SUBMITTED":"Комментарий отправлен!",
  "DELETE_COMMENT":"Удаление комментариев является необратимым",
  "DELETED_COMMENT":"Удаленный комментарий",
  "UPLOADING_PICTURE":"Загрузка изображения",
  "UPLOAD_COMPLETED":"Загрузка завершена",
  "UPLOAD_FAILED":"Не удалось загрузить",
  "PASSWORD_INCORRECT":"Неправильный пароль или имя пользователя",
  "INFO":"Информация",
  "QR_TEXT":"Разместите QR код внутри сканирующей области",
  "BALANCE_TEXT":"Убедитесь что у Вас достаточно средств для транзакции!",
  "NONEXIST_USER":"Пользователь, которому Вы пытаетесь перевести средства, не существует!",
  "TRANSFER_TEXT":"Вы уверены что хотите осуществить перевод средств?",
  "CONFIRMATION":"Подтверждение",
  "TX_BROADCASTED":"Транзакция была транслирована",
  "FEED":"Лента",
  "TRENDING":"Лучшее",
  "HOT":"Актуальное",
  "NEW":"Новое",
  "PROMOTED":"Продвигаемое",
  "VOTES":"Голосов",
  "PAYOUT":"Выплата",
  "COMMENTS":"Комментариев",
  "TRENDING_30":"Лучшее за 30 дней",
  "SORT_POST_BY":"Сортировать посты по:",
  "PAYOUT_CYCLE":"Период выплат",
  "POTENTIAL_PAYOUT":"Потенциальная выплата",
  "PAST_PAYOUT":"Последняя выплата",
  "AUTHOR_PAYOUT":"Авторская выплата",
  "CURATION_PAYOUT":"Кураторская выплата",
  "POST_SUBMITTED":"Пост опубликован!",
  "POST_LATER":"Пост для отсроченной публикации!",
  "SAVED":"Сохранен",
  "CLEARED":"Очищен",
  "FLAGGING_TEXT":"Ставя флаг посту, Вы можете уменьшить награду и сделать этот материал менее заметным.<br><br>Флаг должен быть использован в следующих случаях: <ul><li>Мошенничество или Плагиат</li><li>Брань или Интернет Троллинг</li><li>Преднамеренное использование несоотверствующей категории или Спам</li></ul>",
  "REQUEST_LIMIT_TEXT":"Превышено количество запросов. Проверьте другие тренды/теги!",
  "POST_IS_UNBOOKMARK":"Пост удален из закладок!",
  "POST_IS_BOOKMARK":"Пост добавлен в закладки!",
  "RESET":"Сбросить",
  "MODIFY_PICTURE":"Изменить изображение профиля",
  "MODIFY_COVER_PICTURE":"Изменить изображение обложки",
  "ACTIVE_KEY_REQUIRED_TEXT":"Пожалуйста, предоставьте Активный закрытый ключ, если Вы выбрали расширенный режим авторизации!",
  "RESET_PICTURE_TEXT":"Это приведет к сбросу изображения Вашего профиля",
  "RESET_COVER_PICTURE_TEXT":"Это приведет к сбросу изображения Вашей обложки",
  "UPDATE_REQUIRES_RESTART":"Обновление сервера требует перезагрузки!",
  "SETTINGS_UPDATED":"Настройки обновлены!",
  "LANGUAGES":"Языки",
  "LANGUAGES_TEXT":"Здесь вы можете изменить язык приложения.",
  "LOGIN_TO_X":"Эта операция требует авторизации пользователя в системе с паролем, активным/постинг ключом. Пожалуйста, авторизуйтесь и повторите попытку.",
  "GALLERY":"Галерея",
  "TRANSLATIONS":"Авторы перевода",
  "SHARE":"Поделиться",
  "MARKETPLACE":"Рынок",
  "EXCHANGE":"Биржа",
  "DRAFTS":"Черновики",
  "POST_IS_UNDRAFT":"Пост удален из черновиков!",
  "POST_IS_DRAFT":"Пост добавлен в черновики!",
  "SWIPE_LEFT":"Проведите пальцем влево чтобы увидеть варианты",
  "MANAGE":"Управление",
  "IMAGE_REMOVED":"Изображение удалено",
  "COPY":"Копировать",
  "NO_IMAGE":"Вы еще не загрузили ни одного изображения!",
  "PULL_DOWN_TO_REFRESH":"Потяните вниз, чтобы обновить",
  "EXTERNAL_APPS":"Внешние приложения",
  "PLUGINS":"Плагины",
  "SUGGEST":"Предложить",
  "COMING_SOON":"Скоро",
  "CHAIN":"Блокчейн",
  "CHAIN_TEXT":"Здесь вы можете изменить платформу по умолчанию (блокчейн).",
  "CURRENCY":"Валюта",
  "CURRENCY_TEXT":"Здесь Вы можете изменить валюту по умолчанию. Награда за пост/комментарий будет отображаться в этой валюте.",
  "ABOUT_11":"<br><b>Перечень возможностей</b><br>- Получите доступ к уникальным статьям на любую интересную Вам тему;<br>- Взаимодействуйте с авторами, комментируя и участвуя в дискуссиях;<br>- Голосуйте за посты, чтобы вознаградить автора, а также получить кураторское вознаграждение;<br>- Публикуйте свои посты и бесплатно размещайте их, чтобы привлечь фолловеров и получить вознаграждения;<br>- Пишите статьи в пути, сохраняйте несколько черновиков поста и публикуйте их, когда Вам удобно;<br>- Добавляйте понравившиеся статьи в закладки, чтобы вернуться к ним позже;<br>- Обменивайте или обналичивайте Ваши вознаграждения;<br>- Посылайте средства любым авторам, пользователям, друзьям, фолловерам и т.д.;<br>- Подписывайтесь на интересных авторов и блоггеров;<br>- Пользуйтесь удобным поиском по фолловерам или авторам, на которых Вы подписаны;<br>- Получайте уведомления - оставайтесь на связи с Вашими фолловерами и наблюдайте за развитием дискуссий, в которых участвуете;<br>- Находите новых интересных авторов и статьи, используя поиск по тегам/категориям;<br>- Персонализируйте страницу своего профиля;<br>- Не пропускайте обновления - в них Вы найдете еще больше новых функций!<br><br><b>Безопасность</b><br>1. Приложение не имеет доступа или права распоряжаться средствами пользователя;<br>2. Приложение предлагает модель безопасности на стороне клиента, где приватные ключи хранятся локально и никогда не отправляются ни на какие сервера - только Вы ответственны за хранение своих паролей;<br>3. Приложение обладает простым привлекательным пользовательским интерфейсом, что подарит Вам положительный опыт использования;<br>4. В приложении предусмотрен дополнительный уровень безопасности в виде пин-кода.<br><br>eSteem поддерживает платформы Steem и Golos.<br>",
  "FOUNDER":"Основатель и ведущий разработчик",
  "ADD_ACCOUNT":"Добавить аккаунт",
  "PLATFORM":"Платформа"
}
},{}],154:[function(require,module,exports){
module.exports={
  "HOME":"Hem",
  "LOGIN":"Logga in",
  "LOGOUT":"Logga ut",
  "PROFILE":"Profil",
  "FOLLOW":"Följ",
  "BOOKMARKS":"Bokmärken",
  "TRANSFER":"Överföring",
  "MARKET":"Marknad",
  "SETTINGS":"Inställningar",
  "ABOUT":"Om",
  "ABOUT_1":"där vem som helst kan belönas för sitt material!",
  "ABOUT_2":"är en social mediaplatform där du betalas för att blogga, kommentera och kurrera inlägg.",
  "ABOUT_3":"och är ett community-drivet projekt för mobilen som baseras på öppen källkod. Den ger ger dig tillgång så att du kan läsa innehåll, kommentera, rösta, skapa inlägg och föra över belöningar, och diverse andra funktioner som görs möjliga av {{platformname}} block-kedja och {{sitename}}.",
  "ABOUT_4":"Appen har aldrig tillgång till användarens pengar.",
  "ABOUT_5":"Appen erbjuder en klientcentrerad säkerhetsmodell, dvs. dina privata nycklar stannar lokalt och skickas inte till andra servrar.",
  "ABOUT_6":"Appen erbjuder ett enkelt och attraktivt användergränssnitt, vilket ger en god användarupplevelse.",
  "ABOUT_7":"Appen kräver aldrig att användaren matar in personlig information.",
  "ABOUT_8":"Rösta på good-karma som vittne",
  "ABOUT_9":"Kontakt/Återkoppling",
  "ABOUT_10":"Mera information:",
  "REMOVE":"Ta bort",
  "MARKET_VIEW":"Marknadsvy",
  "PRICE":"Pris",
  "AMOUNT":"Mängd",
  "TOTAL":"Summa",
  "NOORDERS":"Inga aktiva ordrar för",
  "DATE":"Datum",
  "BUY":"Köp",
  "SELL":"Sälj",
  "OPEN":"Öppen",
  "HISTORY":"Historik",
  "FOLLOW_BACK":"Följ tillbaka",
  "FOLLOWED":"Följer",
  "UNFOLLOW":"Sluta följa",
  "FOLLOWING":"Följer",
  "FOLLOWERS":"Följare",
  "SEARCH_FOLLOWERS":"Sök bland följare",
  "SEARCH_FOLLOWING":"Sök bland de du följer",
  "BY":"av",
  "IN":"i",
  "MENU":"Meny",
  "BOOKMARK":"Bokmärk",
  "REBLOG":"Återblogga",
  "UPVOTE":"Rösta upp",
  "DOWNVOTE":"Rösta ner",
  "UNVOTE_DOWNVOTED":"Ångra rösta ner",
  "UNVOTE_UPVOTED":"Ångra rösta upp",
  "REPLY":"Svara",
  "EDIT":"Redigera",
  "POST_1":"Svep åt vänster över kommentarer för att se alternativ",
  "POST_2":"Dutta på kommentarer för att se underkommentarer",
  "OPTIONS":"Alternativ",
  "RESTEEMED_BY":"Återsteemades av",
  "NOTHING_HERE":"Tomt än så länge...",
  "BALANCES":"Saldon",
  "PROFILE_1":"Steem, utbytsbara polletter som går att överföra när som helst. Steem kan omvandlas till SteemPower i en process som kallas att öka rösteffekt eller \"ånga upp\".",
  "PROFILE_2":"SteemPower, inflytandepolletter som ger högre rösteffekt för att du sparar dem långsiktigt och röstar på inlägg. Ju mer du har, desto mer kan du påverka andras belöningar och belönas för smart röstning.",
  "PROFILE_3":"Polletter värda ungefär {{platformsunit}} av {{platformname}.",
  "ESTIMATED_VALUE":"Uppskattat värde",
  "PROFILE_4":"Det uppskattade värdet är baserat på ett 7 dagars genomsnittlig värde av {{platformname}.",
  "TRANSACTION_HISTORY":"Transaktionshistorik",
  "POSTING":"Inlägg",
  "PROFILE_5":"Inläggsnyckeln används för att skriva inlägg och rösta. Den bör vara olik allmännyckeln och huvudnyckeln.",
  "OWNER":"Ägare",
  "PROFILE_6":"Ägarnyckeln är huvudnyckeln för kontot och behövs för att kunna byta de andra nycklarna. För att öka säkerheten bör den \"privata nyckeln\" eller lösenordet till huvudnyckeln användas så lite som möjligt.",
  "ACTIVE":"Rörelse",
  "PROFILE_7":"Allmännyckeln används för att göra överföringar och att lägga ordrar i den interna marknaden.",
  "MEMO":"Anteckning",
  "PROFILE_8":"Anteckningsnyckeln används för att skapa och läsa anteckningar.",
  "BLOG":"Blogg",
  "POSTS":"Inlägg",
  "REPLIES":"Svar",
  "WALLET":"Plånbok",
  "TAG":"Ämne",
  "USER":"Användare",
  "CLOSE":"Stäng",
  "TO":"Till",
  "ASSET":"Tillgång",
  "SEND":"Skicka",
  "SECURITY":"Säkerhet",
  "AVAILABLE":"Tillgänglig",
  "PUBLIC_MEMO":"Offentlig anteckning",
  "TO_DESC":"Användare t.ex. good-karma",
  "PIN_CODE":"Pinkod",
  "PIN_TEXT":"Pinkoden hjälper dig att säkra appen och din data. När den aktiveras har du max 4 försök att låsa upp appen. Om du har glömt den eller misslyckas kommer appen att ta bort inloggad användardata. Du måste då logga in på nytt för att fortsätta använda appen.",
  "NOTIFICATIONS":"Meddelanden",
  "VOTE_TEXT":"Du kommer få ett meddelande när någon röstar upp ditt inlägg. Meddelanden talar även om den valda röstvikten. (oavsett uppröstning, nedröstning, av/omröstning).",
  "VOTE":"Rösta",
  "COMMENT_TEXT":"Du kommer få ett meddelande när någon kommenterar på ditt inlägg eller kommentar. Meddelanden inkluderar även när någon redigerar sin kommentar.",
  "COMMENT":"Kommentar",
  "FOLLOW_TEXT":"Du kommer få ett meddelande när någon följer eller slutar följa dig.",
  "MENTIONS":"Omnämnande",
  "MENTIONS_TEXT":"Du kommer få ett meddelande när någon nämnar ditt namn i deras inlägg/kommentar!",
  "RESTEEM":"Återsteema",
  "RESTEEM_TEXT":"Du kommer få ett meddelande när någon återsteemar ditt inlägg!",
  "CONFIGURATIONS":"Inställningar",
  "VOTING":"Röstning",
  "VOTING_TEXT":"Röstningsvikt eller procent påverkar röstningskraften på appen så att du kan reglera hur mycket du vill belöna inlägg. Detta ändrar också på röstningsvikten/procenten för nedröstningar och gäller överallt på appen.",
  "SERVER":"Server",
  "SERVER_TEXT":"Rekommenderas",
  "SAVE_CHANGES":"Spara ändringar",
  "VOTERS_INFO":"Röstarens information",
  "WELCOME_BACK":"Välkommen tillbaka!",
  "LOGIN_1":"Logga in med ditt användarnamn och lösenord för att fortsätta.",
  "LOGIN_2":"Inläggsnyckeln används för att göra inlägg, kommentera, röst, följa.",
  "LOGIN_3":"Allmännyckeln används för att göra överföringar och att uppdatera profilbild.",
  "LOGIN_4":"Användaruppgifter lagras lokalt på enheten. Vid utloggning avlägsnas uppgifterna!",
  "DONT_HAVE":"Har du inget konto?",
  "SIGN_UP_NOW":"Registrera dig nu",
  "CANCEL":"Avbryt",
  "ADVANCED":"Avancerat läge",
  "ACTIVE_PRIKEY":"Privat allmännyckel",
  "POSTING_PRIKEY":"Privat inläggsnyckel",
  "MASTER_PASS":"Ägare/huvudlösenord",
  "USERNAME":"Användarnamn",
  "CARD_VIEW":"Kortvy",
  "COMPACT_VIEW":"Kompakt vy",
  "SEARCH":"Sök",
  "SUBMIT_A_STORY":"Gör ett inlägg",
  "REPLYTO":"Svara",
  "POST":"Skicka",
  "PREVIEW":"Förhandsgranska",
  "DEFAULT":"Normal 50% / 50%",
  "POWERUP":"Ånga upp 100%",
  "DECLINE_PAYOUT":"Avsäg dig belöning",
  "SAVE_FOR_LATER":"SPARA TILL SENARE",
  "CLEAR":"TÖM",
  "POST_CONTENT":"Skriv inlägg",
  "COMMENT_CONTENT":"Kommentera material",
  "TITLE":"Titel",
  "TAGS":"Ämnen",
  "NOT_MATCH":"MATCHAR INTE",
  "CONFIRM_PIN":"Bekräfta pinkod",
  "INCORRECT":"FELAKTIG",
  "OPENING_POST":"öppnar inlägg",
  "SET_PIN":"Ställ in pinkod",
  "ENTER_PIN":"Ange pinkod",
  "ARE_YOU_SURE":"Är du säker?",
  "REBLOG_TEXT":"Återsteemade inlägg kan inte ångras, vill du fortsätta?",
  "BROADCAST_ERROR":"Sändningsfel, försök igen!",
  "SUCCESS":"Utfört",
  "REBLOGGED_POST":"Återbloggade inlägg!",
  "LOGIN_FAIL":"Inloggning misslyckades! Var god säkerställ att du loggar in med huvudlösenord eller din privata inläggsnyckel om du valt \"Avancerat läge\".",
  "LOGIN_FAIL_A":"Inloggning misslyckades! Var god säkerställ att du loggar in med huvudlösenord eller din privata rörelsenyckel om du valt \"Avancerat läge\".",
  "WARNING":"Varning",
  "VOTE_FOR_WITNESS":"Rösta på vittne",
  "VOTED_FOR_WITNESS":"Röstade på vittnet",
  "AGO":"sedan",
  "FROM_NOW":"från och med nu",
  "SECS":"sek",
  "A_MIN":"en minut",
  "MINS":"min",
  "AN_HOUR":"en timme",
  "HOURS":"timmar",
  "A_DAY":"en dag",
  "DAYS":"dagar",
  "A_MONTH":"en månad",
  "MONTHS":"månader",
  "A_YEAR":"ett år",
  "YEARS":"år",
  "MIN_READ":"min läsning",
  "DOWNVOTE_FLAG":"Rösta Ner",
  "CAPTURE_PICTURE":"Ta Foto",
  "SELECT_PICTURE":"Välj Bild",
  "SET_CUSTOM_URL":"Ställ in egen URL",
  "INSERT_PICTURE":"Infoga Bild",
  "ERROR":"Fel",
  "UPLOAD_ERROR":"Uppladdningsfel",
  "CAMERA_CANCELLED":"Kamera Avbruten",
  "SET_URL":"Ställ in URL",
  "DIRECT_LINK_PICTURE":"Direkt webblänk för bild",
  "COMMENT_SUBMITTED":"Kommentaren är skickad!",
  "DELETE_COMMENT":"Borttagning av kommentarer går inte att ångra...",
  "DELETED_COMMENT":"Tog bort kommentaren",
  "UPLOADING_PICTURE":"Laddar upp bild",
  "UPLOAD_COMPLETED":"Uppladdning Slutförd",
  "UPLOAD_FAILED":"Uppladdning Misslyckades",
  "PASSWORD_INCORRECT":"Lösenordet eller kontonamnet var felaktigt",
  "INFO":"Info",
  "QR_TEXT":"Placera QR-kod innanför skanningsområdet",
  "BALANCE_TEXT":"Se till att du har tillräckligt saldo för transaktionen!",
  "NONEXIST_USER":"Användaren du försöker överföra till existerar inte!",
  "TRANSFER_TEXT":"Är du säker att du vill föra över?",
  "CONFIRMATION":"Bekräftelse",
  "TX_BROADCASTED":"Överföring sändes",
  "FEED":"Flöde",
  "TRENDING":"Trendande",
  "HOT":"Hett",
  "NEW":"Nytt",
  "PROMOTED":"Marknadsfört",
  "VOTES":"Röster",
  "PAYOUT":"Utbetalning",
  "COMMENTS":"Kommentarer",
  "TRENDING_30":"Trendande för 30 dagar",
  "SORT_POST_BY":"Sortera inlägg efter",
  "PAYOUT_CYCLE":"Utbetalningsperiod",
  "POTENTIAL_PAYOUT":"Potentiell Utbetalning",
  "PAST_PAYOUT":"Tidigare Utbetalning",
  "AUTHOR_PAYOUT":"Skribents Utbetalning",
  "CURATION_PAYOUT":"Kuratorers Utbetalning",
  "POST_SUBMITTED":"Inlägget är publicerat!",
  "POST_LATER":"Inlägg för senare publicering!",
  "SAVED":"Sparat",
  "CLEARED":"Tömt",
  "FLAGGING_TEXT":"Att rösta ner ett inlägg kan ta bort belöning och göra inlägget mindre synligt.<br><br> Nedrösten bör användas för följande: <ul><li>Bedräger eller Plagiat</li><li>Hets eller Trolling</li><li>Medvetet felkategoriserat innehåll eller Spam</li></ul>",
  "REQUEST_LIMIT_TEXT":"Slut på flödet nått. Kolla in andra trender/ämnestaggar!",
  "POST_IS_UNBOOKMARK":"Inlägget har tagits bort från bokmärken!",
  "POST_IS_BOOKMARK":"Inlägget har lagts till i bokmärken!",
  "RESET":"Återställ",
  "MODIFY_PICTURE":"Modifiera profilbild",
  "MODIFY_COVER_PICTURE":"Modifiera uppslagsbild",
  "ACTIVE_KEY_REQUIRED_TEXT":"Var god ange den privata rörelsenyckeln om du har valt Avancerat läge!",
  "RESET_PICTURE_TEXT":"Det här återställer profilbild",
  "RESET_COVER_PICTURE_TEXT":"Det här återställer uppslagsbild",
  "UPDATE_REQUIRES_RESTART":"Serveruppdatering kräver omstart!",
  "SETTINGS_UPDATED":"Inställningar har uppdaterats!",
  "LANGUAGES":"Språk",
  "LANGUAGES_TEXT":"Här kan du välja det språk som appen använder.",
  "LOGIN_TO_X":"Den här operationen kräver att användaren är inloggad med lösenord, allmännyckel/inläggsnyckel. Var god logga in och försök igen.",
  "GALLERY":"Galleri",
  "TRANSLATIONS":"Bidragande översättare",
  "SHARE":"Dela",
  "MARKETPLACE":"Marknadsplats",
  "EXCHANGE":"Börs",
  "DRAFTS":"Utskick",
  "POST_IS_UNDRAFT":"Inlägg har tagits bort från utskick!",
  "POST_IS_DRAFT":"Inlägg har lagts till i utskick!",
  "SWIPE_LEFT":"Dra åt vänster för att se alternativ",
  "MANAGE":"Hantera",
  "IMAGE_REMOVED":"Bilden är borttagen",
  "COPY":"Kopiera",
  "NO_IMAGE":"Du har inte laddat upp någon bild ännu!",
  "PULL_DOWN_TO_REFRESH":"Dra ner för att uppdatera",
  "EXTERNAL_APPS":"Externa appar",
  "PLUGINS":"Plugin",
  "SUGGEST":"Förslag",
  "COMING_SOON":"Kommer snart",
  "CHAIN":"Kedja",
  "CHAIN_TEXT":"Här kan du ändra blockkedja eller förvald plattform.",
  "CURRENCY":"Valuta",
  "CURRENCY_TEXT":"Här kan du ändra din standardvaluta. Det är den valuta som belöningar för inlägg/kommentarer kommer att visas i.",
  "ABOUT_11":"<br><b>Lista över funktioner</b><br>- Tillgång till artiklar i ämnen som intresserar dig.<br>- Interagera med skribenter genom att kommentera, diskutera ämnen.<br>- Rösta på inlägg för at belöna skribenter och tjäna kureringsbelöningar.<br>- Publicera dina artiklar, blogginlägg och gör dem tillgänliga för andra helt gratis, samt tjäna belöningar genom att engagera och få följare.<br>- Skriv artiklar på stående fåt, spara flera utkast av dina inlägg för senare publicering.<br>- Bokmärk favortinlägg för att läsa senare.<br>- Handla med eller ta ut dina belöningar.<br>- Gör transaktioner till valfri användare, vän, följare, etc.<br>- Följ intressanta skribenter, bloggare.<br>- Sök bland dina följare och skribenter du följer.<br>- Få meddelande så att du kan hålla kontakten med dina följare och ha koll på de diskussioner du deltar i.<br>- Sök efter intressanta ämnen/artikelkategorier, skribenter.<br>- Gör din profil mer personlig.<br>- Många fler funktioner på väg<br><br><b>Säkerhet</b><br>1. Appen har får aldrig tillgång till eller kontroll över dina pengar.<br>2. Appens säkerhetsmodell är klientcentrerad, med privata nycklar sparade lokalt och aldrig skickade till några andra servrar, du är själv ansvarig för att säkerhetskopiera dina lösenord.<br>3. Appen erbjuder ett enkelt, attraktivt användargränssnitt och användarupplevelse.<br>4. Appen erbjuder extra säkerhet med pin-kod<br><br>eSteem stödjer Steem- och Golos- plattformarna.<br>",
  "FOUNDER":"Grundare och Lead Developer",
  "ADD_ACCOUNT":"Lägg till konto",
  "PLATFORM":"Plattform"
}
},{}],155:[function(require,module,exports){
module.exports={
  "HOME":"首页",
  "LOGIN":"登录",
  "LOGOUT":"退出",
  "PROFILE":"简介",
  "FOLLOW":"关注",
  "BOOKMARKS":"书签",
  "TRANSFER":"转账",
  "MARKET":"市场",
  "SETTINGS":"设置",
  "ABOUT":"关于",
  "ABOUT_1":"在这里任何人都可以靠贡献内容赚钱！",
  "ABOUT_2":"由{{platformname}}平台提供。应用程序创建由",
  "ABOUT_3":"它作为开源、社区驱动移动端项目，提供内容访问用于阅读、评论、投票、发表、转账收益等功能。由{{platformname}}区块链和{{sitename}}提供功能。",
  "ABOUT_4":"1.应用程序永不访问或持有用户金钱。",
  "ABOUT_5":"2. 应用程序提供客户端安全模型，私钥保存在本地，永不发送给任何服务器",
  "ABOUT_6":"3.应用程序提供简单具有吸引力的用户接口以及体验。",
  "ABOUT_7":"4.应用程序永不要求用户输入任何个人信息",
  "ABOUT_8":"投票 good-karma 作为见证人",
  "ABOUT_9":"联系/反馈",
  "ABOUT_10":"更多信息",
  "REMOVE":"移除",
  "MARKET_VIEW":"市场观察",
  "PRICE":"价格",
  "AMOUNT":"数量",
  "TOTAL":"总共",
  "NOORDERS":"没有订单",
  "DATE":"日期",
  "BUY":"买",
  "SELL":"卖",
  "OPEN":"开放",
  "HISTORY":"历史",
  "FOLLOW_BACK":"关注回",
  "FOLLOWED":"已关注",
  "UNFOLLOW":"取消关注",
  "FOLLOWING":"关注",
  "FOLLOWERS":"粉丝",
  "SEARCH_FOLLOWERS":"搜索粉丝",
  "SEARCH_FOLLOWING":"搜索关注",
  "BY":"由",
  "IN":"在",
  "MENU":"菜单",
  "BOOKMARK":"书签",
  "REBLOG":"转发",
  "UPVOTE":"赞成票",
  "DOWNVOTE":"反对票",
  "UNVOTE_DOWNVOTED":"取消反对票",
  "UNVOTE_UPVOTED":"取消赞成票",
  "REPLY":"回复",
  "EDIT":"编辑",
  "POST_1":"在评论上向左滑动来查看选项",
  "POST_2":"在评论上点击来查看子评论",
  "OPTIONS":"选项",
  "RESTEEMED_BY":"转发由",
  "NOTHING_HERE":"这还什么都没有...",
  "BALANCES":"余额",
  "PROFILE_1":"{{platformname}}, 可交易代币可以随时转移. {{platformname}} 可以通过叫做充能的过程被转换为{{platformpower}}。",
  "PROFILE_2":"{{platformpower}}, 影响力代币用于长期持有以及给文章投票。持有的越多越能影响他人的赏金以及通过正确地投票获得奖励。",
  "PROFILE_3":"代币大概值{{platformsunit}} {{platformname}}",
  "ESTIMATED_VALUE":"估计价值",
  "PROFILE_4":"估计价值基于{{platformname}}的7日平均值",
  "TRANSACTION_HISTORY":"交易历史",
  "POSTING":"发布",
  "PROFILE_5":"发布密钥用于发表文章以及投票，它应该不同于活动密钥以及所有者密钥。",
  "OWNER":"所有者",
  "PROFILE_6":"所有者密钥是帐户主密钥，当修改其它密钥时需要提供。所有者密钥的私钥或密码应尽可能地离线保管。",
  "ACTIVE":"活动",
  "PROFILE_7":"活动密钥用于发起转账以及在内部市场下单",
  "MEMO":"备注",
  "PROFILE_8":"备注密钥用于创建和阅读备注",
  "BLOG":"博客",
  "POSTS":"文章",
  "REPLIES":"回复",
  "WALLET":"钱包",
  "TAG":"标签",
  "USER":"用户",
  "CLOSE":"关闭",
  "TO":"",
  "ASSET":"资产",
  "SEND":"发送",
  "SECURITY":"安全",
  "AVAILABLE":"可用",
  "PUBLIC_MEMO":"公共备注",
  "TO_DESC":"用户 (例如:good-karma)",
  "PIN_CODE":"Pin 码",
  "PIN_TEXT":"PIN码帮助你保护应用和数据安全。<br/><br/><b>注意:</b>一旦启用，你最多尝试解锁4次，如果忘记或失败，应用程序将移除已登陆用户数据。你可以重新登陆并继续使用应用程序。",
  "NOTIFICATIONS":"通知",
  "VOTE_TEXT":"当有人给你的内容投票时，你将得到通知！<br/> <b>注意:</b> 通知包括投票权重以及提醒信息。 (赞成票, 反对票, 取消投票). ",
  "VOTE":"投票",
  "COMMENT_TEXT":"当有人评论你的文章或评论时，你将得到通知！<b>注意:</b> 通知也包括别人<b>编辑</b>他们的评论. ",
  "COMMENT":"评论",
  "FOLLOW_TEXT":"当他人关注你或取消关注时你将获得通知！",
  "MENTIONS":"提及",
  "MENTIONS_TEXT":"当他人在文章或评论中提及你，你将得到通知！",
  "RESTEEM":"转发",
  "RESTEEM_TEXT":"当他人转发你的文章时，你将得到通知！",
  "CONFIGURATIONS":"配置",
  "VOTING":"投票中",
  "VOTING_TEXT":"投票权重或百分比影响APP中投票威力，你可以用于调节你的投票收益。<br/><br/><b>注意:</b> 这也将更改投反对票的权重/百分比并且整个APP范围内有效.",
  "SERVER":"服务器",
  "SERVER_TEXT":"推荐",
  "SAVE_CHANGES":"保存修改",
  "VOTERS_INFO":"投票者信息",
  "WELCOME_BACK":"欢迎归来！",
  "LOGIN_1":"使用用户名密码登陆后继续",
  "LOGIN_2":"发布密钥用于发表文章、评论、投票、以及关注他人",
  "LOGIN_3":"活动密钥用于转账以及更新资料图片。",
  "LOGIN_4":"用户凭证保存在设备本地，退出后凭证会被移除！",
  "DONT_HAVE":"还没有账户？",
  "SIGN_UP_NOW":"立即注册",
  "CANCEL":"取消",
  "ADVANCED":"高级的",
  "ACTIVE_PRIKEY":"活动私钥",
  "POSTING_PRIKEY":"发布私钥",
  "MASTER_PASS":"主密码",
  "USERNAME":"用户名",
  "CARD_VIEW":"卡片视图",
  "COMPACT_VIEW":"紧凑视图",
  "SEARCH":"搜索",
  "SUBMIT_A_STORY":"提交故事",
  "REPLYTO":"回复给",
  "POST":"发布",
  "PREVIEW":"预览",
  "DEFAULT":"默认 50% / 50%",
  "POWERUP":"100% 充能",
  "DECLINE_PAYOUT":"拒绝奖金",
  "SAVE_FOR_LATER":"留待以后",
  "CLEAR":"清除",
  "POST_CONTENT":"文章内容",
  "COMMENT_CONTENT":"评论内容",
  "TITLE":"标题",
  "TAGS":"标签",
  "NOT_MATCH":"不匹配",
  "CONFIRM_PIN":"确认 PIN",
  "INCORRECT":"错误的",
  "OPENING_POST":"正在打开文章",
  "SET_PIN":"设置 PIN",
  "ENTER_PIN":"输入 PIN",
  "ARE_YOU_SURE":"你确定吗？",
  "REBLOG_TEXT":"转发不可逆，是否继续？",
  "BROADCAST_ERROR":"广播错误，请重试！",
  "SUCCESS":"成功",
  "REBLOGGED_POST":"转发的文章",
  "LOGIN_FAIL":"登陆失败！如果选择高级模式，请确认使用主密码登陆或在登陆时提供发布私钥。",
  "LOGIN_FAIL_A":"登陆失败！如果选择高级模式，请确认使用主密码登陆或在登陆时提供发布私钥。",
  "WARNING":"警告",
  "VOTE_FOR_WITNESS":"投票给见证人",
  "VOTED_FOR_WITNESS":"已投票给见证人",
  "AGO":"以前",
  "FROM_NOW":"从现在开始",
  "SECS":"秒",
  "A_MIN":"一分钟",
  "MINS":"分钟",
  "AN_HOUR":"一小时",
  "HOURS":"小时",
  "A_DAY":"一天",
  "DAYS":"天",
  "A_MONTH":"一月",
  "MONTHS":"月",
  "A_YEAR":"一年",
  "YEARS":"年",
  "MIN_READ":"分钟阅读",
  "DOWNVOTE_FLAG":"反对票",
  "CAPTURE_PICTURE":"捕获图片",
  "SELECT_PICTURE":"选择图片",
  "SET_CUSTOM_URL":"设置自定义URL",
  "INSERT_PICTURE":"插入图片",
  "ERROR":"错误",
  "UPLOAD_ERROR":"上传错误",
  "CAMERA_CANCELLED":"相机已取消",
  "SET_URL":"设置URL",
  "DIRECT_LINK_PICTURE":"图片的直接网络链接",
  "COMMENT_SUBMITTED":"评论已提交",
  "DELETE_COMMENT":"删除评论是不可逆的...",
  "DELETED_COMMENT":"评论已删除",
  "UPLOADING_PICTURE":"图片上传中",
  "UPLOAD_COMPLETED":"上传完成",
  "UPLOAD_FAILED":"上传失败",
  "PASSWORD_INCORRECT":"用户名或密码不对",
  "INFO":"信息",
  "QR_TEXT":"请将二维码框入扫描区域",
  "BALANCE_TEXT":"请确认你有足够的余额用于转账！",
  "NONEXIST_USER":"你转账的目标用户不存在！",
  "TRANSFER_TEXT":"是否确认转账？",
  "CONFIRMATION":"确认",
  "TX_BROADCASTED":"交易已广播",
  "FEED":"话题",
  "TRENDING":"趋向",
  "HOT":"热点",
  "NEW":"新的",
  "PROMOTED":"推销",
  "VOTES":"票",
  "PAYOUT":"奖金",
  "COMMENTS":"评论",
  "TRENDING_30":"30日趋向",
  "SORT_POST_BY":"排序按：",
  "PAYOUT_CYCLE":"支付周期",
  "POTENTIAL_PAYOUT":"潜在奖金",
  "PAST_PAYOUT":"过去的奖金",
  "AUTHOR_PAYOUT":"作者奖金",
  "CURATION_PAYOUT":"监护人奖金",
  "POST_SUBMITTED":"文章已提交！",
  "POST_LATER":"文章留待以后提交！",
  "SAVED":"已保存",
  "CLEARED":"已清除",
  "FLAGGING_TEXT":"给文章投反对票会移除收益并降低材料的可见性。<br><br>反对票用于以下场景：<ul><li>弄虚作假或剽窃</li><li>仇恨言论或网络钓鱼</li><li>故意放错类目内容或者SPAM</li></ul>",
  "REQUEST_LIMIT_TEXT":"达到请求限制。检查其他趋势/标签！",
  "POST_IS_UNBOOKMARK":"文章已从书签内移除！",
  "POST_IS_BOOKMARK":"文章已经加入书签！",
  "RESET":"重置",
  "MODIFY_PICTURE":"编辑资料图片",
  "MODIFY_COVER_PICTURE":"修改封面图片",
  "ACTIVE_KEY_REQUIRED_TEXT":"如果你选中高级登陆模式，请提供活动私钥！",
  "RESET_PICTURE_TEXT":"这将重置用户资料图片",
  "RESET_COVER_PICTURE_TEXT":"这将重置用户封面图片",
  "UPDATE_REQUIRES_RESTART":"服务器更新需要重启",
  "SETTINGS_UPDATED":"设置已更新",
  "LANGUAGES":"语言",
  "LANGUAGES_TEXT":"你可以在这修改此应用语言。",
  "LOGIN_TO_X":"此项操作要求用户使用主密码，活动/发布密钥。请登陆并重试。",
  "GALLERY":"图库",
  "TRANSLATIONS":"翻译贡献者",
  "SHARE":"分享",
  "MARKETPLACE":"市场",
  "EXCHANGE":"交易所",
  "DRAFTS":"草稿",
  "POST_IS_UNDRAFT":"文章已从草稿内移除！",
  "POST_IS_DRAFT":"文章已经加入草稿！",
  "SWIPE_LEFT":"向左滑动查看选项",
  "MANAGE":"管理",
  "IMAGE_REMOVED":"图像已删除",
  "COPY":"复制",
  "NO_IMAGE":"你还没有上传任何图片！",
  "PULL_DOWN_TO_REFRESH":"下拉刷新",
  "EXTERNAL_APPS":"外部应用",
  "PLUGINS":"插件",
  "SUGGEST":"建议",
  "COMING_SOON":"即将到来",
  "CHAIN":"链",
  "CHAIN_TEXT":"在着你可以修改区块链或默认平台",
  "CURRENCY":"",
  "CURRENCY_TEXT":"",
  "ABOUT_11":"",
  "FOUNDER":"",
  "ADD_ACCOUNT":"",
  "PLATFORM":""
}
},{}],156:[function(require,module,exports){
module.exports={
  "HOME":"首頁",
  "LOGIN":"登入",
  "LOGOUT":"登出",
  "PROFILE":"關於",
  "FOLLOW":"追蹤",
  "BOOKMARKS":"書籤",
  "TRANSFER":"轉帳",
  "MARKET":"市場",
  "SETTINGS":"設定",
  "ABOUT":"關於",
  "ABOUT_1":"所有人的內容都可以在這裡獲得獎勵",
  "ABOUT_2":"是由{{platformname}}平台所支持。此App之開發者為",
  "ABOUT_3":"此為開源式、社區驅動之行動使用方案，提供使用者內容閱讀、評論、投票、文章發布與收入轉帳等功能。各項功能是由{{platformname}}之區塊鏈以及{{sitename}}網站所提供。",
  "ABOUT_4":"本App不會處理或管控使用者之資金。",
  "ABOUT_5":"本App提供客戶端安全使用模式，使用者私鑰只在本機內部使用，絕不送出到任何外部伺服器。",
  "ABOUT_6":"本App提供簡單好用之使用者介面與經驗。",
  "ABOUT_7":"本App絕不會向使用者要求提供任何個人資料。",
  "ABOUT_8":"投票支持good-karma成為witness",
  "ABOUT_9":"聯絡/意見回饋",
  "ABOUT_10":"更多訊息",
  "REMOVE":"移除",
  "MARKET_VIEW":"交易市場",
  "PRICE":"價格",
  "AMOUNT":"數量",
  "TOTAL":"總計",
  "NOORDERS":"無掛單",
  "DATE":"日期",
  "BUY":"買入",
  "SELL":"賣出",
  "OPEN":"掛單",
  "HISTORY":"歷史紀錄",
  "FOLLOW_BACK":"納入追蹤",
  "FOLLOWED":"正被追蹤",
  "UNFOLLOW":"取消追蹤",
  "FOLLOWING":"追蹤你的名單",
  "FOLLOWERS":"你追蹤的名單",
  "SEARCH_FOLLOWERS":"搜尋追蹤你的名單",
  "SEARCH_FOLLOWING":"搜尋你追蹤的名單",
  "BY":"由",
  "IN":"在",
  "MENU":"選單",
  "BOOKMARK":"書籤",
  "REBLOG":"轉貼",
  "UPVOTE":"讚",
  "DOWNVOTE":"噓",
  "UNVOTE_DOWNVOTED":"取消噓",
  "UNVOTE_UPVOTED":"取消讚",
  "REPLY":"回覆",
  "EDIT":"編輯",
  "POST_1":"評論上向左滑以顯示動作清單",
  "POST_2":"點擊評論可展開下一層評論",
  "OPTIONS":"選項",
  "RESTEEMED_BY":"轉貼",
  "NOTHING_HERE":"施工中",
  "BALANCES":"結餘",
  "PROFILE_1":"{{platformname}} 是可交易的貨幣，隨時可以進行移轉。{{platformname}} 可以被轉換成 {{platformpower}}，此一動作稱為powering up。",
  "PROFILE_2":"{{platformpower}} 可視為具有影響力的股權，持有可長期增值並對文章投票，持有數量越多對於其他人獎勵大小的影響力就越大，也更能從準確的投票行為中獲得獎勵。 ",
  "PROFILE_3":"目前持有{{platformsunit}}的{{platformname}}。",
  "ESTIMATED_VALUE":"概估價值",
  "PROFILE_4":"概估價值是以{{platformname}}3-5天之平均價為基礎",
  "TRANSACTION_HISTORY":"交易歷史紀錄",
  "POSTING":"",
  "PROFILE_5":"Posting私鑰使用於發文與按讚活動上，其與Active以及Owner私鑰功能不同。",
  "OWNER":"",
  "PROFILE_6":"Owner私鑰是本帳號之主鑰，具有更改其他私鑰的權力。安全起見，Owner私鑰密碼應該儘可能地離線儲存。",
  "ACTIVE":"",
  "PROFILE_7":"Active私鑰用於帳號資金處理活動以及於內部市場下單買賣方面。",
  "MEMO":"",
  "PROFILE_8":"Memo私鑰用於創造與讀取memo訊息。",
  "BLOG":"部落格",
  "POSTS":"你的評論",
  "REPLIES":"回應評論",
  "WALLET":"錢包",
  "TAG":"標籤",
  "USER":"使用者",
  "CLOSE":"關閉",
  "TO":"到",
  "ASSET":"資產",
  "SEND":"傳送",
  "SECURITY":"安全性",
  "AVAILABLE":"可使用",
  "PUBLIC_MEMO":"公開訊息",
  "TO_DESC":"使用者，例如 good-karma",
  "PIN_CODE":"密碼",
  "PIN_TEXT":"設置此密碼以保護App與用戶資料。<br/><br/><b>注意：</b>一旦啟用，你只能有4次解鎖機會，如果忘記密碼或是全數登入失敗，則App會移除登入資料。你可以再次登入並繼續使用App。",
  "NOTIFICATIONS":"通知",
  "VOTE_TEXT":"你的內容獲得別人按讚時會通知你！<br/> <b>注意：</b> 通知內容包括按讚權重與提醒訊息。（按讚、按噓、取消讚）",
  "VOTE":"投票",
  "COMMENT_TEXT":"他人評論你的文章或評論時，你會收到通知！<br/> <b>注意：</b> 對方若<b>重新編輯</b>評論內容，亦會通知你。",
  "COMMENT":"評論",
  "FOLLOW_TEXT":"他人追蹤或取消追蹤你時，你會收到通知！",
  "MENTIONS":"提及",
  "MENTIONS_TEXT":"他人在文章或評論中提及你時，你會收到通知！",
  "RESTEEM":"轉貼",
  "RESTEEM_TEXT":"他人轉貼你的文章時，你會收到通知！",
  "CONFIGURATIONS":"組態設定",
  "VOTING":"投票",
  "VOTING_TEXT":"投票權重會影響投票能量以及投票獎勵，你可以予以調整。<br/> <b>注意：</b> 對權重之調整同樣適用於按讚與按噓，並持續保持此一權重。",
  "SERVER":"伺服器",
  "SERVER_TEXT":"推薦",
  "SAVE_CHANGES":"儲存變更",
  "VOTERS_INFO":"投票訊息",
  "WELCOME_BACK":"歡迎回來！",
  "LOGIN_1":"請以您的使用者帳號與密碼登入",
  "LOGIN_2":"Posting key用於發布文章、投票與追蹤。",
  "LOGIN_3":"Active key用於轉帳相關與「關於」之圖片更新。",
  "LOGIN_4":"使用者的認證資訊只保存在裝置本地端。登出後認證資訊將被移除。",
  "DONT_HAVE":"還沒有帳號嗎？",
  "SIGN_UP_NOW":"馬上去註冊",
  "CANCEL":"取消",
  "ADVANCED":"進階",
  "ACTIVE_PRIKEY":"",
  "POSTING_PRIKEY":"",
  "MASTER_PASS":"Master密碼/主密碼",
  "USERNAME":"使用者名稱",
  "CARD_VIEW":"正常模式",
  "COMPACT_VIEW":"精簡模式",
  "SEARCH":"搜尋",
  "SUBMIT_A_STORY":"提交文章",
  "REPLYTO":"回覆",
  "POST":"貼文",
  "PREVIEW":"預覽",
  "DEFAULT":"預設 50% / 50%",
  "POWERUP":"",
  "DECLINE_PAYOUT":"謝絕Payout",
  "SAVE_FOR_LATER":"預存草稿",
  "CLEAR":"清除",
  "POST_CONTENT":"貼文內容",
  "COMMENT_CONTENT":"評論內容",
  "TITLE":"標題",
  "TAGS":"標籤",
  "NOT_MATCH":"不符",
  "CONFIRM_PIN":"確認密碼",
  "INCORRECT":"不正確",
  "OPENING_POST":"打開貼文",
  "SET_PIN":"重設密碼",
  "ENTER_PIN":"輸入密碼",
  "ARE_YOU_SURE":"是否確定？",
  "REBLOG_TEXT":"轉貼無法取消，還要繼續嗎？",
  "BROADCAST_ERROR":"廣播錯誤，請再試一次！",
  "SUCCESS":"成功",
  "REBLOGGED_POST":"轉貼文章",
  "LOGIN_FAIL":"登入失敗！請確認你是以master密碼登入，或是在進階模式下以提供之Posting私鑰登入。",
  "LOGIN_FAIL_A":"登入失敗！請確認你是以master密碼登入，或是在進階模式下以提供之Active私鑰登入。",
  "WARNING":"警告",
  "VOTE_FOR_WITNESS":"投票支持見證人",
  "VOTED_FOR_WITNESS":"投票支持為見證人",
  "AGO":"前",
  "FROM_NOW":"還有",
  "SECS":"秒",
  "A_MIN":"一分鐘",
  "MINS":"分鐘",
  "AN_HOUR":"一小時",
  "HOURS":"小時",
  "A_DAY":"一天",
  "DAYS":"天",
  "A_MONTH":"一個月",
  "MONTHS":"個月",
  "A_YEAR":"一年",
  "YEARS":"個年",
  "MIN_READ":"分鐘閱讀時間",
  "DOWNVOTE_FLAG":"按噓",
  "CAPTURE_PICTURE":"獲取圖片",
  "SELECT_PICTURE":"選擇圖片",
  "SET_CUSTOM_URL":"設定專用連結",
  "INSERT_PICTURE":"插入圖片",
  "ERROR":"錯誤",
  "UPLOAD_ERROR":"上傳錯誤",
  "CAMERA_CANCELLED":"取消相機",
  "SET_URL":"設定URL",
  "DIRECT_LINK_PICTURE":"圖片之網站連結",
  "COMMENT_SUBMITTED":"評論送出",
  "DELETE_COMMENT":"刪除評論動作是不可恢復的",
  "DELETED_COMMENT":"已刪除之評論",
  "UPLOADING_PICTURE":"上傳圖片",
  "UPLOAD_COMPLETED":"上傳完成",
  "UPLOAD_FAILED":"上傳失敗",
  "PASSWORD_INCORRECT":"密碼或帳號名稱錯誤",
  "INFO":"訊息",
  "QR_TEXT":"請將QR code置於掃描區域內",
  "BALANCE_TEXT":"請確認有足夠餘額可供交易！",
  "NONEXIST_USER":"轉入帳號不存在",
  "TRANSFER_TEXT":"確定要進行轉帳？",
  "CONFIRMATION":"確認",
  "TX_BROADCASTED":"交易已廣播",
  "FEED":"動態消息",
  "TRENDING":"焦點",
  "HOT":"熱門",
  "NEW":"最新",
  "PROMOTED":"贊助",
  "VOTES":"票數",
  "PAYOUT":"收入",
  "COMMENTS":"評論",
  "TRENDING_30":"30天焦點",
  "SORT_POST_BY":"文章排序",
  "PAYOUT_CYCLE":"收入週期",
  "POTENTIAL_PAYOUT":"未實現收入",
  "PAST_PAYOUT":"已支付收入",
  "AUTHOR_PAYOUT":"作者收入",
  "CURATION_PAYOUT":"投票收入",
  "POST_SUBMITTED":"文章已送出",
  "POST_LATER":"待發文章",
  "SAVED":"已儲存",
  "CLEARED":"已清除",
  "FLAGGING_TEXT":"對文章按噓會影響其獎勵，並降低其能見度。<br><br> 應在下列情況下按噓：<ul><li>詐欺或抄襲</li><li>仇恨性言論或網路濫用</li><li>內容故意分類錯誤或大量散布垃圾訊息</li></ul>",
  "REQUEST_LIMIT_TEXT":"已達要求限度，請查詢其他焦點文章或標籤！",
  "POST_IS_UNBOOKMARK":"文章已自書籤中移除",
  "POST_IS_BOOKMARK":"文章已加入書籤",
  "RESET":"重置",
  "MODIFY_PICTURE":"修改「關於」的圖片",
  "MODIFY_COVER_PICTURE":"修改封面圖片",
  "ACTIVE_KEY_REQUIRED_TEXT":"若選擇進階模式，請提供Active私鑰！",
  "RESET_PICTURE_TEXT":"此動作將重設使用者「關於」的圖片",
  "RESET_COVER_PICTURE_TEXT":"此動作將重設使用者封面圖片",
  "UPDATE_REQUIRES_RESTART":"由於伺服器更新需要重新啟動！",
  "SETTINGS_UPDATED":"設定已更新！",
  "LANGUAGES":"語言",
  "LANGUAGES_TEXT":"你可以在此更改APP的使用語言",
  "LOGIN_TO_X":"此一動作需要使用者以主密碼、Active私鑰或Posting私鑰登入。請登入再試一下。",
  "GALLERY":"陳列",
  "TRANSLATIONS":"多國語言翻譯工作協助者",
  "SHARE":"分享",
  "MARKETPLACE":"市場",
  "EXCHANGE":"交易所",
  "DRAFTS":"草稿",
  "POST_IS_UNDRAFT":"文章自草稿中移除！",
  "POST_IS_DRAFT":"文章加入草稿！",
  "SWIPE_LEFT":"向左滑動可開啟動作選項",
  "MANAGE":"管理",
  "IMAGE_REMOVED":"圖片移除",
  "COPY":"複製",
  "NO_IMAGE":"您尚未上傳任何圖片！",
  "PULL_DOWN_TO_REFRESH":"向下拉動可更新",
  "EXTERNAL_APPS":"外部App",
  "PLUGINS":"外掛程式",
  "SUGGEST":"建議",
  "COMING_SOON":"即將推出",
  "CHAIN":"鏈",
  "CHAIN_TEXT":"您可以在這裡變更使用的區塊鏈或是預設的平台。",
  "CURRENCY":"",
  "CURRENCY_TEXT":"",
  "ABOUT_11":"",
  "FOUNDER":"",
  "ADD_ACCOUNT":"",
  "PLATFORM":""
}
},{}],157:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//angular.module('steem.services', [])
module.exports = function (app) {
	app.service('APIs', ['$http', '$rootScope', 'API_END_POINT', function ($http, $rootScope, API_END_POINT) {
		'use strict';
		return {
      getCurrencyRate: function(code_from, code_to){
        console.log(code_from,code_to);
        return $http.get("https://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20yahoo.finance.xchange%20where%20pair%20in%20(%22"+code_from+code_to+"%22)&format=json&diagnostics=false&env=store%3A%2F%2Fdatatables.org%2Falltableswithkeys");
      },
      saveSubscription: function(deviceid, username, subscription) {
        return $http.post(API_END_POINT+"/api/devices", {deviceid: deviceid, username: username, subscription: subscription, chain: $rootScope.$storage.chain});
      },
      updateSubscription: function(deviceid, username, subscription) {
        return $http.put(API_END_POINT+"/api/devices", {deviceid: deviceid, username: username, subscription: subscription, chain: $rootScope.$storage.chain});
      },
      updateToken: function(deviceid, newdev) {
        return $http.put(API_END_POINT+"/api/device/"+deviceid, {newdev: newdev, chain: $rootScope.$storage.chain});
      },
      deleteSubscription: function(deviceid) {
        return $http.delete(API_END_POINT+"/api/devices/"+deviceid);
      },
      getSubscriptions: function(deviceid) {
        return $http.get(API_END_POINT+"/api/devices/"+deviceid);
      },
			addBookmark: function(user, bookmark) {
        return $http.post(API_END_POINT+"/api/bookmark", {username: user, author: bookmark.author, permlink: bookmark.permlink, chain: $rootScope.$storage.chain});
      },
			getBookmarks: function(user) {
        return $http.get(API_END_POINT+"/api/bookmarks/"+user);
      },
			removeBookmark: function(id, user) {
        return $http.delete(API_END_POINT+"/api/bookmarks/"+user+"/"+id);
      },
			addDraft: function(user, draft) {
        return $http.post(API_END_POINT+"/api/draft", {username: user, title: draft.title, body: draft.body, tags: draft.tags, post_type: draft.post_type, chain: $rootScope.$storage.chain});
      },
			getDrafts: function(user) {
        return $http.get(API_END_POINT+"/api/drafts/"+user);
      },
			removeDraft: function(id, user) {
        return $http.delete(API_END_POINT+"/api/drafts/"+user+"/"+id);
      },
			removeImage: function(id, user) {
        return $http.delete(API_END_POINT+"/api/images/"+user+"/"+id);
      },
			fetchImages: function(user) {
        return $http.get(API_END_POINT+"/api/images/"+user);
      }
		};
	}])
  app.directive('backImg', function(){
    return function(scope, element, attrs){
        var url = attrs.backImg;
        element.css({
            'background-image': 'url(' + url +')',
            'background-size' : 'cover'
        });
    };
  });
  app.directive('select', function() {
    return {
      restrict: 'E',
      link: function(scope, element, attrs) {
        element.bind('focus', function(e) {
          if (window.cordova && window.cordova.plugins.Keyboard) {
            // $rootScope.log("show bar (hide = false)");
            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(false);
          }
        });
        element.bind('blur', function(e) {
          if (window.cordova && window.cordova.plugins.Keyboard) {
            // $rootScope.log("hide bar (hide = true)");
            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
          }
        });
      }
    };
  });
  app.directive('navigation', function () {
    var controller = ['$scope', '$rootScope', function ($scope, $rootScope) {
      $scope.addactiveclass = function (menuItem) {
          $scope.activeMenu = menuItem.name;
          //$rootScope.log(menuItem);
          $rootScope.$storage.filter = menuItem.href;
          $rootScope.$broadcast('filter:change');
          $scope.center(menuItem.name);
          $scope.someCtrlFn({menulinks: menuItem});
      };

      $(window).resize(function(){
        $scope.center();
      });
      $scope.center = function(menuItem) {
        var nav = document.getElementById("nav1");
        var navWidth = document.getElementById("nav2").offsetWidth;
        var currentElement = document.querySelectorAll('[name="'+menuItem+'"]');
        currentElement = menuItem ? currentElement[0] : document.getElementsByClassName('active')[0];
        if(currentElement) {
          var margin = 0;
          var lenm = nav.children.length;
          for(var i =0; i<lenm; i++){

            if(currentElement == nav.children[i]){
              break;
            }else {
              margin += nav.children[i].offsetWidth;
            }
          }
          nav.style.marginLeft = (navWidth/2 - margin - currentElement.offsetWidth/2) + 'px';
        }
        else {
          nav.style.marginLeft = (navWidth/2 - $scope.activeMenu.length) + 'px';
        }
      };
      var _len = $scope.menulinks.length;
      for (var i = 0; i < _len; i++) {
        if ($rootScope.$storage.filter) {
          if ($scope.menulinks[i].href == $rootScope.$storage.filter) {
            $scope.activeMenu = $scope.menulinks[i].name;
          }
        } else {
          $scope.activeMenu = "Trending";
        }
      }

      //$scope.center();
      setTimeout(function() {
        $scope.center();
      }, 50);
    }];

    return {
      restrict: "E",
      replace: true,
      scope: {
        menulinks: '=',
        someCtrlFn: '&callbackFn'
      },
      controller: controller,
      template: "<ul id='nav1'>"+
              "<li ng-repeat='menulinks in menulinks' name='{{menulink.name}}' class='top {{menulink.role}}' ng-class='{active : activeMenu === menulink.name}'>"+
                "<a on-tap='addactiveclass(menulink)'>"+
                  "{{menulink.name}}"
                +"</a>"+
                "<div class='arrow'></div>"+
                "</li>"
            +"</ul>"
    }
  });
  function SimplePubSub() {
      var events = {};
      return {
          on: function(names, handler) {
              names.split(' ').forEach(function(name) {
                  if (!events[name]) {
                      events[name] = [];
                  }
                  events[name].push(handler);
              });
              return this;
          },
          trigger: function(name, args) {
              angular.forEach(events[name], function(handler) {
                  handler.call(null, args);
              });
              return this;
          }
      };
  };

  app.directive('onFinishRender', function ($timeout) {
      return {
          restrict: 'A',
          link: function (scope, element, attr) {
              if (scope.$last === true) {
                  $timeout(function () {
                      scope.$emit('ngRepeatFinished');
                  });
              }
          }
      }
  })
  app.directive('clickHandler', function($timeout){
      return{
          restrict: 'A',
          link: function($scope, $element,$attr){
              $timeout(function(){
                      $element.on('tap', function(){
                        //the function you want to perform on tap
        alert("Just been Clicked");
                      });
              });
          }
      };
  })
  app.directive('tabSlideBox', [ '$timeout', '$window', '$ionicSlideBoxDelegate', '$ionicScrollDelegate', '$rootScope',
    function($timeout, $window, $ionicSlideBoxDelegate, $ionicScrollDelegate, $rootScope) {
      'use strict';

      return {
        restrict : 'A, E, C',
        link : function(scope, element, attrs, ngModel) {

          var ta = element[0], $ta = element;
          $ta.addClass("tabbed-slidebox");
          if(attrs.tabsPosition === "bottom"){
            $ta.addClass("btm");
          }

          //Handle multiple slide/scroll boxes
          var handle = ta.querySelector('.slider').getAttribute('delegate-handle');

          var ionicSlideBoxDelegate = $ionicSlideBoxDelegate;
          if(handle){
            ionicSlideBoxDelegate = ionicSlideBoxDelegate.$getByHandle(handle);
          }

          var ionicScrollDelegate = $ionicScrollDelegate;
          if(handle){
            ionicScrollDelegate = ionicScrollDelegate.$getByHandle(handle);
          }

          function renderScrollableTabs(){
            var iconsDiv = angular.element(ta.querySelector(".tsb-icons")), icons = iconsDiv.find("a"), wrap = iconsDiv[0].querySelector(".tsb-ic-wrp"), totalTabs = icons.length;
            var scrollDiv = wrap.querySelector(".scroll");

            angular.forEach(icons, function(value, key){
                 var a = angular.element(value);
                 a.on('click', function(){
                   ionicSlideBoxDelegate.slide(key);
                 });

              if(a.attr('icon-off')) {
                a.attr("class", a.attr('icon-off'));
              }
            });

            var initialIndex = attrs.tab;
            //Initializing the middle tab
            if(typeof attrs.tab === 'undefined' || (totalTabs <= initialIndex) || initialIndex < 0){
              initialIndex = Math.floor(icons.length/2);
            }

            //If initial element is 0, set position of the tab to 0th tab
            if(initialIndex == 0){
              setPosition(0);
            }
            //$rootScope.log('initialIndex '+initialIndex);
            if ($rootScope.$storage.filter) {
              if ($rootScope.$storage.user) {
                if ($rootScope.$storage.filter === 'feed') {
                  //$scope.events.trigger("slideChange", {"index" : 0});
                  initialIndex = 0;
                }
                if ($rootScope.$storage.filter === 'trending') {
                  //$scope.events.trigger("slideChange", {"index" : 0});
                  initialIndex = 1;
                }
                if ($rootScope.$storage.filter === 'hot'){
                  //$scope.events.trigger("slideChange", {"index" : 1});
                  initialIndex = 2;
                }
                if ($rootScope.$storage.filter === 'created'){
                  //$scope.events.trigger("slideChange", {"index" : 2});
                  initialIndex = 3;
                }
                if ($rootScope.$storage.filter === 'active'){
                  //$scope.events.trigger("slideChange", {"index" : 3});
                  initialIndex = 4;
                }
                if ($rootScope.$storage.filter === 'promoted'){
                  //$scope.events.trigger("slideChange", {"index" : 4});
                  initialIndex = 5;
                }
                if ($rootScope.$storage.filter === 'trending30'){
                  //$scope.events.trigger("slideChange", {"index" : 5});
                  initialIndex = 6;
                }
                if ($rootScope.$storage.filter === 'votes'){
                  //$scope.events.trigger("slideChange", {"index" : 6});
                  initialIndex = 7;
                }
                if ($rootScope.$storage.filter === 'children'){
                  //$scope.events.trigger("slideChange", {"index" : 7});
                  initialIndex = 8;
                }
                if ($rootScope.$storage.filter === 'cashout'){
                  //$scope.events.trigger("slideChange", {"index" : 8});
                  initialIndex = 9;
                }
              } else {
                if ($rootScope.$storage.filter === 'trending') {
                  //$scope.events.trigger("slideChange", {"index" : 0});
                  initialIndex = 0;
                }
                if ($rootScope.$storage.filter === 'hot'){
                  //$scope.events.trigger("slideChange", {"index" : 1});
                  initialIndex = 1;
                }
                if ($rootScope.$storage.filter === 'created'){
                  //$scope.events.trigger("slideChange", {"index" : 2});
                  initialIndex = 2;
                }
                if ($rootScope.$storage.filter === 'active'){
                  //$scope.events.trigger("slideChange", {"index" : 3});
                  initialIndex = 3;
                }
                if ($rootScope.$storage.filter === 'promoted'){
                  //$scope.events.trigger("slideChange", {"index" : 4});
                  initialIndex = 4;
                }
                if ($rootScope.$storage.filter === 'trending30'){
                  //$scope.events.trigger("slideChange", {"index" : 5});
                  initialIndex = 5;
                }
                if ($rootScope.$storage.filter === 'votes'){
                  //$scope.events.trigger("slideChange", {"index" : 6});
                  initialIndex = 6;
                }
                if ($rootScope.$storage.filter === 'children'){
                  //$scope.events.trigger("slideChange", {"index" : 7});
                  initialIndex = 7;
                }
                if ($rootScope.$storage.filter === 'cashout'){
                  //$scope.events.trigger("slideChange", {"index" : 8});
                  initialIndex = 8;
                }
              }
            }
            $timeout(function() {
              ionicSlideBoxDelegate.slide(initialIndex);
            }, 10);
          }

          function setPosition(index){
            var iconsDiv = angular.element(ta.querySelector(".tsb-icons")), icons = iconsDiv.find("a"), wrap = iconsDiv[0].querySelector(".tsb-ic-wrp"), totalTabs = icons.length;
            var scrollDiv = wrap.querySelector(".scroll");

            var middle = iconsDiv[0].offsetWidth/2;
            var curEl = angular.element(icons[index]);
            var prvEl = angular.element(iconsDiv[0].querySelector(".active"));
            if(curEl && curEl.length){
              var curElWidth = curEl[0].offsetWidth, curElLeft = curEl[0].offsetLeft;

              if(prvEl.attr('icon-off')) {
                prvEl.attr("class", prvEl.attr('icon-off'));
              } else{
                prvEl.removeClass("active");
              }
              if(curEl.attr('icon-on')) {
                curEl.attr("class", curEl.attr('icon-on'));
              }
              curEl.addClass("active");

              var leftStr = (middle  - (curElLeft) -  curElWidth/2 + 5);
              //If tabs are not scrollable
              if(!scrollDiv){
                var leftStr = (middle  - (curElLeft) -  curElWidth/2 + 5) + "px";
                wrap.style.webkitTransform =  "translate3d("+leftStr+",0,0)" ;
              } else {
                //If scrollable tabs
                var wrapWidth = wrap.offsetWidth;
                var currentX = Math.abs(getX(scrollDiv.style.webkitTransform));
                var leftOffset = 100;
                var elementOffset = 54;
                //If tabs are reaching right end or left end
                if(((currentX + wrapWidth) < (curElLeft + curElWidth + elementOffset)) || (currentX > (curElLeft - leftOffset))){
                  if(leftStr > 0){
                    leftStr = 0;
                  }
                  //Use this scrollTo, so when scrolling tab manually will not flicker
                  setTimeout(function() {
                    ionicScrollDelegate.scrollTo(Math.abs(leftStr), 0, true);
                  }, 10);

                } else {
                  if(leftStr > 0){
                    leftStr = 0;
                  }
                  setTimeout(function() {
                    ionicScrollDelegate.scrollTo(Math.abs(leftStr), 0, true);
                  }, 10);
                }
              }
            }
          };
          function getX(matrix) {

            matrix = matrix.replace("translate3d(","");
            matrix = matrix.replace("translate(","");
            return (parseInt(matrix));
          }
          var events = scope.events;
          events.on('slideChange', function(data){
            setPosition(data.index);
          });
          events.on('ngRepeatFinished', function(ngRepeatFinishedEvent) {
            renderScrollableTabs();
          });
          setTimeout(function() {
            renderScrollableTabs();
          }, 10);

        },
        controller : function($scope, $attrs, $element, $rootScope) {
          $scope.events = new SimplePubSub();
          $scope.slideHasChanged = function(index){
            $rootScope.log("SlideChanged "+index);
            $scope.currentSlide = index;
            $scope.events.trigger("slideChange", {"index" : index});
            $timeout(function(){
              if($scope.onSlideMove) {
                $scope.onSlideMove({"index" : eval(index)});
              }

              if ($rootScope.$storage.user) {
                if (index === 0) {
                  $rootScope.$storage.filter = 'feed';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 1) {
                  $rootScope.$storage.filter = 'trending';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 2) {
                  $rootScope.$storage.filter = 'hot';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 3) {
                  $rootScope.$storage.filter = 'created';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 4) {
                  $rootScope.$storage.filter = 'active';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 5) {
                  $rootScope.$storage.filter = 'promoted';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 6) {
                  $rootScope.$storage.filter = 'trending30';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 7) {
                  $rootScope.$storage.filter = 'votes';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 8) {
                  $rootScope.$storage.filter = 'children';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 9) {
                  $rootScope.$storage.filter = 'cashout';
                  $rootScope.$broadcast('filter:change');
                }
              } else {
                if (index === 0) {
                  $rootScope.$storage.filter = 'trending';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 1) {
                  $rootScope.$storage.filter = 'hot';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 2) {
                  $rootScope.$storage.filter = 'created';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 3) {
                  $rootScope.$storage.filter = 'active';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 4) {
                  $rootScope.$storage.filter = 'promoted';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 5) {
                  $rootScope.$storage.filter = 'trending30';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 6) {
                  $rootScope.$storage.filter = 'votes';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 7) {
                  $rootScope.$storage.filter = 'children';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 8) {
                  $rootScope.$storage.filter = 'cashout';
                  $rootScope.$broadcast('filter:change');
                }
              }
              if (!$rootScope.$$phase){
                $rootScope.$apply();
              }
            }, 10);
          };

          $scope.$on('ngRepeatFinished', function(ngRepeatFinishedEvent) {
            $rootScope.log('ngRepeatFinished');
            $scope.events.trigger("ngRepeatFinished", {"event" : ngRepeatFinishedEvent});
          });
        }
      };

    }
  ]);

	app.filter('timeago', function($filter, $translate, $rootScope) {

      function TimeAgo(input, p_allowFuture) {
        var substitute = function (stringOrFunction, number, strings) {
                var string = angular.isFunction(stringOrFunction) ? stringOrFunction(number, dateDifference) : stringOrFunction;
                var value = (strings.numbers && strings.numbers[number]) || number;
                return string.replace(/%d/i, value);
            },
            nowTime = (new Date()).getTime(),
            date = (new Date(input)).getTime(),
            //refreshMillis= 6e4, //A minute
            allowFuture = p_allowFuture || false,
            strings= {
                prefixAgo: '',
                prefixFromNow: '',
                suffixAgo: $filter('translate')('AGO'),
                suffixFromNow: $filter('translate')('FROM_NOW'),
                seconds: $filter('translate')('SECS'),
                minute: $filter('translate')('A_MIN'),
                minutes: "%d "+$filter('translate')('MINS'),
                hour: $filter('translate')('AN_HOUR'),
                hours: "%d "+$filter('translate')('HOURS'),
                day: $filter('translate')('A_DAY'),
                days: "%d "+$filter('translate')('DAYS'),
                month: $filter('translate')('A_MONTH'),
                months: "%d "+$filter('translate')('MONTHS'),
                year: $filter('translate')('A_YEAR'),
                years: "%d "+$filter('translate')('YEARS')
            },
            dateDifference = nowTime - date,
            words,
            seconds = Math.abs(dateDifference) / 1000,
            minutes = seconds / 60,
            hours = minutes / 60,
            days = hours / 24,
            years = days / 365,
            separator = strings.wordSeparator === undefined ?  " " : strings.wordSeparator,


            prefix = strings.prefixAgo,
            suffix = strings.suffixAgo;

        if (allowFuture) {
            if (dateDifference < 0) {
                prefix = strings.prefixFromNow;
                suffix = strings.suffixFromNow;
            }
        }

        words = seconds < 45 && substitute(strings.seconds, Math.round(seconds), strings) ||
        seconds < 90 && substitute(strings.minute, 1, strings) ||
        minutes < 45 && substitute(strings.minutes, Math.round(minutes), strings) ||
        minutes < 90 && substitute(strings.hour, 1, strings) ||
        hours < 24 && substitute(strings.hours, Math.round(hours), strings) ||
        hours < 42 && substitute(strings.day, 1, strings) ||
        days < 30 && substitute(strings.days, Math.round(days), strings) ||
        days < 45 && substitute(strings.month, 1, strings) ||
        days < 365 && substitute(strings.months, Math.round(days / 30), strings) ||
        years < 1.5 && substitute(strings.year, 1, strings) ||
        substitute(strings.years, Math.round(years), strings);
        //$rootScope.log(prefix+words+suffix+separator);
        prefix.replace(/ /g, '')
        words.replace(/ /g, '')
        suffix.replace(/ /g, '')
        return (prefix+' '+words+' '+suffix+' '+separator);

      };

      TimeAgo.$stateful = true;
      return TimeAgo;
    });

    app.filter('parseUrl', function($sce) {
	    var urls = /(\b(https?|ftp):\/\/[A-Z0-9+&@#\/%?=~_|!:,.;-]*[-A-Z0-9+&@#\/%=~_|])/gim;
	    var emails = /(\w+@[a-zA-Z_]+?\.[a-zA-Z]{2,6})/gim;
  	 	var imgs = /(https?:\/\/.*\.(?:png|jpg|jpeg|gif))/gim;
  		var youtube = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/;
  		var youtubeid = /(?:(?:youtube.com\/watch\?v=)|(?:youtu.be\/))([A-Za-z0-9\_\-]+)/i;

	    return function(textu, subpart) {
        var options = {
        	gfm: true,
			    tables: true,
          smartLists: true,
			    breaks: true,
			    pedantic: false,
			    sanitize: false,
			    smartLists: true,
			    smartypants: false
			  };
        if (textu) {
          var textu = marked(textu, options);
          if (subpart) {
            var s = $sce.trustAsHtml(textu).toString();
            var text = s.substring(s.indexOf("<p>"), s.indexOf("</p>"));
            return text;
          } else {
            return $sce.trustAsHtml(textu);
          }
        }
	    };
	});

    app.filter('metadata', function($sce) {
        var urls = /(\b(https?|ftp):\/\/[A-Z0-9+&@#\/%?=~_|!:,.;-]*[-A-Z0-9+&@#\/%=~_|])/gim;
        var users = /(^|\s)(@[a-z][-\.a-z\d]+[a-z\d])/gim;
        var imgs = /(https?:\/\/.*\.(?:png|jpg|jpeg|gif))/gim;
        var youtube = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/;
        var youtubeid = /(?:(?:youtube.com\/watch\?v=)|(?:youtu.be\/))([A-Za-z0-9\_\-]+)/i;

        return function(textu) {
            var out = {};
            var murls = textu.match(urls);
            var musers = textu.match(users);
            var mimgs = [];
            var mlinks = [];
            if (murls) {
              var _len = murls.length;
                for (var i = 0; i < _len; i++) {
                    var ind = murls[i].match(imgs);
                    if (ind) {
                        mimgs.push(murls[i]);
                    } else {
                        mlinks.push(murls[i]);
                    }
                }
                if (mlinks) {
                    angular.merge(out, {links: mlinks});
                }
                if (mimgs) {
                    angular.merge(out, {image: mimgs});
                }
            }
            if (musers) {
              var _len = musers.length;
                for (var i = 0; i < _len; i++) {
                    musers[i] = musers[i].trim().substring(1);
                }
                if (musers) {
                    angular.merge(out, {users: musers});
                }
            }
            return out;
        };
    });

    app.filter('metadataUsers', function($sce) {
        var users = /(^|\s)(@[a-z][-\.a-z\d]+[a-z\d])/gim;
        return function(textu) {
          if (textu) {
            var out = {};
            var musers = textu.match(users);

            $rootScope.log(angular.toJson(musers));

            return textu;
          }
        };
    });

     app.filter('getCurrencySymbol', function($filter) {
        return function(text) {
          if (text) {
            //console.log(text.split('-')[1]);
            //var x = text.split('-')[1];
            //var tt = $filter('uppercase')(x);
            var textu = window.getSymbol(text);
            return textu=="?"?text:textu;
          }
        };
    });

  function ansiWordBound(c) {
    return (
      (' ' === c) ||
      ('\n' === c) ||
      ('\r' === c) ||
      ('\t' === c)
    )
  }

  function readingTime(text, options) {
    var words = 0, start = 0, end = text.length - 1, wordBound, i

    options = options || {}

    // use default values if necessary
    options.wordsPerMinute = options.wordsPerMinute || 200

    // use provided function if available
    wordBound = options.wordBound || ansiWordBound

    // fetch bounds
    while (wordBound(text[start])) start++
    while (wordBound(text[end])) end--

    // calculate the number of words
    for (i = start; i <= end;) {
      for (; i <= end && !wordBound(text[i]); i++) ;
      words++
      for (; i <= end && wordBound(text[i]); i++) ;
    }

    // reading time stats
    var minutes = words / options.wordsPerMinute
    var time = minutes * 60 * 1000
    var displayed = Math.ceil(minutes.toFixed(2))

    return {
      text: displayed + ' min read',
      minutes: Math.ceil(minutes.toFixed(2)),
      time: time,
      words: words
    }
  }

  app.filter('readingtime', function($sce, $rootScope) {
      return function(text) {
        if (text) {
          return readingTime(text).minutes;
        }
      };
  })

	app.filter('sp', function($sce, $rootScope) {
	    return function(text) {
	    	if (text) {
	    		return (Number(text.split(" ")[0])/1e6*$rootScope.$storage.steem_per_mvests).toFixed(3);
	    	}
	    };
	})
	app.filter('sd', function($sce, $rootScope) {
	    return function(text, balance, sbd) {
	    	if (text) {
	    		return ((Number(text.split(" ")[0])/1e6*$rootScope.$storage.steem_per_mvests*$rootScope.$storage.base + Number(balance.split(" ")[0])*$rootScope.$storage.base + Number(sbd.split(" ")[0])).toFixed(3))*$rootScope.$storage.currencyRate;
	    	}
	    };
	})
	app.filter('sbd', function($sce, $rootScope) {
	    return function(text) {
	    	if (text) {
	    		return (Number(text.split(" ")[0]).toFixed(3));
	    	}
	    };
	})
	app.filter('st', function($sce, $rootScope) {
	    return function(text) {
	    	if (text) {
	    		return (Number(text.split(" ")[0]).toFixed(3));
	    	}
	    };
	})
	app.filter('reputation', function(){
		return function(value, bool) {
			reputation_level = 1;
			neg = false;

			if (value < 0)
				neg = true;

			if (value != 0) {
				reputation_level = Math.log10(Math.abs(value));
				reputation_level = Math.max(reputation_level - 9, 0);

				if (reputation_level < 0)
					reputation_level = 0;
				if (neg)
					reputation_level *= -1;

				reputation_level = (reputation_level*9) + 25;
			} else {
				return 0;
			}

			return bool?reputation_level:Math.floor(reputation_level);
		}
	})

  app.filter("sumPostTotal", function($rootScope){
    function SumPostTotal(value, rate) {
      //console.log(value, rate);
      if (value && value.pending_payout_value) {
        //value.total_payout_value.split(" ")[0])+parseFloat(value.total_pending_payout_value.split(" ")[0])
        return (parseFloat(value.pending_payout_value.split(" ")[0])*rate);
      }
    }
    //SumPostTotal.$stateful = true;

    return SumPostTotal;
  });

  app.filter("rate", function($rootScope){
    return function(value) {
      if (value) {
        return (parseFloat(value)*$rootScope.$storage.currencyRate);
      }
    }
  });  

  app.filter('hrefToJS', function ($sce, $sanitize) {
      return function (text) {
          var regex = /href="([\S]+)"/g;
          var newString = $sanitize(text).replace(regex, "href onClick=\"window.open('$1', '_blank', 'location=yes');return false;\"");
          return $sce.trustAsHtml(newString);
      }
  });

  app.directive('autofocus', ['$timeout',
    function ($timeout) {
      return {
        restrict: 'A',
        link: function ($scope, $element) {
          $timeout(function () {
            $element[0].focus();
          });
        }
      };
    }]);

	app.directive('qrcode', function($interpolate) {
		return {
		    restrict: 'E',
		    link: function($scope, $element, $attrs) {

		      var options = {
		        text: '',
		        width: 128,
		        height: 128,
		        colorDark: '#000000',
		        colorLight: '#ffffff',
		        correctLevel: 'H'
		      };

		      Object.keys(options).forEach(function(key) {
		        options[key] = $interpolate($attrs[key] || '')($scope) || options[key];
		      });

		      options.correctLevel = QRCode.CorrectLevel[options.correctLevel];

		      new QRCode($element[0], options);

		    }
		}
	});


    app.directive('ionComment', ionComment)
    app.directive('ionThread', ionThread);

    function ionComment() {
        return {
            restrict: 'E',
            scope: {
                comment: '='
            },
            template: '<ion-item ng-if="comment.author" class="ion-comment item">\
                        <div class="ion-comment--author"><img class="round-avatar" src="img/user_profile.png" ng-src="{{$root.$storage.paccounts[comment.author].json_metadata.user_image||$root.$storage.paccounts[comment.author].json_metadata.profile.profile_image}}" onerror="this.src=\'img/user_profile.png\'" onabort="this.src=\'img/user_profile.png\'" /><b><a href="#/app/profile/{{comment.author}}">{{comment.author}}</a></b>&nbsp;<div class="reputation">{{comment.author_reputation|reputation|number:0}}</div>&middot;{{comment.created|timeago}}</div>\
                        <div class="ion-comment--score"><span on-tap="openTooltip($event,comment)"><b>{{$root.$storage.currency|getCurrencySymbol}}</b> {{comment.total_pending_payout_value.split(" ")[0]|rate|number}} </span> | <span on-tap="downvotePost(comment)"><span class="fa fa-flag" ng-class="{\'assertive\':comment.downvoted}"></span></span></div>\
                        <div class="ion-comment--text bodytext selectable" ng-bind-html="comment.body | parseUrl "></div>\
                        <div class="ion-comment--replies"><span on-tap="upvotePost(comment)" on-hold="openSliderr($event)"><span class="fa fa-chevron-circle-up" ng-class="{\'positive\':comment.upvoted}"></span> {{"UPVOTE"|translate}}</span> | <span on-tap="$root.openInfo(comment)">{{comment.net_votes || 0}} {{"VOTES"|translate}}</span> | <span on-tap="toggleComment(comment)">{{comment.children || 0}} {{"REPLIES"|translate}}</span> | <span on-tap="replyToComment(comment)"><span class="fa fa-reply"></span> {{"REPLY"|translate}}</span> <span ng-if="comment.author == $root.$storage.user.username && compateDate(comment)" on-tap="editComment(comment)"> | <span class="ion-ios-compose-outline"></span> {{\'EDIT\'|translate}}</span> <span ng-if="comment.author == $root.$storage.user.username" on-tap="deleteComment(comment)"> | <span class="ion-ios-trash-outline"></span> {{\'REMOVE\'|translate}}</span></div>\
                    </ion-item>',
            controller: function($scope, $rootScope, $state, $ionicModal, $ionicPopover, $ionicPopup, $ionicActionSheet, $cordovaCamera, $filter) {
                  $ionicPopover.fromTemplateUrl('popoverTr.html', {
                      scope: $scope
                   }).then(function(popover) {
                      $scope.tooltip = popover;
                   });
                  var formatToPercentage = function (value) {
                    return value + '%';
                  };
                  $scope.pslider = {
                    value: $rootScope.$storage.voteWeight/100,
                    options: {
                      floor: 1,
                      ceil: 100,
                      translate: formatToPercentage,
                      showSelectionBar: true
                    }
                  };
                  $ionicPopover.fromTemplateUrl('popoverSliderr.html', {
                      scope: $scope
                  }).then(function(popover) {
                      $scope.tooltipSliderr = popover;
                  });
                  
                  $scope.openSliderr = function($event) {
                    $scope.pslider = {
                      value: $rootScope.$storage.voteWeight/100,
                      options: {
                        floor: 1,
                        ceil: 100,
                        translate: formatToPercentage,
                        showSelectionBar: true
                      }
                    };
                    $scope.tooltipSliderr.show($event);
                  };

                  $scope.closeSliderr = function() {
                    $scope.tooltipSliderr.hide();
                  };

                  $scope.$watch('pslider', function(newValue, oldValue){
                    //console.log(newValue.value);
                    if (newValue.value) {
                      $rootScope.$storage.voteWeight = newValue.value*100;
                    }
                  }, true);

                   $scope.openTooltip = function($event, d) {
                    var tppv = Number(d.total_pending_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
                    var p = Number(d.promoted.split(' ')[0])*$rootScope.$storage.currencyRate;
                    var tpv = Number(d.total_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
                    var ar = Number(d.total_payout_value.split(' ')[0]-d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
                    var crp = Number(d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
                    var texth = "<div class='row'><div class='col'><b>"+$filter('translate')('PAYOUT_CYCLE')+"</b></div><div class='col'>"+d.mode.replace('_',' ')+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('POTENTIAL_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tppv, 3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAST_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tpv,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAYOUT')+"</b></div><div class='col'>"+$filter('timeago')(d.cashout_time, true)+"</div></div>";
                    $scope.tooltipText = texth;
                    $scope.tooltip.show($event);
                   };

                   $scope.closeTooltip = function() {
                      $scope.tooltip.hide();
                   };

                   //Cleanup the popover when we're done with it!
                   $scope.$on('$destroy', function() {
                      $scope.tooltip.remove();
                   });


                  $scope.compateDate = function(comment) {
                    if (comment.last_payout == "1970-01-01T00:00:00") {
                        return true;
                    } else {
                      if (comment.mode == "first_payout"){
                        return true;
                      } else {
                        return false;
                      }
                    }
                  };
                  $scope.toggleComment = function(comment) {
                      $rootScope.log('toggleComment');

                      if (comment.showChildren) {
                          comment.showChildren = false;
                      } else {
                          comment.showChildren = true;
                      }
                    //$rootScope.$broadcast('hide:loading');
                  };
                  $scope.upvotePost = function(post) {
                    $rootScope.votePost(post, 'upvote', 'update:content');
                  };

                  $scope.downvotePost = function(post) {
                    var confirmPopup = $ionicPopup.confirm({
                      title: $filter('translate')('ARE_YOU_SURE'),
                      template: $filter('translate')('DOWNVOTE_FLAG')
                    });
                    confirmPopup.then(function(res) {
                      if(res) {
                        $rootScope.log('You are sure');
                        $rootScope.votePost(post, 'downvote', 'update:content');
                      } else {
                        $rootScope.log('You are not sure');
                      }
                    });
                  };

                  $scope.unvotePost = function(post) {
                    $rootScope.votePost(post, 'unvote', 'update:content');
                  };
                  $scope.data={};
                  $ionicModal.fromTemplateUrl('templates/reply.html', {
                    scope: $scope  }).then(function(modal) {
                    $scope.cmodal = modal;
                  });

                  $scope.openModal = function(item) {
                    $scope.cmodal.show();
                  };

                  $scope.closeModal = function() {
                    $scope.replying = false;
                    $scope.cmodal.hide();
                  };

                  $scope.isreplying = function(cho, xx) {
                    $scope.replying = xx;
                    $scope.post = cho;
                    if (xx) {
                        $scope.editc = false;
                        $scope.edit = false;
                        $scope.data.comment = '';
                        $scope.openModal();
                    } else {
                        $scope.editc = true;
                        $scope.edit = true;
                        $scope.data.comment = $scope.post.body;
                        $scope.patchbody = $scope.post.body;
                        $scope.openModal();
                    }
                  };

                  $scope.showImg = function() {
                   var hideSheet = $ionicActionSheet.show({
                     buttons: [
                       { text: $filter('translate')('CAPTURE_PICTURE') },
                       { text: $filter('translate')('SELECT_PICTURE') },
                       { text: $filter('translate')('SET_CUSTOM_URL') },
                     ],
                     titleText: $filter('translate')('INSERT_PICTURE'),
                     cancelText: $filter('translate')('CANCEL'),
                     cancel: function() {
                        // add cancel code..
                      },
                     buttonClicked: function(index) {
                        $scope.insertImageC(index);
                        return true;
                     }
                   });
                  };

                  $scope.insertImageC = function(type) {
                    var options = {};
                    if (type == 0 || type == 1) {
                      options = {
                        quality: 50,
                        destinationType: Camera.DestinationType.FILE_URI,
                        sourceType: (type===0)?Camera.PictureSourceType.CAMERA:Camera.PictureSourceType.PHOTOLIBRARY,
                        allowEdit: (type===0)?true:false,
                        encodingType: Camera.EncodingType.JPEG,
                        popoverOptions: CameraPopoverOptions,
                        saveToPhotoAlbum: false
                        //correctOrientation:true
                      };
                      $cordovaCamera.getPicture(options).then(function(imageData) {
                        setTimeout(function() {
                          ImageUploadService.uploadImage(imageData).then(function(result) {
                            //var url = result.secure_url || '';
                            var url = result.imageUrl || '';
                            var final = " ![image](" + url + ")";
                            $rootScope.log(final);
                            if ($scope.data.comment) {
                              $scope.data.comment += final;
                            } else {
                              $scope.data.comment = final;
                            }
                            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                              $cordovaCamera.cleanup();
                            }
                          },
                          function(err) {
                            $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('UPLOAD_ERROR'));
                            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                              $cordovaCamera.cleanup();
                            }
                          });
                        }, 10);
                      }, function(err) {
                        $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('CAMERA_CANCELLED'));
                      });
                    } else {
                      $ionicPopup.prompt({
                        title: $filter('translate')('SET_URL'),
                        template: $filter('translate')('DIRECT_LINK_PICTURE'),
                        inputType: 'text',
                        inputPlaceholder: 'http://example.com/image.jpg'
                      }).then(function(res) {
                        $rootScope.log('Your url is' + res);
                        if (res) {
                          var url = res.trim();
                          var final = " ![image](" + url + ")";
                          $rootScope.log(final);
                          if ($scope.data.comment) {
                            $scope.data.comment += final;
                          } else {
                            $scope.data.comment = final;
                          }
                        }
                      });
                    }
                  };

                  var dmp = new window.diff_match_patch();
                  function createPatch(text1, text2) {
                      if (!text1 && text1 === '') return undefined;
                      var patches = dmp.patch_make(text1, text2);
                      var patch = dmp.patch_toText(patches);
                      return patch;
                  }
                  $scope.reply = function (xx) {
                    if (!$scope.editc) {
                        $rootScope.$broadcast('show:loading');
                        if ($rootScope.$storage.user) {
                          $scope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
                          $scope.mylogin.setRoles(["posting"]);
                          var loginSuccess = $scope.mylogin.checkKeys({
                              accountName: $rootScope.$storage.user.username,
                              password: $rootScope.$storage.user.password || null,
                              auths: {
                                  posting: $rootScope.$storage.user.posting.key_auths
                              },
                              privateKey: $rootScope.$storage.user.privatePostingKey || null
                            }
                          );
                          if (loginSuccess) {
                            var tr = new window[$rootScope.$storage.chain+"JS"].TransactionBuilder();
                            var t = new Date();
                            var timeformat = t.getFullYear().toString()+(t.getMonth()+1).toString()+t.getDate().toString()+"t"+t.getHours().toString()+t.getMinutes().toString()+t.getSeconds().toString()+t.getMilliseconds().toString()+"z";

                            var json = {tags: angular.fromJson($scope.post.json_metadata).tags[0] || "", app: 'esteem/'+$rootScope.$storage.appversion, format: 'markdown+html' };
                            tr.add_type_operation("comment", {
                              parent_author: $scope.post.author,
                              parent_permlink: $scope.post.permlink,
                              author: $rootScope.$storage.user.username,
                              permlink: "re-"+$scope.post.author+"-"+$scope.post.permlink+"-"+timeformat,
                              title: "",
                              body: $scope.data.comment,
                              json_metadata: angular.toJson(json)
                            });
                            //$rootScope.log(my_pubkeys);
                            localStorage.error = 0;
                            tr.process_transaction($scope.mylogin, null, true);

                            $scope.replying = false;
                            setTimeout(function() {
                              if (localStorage.error == 1) {
                                $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                              } else {
                                $scope.closeModal();
                                $scope.data.comment = "";
                                $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('COMMENT_SUBMITTED'));
                                $rootScope.$broadcast("update:content");
                              }
                              $rootScope.$broadcast('hide:loading');
                            }, 3000);
                          } else {
                            $rootScope.$broadcast('hide:loading');
                            $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
                          }
                        } else {
                          $rootScope.$broadcast('hide:loading');
                          $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
                        }
                    } else {

                        var patch = createPatch($scope.patchbody, $scope.data.comment)
                        // Putting body into buffer will expand Unicode characters into their true length
                        if (patch && patch.length < new Buffer($scope.data.comment, 'utf-8').length) {
                          $scope.data.comment2 = patch;
                          //$rootScope.log(patch);
                        }

                        $rootScope.$broadcast('show:loading');
                        if ($rootScope.$storage.user) {
                          $scope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
                          $scope.mylogin.setRoles(["posting"]);
                          var loginSuccess = $scope.mylogin.checkKeys({
                              accountName: $rootScope.$storage.user.username,
                              password: $rootScope.$storage.user.password || null,
                              auths: {
                                  posting: $rootScope.$storage.user.posting.key_auths
                              },
                              privateKey: $rootScope.$storage.user.privatePostingKey || null
                            }
                          );
                          if (loginSuccess) {
                            var tr = new window[$rootScope.$storage.chain+"JS"].TransactionBuilder();

                            var json = {tags: angular.fromJson($scope.post.json_metadata).tags[0] || "", app: 'esteem/'+$rootScope.$storage.appversion, format: 'markdown+html' };
                            tr.add_type_operation("comment", {
                              parent_author: $scope.post.parent_author,
                              parent_permlink: $scope.post.parent_permlink,
                              author: $scope.post.author,
                              permlink: $scope.post.permlink,
                              title: "",
                              body: $scope.data.comment2 || $scope.data.comment,
                              json_metadata: $scope.post.json_metadata
                            });
                            //$rootScope.log(my_pubkeys);
                            localStorage.error = 0;
                            tr.process_transaction($scope.mylogin, null, true);

                            $scope.closeModal();
                            $scope.replying = false;
                            setTimeout(function() {
                              if (localStorage.error == 1) {
                                $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                              } else {
                                $scope.data.comment = "";
                                $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('COMMENT_SUBMITTED'));
                                $rootScope.$broadcast("update:content");
                              }
                              $rootScope.$broadcast('hide:loading');
                            }, 3000);
                          } else {
                            $rootScope.$broadcast('hide:loading');
                            $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
                          }
                        } else {
                          $rootScope.$broadcast('hide:loading');
                          $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
                        }
                    }
                  $rootScope.$broadcast('hide:loading');
                }
                $scope.replyToComment = function(comment) {
                    $rootScope.log('reply to comment')
                    //$rootScope.$storage.sitem = comment;
                    $scope.isreplying(comment, true);
                }
                $scope.editComment = function(comment) {
                    $rootScope.log('edit to comment')
                    //$rootScope.$storage.sitem = comment;
                    $scope.isreplying(comment, false);
                }
                $scope.deleteComment = function(comment) {
                    $rootScope.log('delete to comment '+ angular.toJson(comment));
                    var confirmPopup = $ionicPopup.confirm({
                        title: $filter('translate')('ARE_YOU_SURE'),
                        template: $filter('translate')('DELETE_COMMENT')
                    });
                    confirmPopup.then(function(res) {
                        if(res) {
                            $rootScope.log('You are sure');
                            $rootScope.$broadcast('show:loading');
                            if ($rootScope.$storage.user) {
                              $scope.mylogin = new window[$rootScope.$storage.chain+"JS"].Login();
                              $scope.mylogin.setRoles(["posting"]);
                              var loginSuccess = $scope.mylogin.checkKeys({
                                  accountName: $rootScope.$storage.user.username,
                                  password: $rootScope.$storage.user.password || null,
                                  auths: {
                                      posting: $rootScope.$storage.user.posting.key_auths
                                  },
                                  privateKey: $rootScope.$storage.user.privatePostingKey || null
                                }
                              );
                              if (loginSuccess) {
                                var tr = new window[$rootScope.$storage.chain+"JS"].TransactionBuilder();

                                tr.add_type_operation("delete_comment", {
                                  author: comment.author,
                                  permlink: comment.permlink
                                });
                                //$rootScope.log(my_pubkeys);
                                localStorage.error = 0;
                                tr.process_transaction($scope.mylogin, null, true);

                                setTimeout(function() {
                                  if (localStorage.error == 1) {
                                    $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                                  } else {
                                    $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('DELETED_COMMENT'));
                                    $rootScope.$broadcast("update:content");
                                  }
                                  $rootScope.$broadcast('hide:loading');
                                }, 3000);
                              } else {
                                $rootScope.$broadcast('hide:loading');
                              }
                            } else {
                              $rootScope.$broadcast('hide:loading');
                              $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
                            }
                        } else {
                          $rootScope.log('You are not sure');
                        }
                    });
                }
            }
        }
    }

    function ionThread() {
        return {
            restrict: 'E',
            scope: {
                comments: '='
            },
            //Replace ng-if="!comment.showChildren" with ng-if="comment.showChildren" to hide all child comments by default
            //Replace comment.data.replies.data.children according to the API you are using | orderBy:\'-net_votes\'
            template: '<script type="text/ng-template" id="node.html">\
                            <ion-comment comment="comment">\
                            </ion-comment>\
                            <div class="reddit-post--comment--container">\
                                 <ul ng-if="!comment.showChildren" class="animate-if ion-comment--children">\
                                    <li ng-repeat="comment in comment.comments | orderBy:\'-net_votes\' track by $index ">\
                                        <ng-include src="\'node.html\'"/>\
                                    </li>\
                                </ul>\
                            </div>\
                        </script>\
                        <ion-list ng-if="comments && comments.length > 0">\
                          <ul>\
                            <li ng-repeat="comment in comments | orderBy:\'-net_votes\' track by $index">\
                                <ng-include src="\'node.html\'"/>\
                            </li>\
                          </ul>\
                        </ion-list>',
            controller: function($scope, $rootScope) {
                $scope.toggleComment = function(comment) {
                  $rootScope.log('toggleComment');
                  if (comment.showChildren) {
                      comment.showChildren = false;
                  } else {
                      comment.showChildren = true;
                  }
                };
            }
        }
    }

    function ius($q, $ionicLoading, $cordovaFileTransfer, $ionicPlatform, $filter, $rootScope) {
        var service = {};
        service.uploadImage = uploadImage;
        return service;
        function uploadImage(imageURI) {
          var deferred = $q.defer();
          var fileSize;
          var percentage;
          /*if (ionic.Platform.isAndroid()) {
            if (imageURI.indexOf('file://')===-1) {
              imageURI="file://"+imageURI;
            }
          }*/
          // Find out how big the original file is
          window.resolveLocalFileSystemURL(imageURI, function(fileEntry) {
            fileEntry.file(function(fileObj) {
              fileSize = fileObj.size;
              // Display a loading indicator reporting the start of the upload
              $ionicLoading.show({template : $filter('translate')('UPLOADING_PICTURE') + 0 + '%'});
              // Trigger the upload
              uploadFile();
            });
          });
          function uploadFile() {
            // Add the Cloudinary "upload preset" name to the headers
            // "https://api.cloudinary.com/v1_1/esteem/image/upload"
            var uploadOptions = {
              params : { 'username': $rootScope.$storage.user.username}
            };
            $ionicPlatform.ready(function() {
                $cordovaFileTransfer.upload("http://192.158.29.1:8080/api/upload", imageURI, uploadOptions).then(function(result) {
                    // Let the user know the upload is completed
                    $ionicLoading.show({template : $filter('translate')('UPLOAD_COMPLETED'), duration: 1000});
                    // Result has a "response" property that is escaped
                    // FYI: The result will also have URLs for any new images generated with
                    // eager transformations
                    var response = JSON.parse(decodeURIComponent(result.response));
                    deferred.resolve(response);
                  }, function(err) {
                    // Uh oh!
                    $ionicLoading.show({template : $filter('translate')('UPLOAD_FAILED'), duration: 2000});
                    deferred.reject(err);
                  }, function (progress) {
                    // The upload plugin gives you information about how much data has been transferred
                    // on some interval.  Use this with the original file size to show a progress indicator.
                    percentage = Math.floor((progress.loaded / fileSize) * 100);
                    $ionicLoading.show({template : $filter('translate')('UPLOADING_PICTURE') + percentage + '%'});
                  });
            });
          }
          return deferred.promise;
        }
    }

    app.factory('ImageUploadService', ius);

    app.constant('defaultSettings', {
        alphabetcolors: ["#5A8770", "#B2B7BB", "#6FA9AB", "#F5AF29", "#0088B9", "#F18636", "#D93A37", "#A6B12E", "#5C9BBC", "#F5888D", "#9A89B5", "#407887", "#9A89B5", "#5A8770", "#D33F33", "#A2B01F", "#F0B126", "#0087BF", "#F18636", "#0087BF", "#B2B7BB", "#72ACAE", "#9C8AB4", "#5A8770", "#EEB424", "#407887"],
        textColor: '#ffffff',
        defaultBorder: 'border:5px solid white',
        triangleup: 'width: 0;height: 0;border-left: 50px solid transparent;border-right: 50px solid transparent;border-bottom: 100px solid;',
        fontsize: 30, // unit in pixels
        height: 50, // unit in pixels
        width: 50, // unit in pixels
        fontWeight: 400, //
        charCount: 1,
        fontFamily: 'HelveticaNeue-Light,Helvetica Neue Light,Helvetica Neue,Helvetica, Arial,Lucida Grande, sans-serif',
        base: 'data:image/svg+xml;base64,',
        radius: 'border-radius:50%;',
        custombgcolor: '',
        dynamic: 'false',
        rotatedeg: '0'
    });

    /**
     * directive to create the avatar
     * @param {type} param1
     * @param {type} param2
     */
    app.directive('ngLetterAvatar', ['defaultSettings', function (defaultSettings) {
        return {
            restrict: 'AE',
            replace: true,
            scope: {
                alphabetcolors: '=alphabetcolors',
                data: '@'
            },
            link: function (scope, element, attrs) {

                /**
                 * Populate the attribute values to params object
                 * @type type
                 */
                var params = {
                    charCount: attrs.charcount || defaultSettings.charCount,
                    data: attrs.data,
                    textColor: defaultSettings.textColor,
                    height: attrs.height || defaultSettings.height,
                    width: attrs.width || defaultSettings.width,
                    fontsize: attrs.fontsize || defaultSettings.fontsize,
                    fontWeight: attrs.fontweight || defaultSettings.fontWeight,
                    fontFamily: attrs.fontfamily || defaultSettings.fontFamily,
                    avatarBorderStyle: attrs.avatarcustomborder,
                    avatardefaultBorder: attrs.avatarborder,
                    defaultBorder: defaultSettings.defaultBorder,
                    shape: attrs.shape,
                    alphabetcolors: scope.alphabetcolors || defaultSettings.alphabetcolors,
                    avatarCustomBGColor: attrs.avatarcustombgcolor || defaultSettings.custombgcolor,
                    dynamic: attrs.dynamic || defaultSettings.dynamic,
                    rotatedeg: attrs.rotatedeg || defaultSettings.rotatedeg
                };

                /**
                 * to generate the avatar dynamically on data change, enable the below function to watch the event
                 */
                if (params.dynamic === 'true') {
                    scope.$watch('data', function () {
                        _generateLetterAvatar();
                    });
                } else {
                    _generateLetterAvatar();
                }

                function _generateLetterAvatar() {
                    var c = '';
                    if (params.charCount == 2) {
                        var _data = getFirstAndLastName(scope.data.toUpperCase());
                        if (_data) {
                            c = _data;
                        } else {
                            c = scope.data.substr(0, params.charCount).toUpperCase();
                        }
                    } else {
                        c = scope.data.substr(0, params.charCount).toUpperCase();
                    }
                    var cobj = getCharacterObject(c, params.textColor, params.fontFamily, params.fontWeight, params.fontsize);
                    var colorIndex = '';
                    var color = '';

                    /**
                     * Populate the colors according to attributes
                     */
                    if (c.charCodeAt(0) < 65) {
                        color = getRandomColors();
                    } else {
                        colorIndex = Math.floor((c.charCodeAt(0) - 65) % params.alphabetcolors.length);
                        color = params.alphabetcolors[colorIndex];
                    }

                    if (params.avatarCustomBGColor) {
                        color = params.avatarCustomBGColor;
                    }

                    var svg = getImgTag(params.width, params.height, color);
                    svg.append(cobj);
                    var lvcomponent = angular.element('<div>').append(svg.clone()).html();
                    var svgHtml = window.btoa(unescape(encodeURIComponent(lvcomponent)));
                    var component;
                    var base = defaultSettings.base;
                    var _style = '';
                    if (params.avatarBorderStyle) {
                        _style = params.avatarBorderStyle;
                    } else if (params.avatardefaultBorder) {
                        _style = params.defaultBorder;
                    }

                    if (params.rotatedeg != '0') {
                        _style = '-ms-transform: rotate(' + params.rotatedeg + 'deg); -webkit-transform: rotate(' + params.rotatedeg + 'deg); transform: rotate(' + params.rotatedeg + 'deg)';
                    }

                    if (params.shape) {
                        if (params.shape === 'round') {
                            var round_style = defaultSettings.radius + _style;
                            if (scope.data.indexOf('http') > -1 || scope.data.indexOf('data:image') > -1) {
                                var img_size = 'width:' + params.width + 'px;height:' + params.height + 'px;';
                                component = "<img src=" + scope.data + " style='" + img_size + round_style + "'  />";
                            } else {
                                component = "<img src=" + base + svgHtml + " style='" + round_style + "' title='" + scope.data + "' />";
                            }
                        }
                    } else {
                        if (scope.data.indexOf('http') > -1 || scope.data.indexOf('data:image') > -1) {
                            var img_size = 'width:' + params.width + 'px;height:' + params.height + 'px;';
                            component = "<img src=" + scope.data + " style='" + img_size + _style + "'  />";
                        } else {
                            component = "<img src=" + base + svgHtml + " style='" + _style + "' title='" + scope.data + "' />";
                        }
                    }

                    if (params.dynamic === 'true') {
                        element.empty();
                        element.append(component);
                    } else {
                        element.replaceWith(component);
                    }
                }
            }
        };
    }]);
    /**
     * Get the random colors
     * @returns {String}
     */
    function getRandomColors() {
        var letters = '0123456789ABCDEF'.split('');
        var _color = '#';
        for (var i = 0; i < 6; i++) {
            _color += letters[Math.floor(Math.random() * 16)];
        }
        return _color;
    }
    /**
     * get the first name and last name first letters and combined and form the letter avatar
     * @param {type} data
     * @returns {unresolved}
     */
    function getFirstAndLastName(data) {
        var names = data.split(" ");
        if (names && names.length >= 2) {
            var firstName = names[0];
            var lastName = names[1];
            if (firstName && lastName) {
                var text = firstName.substr(0, 1) + lastName.substr(0, 1);
                return text;
            } else {
                return data.substr(0, 2);
            }
        }
    }

    /**
     * Populate the svg tag which will used for the avatar generation
     * @param {type} width
     * @param {type} height
     * @param {type} color
     * @returns {unresolved}
     */
    function getImgTag(width, height, color) {

        var svgTag = angular.element('<svg></svg>')
                .attr({
                    'xmlns': 'http://www.w3.org/2000/svg',
                    'pointer-events': 'none',
                    'width': width,
                    'height': height
                })
                .css({
                    'background-color': color,
                    'width': width + 'px',
                    'height': height + 'px'
                });

        return svgTag;
    }

    /**
     *  Generate the Letter tag by using the svg text element
     * @param {type} character
     * @param {type} textColor
     * @param {type} fontFamily
     * @param {type} fontWeight
     * @param {type} fontsize
     * @returns {unresolved}
     */
    function getCharacterObject(character, textColor, fontFamily, fontWeight, fontsize) {
        var textTag = angular.element('<text text-anchor="middle"></text>')
                .attr({
                    'y': '50%',
                    'x': '50%',
                    'dy': '0.35em',
                    //'stroke': '#000000',
                    'pointer-events': 'auto',
                    'fill': textColor,
                    'font-family': fontFamily
                })
                .html(character)
                .css({
                    'font-weight': fontWeight,
                    'font-size': fontsize + 'px',
                });

        return textTag;
    }

}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/posts/services.js","/posts")
},{"buffer":11,"pBGvAp":74}]},{},[134])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9iYXNlLXgvaW5kZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvYmlnaS9saWIvYmlnaS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9iaWdpL2xpYi9jb252ZXJ0LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2JpZ2kvbGliL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2JpZ2kvcGFja2FnZS5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9ieXRlYnVmZmVyL2Rpc3QvYnl0ZWJ1ZmZlci5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jaXBoZXItYmFzZS9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9icm93c2VyLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL2hlbHBlcnMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbWQ1LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2NyZWF0ZS1obWFjL2Jyb3dzZXIuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2Flcy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY2lwaGVyLWNvcmUuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy1iYXNlNjQuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy1oZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2V2cGtkZi5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvaG1hYy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbWQ1LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGExLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2N1cnJlbmN5LXN5bWJvbC1tYXAvY3VycmVuY3ktc3ltYm9sLW1hcC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jdXJyZW5jeS1zeW1ib2wtbWFwL21hcC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9kaWZmLW1hdGNoLXBhdGNoL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWIvY3VydmUuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZWN1cnZlL2xpYi9jdXJ2ZXMuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lY3VydmUvbGliL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWIvbmFtZXMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZWN1cnZlL2xpYi9wb2ludC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvY2hhaW4vaW5kZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9jaGFpbi9zcmMvQWNjb3VudExvZ2luLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvY2hhaW4vc3JjL0NoYWluQ29uZmlnLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvY2hhaW4vc3JjL0NoYWluVHlwZXMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9jaGFpbi9zcmMvQ2hhaW5WYWxpZGF0aW9uLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvY2hhaW4vc3JjL051bWJlclV0aWxzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvY2hhaW4vc3JjL09iamVjdElkLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvY2hhaW4vc3JjL1RyYW5zYWN0aW9uQnVpbGRlci5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L2NoYWluL3NyYy9UcmFuc2FjdGlvbkhlbHBlci5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L2VjYy9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L2VjYy9zcmMvQnJhaW5LZXkuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9lY2Mvc3JjL0tleVV0aWxzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvZWNjL3NyYy9Qcml2YXRlS2V5LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvZWNjL3NyYy9QdWJsaWNLZXkuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9lY2Mvc3JjL2FkZHJlc3MuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9lY2Mvc3JjL2Flcy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L2VjYy9zcmMvZWNkc2EuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9lY2Mvc3JjL2Vjc2lnbmF0dXJlLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvZWNjL3NyYy9lbmZvcmNlX3R5cGVzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvZWNjL3NyYy9oYXNoLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvZWNjL3NyYy9zaWduYXR1cmUuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvaW5kZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9GYXN0UGFyc2VyLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvU2VyaWFsaXplclZhbGlkYXRpb24uanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9lcnJvcl93aXRoX2NhdXNlLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvbnVtYmVyVXRpbHMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9vcGVyYXRpb25zLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvc2VyaWFsaXplci5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL3RlbXBsYXRlLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvdHlwZXMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvaW5kZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIva2V5cy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvbG9uZy9kaXN0L2xvbmcuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvcmlwZW1kMTYwL2xpYi9yaXBlbWQxNjAuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc2VjdXJlLXJhbmRvbS9saWIvc2VjdXJlLXJhbmRvbS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zaGEuanMvaGFzaC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zaGEuanMvaW5kZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjI0LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyNTYuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTM4NC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhNTEyLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWIvQXBpSW5zdGFuY2UuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RlZW0tcnBjL2xpYi9TdGVlbUFwaS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbS1ycGMvbGliL1dlYlNvY2tldFJwYy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbS1ycGMvbGliL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWIvcmVjb25uZWN0aW5nLXdlYnNvY2tldC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2NoYWluL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvY2hhaW4vc3JjL0FjY291bnRMb2dpbi5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2NoYWluL3NyYy9DaGFpbkNvbmZpZy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2NoYWluL3NyYy9DaGFpblR5cGVzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvY2hhaW4vc3JjL0NoYWluVmFsaWRhdGlvbi5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2NoYWluL3NyYy9OdW1iZXJVdGlscy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2NoYWluL3NyYy9PYmplY3RJZC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2NoYWluL3NyYy9UcmFuc2FjdGlvbkJ1aWxkZXIuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9jaGFpbi9zcmMvVHJhbnNhY3Rpb25IZWxwZXIuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9lY2MvaW5kZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9lY2Mvc3JjL0JyYWluS2V5LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvZWNjL3NyYy9LZXlVdGlscy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmMvUHJpdmF0ZUtleS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmMvUHVibGljS2V5LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvZWNjL3NyYy9hZGRyZXNzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvZWNjL3NyYy9hZXMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9lY2Mvc3JjL2VjZHNhLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvZWNjL3NyYy9lY3NpZ25hdHVyZS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmMvZW5mb3JjZV90eXBlcy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmMvaGFzaC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmMvc2lnbmF0dXJlLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvaW5kZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9zZXJpYWxpemVyL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvRmFzdFBhcnNlci5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL1NlcmlhbGl6ZXJWYWxpZGF0aW9uLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvZXJyb3Jfd2l0aF9jYXVzZS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL251bWJlclV0aWxzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvb3BlcmF0aW9ucy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL3NlcmlhbGl6ZXIuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy90ZW1wbGF0ZS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL3R5cGVzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9pc19hcmd1bWVudHMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2tleXMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvZHVwbGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvcGFzc3Rocm91Z2guanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvcmVhZGFibGUuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvdHJhbnNmb3JtLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L3dyaXRhYmxlLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3V0aWwvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvZmFrZV9kMmVjY2MwYy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9jb25maWcuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvY29udHJvbGxlcnMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvaW5kZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9iZy1CRy5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvY3MtQ1ouanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL2RlLURFLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9kb2wuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL2VsLUdSLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9lbi5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvZXMtRVMuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL2ZyLUZSLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9oZS1JTC5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvaHUtSFUuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL2lkLUlELmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9ubC1OTC5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcGwtUEwuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3B0LUJSLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9wdC1QVC5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcnUtUlUuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3N2LVNFLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy96aC1DTi5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvemgtVFcuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9zZXJ2aWNlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2K0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmxDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25wRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwOEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3A4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1VuaXRfVGVzdGluZy8xLjBcbi8vXG4vLyBUSElTIElTIE5PVCBURVNURUQgTk9SIExJS0VMWSBUTyBXT1JLIE9VVFNJREUgVjghXG4vL1xuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyB3aGVuIHVzZWQgaW4gbm9kZSwgdGhpcyB3aWxsIGFjdHVhbGx5IGxvYWQgdGhlIHV0aWwgbW9kdWxlIHdlIGRlcGVuZCBvblxuLy8gdmVyc3VzIGxvYWRpbmcgdGhlIGJ1aWx0aW4gdXRpbCBtb2R1bGUgYXMgaGFwcGVucyBvdGhlcndpc2Vcbi8vIHRoaXMgaXMgYSBidWcgaW4gbm9kZSBtb2R1bGUgbG9hZGluZyBhcyBmYXIgYXMgSSBhbSBjb25jZXJuZWRcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbC8nKTtcblxudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNZXNzYWdlKHRoaXMpO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBub24gdjggYnJvd3NlcnMgc28gd2UgY2FuIGhhdmUgYSBzdGFja3RyYWNlXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgIHZhciBvdXQgPSBlcnIuc3RhY2s7XG5cbiAgICAgIC8vIHRyeSB0byBzdHJpcCB1c2VsZXNzIGZyYW1lc1xuICAgICAgdmFyIGZuX25hbWUgPSBzdGFja1N0YXJ0RnVuY3Rpb24ubmFtZTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKHV0aWwuaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7XG4gIH1cbiAgaWYgKHV0aWwuaXNOdW1iZXIodmFsdWUpICYmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKHZhbHVlKSB8fCB1dGlsLmlzUmVnRXhwKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodXRpbC5pc1N0cmluZyhzKSkge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHNlbGYpIHtcbiAgcmV0dXJuIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHNlbGYuYWN0dWFsLCByZXBsYWNlciksIDEyOCkgKyAnICcgK1xuICAgICAgICAgc2VsZi5vcGVyYXRvciArICcgJyArXG4gICAgICAgICB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmV4cGVjdGVkLCByZXBsYWNlciksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKHV0aWwuaXNCdWZmZXIoYWN0dWFsKSAmJiB1dGlsLmlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIGlmIChhY3R1YWwubGVuZ3RoICE9IGV4cGVjdGVkLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3R1YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhY3R1YWxbaV0gIT09IGV4cGVjdGVkW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8gNy4yLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBEYXRlIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBEYXRlIG9iamVjdCB0aGF0IHJlZmVycyB0byB0aGUgc2FtZSB0aW1lLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNEYXRlKGFjdHVhbCkgJiYgdXRpbC5pc0RhdGUoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMgSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBSZWdFeHAgb2JqZWN0IHdpdGggdGhlIHNhbWUgc291cmNlIGFuZFxuICAvLyBwcm9wZXJ0aWVzIChgZ2xvYmFsYCwgYG11bHRpbGluZWAsIGBsYXN0SW5kZXhgLCBgaWdub3JlQ2FzZWApLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNSZWdFeHAoYWN0dWFsKSAmJiB1dGlsLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcbiAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmXG4gICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJlxuICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcbiAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7XG5cbiAgLy8gNy40LiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKCF1dGlsLmlzT2JqZWN0KGFjdHVhbCkgJiYgIXV0aWwuaXNPYmplY3QoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiKSB7XG4gIGlmICh1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGEpIHx8IHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZTtcbiAgLy9+fn5JJ3ZlIG1hbmFnZWQgdG8gYnJlYWsgT2JqZWN0LmtleXMgdGhyb3VnaCBzY3Jld3kgYXJndW1lbnRzIHBhc3NpbmcuXG4gIC8vICAgQ29udmVydGluZyB0byBhcnJheSBzb2x2ZXMgdGhlIHByb2JsZW0uXG4gIGlmIChpc0FyZ3VtZW50cyhhKSkge1xuICAgIGlmICghaXNBcmd1bWVudHMoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiKTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBrYSA9IG9iamVjdEtleXMoYSksXG4gICAgICAgIGtiID0gb2JqZWN0S2V5cyhiKSxcbiAgICAgICAga2V5LCBpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFfZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyA4LiBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cbi8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBhc3NlcnQuc3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG4vLyAxMC4gVGhlIHN0cmljdCBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciBzdHJpY3QgaW5lcXVhbGl0eSwgYXNcbi8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIGFzc2VydC5ub3RTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodXRpbC5pc1N0cmluZyhleHBlY3RlZCkpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBibG9jaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgYWN0dWFsID0gZTtcbiAgfVxuXG4gIG1lc3NhZ2UgPSAoZXhwZWN0ZWQgJiYgZXhwZWN0ZWQubmFtZSA/ICcgKCcgKyBleHBlY3RlZC5uYW1lICsgJykuJyA6ICcuJykgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgPyAnICcgKyBtZXNzYWdlIDogJy4nKTtcblxuICBpZiAoc2hvdWxkVGhyb3cgJiYgIWFjdHVhbCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKCFzaG91bGRUaHJvdyAmJiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoKHNob3VsZFRocm93ICYmIGFjdHVhbCAmJiBleHBlY3RlZCAmJlxuICAgICAgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fCAoIXNob3VsZFRocm93ICYmIGFjdHVhbCkpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuLy8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuLy8gYXNzZXJ0LnRocm93cyhibG9jaywgRXJyb3Jfb3B0LCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cy5hcHBseSh0aGlzLCBbdHJ1ZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW2ZhbHNlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikge3Rocm93IGVycjt9fTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2Fzc2VydC9hc3NlcnQuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYXNzZXJ0XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gYmFzZS14IGVuY29kaW5nXG4vLyBGb3JrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL2JzNThcbi8vIE9yaWdpbmFsbHkgd3JpdHRlbiBieSBNaWtlIEhlYXJuIGZvciBCaXRjb2luSlxuLy8gQ29weXJpZ2h0IChjKSAyMDExIEdvb2dsZSBJbmNcbi8vIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IFN0ZWZhbiBUaG9tYXNcbi8vIE1lcmdlZCBCdWZmZXIgcmVmYWN0b3JpbmdzIGZyb20gYmFzZTU4LW5hdGl2ZSBieSBTdGVwaGVuIFBhaXJcbi8vIENvcHlyaWdodCAoYykgMjAxMyBCaXRQYXkgSW5jXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmFzZSAoQUxQSEFCRVQpIHtcbiAgdmFyIEFMUEhBQkVUX01BUCA9IHt9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoXG4gIHZhciBMRUFERVIgPSBBTFBIQUJFVC5jaGFyQXQoMClcblxuICAvLyBwcmUtY29tcHV0ZSBsb29rdXAgdGFibGVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgIEFMUEhBQkVUX01BUFtBTFBIQUJFVC5jaGFyQXQoaSldID0gaVxuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlIChzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG5cbiAgICB2YXIgZGlnaXRzID0gWzBdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgIGZvciAodmFyIGogPSAwLCBjYXJyeSA9IHNvdXJjZVtpXTsgaiA8IGRpZ2l0cy5sZW5ndGg7ICsraikge1xuICAgICAgICBjYXJyeSArPSBkaWdpdHNbal0gPDwgOFxuICAgICAgICBkaWdpdHNbal0gPSBjYXJyeSAlIEJBU0VcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSB8IDBcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xuICAgICAgICBkaWdpdHMucHVzaChjYXJyeSAlIEJBU0UpXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgfCAwXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICBmb3IgKHZhciBrID0gMDsgc291cmNlW2tdID09PSAwICYmIGsgPCBzb3VyY2UubGVuZ3RoIC0gMTsgKytrKSB7XG4gICAgICBkaWdpdHMucHVzaCgwKVxuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgZGlnaXRzIHRvIGEgc3RyaW5nXG4gICAgZm9yICh2YXIgaWkgPSAwLCBqaiA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpaSA8PSBqajsgKytpaSwgLS1qaikge1xuICAgICAgdmFyIHRtcCA9IEFMUEhBQkVUW2RpZ2l0c1tpaV1dXG4gICAgICBkaWdpdHNbaWldID0gQUxQSEFCRVRbZGlnaXRzW2pqXV1cbiAgICAgIGRpZ2l0c1tqal0gPSB0bXBcbiAgICB9XG5cbiAgICByZXR1cm4gZGlnaXRzLmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUgKHN0cmluZykge1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID09PSAwKSByZXR1cm4gW11cblxuICAgIHZhciBieXRlcyA9IFswXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBBTFBIQUJFVF9NQVBbc3RyaW5nW2ldXVxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignTm9uLWJhc2UnICsgQkFTRSArICcgY2hhcmFjdGVyJylcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGNhcnJ5ID0gdmFsdWU7IGogPCBieXRlcy5sZW5ndGg7ICsraikge1xuICAgICAgICBjYXJyeSArPSBieXRlc1tqXSAqIEJBU0VcbiAgICAgICAgYnl0ZXNbal0gPSBjYXJyeSAmIDB4ZmZcbiAgICAgICAgY2FycnkgPj49IDhcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xuICAgICAgICBieXRlcy5wdXNoKGNhcnJ5ICYgMHhmZilcbiAgICAgICAgY2FycnkgPj49IDhcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICAgIGZvciAodmFyIGsgPSAwOyBzdHJpbmdba10gPT09IExFQURFUiAmJiBrIDwgc3RyaW5nLmxlbmd0aCAtIDE7ICsraykge1xuICAgICAgYnl0ZXMucHVzaCgwKVxuICAgIH1cblxuICAgIHJldHVybiBieXRlcy5yZXZlcnNlKClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9iYXNlLXgvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYmFzZS14XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyAocHVibGljKSBDb25zdHJ1Y3RvclxuZnVuY3Rpb24gQmlnSW50ZWdlcihhLCBiLCBjKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCaWdJbnRlZ2VyKSlcbiAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYSwgYiwgYylcblxuICBpZiAoYSAhPSBudWxsKSB7XG4gICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGEpIHRoaXMuZnJvbU51bWJlcihhLCBiLCBjKVxuICAgIGVsc2UgaWYgKGIgPT0gbnVsbCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBhKSB0aGlzLmZyb21TdHJpbmcoYSwgMjU2KVxuICAgIGVsc2UgdGhpcy5mcm9tU3RyaW5nKGEsIGIpXG4gIH1cbn1cblxudmFyIHByb3RvID0gQmlnSW50ZWdlci5wcm90b3R5cGVcblxuLy8gZHVjay10eXBlZCBpc0JpZ0ludGVnZXJcbnByb3RvLl9fYmlnaSA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cbkJpZ0ludGVnZXIuaXNCaWdJbnRlZ2VyID0gZnVuY3Rpb24gKG9iaiwgY2hlY2tfdmVyKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fYmlnaSAmJiAoIWNoZWNrX3ZlciB8fCBvYmouX19iaWdpID09PSBwcm90by5fX2JpZ2kpXG59XG5cbi8vIEJpdHMgcGVyIGRpZ2l0XG52YXIgZGJpdHNcblxuLy8gYW06IENvbXB1dGUgd19qICs9ICh4KnRoaXNfaSksIHByb3BhZ2F0ZSBjYXJyaWVzLFxuLy8gYyBpcyBpbml0aWFsIGNhcnJ5LCByZXR1cm5zIGZpbmFsIGNhcnJ5LlxuLy8gYyA8IDMqZHZhbHVlLCB4IDwgMipkdmFsdWUsIHRoaXNfaSA8IGR2YWx1ZVxuLy8gV2UgbmVlZCB0byBzZWxlY3QgdGhlIGZhc3Rlc3Qgb25lIHRoYXQgd29ya3MgaW4gdGhpcyBlbnZpcm9ubWVudC5cblxuLy8gYW0xOiB1c2UgYSBzaW5nbGUgbXVsdCBhbmQgZGl2aWRlIHRvIGdldCB0aGUgaGlnaCBiaXRzLFxuLy8gbWF4IGRpZ2l0IGJpdHMgc2hvdWxkIGJlIDI2IGJlY2F1c2Vcbi8vIG1heCBpbnRlcm5hbCB2YWx1ZSA9IDIqZHZhbHVlXjItMipkdmFsdWUgKDwgMl41MylcbmZ1bmN0aW9uIGFtMShpLCB4LCB3LCBqLCBjLCBuKSB7XG4gIHdoaWxlICgtLW4gPj0gMCkge1xuICAgIHZhciB2ID0geCAqIHRoaXNbaSsrXSArIHdbal0gKyBjXG4gICAgYyA9IE1hdGguZmxvb3IodiAvIDB4NDAwMDAwMClcbiAgICB3W2orK10gPSB2ICYgMHgzZmZmZmZmXG4gIH1cbiAgcmV0dXJuIGNcbn1cbi8vIGFtMiBhdm9pZHMgYSBiaWcgbXVsdC1hbmQtZXh0cmFjdCBjb21wbGV0ZWx5LlxuLy8gTWF4IGRpZ2l0IGJpdHMgc2hvdWxkIGJlIDw9IDMwIGJlY2F1c2Ugd2UgZG8gYml0d2lzZSBvcHNcbi8vIG9uIHZhbHVlcyB1cCB0byAyKmhkdmFsdWVeMi1oZHZhbHVlLTEgKDwgMl4zMSlcbmZ1bmN0aW9uIGFtMihpLCB4LCB3LCBqLCBjLCBuKSB7XG4gIHZhciB4bCA9IHggJiAweDdmZmYsXG4gICAgeGggPSB4ID4+IDE1XG4gIHdoaWxlICgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpc1tpXSAmIDB4N2ZmZlxuICAgIHZhciBoID0gdGhpc1tpKytdID4+IDE1XG4gICAgdmFyIG0gPSB4aCAqIGwgKyBoICogeGxcbiAgICBsID0geGwgKiBsICsgKChtICYgMHg3ZmZmKSA8PCAxNSkgKyB3W2pdICsgKGMgJiAweDNmZmZmZmZmKVxuICAgIGMgPSAobCA+Pj4gMzApICsgKG0gPj4+IDE1KSArIHhoICogaCArIChjID4+PiAzMClcbiAgICB3W2orK10gPSBsICYgMHgzZmZmZmZmZlxuICB9XG4gIHJldHVybiBjXG59XG4vLyBBbHRlcm5hdGVseSwgc2V0IG1heCBkaWdpdCBiaXRzIHRvIDI4IHNpbmNlIHNvbWVcbi8vIGJyb3dzZXJzIHNsb3cgZG93biB3aGVuIGRlYWxpbmcgd2l0aCAzMi1iaXQgbnVtYmVycy5cbmZ1bmN0aW9uIGFtMyhpLCB4LCB3LCBqLCBjLCBuKSB7XG4gIHZhciB4bCA9IHggJiAweDNmZmYsXG4gICAgeGggPSB4ID4+IDE0XG4gIHdoaWxlICgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpc1tpXSAmIDB4M2ZmZlxuICAgIHZhciBoID0gdGhpc1tpKytdID4+IDE0XG4gICAgdmFyIG0gPSB4aCAqIGwgKyBoICogeGxcbiAgICBsID0geGwgKiBsICsgKChtICYgMHgzZmZmKSA8PCAxNCkgKyB3W2pdICsgY1xuICAgIGMgPSAobCA+PiAyOCkgKyAobSA+PiAxNCkgKyB4aCAqIGhcbiAgICB3W2orK10gPSBsICYgMHhmZmZmZmZmXG4gIH1cbiAgcmV0dXJuIGNcbn1cblxuLy8gd3RmP1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTFcbmRiaXRzID0gMjZcblxuQmlnSW50ZWdlci5wcm90b3R5cGUuREIgPSBkYml0c1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRE0gPSAoKDEgPDwgZGJpdHMpIC0gMSlcbnZhciBEViA9IEJpZ0ludGVnZXIucHJvdG90eXBlLkRWID0gKDEgPDwgZGJpdHMpXG5cbnZhciBCSV9GUCA9IDUyXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GViA9IE1hdGgucG93KDIsIEJJX0ZQKVxuQmlnSW50ZWdlci5wcm90b3R5cGUuRjEgPSBCSV9GUCAtIGRiaXRzXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GMiA9IDIgKiBkYml0cyAtIEJJX0ZQXG5cbi8vIERpZ2l0IGNvbnZlcnNpb25zXG52YXIgQklfUk0gPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiXG52YXIgQklfUkMgPSBuZXcgQXJyYXkoKVxudmFyIHJyLCB2dlxucnIgPSBcIjBcIi5jaGFyQ29kZUF0KDApXG5mb3IgKHZ2ID0gMDsgdnYgPD0gOTsgKyt2dikgQklfUkNbcnIrK10gPSB2dlxucnIgPSBcImFcIi5jaGFyQ29kZUF0KDApXG5mb3IgKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIEJJX1JDW3JyKytdID0gdnZcbnJyID0gXCJBXCIuY2hhckNvZGVBdCgwKVxuZm9yICh2diA9IDEwOyB2diA8IDM2OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2XG5cbmZ1bmN0aW9uIGludDJjaGFyKG4pIHtcbiAgcmV0dXJuIEJJX1JNLmNoYXJBdChuKVxufVxuXG5mdW5jdGlvbiBpbnRBdChzLCBpKSB7XG4gIHZhciBjID0gQklfUkNbcy5jaGFyQ29kZUF0KGkpXVxuICByZXR1cm4gKGMgPT0gbnVsbCkgPyAtMSA6IGNcbn1cblxuLy8gKHByb3RlY3RlZCkgY29weSB0aGlzIHRvIHJcbmZ1bmN0aW9uIGJucENvcHlUbyhyKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSkgcltpXSA9IHRoaXNbaV1cbiAgci50ID0gdGhpcy50XG4gIHIucyA9IHRoaXMuc1xufVxuXG4vLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBpbnRlZ2VyIHZhbHVlIHgsIC1EViA8PSB4IDwgRFZcbmZ1bmN0aW9uIGJucEZyb21JbnQoeCkge1xuICB0aGlzLnQgPSAxXG4gIHRoaXMucyA9ICh4IDwgMCkgPyAtMSA6IDBcbiAgaWYgKHggPiAwKSB0aGlzWzBdID0geFxuICBlbHNlIGlmICh4IDwgLTEpIHRoaXNbMF0gPSB4ICsgRFZcbiAgZWxzZSB0aGlzLnQgPSAwXG59XG5cbi8vIHJldHVybiBiaWdpbnQgaW5pdGlhbGl6ZWQgdG8gdmFsdWVcbmZ1bmN0aW9uIG5idihpKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICByLmZyb21JbnQoaSlcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHByb3RlY3RlZCkgc2V0IGZyb20gc3RyaW5nIGFuZCByYWRpeFxuZnVuY3Rpb24gYm5wRnJvbVN0cmluZyhzLCBiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBrXG4gIGlmIChiID09IDE2KSBrID0gNFxuICBlbHNlIGlmIChiID09IDgpIGsgPSAzXG4gIGVsc2UgaWYgKGIgPT0gMjU2KSBrID0gODsgLy8gYnl0ZSBhcnJheVxuICBlbHNlIGlmIChiID09IDIpIGsgPSAxXG4gIGVsc2UgaWYgKGIgPT0gMzIpIGsgPSA1XG4gIGVsc2UgaWYgKGIgPT0gNCkgayA9IDJcbiAgZWxzZSB7XG4gICAgc2VsZi5mcm9tUmFkaXgocywgYilcbiAgICByZXR1cm5cbiAgfVxuICBzZWxmLnQgPSAwXG4gIHNlbGYucyA9IDBcbiAgdmFyIGkgPSBzLmxlbmd0aCxcbiAgICBtaSA9IGZhbHNlLFxuICAgIHNoID0gMFxuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICB2YXIgeCA9IChrID09IDgpID8gc1tpXSAmIDB4ZmYgOiBpbnRBdChzLCBpKVxuICAgIGlmICh4IDwgMCkge1xuICAgICAgaWYgKHMuY2hhckF0KGkpID09IFwiLVwiKSBtaSA9IHRydWVcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIG1pID0gZmFsc2VcbiAgICBpZiAoc2ggPT0gMClcbiAgICAgIHNlbGZbc2VsZi50KytdID0geFxuICAgIGVsc2UgaWYgKHNoICsgayA+IHNlbGYuREIpIHtcbiAgICAgIHNlbGZbc2VsZi50IC0gMV0gfD0gKHggJiAoKDEgPDwgKHNlbGYuREIgLSBzaCkpIC0gMSkpIDw8IHNoXG4gICAgICBzZWxmW3NlbGYudCsrXSA9ICh4ID4+IChzZWxmLkRCIC0gc2gpKVxuICAgIH0gZWxzZVxuICAgICAgc2VsZltzZWxmLnQgLSAxXSB8PSB4IDw8IHNoXG4gICAgc2ggKz0ga1xuICAgIGlmIChzaCA+PSBzZWxmLkRCKSBzaCAtPSBzZWxmLkRCXG4gIH1cbiAgaWYgKGsgPT0gOCAmJiAoc1swXSAmIDB4ODApICE9IDApIHtcbiAgICBzZWxmLnMgPSAtMVxuICAgIGlmIChzaCA+IDApIHNlbGZbc2VsZi50IC0gMV0gfD0gKCgxIDw8IChzZWxmLkRCIC0gc2gpKSAtIDEpIDw8IHNoXG4gIH1cbiAgc2VsZi5jbGFtcCgpXG4gIGlmIChtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHNlbGYsIHNlbGYpXG59XG5cbi8vIChwcm90ZWN0ZWQpIGNsYW1wIG9mZiBleGNlc3MgaGlnaCB3b3Jkc1xuZnVuY3Rpb24gYm5wQ2xhbXAoKSB7XG4gIHZhciBjID0gdGhpcy5zICYgdGhpcy5ETVxuICB3aGlsZSAodGhpcy50ID4gMCAmJiB0aGlzW3RoaXMudCAtIDFdID09IGMpLS10aGlzLnRcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBnaXZlbiByYWRpeFxuZnVuY3Rpb24gYm5Ub1N0cmluZyhiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5zIDwgMCkgcmV0dXJuIFwiLVwiICsgc2VsZi5uZWdhdGUoKVxuICAgIC50b1N0cmluZyhiKVxuICB2YXIga1xuICBpZiAoYiA9PSAxNikgayA9IDRcbiAgZWxzZSBpZiAoYiA9PSA4KSBrID0gM1xuICBlbHNlIGlmIChiID09IDIpIGsgPSAxXG4gIGVsc2UgaWYgKGIgPT0gMzIpIGsgPSA1XG4gIGVsc2UgaWYgKGIgPT0gNCkgayA9IDJcbiAgZWxzZSByZXR1cm4gc2VsZi50b1JhZGl4KGIpXG4gIHZhciBrbSA9ICgxIDw8IGspIC0gMSxcbiAgICBkLCBtID0gZmFsc2UsXG4gICAgciA9IFwiXCIsXG4gICAgaSA9IHNlbGYudFxuICB2YXIgcCA9IHNlbGYuREIgLSAoaSAqIHNlbGYuREIpICUga1xuICBpZiAoaS0tID4gMCkge1xuICAgIGlmIChwIDwgc2VsZi5EQiAmJiAoZCA9IHNlbGZbaV0gPj4gcCkgPiAwKSB7XG4gICAgICBtID0gdHJ1ZVxuICAgICAgciA9IGludDJjaGFyKGQpXG4gICAgfVxuICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgIGlmIChwIDwgaykge1xuICAgICAgICBkID0gKHNlbGZbaV0gJiAoKDEgPDwgcCkgLSAxKSkgPDwgKGsgLSBwKVxuICAgICAgICBkIHw9IHNlbGZbLS1pXSA+PiAocCArPSBzZWxmLkRCIC0gaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGQgPSAoc2VsZltpXSA+PiAocCAtPSBrKSkgJiBrbVxuICAgICAgICBpZiAocCA8PSAwKSB7XG4gICAgICAgICAgcCArPSBzZWxmLkRCXG4gICAgICAgICAgLS1pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkID4gMCkgbSA9IHRydWVcbiAgICAgIGlmIChtKSByICs9IGludDJjaGFyKGQpXG4gICAgfVxuICB9XG4gIHJldHVybiBtID8gciA6IFwiMFwiXG59XG5cbi8vIChwdWJsaWMpIC10aGlzXG5mdW5jdGlvbiBibk5lZ2F0ZSgpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB8dGhpc3xcbmZ1bmN0aW9uIGJuQWJzKCkge1xuICByZXR1cm4gKHRoaXMucyA8IDApID8gdGhpcy5uZWdhdGUoKSA6IHRoaXNcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuICsgaWYgdGhpcyA+IGEsIC0gaWYgdGhpcyA8IGEsIDAgaWYgZXF1YWxcbmZ1bmN0aW9uIGJuQ29tcGFyZVRvKGEpIHtcbiAgdmFyIHIgPSB0aGlzLnMgLSBhLnNcbiAgaWYgKHIgIT0gMCkgcmV0dXJuIHJcbiAgdmFyIGkgPSB0aGlzLnRcbiAgciA9IGkgLSBhLnRcbiAgaWYgKHIgIT0gMCkgcmV0dXJuICh0aGlzLnMgPCAwKSA/IC1yIDogclxuICB3aGlsZSAoLS1pID49IDApXG4gICAgaWYgKChyID0gdGhpc1tpXSAtIGFbaV0pICE9IDApIHJldHVybiByXG4gIHJldHVybiAwXG59XG5cbi8vIHJldHVybnMgYml0IGxlbmd0aCBvZiB0aGUgaW50ZWdlciB4XG5mdW5jdGlvbiBuYml0cyh4KSB7XG4gIHZhciByID0gMSxcbiAgICB0XG4gIGlmICgodCA9IHggPj4+IDE2KSAhPSAwKSB7XG4gICAgeCA9IHRcbiAgICByICs9IDE2XG4gIH1cbiAgaWYgKCh0ID0geCA+PiA4KSAhPSAwKSB7XG4gICAgeCA9IHRcbiAgICByICs9IDhcbiAgfVxuICBpZiAoKHQgPSB4ID4+IDQpICE9IDApIHtcbiAgICB4ID0gdFxuICAgIHIgKz0gNFxuICB9XG4gIGlmICgodCA9IHggPj4gMikgIT0gMCkge1xuICAgIHggPSB0XG4gICAgciArPSAyXG4gIH1cbiAgaWYgKCh0ID0geCA+PiAxKSAhPSAwKSB7XG4gICAgeCA9IHRcbiAgICByICs9IDFcbiAgfVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSByZXR1cm4gdGhlIG51bWJlciBvZiBiaXRzIGluIFwidGhpc1wiXG5mdW5jdGlvbiBibkJpdExlbmd0aCgpIHtcbiAgaWYgKHRoaXMudCA8PSAwKSByZXR1cm4gMFxuICByZXR1cm4gdGhpcy5EQiAqICh0aGlzLnQgLSAxKSArIG5iaXRzKHRoaXNbdGhpcy50IC0gMV0gXiAodGhpcy5zICYgdGhpcy5ETSkpXG59XG5cbi8vIChwdWJsaWMpIHJldHVybiB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIFwidGhpc1wiXG5mdW5jdGlvbiBibkJ5dGVMZW5ndGgoKSB7XG4gIHJldHVybiB0aGlzLmJpdExlbmd0aCgpID4+IDNcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgbipEQlxuZnVuY3Rpb24gYm5wRExTaGlmdFRvKG4sIHIpIHtcbiAgdmFyIGlcbiAgZm9yIChpID0gdGhpcy50IC0gMTsgaSA+PSAwOyAtLWkpIHJbaSArIG5dID0gdGhpc1tpXVxuICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyAtLWkpIHJbaV0gPSAwXG4gIHIudCA9IHRoaXMudCArIG5cbiAgci5zID0gdGhpcy5zXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG4qREJcbmZ1bmN0aW9uIGJucERSU2hpZnRUbyhuLCByKSB7XG4gIGZvciAodmFyIGkgPSBuOyBpIDwgdGhpcy50OyArK2kpIHJbaSAtIG5dID0gdGhpc1tpXVxuICByLnQgPSBNYXRoLm1heCh0aGlzLnQgLSBuLCAwKVxuICByLnMgPSB0aGlzLnNcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgblxuZnVuY3Rpb24gYm5wTFNoaWZ0VG8obiwgcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGJzID0gbiAlIHNlbGYuREJcbiAgdmFyIGNicyA9IHNlbGYuREIgLSBic1xuICB2YXIgYm0gPSAoMSA8PCBjYnMpIC0gMVxuICB2YXIgZHMgPSBNYXRoLmZsb29yKG4gLyBzZWxmLkRCKSxcbiAgICBjID0gKHNlbGYucyA8PCBicykgJiBzZWxmLkRNLFxuICAgIGlcbiAgZm9yIChpID0gc2VsZi50IC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICByW2kgKyBkcyArIDFdID0gKHNlbGZbaV0gPj4gY2JzKSB8IGNcbiAgICBjID0gKHNlbGZbaV0gJiBibSkgPDwgYnNcbiAgfVxuICBmb3IgKGkgPSBkcyAtIDE7IGkgPj0gMDsgLS1pKSByW2ldID0gMFxuICByW2RzXSA9IGNcbiAgci50ID0gc2VsZi50ICsgZHMgKyAxXG4gIHIucyA9IHNlbGYuc1xuICByLmNsYW1wKClcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gblxuZnVuY3Rpb24gYm5wUlNoaWZ0VG8obiwgcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgci5zID0gc2VsZi5zXG4gIHZhciBkcyA9IE1hdGguZmxvb3IobiAvIHNlbGYuREIpXG4gIGlmIChkcyA+PSBzZWxmLnQpIHtcbiAgICByLnQgPSAwXG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGJzID0gbiAlIHNlbGYuREJcbiAgdmFyIGNicyA9IHNlbGYuREIgLSBic1xuICB2YXIgYm0gPSAoMSA8PCBicykgLSAxXG4gIHJbMF0gPSBzZWxmW2RzXSA+PiBic1xuICBmb3IgKHZhciBpID0gZHMgKyAxOyBpIDwgc2VsZi50OyArK2kpIHtcbiAgICByW2kgLSBkcyAtIDFdIHw9IChzZWxmW2ldICYgYm0pIDw8IGNic1xuICAgIHJbaSAtIGRzXSA9IHNlbGZbaV0gPj4gYnNcbiAgfVxuICBpZiAoYnMgPiAwKSByW3NlbGYudCAtIGRzIC0gMV0gfD0gKHNlbGYucyAmIGJtKSA8PCBjYnNcbiAgci50ID0gc2VsZi50IC0gZHNcbiAgci5jbGFtcCgpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIC0gYVxuZnVuY3Rpb24gYm5wU3ViVG8oYSwgcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGkgPSAwLFxuICAgIGMgPSAwLFxuICAgIG0gPSBNYXRoLm1pbihhLnQsIHNlbGYudClcbiAgd2hpbGUgKGkgPCBtKSB7XG4gICAgYyArPSBzZWxmW2ldIC0gYVtpXVxuICAgIHJbaSsrXSA9IGMgJiBzZWxmLkRNXG4gICAgYyA+Pj0gc2VsZi5EQlxuICB9XG4gIGlmIChhLnQgPCBzZWxmLnQpIHtcbiAgICBjIC09IGEuc1xuICAgIHdoaWxlIChpIDwgc2VsZi50KSB7XG4gICAgICBjICs9IHNlbGZbaV1cbiAgICAgIHJbaSsrXSA9IGMgJiBzZWxmLkRNXG4gICAgICBjID4+PSBzZWxmLkRCXG4gICAgfVxuICAgIGMgKz0gc2VsZi5zXG4gIH0gZWxzZSB7XG4gICAgYyArPSBzZWxmLnNcbiAgICB3aGlsZSAoaSA8IGEudCkge1xuICAgICAgYyAtPSBhW2ldXG4gICAgICByW2krK10gPSBjICYgc2VsZi5ETVxuICAgICAgYyA+Pj0gc2VsZi5EQlxuICAgIH1cbiAgICBjIC09IGEuc1xuICB9XG4gIHIucyA9IChjIDwgMCkgPyAtMSA6IDBcbiAgaWYgKGMgPCAtMSkgcltpKytdID0gc2VsZi5EViArIGNcbiAgZWxzZSBpZiAoYyA+IDApIHJbaSsrXSA9IGNcbiAgci50ID0gaVxuICByLmNsYW1wKClcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgKiBhLCByICE9IHRoaXMsYSAoSEFDIDE0LjEyKVxuLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuZnVuY3Rpb24gYm5wTXVsdGlwbHlUbyhhLCByKSB7XG4gIHZhciB4ID0gdGhpcy5hYnMoKSxcbiAgICB5ID0gYS5hYnMoKVxuICB2YXIgaSA9IHgudFxuICByLnQgPSBpICsgeS50XG4gIHdoaWxlICgtLWkgPj0gMCkgcltpXSA9IDBcbiAgZm9yIChpID0gMDsgaSA8IHkudDsgKytpKSByW2kgKyB4LnRdID0geC5hbSgwLCB5W2ldLCByLCBpLCAwLCB4LnQpXG4gIHIucyA9IDBcbiAgci5jbGFtcCgpXG4gIGlmICh0aGlzLnMgIT0gYS5zKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ociwgcilcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXNeMiwgciAhPSB0aGlzIChIQUMgMTQuMTYpXG5mdW5jdGlvbiBibnBTcXVhcmVUbyhyKSB7XG4gIHZhciB4ID0gdGhpcy5hYnMoKVxuICB2YXIgaSA9IHIudCA9IDIgKiB4LnRcbiAgd2hpbGUgKC0taSA+PSAwKSByW2ldID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgeC50IC0gMTsgKytpKSB7XG4gICAgdmFyIGMgPSB4LmFtKGksIHhbaV0sIHIsIDIgKiBpLCAwLCAxKVxuICAgIGlmICgocltpICsgeC50XSArPSB4LmFtKGkgKyAxLCAyICogeFtpXSwgciwgMiAqIGkgKyAxLCBjLCB4LnQgLSBpIC0gMSkpID49IHguRFYpIHtcbiAgICAgIHJbaSArIHgudF0gLT0geC5EVlxuICAgICAgcltpICsgeC50ICsgMV0gPSAxXG4gICAgfVxuICB9XG4gIGlmIChyLnQgPiAwKSByW3IudCAtIDFdICs9IHguYW0oaSwgeFtpXSwgciwgMiAqIGksIDAsIDEpXG4gIHIucyA9IDBcbiAgci5jbGFtcCgpXG59XG5cbi8vIChwcm90ZWN0ZWQpIGRpdmlkZSB0aGlzIGJ5IG0sIHF1b3RpZW50IGFuZCByZW1haW5kZXIgdG8gcSwgciAoSEFDIDE0LjIwKVxuLy8gciAhPSBxLCB0aGlzICE9IG0uICBxIG9yIHIgbWF5IGJlIG51bGwuXG5mdW5jdGlvbiBibnBEaXZSZW1UbyhtLCBxLCByKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcG0gPSBtLmFicygpXG4gIGlmIChwbS50IDw9IDApIHJldHVyblxuICB2YXIgcHQgPSBzZWxmLmFicygpXG4gIGlmIChwdC50IDwgcG0udCkge1xuICAgIGlmIChxICE9IG51bGwpIHEuZnJvbUludCgwKVxuICAgIGlmIChyICE9IG51bGwpIHNlbGYuY29weVRvKHIpXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHIgPT0gbnVsbCkgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdmFyIHkgPSBuZXcgQmlnSW50ZWdlcigpLFxuICAgIHRzID0gc2VsZi5zLFxuICAgIG1zID0gbS5zXG4gIHZhciBuc2ggPSBzZWxmLkRCIC0gbmJpdHMocG1bcG0udCAtIDFdKTsgLy8gbm9ybWFsaXplIG1vZHVsdXNcbiAgaWYgKG5zaCA+IDApIHtcbiAgICBwbS5sU2hpZnRUbyhuc2gsIHkpXG4gICAgcHQubFNoaWZ0VG8obnNoLCByKVxuICB9IGVsc2Uge1xuICAgIHBtLmNvcHlUbyh5KVxuICAgIHB0LmNvcHlUbyhyKVxuICB9XG4gIHZhciB5cyA9IHkudFxuICB2YXIgeTAgPSB5W3lzIC0gMV1cbiAgaWYgKHkwID09IDApIHJldHVyblxuICB2YXIgeXQgPSB5MCAqICgxIDw8IHNlbGYuRjEpICsgKCh5cyA+IDEpID8geVt5cyAtIDJdID4+IHNlbGYuRjIgOiAwKVxuICB2YXIgZDEgPSBzZWxmLkZWIC8geXQsXG4gICAgZDIgPSAoMSA8PCBzZWxmLkYxKSAvIHl0LFxuICAgIGUgPSAxIDw8IHNlbGYuRjJcbiAgdmFyIGkgPSByLnQsXG4gICAgaiA9IGkgLSB5cyxcbiAgICB0ID0gKHEgPT0gbnVsbCkgPyBuZXcgQmlnSW50ZWdlcigpIDogcVxuICB5LmRsU2hpZnRUbyhqLCB0KVxuICBpZiAoci5jb21wYXJlVG8odCkgPj0gMCkge1xuICAgIHJbci50KytdID0gMVxuICAgIHIuc3ViVG8odCwgcilcbiAgfVxuICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oeXMsIHQpXG4gIHQuc3ViVG8oeSwgeSk7IC8vIFwibmVnYXRpdmVcIiB5IHNvIHdlIGNhbiByZXBsYWNlIHN1YiB3aXRoIGFtIGxhdGVyXG4gIHdoaWxlICh5LnQgPCB5cykgeVt5LnQrK10gPSAwXG4gIHdoaWxlICgtLWogPj0gMCkge1xuICAgIC8vIEVzdGltYXRlIHF1b3RpZW50IGRpZ2l0XG4gICAgdmFyIHFkID0gKHJbLS1pXSA9PSB5MCkgPyBzZWxmLkRNIDogTWF0aC5mbG9vcihyW2ldICogZDEgKyAocltpIC0gMV0gKyBlKSAqIGQyKVxuICAgIGlmICgocltpXSArPSB5LmFtKDAsIHFkLCByLCBqLCAwLCB5cykpIDwgcWQpIHsgLy8gVHJ5IGl0IG91dFxuICAgICAgeS5kbFNoaWZ0VG8oaiwgdClcbiAgICAgIHIuc3ViVG8odCwgcilcbiAgICAgIHdoaWxlIChyW2ldIDwgLS1xZCkgci5zdWJUbyh0LCByKVxuICAgIH1cbiAgfVxuICBpZiAocSAhPSBudWxsKSB7XG4gICAgci5kclNoaWZ0VG8oeXMsIHEpXG4gICAgaWYgKHRzICE9IG1zKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocSwgcSlcbiAgfVxuICByLnQgPSB5c1xuICByLmNsYW1wKClcbiAgaWYgKG5zaCA+IDApIHIuclNoaWZ0VG8obnNoLCByKTsgLy8gRGVub3JtYWxpemUgcmVtYWluZGVyXG4gIGlmICh0cyA8IDApIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhyLCByKVxufVxuXG4vLyAocHVibGljKSB0aGlzIG1vZCBhXG5mdW5jdGlvbiBibk1vZChhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmFicygpXG4gICAgLmRpdlJlbVRvKGEsIG51bGwsIHIpXG4gIGlmICh0aGlzLnMgPCAwICYmIHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuWkVSTykgPiAwKSBhLnN1YlRvKHIsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIE1vZHVsYXIgcmVkdWN0aW9uIHVzaW5nIFwiY2xhc3NpY1wiIGFsZ29yaXRobVxuZnVuY3Rpb24gQ2xhc3NpYyhtKSB7XG4gIHRoaXMubSA9IG1cbn1cblxuZnVuY3Rpb24gY0NvbnZlcnQoeCkge1xuICBpZiAoeC5zIDwgMCB8fCB4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHJldHVybiB4Lm1vZCh0aGlzLm0pXG4gIGVsc2UgcmV0dXJuIHhcbn1cblxuZnVuY3Rpb24gY1JldmVydCh4KSB7XG4gIHJldHVybiB4XG59XG5cbmZ1bmN0aW9uIGNSZWR1Y2UoeCkge1xuICB4LmRpdlJlbVRvKHRoaXMubSwgbnVsbCwgeClcbn1cblxuZnVuY3Rpb24gY011bFRvKHgsIHksIHIpIHtcbiAgeC5tdWx0aXBseVRvKHksIHIpXG4gIHRoaXMucmVkdWNlKHIpXG59XG5cbmZ1bmN0aW9uIGNTcXJUbyh4LCByKSB7XG4gIHguc3F1YXJlVG8ocilcbiAgdGhpcy5yZWR1Y2Uocilcbn1cblxuQ2xhc3NpYy5wcm90b3R5cGUuY29udmVydCA9IGNDb252ZXJ0XG5DbGFzc2ljLnByb3RvdHlwZS5yZXZlcnQgPSBjUmV2ZXJ0XG5DbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2UgPSBjUmVkdWNlXG5DbGFzc2ljLnByb3RvdHlwZS5tdWxUbyA9IGNNdWxUb1xuQ2xhc3NpYy5wcm90b3R5cGUuc3FyVG8gPSBjU3FyVG9cblxuLy8gKHByb3RlY3RlZCkgcmV0dXJuIFwiLTEvdGhpcyAlIDJeREJcIjsgdXNlZnVsIGZvciBNb250LiByZWR1Y3Rpb25cbi8vIGp1c3RpZmljYXRpb246XG4vLyAgICAgICAgIHh5ID09IDEgKG1vZCBtKVxuLy8gICAgICAgICB4eSA9ICAxK2ttXG4vLyAgIHh5KDIteHkpID0gKDEra20pKDEta20pXG4vLyB4W3koMi14eSldID0gMS1rXjJtXjJcbi8vIHhbeSgyLXh5KV0gPT0gMSAobW9kIG1eMilcbi8vIGlmIHkgaXMgMS94IG1vZCBtLCB0aGVuIHkoMi14eSkgaXMgMS94IG1vZCBtXjJcbi8vIHNob3VsZCByZWR1Y2UgeCBhbmQgeSgyLXh5KSBieSBtXjIgYXQgZWFjaCBzdGVwIHRvIGtlZXAgc2l6ZSBib3VuZGVkLlxuLy8gSlMgbXVsdGlwbHkgXCJvdmVyZmxvd3NcIiBkaWZmZXJlbnRseSBmcm9tIEMvQysrLCBzbyBjYXJlIGlzIG5lZWRlZCBoZXJlLlxuZnVuY3Rpb24gYm5wSW52RGlnaXQoKSB7XG4gIGlmICh0aGlzLnQgPCAxKSByZXR1cm4gMFxuICB2YXIgeCA9IHRoaXNbMF1cbiAgaWYgKCh4ICYgMSkgPT0gMCkgcmV0dXJuIDBcbiAgdmFyIHkgPSB4ICYgMzsgLy8geSA9PSAxL3ggbW9kIDJeMlxuICB5ID0gKHkgKiAoMiAtICh4ICYgMHhmKSAqIHkpKSAmIDB4ZjsgLy8geSA9PSAxL3ggbW9kIDJeNFxuICB5ID0gKHkgKiAoMiAtICh4ICYgMHhmZikgKiB5KSkgJiAweGZmOyAvLyB5ID09IDEveCBtb2QgMl44XG4gIHkgPSAoeSAqICgyIC0gKCgoeCAmIDB4ZmZmZikgKiB5KSAmIDB4ZmZmZikpKSAmIDB4ZmZmZjsgLy8geSA9PSAxL3ggbW9kIDJeMTZcbiAgLy8gbGFzdCBzdGVwIC0gY2FsY3VsYXRlIGludmVyc2UgbW9kIERWIGRpcmVjdGx5XG4gIC8vIGFzc3VtZXMgMTYgPCBEQiA8PSAzMiBhbmQgYXNzdW1lcyBhYmlsaXR5IHRvIGhhbmRsZSA0OC1iaXQgaW50c1xuICB5ID0gKHkgKiAoMiAtIHggKiB5ICUgdGhpcy5EVikpICUgdGhpcy5EVjsgLy8geSA9PSAxL3ggbW9kIDJeZGJpdHNcbiAgLy8gd2UgcmVhbGx5IHdhbnQgdGhlIG5lZ2F0aXZlIGludmVyc2UsIGFuZCAtRFYgPCB5IDwgRFZcbiAgcmV0dXJuICh5ID4gMCkgPyB0aGlzLkRWIC0geSA6IC15XG59XG5cbi8vIE1vbnRnb21lcnkgcmVkdWN0aW9uXG5mdW5jdGlvbiBNb250Z29tZXJ5KG0pIHtcbiAgdGhpcy5tID0gbVxuICB0aGlzLm1wID0gbS5pbnZEaWdpdCgpXG4gIHRoaXMubXBsID0gdGhpcy5tcCAmIDB4N2ZmZlxuICB0aGlzLm1waCA9IHRoaXMubXAgPj4gMTVcbiAgdGhpcy51bSA9ICgxIDw8IChtLkRCIC0gMTUpKSAtIDFcbiAgdGhpcy5tdDIgPSAyICogbS50XG59XG5cbi8vIHhSIG1vZCBtXG5mdW5jdGlvbiBtb250Q29udmVydCh4KSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB4LmFicygpXG4gICAgLmRsU2hpZnRUbyh0aGlzLm0udCwgcilcbiAgci5kaXZSZW1Ubyh0aGlzLm0sIG51bGwsIHIpXG4gIGlmICh4LnMgPCAwICYmIHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuWkVSTykgPiAwKSB0aGlzLm0uc3ViVG8ociwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8geC9SIG1vZCBtXG5mdW5jdGlvbiBtb250UmV2ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHguY29weVRvKHIpXG4gIHRoaXMucmVkdWNlKHIpXG4gIHJldHVybiByXG59XG5cbi8vIHggPSB4L1IgbW9kIG0gKEhBQyAxNC4zMilcbmZ1bmN0aW9uIG1vbnRSZWR1Y2UoeCkge1xuICB3aGlsZSAoeC50IDw9IHRoaXMubXQyKSAvLyBwYWQgeCBzbyBhbSBoYXMgZW5vdWdoIHJvb20gbGF0ZXJcbiAgICB4W3gudCsrXSA9IDBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm0udDsgKytpKSB7XG4gICAgLy8gZmFzdGVyIHdheSBvZiBjYWxjdWxhdGluZyB1MCA9IHhbaV0qbXAgbW9kIERWXG4gICAgdmFyIGogPSB4W2ldICYgMHg3ZmZmXG4gICAgdmFyIHUwID0gKGogKiB0aGlzLm1wbCArICgoKGogKiB0aGlzLm1waCArICh4W2ldID4+IDE1KSAqIHRoaXMubXBsKSAmIHRoaXMudW0pIDw8IDE1KSkgJiB4LkRNXG4gICAgLy8gdXNlIGFtIHRvIGNvbWJpbmUgdGhlIG11bHRpcGx5LXNoaWZ0LWFkZCBpbnRvIG9uZSBjYWxsXG4gICAgaiA9IGkgKyB0aGlzLm0udFxuICAgIHhbal0gKz0gdGhpcy5tLmFtKDAsIHUwLCB4LCBpLCAwLCB0aGlzLm0udClcbiAgICAvLyBwcm9wYWdhdGUgY2FycnlcbiAgICB3aGlsZSAoeFtqXSA+PSB4LkRWKSB7XG4gICAgICB4W2pdIC09IHguRFZcbiAgICAgIHhbKytqXSsrXG4gICAgfVxuICB9XG4gIHguY2xhbXAoKVxuICB4LmRyU2hpZnRUbyh0aGlzLm0udCwgeClcbiAgaWYgKHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgeC5zdWJUbyh0aGlzLm0sIHgpXG59XG5cbi8vIHIgPSBcInheMi9SIG1vZCBtXCI7IHggIT0gclxuZnVuY3Rpb24gbW9udFNxclRvKHgsIHIpIHtcbiAgeC5zcXVhcmVUbyhyKVxuICB0aGlzLnJlZHVjZShyKVxufVxuXG4vLyByID0gXCJ4eS9SIG1vZCBtXCI7IHgseSAhPSByXG5mdW5jdGlvbiBtb250TXVsVG8oeCwgeSwgcikge1xuICB4Lm11bHRpcGx5VG8oeSwgcilcbiAgdGhpcy5yZWR1Y2Uocilcbn1cblxuTW9udGdvbWVyeS5wcm90b3R5cGUuY29udmVydCA9IG1vbnRDb252ZXJ0XG5Nb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQgPSBtb250UmV2ZXJ0XG5Nb250Z29tZXJ5LnByb3RvdHlwZS5yZWR1Y2UgPSBtb250UmVkdWNlXG5Nb250Z29tZXJ5LnByb3RvdHlwZS5tdWxUbyA9IG1vbnRNdWxUb1xuTW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG8gPSBtb250U3FyVG9cblxuLy8gKHByb3RlY3RlZCkgdHJ1ZSBpZmYgdGhpcyBpcyBldmVuXG5mdW5jdGlvbiBibnBJc0V2ZW4oKSB7XG4gIHJldHVybiAoKHRoaXMudCA+IDApID8gKHRoaXNbMF0gJiAxKSA6IHRoaXMucykgPT0gMFxufVxuXG4vLyAocHJvdGVjdGVkKSB0aGlzXmUsIGUgPCAyXjMyLCBkb2luZyBzcXIgYW5kIG11bCB3aXRoIFwiclwiIChIQUMgMTQuNzkpXG5mdW5jdGlvbiBibnBFeHAoZSwgeikge1xuICBpZiAoZSA+IDB4ZmZmZmZmZmYgfHwgZSA8IDEpIHJldHVybiBCaWdJbnRlZ2VyLk9ORVxuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKCksXG4gICAgcjIgPSBuZXcgQmlnSW50ZWdlcigpLFxuICAgIGcgPSB6LmNvbnZlcnQodGhpcyksXG4gICAgaSA9IG5iaXRzKGUpIC0gMVxuICBnLmNvcHlUbyhyKVxuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICB6LnNxclRvKHIsIHIyKVxuICAgIGlmICgoZSAmICgxIDw8IGkpKSA+IDApIHoubXVsVG8ocjIsIGcsIHIpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgdCA9IHJcbiAgICAgIHIgPSByMlxuICAgICAgcjIgPSB0XG4gICAgfVxuICB9XG4gIHJldHVybiB6LnJldmVydChyKVxufVxuXG4vLyAocHVibGljKSB0aGlzXmUgJSBtLCAwIDw9IGUgPCAyXjMyXG5mdW5jdGlvbiBibk1vZFBvd0ludChlLCBtKSB7XG4gIHZhciB6XG4gIGlmIChlIDwgMjU2IHx8IG0uaXNFdmVuKCkpIHogPSBuZXcgQ2xhc3NpYyhtKVxuICBlbHNlIHogPSBuZXcgTW9udGdvbWVyeShtKVxuICByZXR1cm4gdGhpcy5leHAoZSwgeilcbn1cblxuLy8gcHJvdGVjdGVkXG5wcm90by5jb3B5VG8gPSBibnBDb3B5VG9cbnByb3RvLmZyb21JbnQgPSBibnBGcm9tSW50XG5wcm90by5mcm9tU3RyaW5nID0gYm5wRnJvbVN0cmluZ1xucHJvdG8uY2xhbXAgPSBibnBDbGFtcFxucHJvdG8uZGxTaGlmdFRvID0gYm5wRExTaGlmdFRvXG5wcm90by5kclNoaWZ0VG8gPSBibnBEUlNoaWZ0VG9cbnByb3RvLmxTaGlmdFRvID0gYm5wTFNoaWZ0VG9cbnByb3RvLnJTaGlmdFRvID0gYm5wUlNoaWZ0VG9cbnByb3RvLnN1YlRvID0gYm5wU3ViVG9cbnByb3RvLm11bHRpcGx5VG8gPSBibnBNdWx0aXBseVRvXG5wcm90by5zcXVhcmVUbyA9IGJucFNxdWFyZVRvXG5wcm90by5kaXZSZW1UbyA9IGJucERpdlJlbVRvXG5wcm90by5pbnZEaWdpdCA9IGJucEludkRpZ2l0XG5wcm90by5pc0V2ZW4gPSBibnBJc0V2ZW5cbnByb3RvLmV4cCA9IGJucEV4cFxuXG4vLyBwdWJsaWNcbnByb3RvLnRvU3RyaW5nID0gYm5Ub1N0cmluZ1xucHJvdG8ubmVnYXRlID0gYm5OZWdhdGVcbnByb3RvLmFicyA9IGJuQWJzXG5wcm90by5jb21wYXJlVG8gPSBibkNvbXBhcmVUb1xucHJvdG8uYml0TGVuZ3RoID0gYm5CaXRMZW5ndGhcbnByb3RvLmJ5dGVMZW5ndGggPSBibkJ5dGVMZW5ndGhcbnByb3RvLm1vZCA9IGJuTW9kXG5wcm90by5tb2RQb3dJbnQgPSBibk1vZFBvd0ludFxuXG4vLyAocHVibGljKVxuZnVuY3Rpb24gYm5DbG9uZSgpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuY29weVRvKHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBpbnRlZ2VyXG5mdW5jdGlvbiBibkludFZhbHVlKCkge1xuICBpZiAodGhpcy5zIDwgMCkge1xuICAgIGlmICh0aGlzLnQgPT0gMSkgcmV0dXJuIHRoaXNbMF0gLSB0aGlzLkRWXG4gICAgZWxzZSBpZiAodGhpcy50ID09IDApIHJldHVybiAtMVxuICB9IGVsc2UgaWYgKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpc1swXVxuICBlbHNlIGlmICh0aGlzLnQgPT0gMCkgcmV0dXJuIDBcbiAgLy8gYXNzdW1lcyAxNiA8IERCIDwgMzJcbiAgcmV0dXJuICgodGhpc1sxXSAmICgoMSA8PCAoMzIgLSB0aGlzLkRCKSkgLSAxKSkgPDwgdGhpcy5EQikgfCB0aGlzWzBdXG59XG5cbi8vIChwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBieXRlXG5mdW5jdGlvbiBibkJ5dGVWYWx1ZSgpIHtcbiAgcmV0dXJuICh0aGlzLnQgPT0gMCkgPyB0aGlzLnMgOiAodGhpc1swXSA8PCAyNCkgPj4gMjRcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIHNob3J0IChhc3N1bWVzIERCPj0xNilcbmZ1bmN0aW9uIGJuU2hvcnRWYWx1ZSgpIHtcbiAgcmV0dXJuICh0aGlzLnQgPT0gMCkgPyB0aGlzLnMgOiAodGhpc1swXSA8PCAxNikgPj4gMTZcbn1cblxuLy8gKHByb3RlY3RlZCkgcmV0dXJuIHggcy50LiByXnggPCBEVlxuZnVuY3Rpb24gYm5wQ2h1bmtTaXplKHIpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5MTjIgKiB0aGlzLkRCIC8gTWF0aC5sb2cocikpXG59XG5cbi8vIChwdWJsaWMpIDAgaWYgdGhpcyA9PSAwLCAxIGlmIHRoaXMgPiAwXG5mdW5jdGlvbiBiblNpZ051bSgpIHtcbiAgaWYgKHRoaXMucyA8IDApIHJldHVybiAtMVxuICBlbHNlIGlmICh0aGlzLnQgPD0gMCB8fCAodGhpcy50ID09IDEgJiYgdGhpc1swXSA8PSAwKSkgcmV0dXJuIDBcbiAgZWxzZSByZXR1cm4gMVxufVxuXG4vLyAocHJvdGVjdGVkKSBjb252ZXJ0IHRvIHJhZGl4IHN0cmluZ1xuZnVuY3Rpb24gYm5wVG9SYWRpeChiKSB7XG4gIGlmIChiID09IG51bGwpIGIgPSAxMFxuICBpZiAodGhpcy5zaWdudW0oKSA9PSAwIHx8IGIgPCAyIHx8IGIgPiAzNikgcmV0dXJuIFwiMFwiXG4gIHZhciBjcyA9IHRoaXMuY2h1bmtTaXplKGIpXG4gIHZhciBhID0gTWF0aC5wb3coYiwgY3MpXG4gIHZhciBkID0gbmJ2KGEpLFxuICAgIHkgPSBuZXcgQmlnSW50ZWdlcigpLFxuICAgIHogPSBuZXcgQmlnSW50ZWdlcigpLFxuICAgIHIgPSBcIlwiXG4gIHRoaXMuZGl2UmVtVG8oZCwgeSwgeilcbiAgd2hpbGUgKHkuc2lnbnVtKCkgPiAwKSB7XG4gICAgciA9IChhICsgei5pbnRWYWx1ZSgpKVxuICAgICAgLnRvU3RyaW5nKGIpXG4gICAgICAuc3Vic3RyKDEpICsgclxuICAgIHkuZGl2UmVtVG8oZCwgeSwgeilcbiAgfVxuICByZXR1cm4gei5pbnRWYWx1ZSgpXG4gICAgLnRvU3RyaW5nKGIpICsgclxufVxuXG4vLyAocHJvdGVjdGVkKSBjb252ZXJ0IGZyb20gcmFkaXggc3RyaW5nXG5mdW5jdGlvbiBibnBGcm9tUmFkaXgocywgYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5mcm9tSW50KDApXG4gIGlmIChiID09IG51bGwpIGIgPSAxMFxuICB2YXIgY3MgPSBzZWxmLmNodW5rU2l6ZShiKVxuICB2YXIgZCA9IE1hdGgucG93KGIsIGNzKSxcbiAgICBtaSA9IGZhbHNlLFxuICAgIGogPSAwLFxuICAgIHcgPSAwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciB4ID0gaW50QXQocywgaSlcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIGlmIChzLmNoYXJBdChpKSA9PSBcIi1cIiAmJiBzZWxmLnNpZ251bSgpID09IDApIG1pID0gdHJ1ZVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdyA9IGIgKiB3ICsgeFxuICAgIGlmICgrK2ogPj0gY3MpIHtcbiAgICAgIHNlbGYuZE11bHRpcGx5KGQpXG4gICAgICBzZWxmLmRBZGRPZmZzZXQodywgMClcbiAgICAgIGogPSAwXG4gICAgICB3ID0gMFxuICAgIH1cbiAgfVxuICBpZiAoaiA+IDApIHtcbiAgICBzZWxmLmRNdWx0aXBseShNYXRoLnBvdyhiLCBqKSlcbiAgICBzZWxmLmRBZGRPZmZzZXQodywgMClcbiAgfVxuICBpZiAobWkpIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhzZWxmLCBzZWxmKVxufVxuXG4vLyAocHJvdGVjdGVkKSBhbHRlcm5hdGUgY29uc3RydWN0b3JcbmZ1bmN0aW9uIGJucEZyb21OdW1iZXIoYSwgYiwgYykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGIpIHtcbiAgICAvLyBuZXcgQmlnSW50ZWdlcihpbnQsaW50LFJORylcbiAgICBpZiAoYSA8IDIpIHNlbGYuZnJvbUludCgxKVxuICAgIGVsc2Uge1xuICAgICAgc2VsZi5mcm9tTnVtYmVyKGEsIGMpXG4gICAgICBpZiAoIXNlbGYudGVzdEJpdChhIC0gMSkpIC8vIGZvcmNlIE1TQiBzZXRcbiAgICAgICAgc2VsZi5iaXR3aXNlVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEgLSAxKSwgb3Bfb3IsIHNlbGYpXG4gICAgICBpZiAoc2VsZi5pc0V2ZW4oKSkgc2VsZi5kQWRkT2Zmc2V0KDEsIDApOyAvLyBmb3JjZSBvZGRcbiAgICAgIHdoaWxlICghc2VsZi5pc1Byb2JhYmxlUHJpbWUoYikpIHtcbiAgICAgICAgc2VsZi5kQWRkT2Zmc2V0KDIsIDApXG4gICAgICAgIGlmIChzZWxmLmJpdExlbmd0aCgpID4gYSkgc2VsZi5zdWJUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYSAtIDEpLCBzZWxmKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBuZXcgQmlnSW50ZWdlcihpbnQsUk5HKVxuICAgIHZhciB4ID0gbmV3IEFycmF5KCksXG4gICAgICB0ID0gYSAmIDdcbiAgICB4Lmxlbmd0aCA9IChhID4+IDMpICsgMVxuICAgIGIubmV4dEJ5dGVzKHgpXG4gICAgaWYgKHQgPiAwKSB4WzBdICY9ICgoMSA8PCB0KSAtIDEpXG4gICAgZWxzZSB4WzBdID0gMFxuICAgIHNlbGYuZnJvbVN0cmluZyh4LCAyNTYpXG4gIH1cbn1cblxuLy8gKHB1YmxpYykgY29udmVydCB0byBiaWdlbmRpYW4gYnl0ZSBhcnJheVxuZnVuY3Rpb24gYm5Ub0J5dGVBcnJheSgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBpID0gc2VsZi50LFxuICAgIHIgPSBuZXcgQXJyYXkoKVxuICByWzBdID0gc2VsZi5zXG4gIHZhciBwID0gc2VsZi5EQiAtIChpICogc2VsZi5EQikgJSA4LFxuICAgIGQsIGsgPSAwXG4gIGlmIChpLS0gPiAwKSB7XG4gICAgaWYgKHAgPCBzZWxmLkRCICYmIChkID0gc2VsZltpXSA+PiBwKSAhPSAoc2VsZi5zICYgc2VsZi5ETSkgPj4gcClcbiAgICAgIHJbaysrXSA9IGQgfCAoc2VsZi5zIDw8IChzZWxmLkRCIC0gcCkpXG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgaWYgKHAgPCA4KSB7XG4gICAgICAgIGQgPSAoc2VsZltpXSAmICgoMSA8PCBwKSAtIDEpKSA8PCAoOCAtIHApXG4gICAgICAgIGQgfD0gc2VsZlstLWldID4+IChwICs9IHNlbGYuREIgLSA4KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZCA9IChzZWxmW2ldID4+IChwIC09IDgpKSAmIDB4ZmZcbiAgICAgICAgaWYgKHAgPD0gMCkge1xuICAgICAgICAgIHAgKz0gc2VsZi5EQlxuICAgICAgICAgIC0taVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoKGQgJiAweDgwKSAhPSAwKSBkIHw9IC0yNTZcbiAgICAgIGlmIChrID09PSAwICYmIChzZWxmLnMgJiAweDgwKSAhPSAoZCAmIDB4ODApKSsra1xuICAgICAgaWYgKGsgPiAwIHx8IGQgIT0gc2VsZi5zKSByW2srK10gPSBkXG4gICAgfVxuICB9XG4gIHJldHVybiByXG59XG5cbmZ1bmN0aW9uIGJuRXF1YWxzKGEpIHtcbiAgcmV0dXJuICh0aGlzLmNvbXBhcmVUbyhhKSA9PSAwKVxufVxuXG5mdW5jdGlvbiBibk1pbihhKSB7XG4gIHJldHVybiAodGhpcy5jb21wYXJlVG8oYSkgPCAwKSA/IHRoaXMgOiBhXG59XG5cbmZ1bmN0aW9uIGJuTWF4KGEpIHtcbiAgcmV0dXJuICh0aGlzLmNvbXBhcmVUbyhhKSA+IDApID8gdGhpcyA6IGFcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgb3AgYSAoYml0d2lzZSlcbmZ1bmN0aW9uIGJucEJpdHdpc2VUbyhhLCBvcCwgcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGksIGYsIG0gPSBNYXRoLm1pbihhLnQsIHNlbGYudClcbiAgZm9yIChpID0gMDsgaSA8IG07ICsraSkgcltpXSA9IG9wKHNlbGZbaV0sIGFbaV0pXG4gIGlmIChhLnQgPCBzZWxmLnQpIHtcbiAgICBmID0gYS5zICYgc2VsZi5ETVxuICAgIGZvciAoaSA9IG07IGkgPCBzZWxmLnQ7ICsraSkgcltpXSA9IG9wKHNlbGZbaV0sIGYpXG4gICAgci50ID0gc2VsZi50XG4gIH0gZWxzZSB7XG4gICAgZiA9IHNlbGYucyAmIHNlbGYuRE1cbiAgICBmb3IgKGkgPSBtOyBpIDwgYS50OyArK2kpIHJbaV0gPSBvcChmLCBhW2ldKVxuICAgIHIudCA9IGEudFxuICB9XG4gIHIucyA9IG9wKHNlbGYucywgYS5zKVxuICByLmNsYW1wKClcbn1cblxuLy8gKHB1YmxpYykgdGhpcyAmIGFcbmZ1bmN0aW9uIG9wX2FuZCh4LCB5KSB7XG4gIHJldHVybiB4ICYgeVxufVxuXG5mdW5jdGlvbiBibkFuZChhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmJpdHdpc2VUbyhhLCBvcF9hbmQsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgfCBhXG5mdW5jdGlvbiBvcF9vcih4LCB5KSB7XG4gIHJldHVybiB4IHwgeVxufVxuXG5mdW5jdGlvbiBibk9yKGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuYml0d2lzZVRvKGEsIG9wX29yLCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzIF4gYVxuZnVuY3Rpb24gb3BfeG9yKHgsIHkpIHtcbiAgcmV0dXJuIHggXiB5XG59XG5cbmZ1bmN0aW9uIGJuWG9yKGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuYml0d2lzZVRvKGEsIG9wX3hvciwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyAmIH5hXG5mdW5jdGlvbiBvcF9hbmRub3QoeCwgeSkge1xuICByZXR1cm4geCAmIH55XG59XG5cbmZ1bmN0aW9uIGJuQW5kTm90KGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuYml0d2lzZVRvKGEsIG9wX2FuZG5vdCwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgfnRoaXNcbmZ1bmN0aW9uIGJuTm90KCkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkgcltpXSA9IHRoaXMuRE0gJiB+dGhpc1tpXVxuICByLnQgPSB0aGlzLnRcbiAgci5zID0gfnRoaXMuc1xuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzIDw8IG5cbmZ1bmN0aW9uIGJuU2hpZnRMZWZ0KG4pIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIGlmIChuIDwgMCkgdGhpcy5yU2hpZnRUbygtbiwgcilcbiAgZWxzZSB0aGlzLmxTaGlmdFRvKG4sIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgPj4gblxuZnVuY3Rpb24gYm5TaGlmdFJpZ2h0KG4pIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIGlmIChuIDwgMCkgdGhpcy5sU2hpZnRUbygtbiwgcilcbiAgZWxzZSB0aGlzLnJTaGlmdFRvKG4sIHIpXG4gIHJldHVybiByXG59XG5cbi8vIHJldHVybiBpbmRleCBvZiBsb3dlc3QgMS1iaXQgaW4geCwgeCA8IDJeMzFcbmZ1bmN0aW9uIGxiaXQoeCkge1xuICBpZiAoeCA9PSAwKSByZXR1cm4gLTFcbiAgdmFyIHIgPSAwXG4gIGlmICgoeCAmIDB4ZmZmZikgPT0gMCkge1xuICAgIHggPj49IDE2XG4gICAgciArPSAxNlxuICB9XG4gIGlmICgoeCAmIDB4ZmYpID09IDApIHtcbiAgICB4ID4+PSA4XG4gICAgciArPSA4XG4gIH1cbiAgaWYgKCh4ICYgMHhmKSA9PSAwKSB7XG4gICAgeCA+Pj0gNFxuICAgIHIgKz0gNFxuICB9XG4gIGlmICgoeCAmIDMpID09IDApIHtcbiAgICB4ID4+PSAyXG4gICAgciArPSAyXG4gIH1cbiAgaWYgKCh4ICYgMSkgPT0gMCkrK3JcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJucyBpbmRleCBvZiBsb3dlc3QgMS1iaXQgKG9yIC0xIGlmIG5vbmUpXG5mdW5jdGlvbiBibkdldExvd2VzdFNldEJpdCgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSlcbiAgICBpZiAodGhpc1tpXSAhPSAwKSByZXR1cm4gaSAqIHRoaXMuREIgKyBsYml0KHRoaXNbaV0pXG4gIGlmICh0aGlzLnMgPCAwKSByZXR1cm4gdGhpcy50ICogdGhpcy5EQlxuICByZXR1cm4gLTFcbn1cblxuLy8gcmV0dXJuIG51bWJlciBvZiAxIGJpdHMgaW4geFxuZnVuY3Rpb24gY2JpdCh4KSB7XG4gIHZhciByID0gMFxuICB3aGlsZSAoeCAhPSAwKSB7XG4gICAgeCAmPSB4IC0gMVxuICAgICsrclxuICB9XG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHJldHVybiBudW1iZXIgb2Ygc2V0IGJpdHNcbmZ1bmN0aW9uIGJuQml0Q291bnQoKSB7XG4gIHZhciByID0gMCxcbiAgICB4ID0gdGhpcy5zICYgdGhpcy5ETVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByICs9IGNiaXQodGhpc1tpXSBeIHgpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRydWUgaWZmIG50aCBiaXQgaXMgc2V0XG5mdW5jdGlvbiBiblRlc3RCaXQobikge1xuICB2YXIgaiA9IE1hdGguZmxvb3IobiAvIHRoaXMuREIpXG4gIGlmIChqID49IHRoaXMudCkgcmV0dXJuICh0aGlzLnMgIT0gMClcbiAgcmV0dXJuICgodGhpc1tqXSAmICgxIDw8IChuICUgdGhpcy5EQikpKSAhPSAwKVxufVxuXG4vLyAocHJvdGVjdGVkKSB0aGlzIG9wICgxPDxuKVxuZnVuY3Rpb24gYm5wQ2hhbmdlQml0KG4sIG9wKSB7XG4gIHZhciByID0gQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KG4pXG4gIHRoaXMuYml0d2lzZVRvKHIsIG9wLCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzIHwgKDE8PG4pXG5mdW5jdGlvbiBiblNldEJpdChuKSB7XG4gIHJldHVybiB0aGlzLmNoYW5nZUJpdChuLCBvcF9vcilcbn1cblxuLy8gKHB1YmxpYykgdGhpcyAmIH4oMTw8bilcbmZ1bmN0aW9uIGJuQ2xlYXJCaXQobikge1xuICByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobiwgb3BfYW5kbm90KVxufVxuXG4vLyAocHVibGljKSB0aGlzIF4gKDE8PG4pXG5mdW5jdGlvbiBibkZsaXBCaXQobikge1xuICByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobiwgb3BfeG9yKVxufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyArIGFcbmZ1bmN0aW9uIGJucEFkZFRvKGEsIHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdmFyIGkgPSAwLFxuICAgIGMgPSAwLFxuICAgIG0gPSBNYXRoLm1pbihhLnQsIHNlbGYudClcbiAgd2hpbGUgKGkgPCBtKSB7XG4gICAgYyArPSBzZWxmW2ldICsgYVtpXVxuICAgIHJbaSsrXSA9IGMgJiBzZWxmLkRNXG4gICAgYyA+Pj0gc2VsZi5EQlxuICB9XG4gIGlmIChhLnQgPCBzZWxmLnQpIHtcbiAgICBjICs9IGEuc1xuICAgIHdoaWxlIChpIDwgc2VsZi50KSB7XG4gICAgICBjICs9IHNlbGZbaV1cbiAgICAgIHJbaSsrXSA9IGMgJiBzZWxmLkRNXG4gICAgICBjID4+PSBzZWxmLkRCXG4gICAgfVxuICAgIGMgKz0gc2VsZi5zXG4gIH0gZWxzZSB7XG4gICAgYyArPSBzZWxmLnNcbiAgICB3aGlsZSAoaSA8IGEudCkge1xuICAgICAgYyArPSBhW2ldXG4gICAgICByW2krK10gPSBjICYgc2VsZi5ETVxuICAgICAgYyA+Pj0gc2VsZi5EQlxuICAgIH1cbiAgICBjICs9IGEuc1xuICB9XG4gIHIucyA9IChjIDwgMCkgPyAtMSA6IDBcbiAgaWYgKGMgPiAwKSByW2krK10gPSBjXG4gIGVsc2UgaWYgKGMgPCAtMSkgcltpKytdID0gc2VsZi5EViArIGNcbiAgci50ID0gaVxuICByLmNsYW1wKClcbn1cblxuLy8gKHB1YmxpYykgdGhpcyArIGFcbmZ1bmN0aW9uIGJuQWRkKGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuYWRkVG8oYSwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyAtIGFcbmZ1bmN0aW9uIGJuU3VidHJhY3QoYSkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5zdWJUbyhhLCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzICogYVxuZnVuY3Rpb24gYm5NdWx0aXBseShhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLm11bHRpcGx5VG8oYSwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpc14yXG5mdW5jdGlvbiBiblNxdWFyZSgpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuc3F1YXJlVG8ocilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyAvIGFcbmZ1bmN0aW9uIGJuRGl2aWRlKGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuZGl2UmVtVG8oYSwgciwgbnVsbClcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyAlIGFcbmZ1bmN0aW9uIGJuUmVtYWluZGVyKGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuZGl2UmVtVG8oYSwgbnVsbCwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgW3RoaXMvYSx0aGlzJWFdXG5mdW5jdGlvbiBibkRpdmlkZUFuZFJlbWFpbmRlcihhKSB7XG4gIHZhciBxID0gbmV3IEJpZ0ludGVnZXIoKSxcbiAgICByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmRpdlJlbVRvKGEsIHEsIHIpXG4gIHJldHVybiBuZXcgQXJyYXkocSwgcilcbn1cblxuLy8gKHByb3RlY3RlZCkgdGhpcyAqPSBuLCB0aGlzID49IDAsIDEgPCBuIDwgRFZcbmZ1bmN0aW9uIGJucERNdWx0aXBseShuKSB7XG4gIHRoaXNbdGhpcy50XSA9IHRoaXMuYW0oMCwgbiAtIDEsIHRoaXMsIDAsIDAsIHRoaXMudClcbiAgKyt0aGlzLnRcbiAgdGhpcy5jbGFtcCgpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHRoaXMgKz0gbiA8PCB3IHdvcmRzLCB0aGlzID49IDBcbmZ1bmN0aW9uIGJucERBZGRPZmZzZXQobiwgdykge1xuICBpZiAobiA9PSAwKSByZXR1cm5cbiAgd2hpbGUgKHRoaXMudCA8PSB3KSB0aGlzW3RoaXMudCsrXSA9IDBcbiAgdGhpc1t3XSArPSBuXG4gIHdoaWxlICh0aGlzW3ddID49IHRoaXMuRFYpIHtcbiAgICB0aGlzW3ddIC09IHRoaXMuRFZcbiAgICBpZiAoKyt3ID49IHRoaXMudCkgdGhpc1t0aGlzLnQrK10gPSAwXG4gICAgKyt0aGlzW3ddXG4gIH1cbn1cblxuLy8gQSBcIm51bGxcIiByZWR1Y2VyXG5mdW5jdGlvbiBOdWxsRXhwKCkge31cblxuZnVuY3Rpb24gbk5vcCh4KSB7XG4gIHJldHVybiB4XG59XG5cbmZ1bmN0aW9uIG5NdWxUbyh4LCB5LCByKSB7XG4gIHgubXVsdGlwbHlUbyh5LCByKVxufVxuXG5mdW5jdGlvbiBuU3FyVG8oeCwgcikge1xuICB4LnNxdWFyZVRvKHIpXG59XG5cbk51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBuTm9wXG5OdWxsRXhwLnByb3RvdHlwZS5yZXZlcnQgPSBuTm9wXG5OdWxsRXhwLnByb3RvdHlwZS5tdWxUbyA9IG5NdWxUb1xuTnVsbEV4cC5wcm90b3R5cGUuc3FyVG8gPSBuU3FyVG9cblxuLy8gKHB1YmxpYykgdGhpc15lXG5mdW5jdGlvbiBiblBvdyhlKSB7XG4gIHJldHVybiB0aGlzLmV4cChlLCBuZXcgTnVsbEV4cCgpKVxufVxuXG4vLyAocHJvdGVjdGVkKSByID0gbG93ZXIgbiB3b3JkcyBvZiBcInRoaXMgKiBhXCIsIGEudCA8PSBuXG4vLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseUxvd2VyVG8oYSwgbiwgcikge1xuICB2YXIgaSA9IE1hdGgubWluKHRoaXMudCArIGEudCwgbilcbiAgci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxuICByLnQgPSBpXG4gIHdoaWxlIChpID4gMCkgclstLWldID0gMFxuICB2YXIgalxuICBmb3IgKGogPSByLnQgLSB0aGlzLnQ7IGkgPCBqOyArK2kpIHJbaSArIHRoaXMudF0gPSB0aGlzLmFtKDAsIGFbaV0sIHIsIGksIDAsIHRoaXMudClcbiAgZm9yIChqID0gTWF0aC5taW4oYS50LCBuKTsgaSA8IGo7ICsraSkgdGhpcy5hbSgwLCBhW2ldLCByLCBpLCAwLCBuIC0gaSlcbiAgci5jbGFtcCgpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSBcInRoaXMgKiBhXCIgd2l0aG91dCBsb3dlciBuIHdvcmRzLCBuID4gMFxuLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuZnVuY3Rpb24gYm5wTXVsdGlwbHlVcHBlclRvKGEsIG4sIHIpIHtcbiAgLS1uXG4gIHZhciBpID0gci50ID0gdGhpcy50ICsgYS50IC0gblxuICByLnMgPSAwOyAvLyBhc3N1bWVzIGEsdGhpcyA+PSAwXG4gIHdoaWxlICgtLWkgPj0gMCkgcltpXSA9IDBcbiAgZm9yIChpID0gTWF0aC5tYXgobiAtIHRoaXMudCwgMCk7IGkgPCBhLnQ7ICsraSlcbiAgICByW3RoaXMudCArIGkgLSBuXSA9IHRoaXMuYW0obiAtIGksIGFbaV0sIHIsIDAsIDAsIHRoaXMudCArIGkgLSBuKVxuICByLmNsYW1wKClcbiAgci5kclNoaWZ0VG8oMSwgcilcbn1cblxuLy8gQmFycmV0dCBtb2R1bGFyIHJlZHVjdGlvblxuZnVuY3Rpb24gQmFycmV0dChtKSB7XG4gIC8vIHNldHVwIEJhcnJldHRcbiAgdGhpcy5yMiA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5xMyA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgQmlnSW50ZWdlci5PTkUuZGxTaGlmdFRvKDIgKiBtLnQsIHRoaXMucjIpXG4gIHRoaXMubXUgPSB0aGlzLnIyLmRpdmlkZShtKVxuICB0aGlzLm0gPSBtXG59XG5cbmZ1bmN0aW9uIGJhcnJldHRDb252ZXJ0KHgpIHtcbiAgaWYgKHgucyA8IDAgfHwgeC50ID4gMiAqIHRoaXMubS50KSByZXR1cm4geC5tb2QodGhpcy5tKVxuICBlbHNlIGlmICh4LmNvbXBhcmVUbyh0aGlzLm0pIDwgMCkgcmV0dXJuIHhcbiAgZWxzZSB7XG4gICAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gICAgeC5jb3B5VG8ocilcbiAgICB0aGlzLnJlZHVjZShyKVxuICAgIHJldHVybiByXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFycmV0dFJldmVydCh4KSB7XG4gIHJldHVybiB4XG59XG5cbi8vIHggPSB4IG1vZCBtIChIQUMgMTQuNDIpXG5mdW5jdGlvbiBiYXJyZXR0UmVkdWNlKHgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHguZHJTaGlmdFRvKHNlbGYubS50IC0gMSwgc2VsZi5yMilcbiAgaWYgKHgudCA+IHNlbGYubS50ICsgMSkge1xuICAgIHgudCA9IHNlbGYubS50ICsgMVxuICAgIHguY2xhbXAoKVxuICB9XG4gIHNlbGYubXUubXVsdGlwbHlVcHBlclRvKHNlbGYucjIsIHNlbGYubS50ICsgMSwgc2VsZi5xMylcbiAgc2VsZi5tLm11bHRpcGx5TG93ZXJUbyhzZWxmLnEzLCBzZWxmLm0udCArIDEsIHNlbGYucjIpXG4gIHdoaWxlICh4LmNvbXBhcmVUbyhzZWxmLnIyKSA8IDApIHguZEFkZE9mZnNldCgxLCBzZWxmLm0udCArIDEpXG4gIHguc3ViVG8oc2VsZi5yMiwgeClcbiAgd2hpbGUgKHguY29tcGFyZVRvKHNlbGYubSkgPj0gMCkgeC5zdWJUbyhzZWxmLm0sIHgpXG59XG5cbi8vIHIgPSB4XjIgbW9kIG07IHggIT0gclxuZnVuY3Rpb24gYmFycmV0dFNxclRvKHgsIHIpIHtcbiAgeC5zcXVhcmVUbyhyKVxuICB0aGlzLnJlZHVjZShyKVxufVxuXG4vLyByID0geCp5IG1vZCBtOyB4LHkgIT0gclxuZnVuY3Rpb24gYmFycmV0dE11bFRvKHgsIHksIHIpIHtcbiAgeC5tdWx0aXBseVRvKHksIHIpXG4gIHRoaXMucmVkdWNlKHIpXG59XG5cbkJhcnJldHQucHJvdG90eXBlLmNvbnZlcnQgPSBiYXJyZXR0Q29udmVydFxuQmFycmV0dC5wcm90b3R5cGUucmV2ZXJ0ID0gYmFycmV0dFJldmVydFxuQmFycmV0dC5wcm90b3R5cGUucmVkdWNlID0gYmFycmV0dFJlZHVjZVxuQmFycmV0dC5wcm90b3R5cGUubXVsVG8gPSBiYXJyZXR0TXVsVG9cbkJhcnJldHQucHJvdG90eXBlLnNxclRvID0gYmFycmV0dFNxclRvXG5cbi8vIChwdWJsaWMpIHRoaXNeZSAlIG0gKEhBQyAxNC44NSlcbmZ1bmN0aW9uIGJuTW9kUG93KGUsIG0pIHtcbiAgdmFyIGkgPSBlLmJpdExlbmd0aCgpLFxuICAgIGssIHIgPSBuYnYoMSksXG4gICAgelxuICBpZiAoaSA8PSAwKSByZXR1cm4gclxuICBlbHNlIGlmIChpIDwgMTgpIGsgPSAxXG4gIGVsc2UgaWYgKGkgPCA0OCkgayA9IDNcbiAgZWxzZSBpZiAoaSA8IDE0NCkgayA9IDRcbiAgZWxzZSBpZiAoaSA8IDc2OCkgayA9IDVcbiAgZWxzZSBrID0gNlxuICBpZiAoaSA8IDgpXG4gICAgeiA9IG5ldyBDbGFzc2ljKG0pXG4gIGVsc2UgaWYgKG0uaXNFdmVuKCkpXG4gICAgeiA9IG5ldyBCYXJyZXR0KG0pXG4gIGVsc2VcbiAgICB6ID0gbmV3IE1vbnRnb21lcnkobSlcblxuICAvLyBwcmVjb21wdXRhdGlvblxuICB2YXIgZyA9IG5ldyBBcnJheSgpLFxuICAgIG4gPSAzLFxuICAgIGsxID0gayAtIDEsXG4gICAga20gPSAoMSA8PCBrKSAtIDFcbiAgZ1sxXSA9IHouY29udmVydCh0aGlzKVxuICBpZiAoayA+IDEpIHtcbiAgICB2YXIgZzIgPSBuZXcgQmlnSW50ZWdlcigpXG4gICAgei5zcXJUbyhnWzFdLCBnMilcbiAgICB3aGlsZSAobiA8PSBrbSkge1xuICAgICAgZ1tuXSA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgICAgIHoubXVsVG8oZzIsIGdbbiAtIDJdLCBnW25dKVxuICAgICAgbiArPSAyXG4gICAgfVxuICB9XG5cbiAgdmFyIGogPSBlLnQgLSAxLFxuICAgIHcsIGlzMSA9IHRydWUsXG4gICAgcjIgPSBuZXcgQmlnSW50ZWdlcigpLFxuICAgIHRcbiAgaSA9IG5iaXRzKGVbal0pIC0gMVxuICB3aGlsZSAoaiA+PSAwKSB7XG4gICAgaWYgKGkgPj0gazEpIHcgPSAoZVtqXSA+PiAoaSAtIGsxKSkgJiBrbVxuICAgIGVsc2Uge1xuICAgICAgdyA9IChlW2pdICYgKCgxIDw8IChpICsgMSkpIC0gMSkpIDw8IChrMSAtIGkpXG4gICAgICBpZiAoaiA+IDApIHcgfD0gZVtqIC0gMV0gPj4gKHRoaXMuREIgKyBpIC0gazEpXG4gICAgfVxuXG4gICAgbiA9IGtcbiAgICB3aGlsZSAoKHcgJiAxKSA9PSAwKSB7XG4gICAgICB3ID4+PSAxXG4gICAgICAtLW5cbiAgICB9XG4gICAgaWYgKChpIC09IG4pIDwgMCkge1xuICAgICAgaSArPSB0aGlzLkRCXG4gICAgICAtLWpcbiAgICB9XG4gICAgaWYgKGlzMSkgeyAvLyByZXQgPT0gMSwgZG9uJ3QgYm90aGVyIHNxdWFyaW5nIG9yIG11bHRpcGx5aW5nIGl0XG4gICAgICBnW3ddLmNvcHlUbyhyKVxuICAgICAgaXMxID0gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKG4gPiAxKSB7XG4gICAgICAgIHouc3FyVG8ociwgcjIpXG4gICAgICAgIHouc3FyVG8ocjIsIHIpXG4gICAgICAgIG4gLT0gMlxuICAgICAgfVxuICAgICAgaWYgKG4gPiAwKSB6LnNxclRvKHIsIHIyKVxuICAgICAgZWxzZSB7XG4gICAgICAgIHQgPSByXG4gICAgICAgIHIgPSByMlxuICAgICAgICByMiA9IHRcbiAgICAgIH1cbiAgICAgIHoubXVsVG8ocjIsIGdbd10sIHIpXG4gICAgfVxuXG4gICAgd2hpbGUgKGogPj0gMCAmJiAoZVtqXSAmICgxIDw8IGkpKSA9PSAwKSB7XG4gICAgICB6LnNxclRvKHIsIHIyKVxuICAgICAgdCA9IHJcbiAgICAgIHIgPSByMlxuICAgICAgcjIgPSB0XG4gICAgICBpZiAoLS1pIDwgMCkge1xuICAgICAgICBpID0gdGhpcy5EQiAtIDFcbiAgICAgICAgLS1qXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB6LnJldmVydChyKVxufVxuXG4vLyAocHVibGljKSBnY2QodGhpcyxhKSAoSEFDIDE0LjU0KVxuZnVuY3Rpb24gYm5HQ0QoYSkge1xuICB2YXIgeCA9ICh0aGlzLnMgPCAwKSA/IHRoaXMubmVnYXRlKCkgOiB0aGlzLmNsb25lKClcbiAgdmFyIHkgPSAoYS5zIDwgMCkgPyBhLm5lZ2F0ZSgpIDogYS5jbG9uZSgpXG4gIGlmICh4LmNvbXBhcmVUbyh5KSA8IDApIHtcbiAgICB2YXIgdCA9IHhcbiAgICB4ID0geVxuICAgIHkgPSB0XG4gIH1cbiAgdmFyIGkgPSB4LmdldExvd2VzdFNldEJpdCgpLFxuICAgIGcgPSB5LmdldExvd2VzdFNldEJpdCgpXG4gIGlmIChnIDwgMCkgcmV0dXJuIHhcbiAgaWYgKGkgPCBnKSBnID0gaVxuICBpZiAoZyA+IDApIHtcbiAgICB4LnJTaGlmdFRvKGcsIHgpXG4gICAgeS5yU2hpZnRUbyhnLCB5KVxuICB9XG4gIHdoaWxlICh4LnNpZ251bSgpID4gMCkge1xuICAgIGlmICgoaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkgeC5yU2hpZnRUbyhpLCB4KVxuICAgIGlmICgoaSA9IHkuZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkgeS5yU2hpZnRUbyhpLCB5KVxuICAgIGlmICh4LmNvbXBhcmVUbyh5KSA+PSAwKSB7XG4gICAgICB4LnN1YlRvKHksIHgpXG4gICAgICB4LnJTaGlmdFRvKDEsIHgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHkuc3ViVG8oeCwgeSlcbiAgICAgIHkuclNoaWZ0VG8oMSwgeSlcbiAgICB9XG4gIH1cbiAgaWYgKGcgPiAwKSB5LmxTaGlmdFRvKGcsIHkpXG4gIHJldHVybiB5XG59XG5cbi8vIChwcm90ZWN0ZWQpIHRoaXMgJSBuLCBuIDwgMl4yNlxuZnVuY3Rpb24gYm5wTW9kSW50KG4pIHtcbiAgaWYgKG4gPD0gMCkgcmV0dXJuIDBcbiAgdmFyIGQgPSB0aGlzLkRWICUgbixcbiAgICByID0gKHRoaXMucyA8IDApID8gbiAtIDEgOiAwXG4gIGlmICh0aGlzLnQgPiAwKVxuICAgIGlmIChkID09IDApIHIgPSB0aGlzWzBdICUgblxuICAgIGVsc2VcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSkgciA9IChkICogciArIHRoaXNbaV0pICUgblxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSAxL3RoaXMgJSBtIChIQUMgMTQuNjEpXG5mdW5jdGlvbiBibk1vZEludmVyc2UobSkge1xuICB2YXIgYWMgPSBtLmlzRXZlbigpXG4gIGlmICh0aGlzLnNpZ251bSgpID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKVxuICBpZiAoKHRoaXMuaXNFdmVuKCkgJiYgYWMpIHx8IG0uc2lnbnVtKCkgPT0gMCkgcmV0dXJuIEJpZ0ludGVnZXIuWkVST1xuICB2YXIgdSA9IG0uY2xvbmUoKSxcbiAgICB2ID0gdGhpcy5jbG9uZSgpXG4gIHZhciBhID0gbmJ2KDEpLFxuICAgIGIgPSBuYnYoMCksXG4gICAgYyA9IG5idigwKSxcbiAgICBkID0gbmJ2KDEpXG4gIHdoaWxlICh1LnNpZ251bSgpICE9IDApIHtcbiAgICB3aGlsZSAodS5pc0V2ZW4oKSkge1xuICAgICAgdS5yU2hpZnRUbygxLCB1KVxuICAgICAgaWYgKGFjKSB7XG4gICAgICAgIGlmICghYS5pc0V2ZW4oKSB8fCAhYi5pc0V2ZW4oKSkge1xuICAgICAgICAgIGEuYWRkVG8odGhpcywgYSlcbiAgICAgICAgICBiLnN1YlRvKG0sIGIpXG4gICAgICAgIH1cbiAgICAgICAgYS5yU2hpZnRUbygxLCBhKVxuICAgICAgfSBlbHNlIGlmICghYi5pc0V2ZW4oKSkgYi5zdWJUbyhtLCBiKVxuICAgICAgYi5yU2hpZnRUbygxLCBiKVxuICAgIH1cbiAgICB3aGlsZSAodi5pc0V2ZW4oKSkge1xuICAgICAgdi5yU2hpZnRUbygxLCB2KVxuICAgICAgaWYgKGFjKSB7XG4gICAgICAgIGlmICghYy5pc0V2ZW4oKSB8fCAhZC5pc0V2ZW4oKSkge1xuICAgICAgICAgIGMuYWRkVG8odGhpcywgYylcbiAgICAgICAgICBkLnN1YlRvKG0sIGQpXG4gICAgICAgIH1cbiAgICAgICAgYy5yU2hpZnRUbygxLCBjKVxuICAgICAgfSBlbHNlIGlmICghZC5pc0V2ZW4oKSkgZC5zdWJUbyhtLCBkKVxuICAgICAgZC5yU2hpZnRUbygxLCBkKVxuICAgIH1cbiAgICBpZiAodS5jb21wYXJlVG8odikgPj0gMCkge1xuICAgICAgdS5zdWJUbyh2LCB1KVxuICAgICAgaWYgKGFjKSBhLnN1YlRvKGMsIGEpXG4gICAgICBiLnN1YlRvKGQsIGIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHYuc3ViVG8odSwgdilcbiAgICAgIGlmIChhYykgYy5zdWJUbyhhLCBjKVxuICAgICAgZC5zdWJUbyhiLCBkKVxuICAgIH1cbiAgfVxuICBpZiAodi5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDApIHJldHVybiBCaWdJbnRlZ2VyLlpFUk9cbiAgd2hpbGUgKGQuY29tcGFyZVRvKG0pID49IDApIGQuc3ViVG8obSwgZClcbiAgd2hpbGUgKGQuc2lnbnVtKCkgPCAwKSBkLmFkZFRvKG0sIGQpXG4gIHJldHVybiBkXG59XG5cbnZhciBsb3dwcmltZXMgPSBbXG4gIDIsIDMsIDUsIDcsIDExLCAxMywgMTcsIDE5LCAyMywgMjksIDMxLCAzNywgNDEsIDQzLCA0NywgNTMsIDU5LCA2MSwgNjcsIDcxLFxuICA3MywgNzksIDgzLCA4OSwgOTcsIDEwMSwgMTAzLCAxMDcsIDEwOSwgMTEzLCAxMjcsIDEzMSwgMTM3LCAxMzksIDE0OSwgMTUxLFxuICAxNTcsIDE2MywgMTY3LCAxNzMsIDE3OSwgMTgxLCAxOTEsIDE5MywgMTk3LCAxOTksIDIxMSwgMjIzLCAyMjcsIDIyOSwgMjMzLFxuICAyMzksIDI0MSwgMjUxLCAyNTcsIDI2MywgMjY5LCAyNzEsIDI3NywgMjgxLCAyODMsIDI5MywgMzA3LCAzMTEsIDMxMywgMzE3LFxuICAzMzEsIDMzNywgMzQ3LCAzNDksIDM1MywgMzU5LCAzNjcsIDM3MywgMzc5LCAzODMsIDM4OSwgMzk3LCA0MDEsIDQwOSwgNDE5LFxuICA0MjEsIDQzMSwgNDMzLCA0MzksIDQ0MywgNDQ5LCA0NTcsIDQ2MSwgNDYzLCA0NjcsIDQ3OSwgNDg3LCA0OTEsIDQ5OSwgNTAzLFxuICA1MDksIDUyMSwgNTIzLCA1NDEsIDU0NywgNTU3LCA1NjMsIDU2OSwgNTcxLCA1NzcsIDU4NywgNTkzLCA1OTksIDYwMSwgNjA3LFxuICA2MTMsIDYxNywgNjE5LCA2MzEsIDY0MSwgNjQzLCA2NDcsIDY1MywgNjU5LCA2NjEsIDY3MywgNjc3LCA2ODMsIDY5MSwgNzAxLFxuICA3MDksIDcxOSwgNzI3LCA3MzMsIDczOSwgNzQzLCA3NTEsIDc1NywgNzYxLCA3NjksIDc3MywgNzg3LCA3OTcsIDgwOSwgODExLFxuICA4MjEsIDgyMywgODI3LCA4MjksIDgzOSwgODUzLCA4NTcsIDg1OSwgODYzLCA4NzcsIDg4MSwgODgzLCA4ODcsIDkwNywgOTExLFxuICA5MTksIDkyOSwgOTM3LCA5NDEsIDk0NywgOTUzLCA5NjcsIDk3MSwgOTc3LCA5ODMsIDk5MSwgOTk3XG5dXG5cbnZhciBscGxpbSA9ICgxIDw8IDI2KSAvIGxvd3ByaW1lc1tsb3dwcmltZXMubGVuZ3RoIC0gMV1cblxuLy8gKHB1YmxpYykgdGVzdCBwcmltYWxpdHkgd2l0aCBjZXJ0YWludHkgPj0gMS0uNV50XG5mdW5jdGlvbiBibklzUHJvYmFibGVQcmltZSh0KSB7XG4gIHZhciBpLCB4ID0gdGhpcy5hYnMoKVxuICBpZiAoeC50ID09IDEgJiYgeFswXSA8PSBsb3dwcmltZXNbbG93cHJpbWVzLmxlbmd0aCAtIDFdKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxvd3ByaW1lcy5sZW5ndGg7ICsraSlcbiAgICAgIGlmICh4WzBdID09IGxvd3ByaW1lc1tpXSkgcmV0dXJuIHRydWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoeC5pc0V2ZW4oKSkgcmV0dXJuIGZhbHNlXG4gIGkgPSAxXG4gIHdoaWxlIChpIDwgbG93cHJpbWVzLmxlbmd0aCkge1xuICAgIHZhciBtID0gbG93cHJpbWVzW2ldLFxuICAgICAgaiA9IGkgKyAxXG4gICAgd2hpbGUgKGogPCBsb3dwcmltZXMubGVuZ3RoICYmIG0gPCBscGxpbSkgbSAqPSBsb3dwcmltZXNbaisrXVxuICAgIG0gPSB4Lm1vZEludChtKVxuICAgIHdoaWxlIChpIDwgaikgaWYgKG0gJSBsb3dwcmltZXNbaSsrXSA9PSAwKSByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4geC5taWxsZXJSYWJpbih0KVxufVxuXG4vLyAocHJvdGVjdGVkKSB0cnVlIGlmIHByb2JhYmx5IHByaW1lIChIQUMgNC4yNCwgTWlsbGVyLVJhYmluKVxuZnVuY3Rpb24gYm5wTWlsbGVyUmFiaW4odCkge1xuICB2YXIgbjEgPSB0aGlzLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKVxuICB2YXIgayA9IG4xLmdldExvd2VzdFNldEJpdCgpXG4gIGlmIChrIDw9IDApIHJldHVybiBmYWxzZVxuICB2YXIgciA9IG4xLnNoaWZ0UmlnaHQoaylcbiAgdCA9ICh0ICsgMSkgPj4gMVxuICBpZiAodCA+IGxvd3ByaW1lcy5sZW5ndGgpIHQgPSBsb3dwcmltZXMubGVuZ3RoXG4gIHZhciBhID0gbmV3IEJpZ0ludGVnZXIobnVsbClcbiAgdmFyIGosIGJhc2VzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0OyArK2kpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBqID0gbG93cHJpbWVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxvd3ByaW1lcy5sZW5ndGgpXVxuICAgICAgaWYgKGJhc2VzLmluZGV4T2YoaikgPT0gLTEpIGJyZWFrXG4gICAgfVxuICAgIGJhc2VzLnB1c2goailcbiAgICBhLmZyb21JbnQoailcbiAgICB2YXIgeSA9IGEubW9kUG93KHIsIHRoaXMpXG4gICAgaWYgKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwICYmIHkuY29tcGFyZVRvKG4xKSAhPSAwKSB7XG4gICAgICB2YXIgaiA9IDFcbiAgICAgIHdoaWxlIChqKysgPCBrICYmIHkuY29tcGFyZVRvKG4xKSAhPSAwKSB7XG4gICAgICAgIHkgPSB5Lm1vZFBvd0ludCgyLCB0aGlzKVxuICAgICAgICBpZiAoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDApIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHkuY29tcGFyZVRvKG4xKSAhPSAwKSByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gcHJvdGVjdGVkXG5wcm90by5jaHVua1NpemUgPSBibnBDaHVua1NpemVcbnByb3RvLnRvUmFkaXggPSBibnBUb1JhZGl4XG5wcm90by5mcm9tUmFkaXggPSBibnBGcm9tUmFkaXhcbnByb3RvLmZyb21OdW1iZXIgPSBibnBGcm9tTnVtYmVyXG5wcm90by5iaXR3aXNlVG8gPSBibnBCaXR3aXNlVG9cbnByb3RvLmNoYW5nZUJpdCA9IGJucENoYW5nZUJpdFxucHJvdG8uYWRkVG8gPSBibnBBZGRUb1xucHJvdG8uZE11bHRpcGx5ID0gYm5wRE11bHRpcGx5XG5wcm90by5kQWRkT2Zmc2V0ID0gYm5wREFkZE9mZnNldFxucHJvdG8ubXVsdGlwbHlMb3dlclRvID0gYm5wTXVsdGlwbHlMb3dlclRvXG5wcm90by5tdWx0aXBseVVwcGVyVG8gPSBibnBNdWx0aXBseVVwcGVyVG9cbnByb3RvLm1vZEludCA9IGJucE1vZEludFxucHJvdG8ubWlsbGVyUmFiaW4gPSBibnBNaWxsZXJSYWJpblxuXG4vLyBwdWJsaWNcbnByb3RvLmNsb25lID0gYm5DbG9uZVxucHJvdG8uaW50VmFsdWUgPSBibkludFZhbHVlXG5wcm90by5ieXRlVmFsdWUgPSBibkJ5dGVWYWx1ZVxucHJvdG8uc2hvcnRWYWx1ZSA9IGJuU2hvcnRWYWx1ZVxucHJvdG8uc2lnbnVtID0gYm5TaWdOdW1cbnByb3RvLnRvQnl0ZUFycmF5ID0gYm5Ub0J5dGVBcnJheVxucHJvdG8uZXF1YWxzID0gYm5FcXVhbHNcbnByb3RvLm1pbiA9IGJuTWluXG5wcm90by5tYXggPSBibk1heFxucHJvdG8uYW5kID0gYm5BbmRcbnByb3RvLm9yID0gYm5PclxucHJvdG8ueG9yID0gYm5Yb3JcbnByb3RvLmFuZE5vdCA9IGJuQW5kTm90XG5wcm90by5ub3QgPSBibk5vdFxucHJvdG8uc2hpZnRMZWZ0ID0gYm5TaGlmdExlZnRcbnByb3RvLnNoaWZ0UmlnaHQgPSBiblNoaWZ0UmlnaHRcbnByb3RvLmdldExvd2VzdFNldEJpdCA9IGJuR2V0TG93ZXN0U2V0Qml0XG5wcm90by5iaXRDb3VudCA9IGJuQml0Q291bnRcbnByb3RvLnRlc3RCaXQgPSBiblRlc3RCaXRcbnByb3RvLnNldEJpdCA9IGJuU2V0Qml0XG5wcm90by5jbGVhckJpdCA9IGJuQ2xlYXJCaXRcbnByb3RvLmZsaXBCaXQgPSBibkZsaXBCaXRcbnByb3RvLmFkZCA9IGJuQWRkXG5wcm90by5zdWJ0cmFjdCA9IGJuU3VidHJhY3RcbnByb3RvLm11bHRpcGx5ID0gYm5NdWx0aXBseVxucHJvdG8uZGl2aWRlID0gYm5EaXZpZGVcbnByb3RvLnJlbWFpbmRlciA9IGJuUmVtYWluZGVyXG5wcm90by5kaXZpZGVBbmRSZW1haW5kZXIgPSBibkRpdmlkZUFuZFJlbWFpbmRlclxucHJvdG8ubW9kUG93ID0gYm5Nb2RQb3dcbnByb3RvLm1vZEludmVyc2UgPSBibk1vZEludmVyc2VcbnByb3RvLnBvdyA9IGJuUG93XG5wcm90by5nY2QgPSBibkdDRFxucHJvdG8uaXNQcm9iYWJsZVByaW1lID0gYm5Jc1Byb2JhYmxlUHJpbWVcblxuLy8gSlNCTi1zcGVjaWZpYyBleHRlbnNpb25cbnByb3RvLnNxdWFyZSA9IGJuU3F1YXJlXG5cbi8vIGNvbnN0YW50c1xuQmlnSW50ZWdlci5aRVJPID0gbmJ2KDApXG5CaWdJbnRlZ2VyLk9ORSA9IG5idigxKVxuQmlnSW50ZWdlci52YWx1ZU9mID0gbmJ2XG5cbm1vZHVsZS5leHBvcnRzID0gQmlnSW50ZWdlclxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9iaWdpL2xpYi9iaWdpLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2JpZ2kvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gRklYTUU6IEtpbmQgb2YgYSB3ZWlyZCB3YXkgdG8gdGhyb3cgZXhjZXB0aW9ucywgY29uc2lkZXIgcmVtb3ZpbmdcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCcuL2JpZ2knKVxuXG4vKipcbiAqIFR1cm5zIGEgYnl0ZSBhcnJheSBpbnRvIGEgYmlnIGludGVnZXIuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGludGVycHJldCBhIGJ5dGUgYXJyYXkgYXMgYSBiaWcgaW50ZWdlciBpbiBiaWdcbiAqIGVuZGlhbiBub3RhdGlvbi5cbiAqL1xuQmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQgPSBmdW5jdGlvbihieXRlQXJyYXkpIHtcbiAgLy8gQmlnSW50ZWdlciBleHBlY3RzIGEgREVSIGludGVnZXIgY29uZm9ybWFudCBieXRlIGFycmF5XG4gIGlmIChieXRlQXJyYXlbMF0gJiAweDgwKSB7XG4gICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKFswXS5jb25jYXQoYnl0ZUFycmF5KSlcbiAgfVxuXG4gIHJldHVybiBuZXcgQmlnSW50ZWdlcihieXRlQXJyYXkpXG59XG5cbi8qKlxuICogUmV0dXJucyBhIGJ5dGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJpZyBpbnRlZ2VyLlxuICpcbiAqIFRoaXMgcmV0dXJucyB0aGUgYWJzb2x1dGUgb2YgdGhlIGNvbnRhaW5lZCB2YWx1ZSBpbiBiaWcgZW5kaWFuXG4gKiBmb3JtLiBBIHZhbHVlIG9mIHplcm8gcmVzdWx0cyBpbiBhbiBlbXB0eSBhcnJheS5cbiAqL1xuQmlnSW50ZWdlci5wcm90b3R5cGUudG9CeXRlQXJyYXlVbnNpZ25lZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYnl0ZUFycmF5ID0gdGhpcy50b0J5dGVBcnJheSgpXG4gIHJldHVybiBieXRlQXJyYXlbMF0gPT09IDAgPyBieXRlQXJyYXkuc2xpY2UoMSkgOiBieXRlQXJyYXlcbn1cblxuQmlnSW50ZWdlci5mcm9tREVSSW50ZWdlciA9IGZ1bmN0aW9uKGJ5dGVBcnJheSkge1xuICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYnl0ZUFycmF5KVxufVxuXG4vKlxuICogQ29udmVydHMgQmlnSW50ZWdlciB0byBhIERFUiBpbnRlZ2VyIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIFRoZSBmb3JtYXQgZm9yIHRoaXMgdmFsdWUgdXNlcyB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgYXMgYSBzaWduXG4gKiBiaXQuICBJZiB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgaXMgYWxyZWFkeSBzZXQgYW5kIHRoZSBpbnRlZ2VyIGlzXG4gKiBwb3NpdGl2ZSwgYSAweDAwIGlzIHByZXBlbmRlZC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIDAgPT4gICAgIDB4MDBcbiAqICAgICAgMSA9PiAgICAgMHgwMVxuICogICAgIC0xID0+ICAgICAweGZmXG4gKiAgICAxMjcgPT4gICAgIDB4N2ZcbiAqICAgLTEyNyA9PiAgICAgMHg4MVxuICogICAgMTI4ID0+ICAgMHgwMDgwXG4gKiAgIC0xMjggPT4gICAgIDB4ODBcbiAqICAgIDI1NSA9PiAgIDB4MDBmZlxuICogICAtMjU1ID0+ICAgMHhmZjAxXG4gKiAgMTYzMDAgPT4gICAweDNmYWNcbiAqIC0xNjMwMCA9PiAgIDB4YzA1NFxuICogIDYyMzAwID0+IDB4MDBmMzVjXG4gKiAtNjIzMDAgPT4gMHhmZjBjYTRcbiovXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b0RFUkludGVnZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b0J5dGVBcnJheVxuXG5CaWdJbnRlZ2VyLmZyb21CdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gQmlnSW50ZWdlciBleHBlY3RzIGEgREVSIGludGVnZXIgY29uZm9ybWFudCBieXRlIGFycmF5XG4gIGlmIChidWZmZXJbMF0gJiAweDgwKSB7XG4gICAgdmFyIGJ5dGVBcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ1ZmZlcilcblxuICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihbMF0uY29uY2F0KGJ5dGVBcnJheSkpXG4gIH1cblxuICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYnVmZmVyKVxufVxuXG5CaWdJbnRlZ2VyLmZyb21IZXggPSBmdW5jdGlvbihoZXgpIHtcbiAgaWYgKGhleCA9PT0gJycpIHJldHVybiBCaWdJbnRlZ2VyLlpFUk9cblxuICBhc3NlcnQuZXF1YWwoaGV4LCBoZXgubWF0Y2goL15bQS1GYS1mMC05XSsvKSwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gIGFzc2VydC5lcXVhbChoZXgubGVuZ3RoICUgMiwgMCwgJ0luY29tcGxldGUgaGV4JylcbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGhleCwgMTYpXG59XG5cbkJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24oc2l6ZSkge1xuICB2YXIgYnl0ZUFycmF5ID0gdGhpcy50b0J5dGVBcnJheVVuc2lnbmVkKClcbiAgdmFyIHplcm9zID0gW11cblxuICB2YXIgcGFkZGluZyA9IHNpemUgLSBieXRlQXJyYXkubGVuZ3RoXG4gIHdoaWxlICh6ZXJvcy5sZW5ndGggPCBwYWRkaW5nKSB6ZXJvcy5wdXNoKDApXG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIoemVyb3MuY29uY2F0KGJ5dGVBcnJheSkpXG59XG5cbkJpZ0ludGVnZXIucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oc2l6ZSkge1xuICByZXR1cm4gdGhpcy50b0J1ZmZlcihzaXplKS50b1N0cmluZygnaGV4Jylcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYmlnaS9saWIvY29udmVydC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9iaWdpL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnLi9iaWdpJylcblxuLy9hZGRvbnNcbnJlcXVpcmUoJy4vY29udmVydCcpXG5cbm1vZHVsZS5leHBvcnRzID0gQmlnSW50ZWdlclxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYmlnaS9saWIvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYmlnaS9saWJcIikiLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiX2FyZ3NcIjogW1xuICAgIFtcbiAgICAgIHtcbiAgICAgICAgXCJyYXdcIjogXCJiaWdpQF4xLjQuMlwiLFxuICAgICAgICBcInNjb3BlXCI6IG51bGwsXG4gICAgICAgIFwiZXNjYXBlZE5hbWVcIjogXCJiaWdpXCIsXG4gICAgICAgIFwibmFtZVwiOiBcImJpZ2lcIixcbiAgICAgICAgXCJyYXdTcGVjXCI6IFwiXjEuNC4yXCIsXG4gICAgICAgIFwic3BlY1wiOiBcIj49MS40LjIgPDIuMC4wXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInJhbmdlXCJcbiAgICAgIH0sXG4gICAgICBcIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWF1dGhcIlxuICAgIF1cbiAgXSxcbiAgXCJfZnJvbVwiOiBcImJpZ2lAPj0xLjQuMiA8Mi4wLjBcIixcbiAgXCJfaWRcIjogXCJiaWdpQDEuNC4yXCIsXG4gIFwiX2luQ2FjaGVcIjogdHJ1ZSxcbiAgXCJfaW5zdGFsbGFibGVcIjogdHJ1ZSxcbiAgXCJfbG9jYXRpb25cIjogXCIvYmlnaVwiLFxuICBcIl9ub2RlVmVyc2lvblwiOiBcIjYuMS4wXCIsXG4gIFwiX25wbU9wZXJhdGlvbmFsSW50ZXJuYWxcIjoge1xuICAgIFwiaG9zdFwiOiBcInBhY2thZ2VzLTEyLXdlc3QuaW50ZXJuYWwubnBtanMuY29tXCIsXG4gICAgXCJ0bXBcIjogXCJ0bXAvYmlnaS0xLjQuMi50Z3pfMTQ2OTU4NDE5MjQxM18wLjY4MDEyMzg2MTE4MDYxODRcIlxuICB9LFxuICBcIl9ucG1Vc2VyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJqcHJpY2hhcmRzb25cIixcbiAgICBcImVtYWlsXCI6IFwianByaWNoYXJkc29uQGdtYWlsLmNvbVwiXG4gIH0sXG4gIFwiX25wbVZlcnNpb25cIjogXCIzLjguNlwiLFxuICBcIl9waGFudG9tQ2hpbGRyZW5cIjoge30sXG4gIFwiX3JlcXVlc3RlZFwiOiB7XG4gICAgXCJyYXdcIjogXCJiaWdpQF4xLjQuMlwiLFxuICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICBcImVzY2FwZWROYW1lXCI6IFwiYmlnaVwiLFxuICAgIFwibmFtZVwiOiBcImJpZ2lcIixcbiAgICBcInJhd1NwZWNcIjogXCJeMS40LjJcIixcbiAgICBcInNwZWNcIjogXCI+PTEuNC4yIDwyLjAuMFwiLFxuICAgIFwidHlwZVwiOiBcInJhbmdlXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvZWN1cnZlXCIsXG4gICAgXCIvc3RlZW1hdXRoXCJcbiAgXSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9iaWdpLy0vYmlnaS0xLjQuMi50Z3pcIixcbiAgXCJfc2hhc3VtXCI6IFwiOWM2NjVhOTVmODhiOGIwOGZjMDVjZmQ3MzFmNTYxODU5ZDcyNTgyNVwiLFxuICBcIl9zaHJpbmt3cmFwXCI6IG51bGwsXG4gIFwiX3NwZWNcIjogXCJiaWdpQF4xLjQuMlwiLFxuICBcIl93aGVyZVwiOiBcIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbWF1dGhcIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYmlnaS9pc3N1ZXNcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7fSxcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkJpZyBpbnRlZ2Vycy5cIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiY292ZXJhbGxzXCI6IFwiXjIuMTEuMlwiLFxuICAgIFwiaXN0YW5idWxcIjogXCJeMC4zLjVcIixcbiAgICBcImpzaGludFwiOiBcIl4yLjUuMVwiLFxuICAgIFwibW9jaGFcIjogXCJeMi4xLjBcIixcbiAgICBcIm1vY2hpZnlcIjogXCJeMi4xLjBcIlxuICB9LFxuICBcImRpcmVjdG9yaWVzXCI6IHt9LFxuICBcImRpc3RcIjoge1xuICAgIFwic2hhc3VtXCI6IFwiOWM2NjVhOTVmODhiOGIwOGZjMDVjZmQ3MzFmNTYxODU5ZDcyNTgyNVwiLFxuICAgIFwidGFyYmFsbFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2JpZ2kvLS9iaWdpLTEuNC4yLnRnelwiXG4gIH0sXG4gIFwiZ2l0SGVhZFwiOiBcImMyNTMwODA4MWM4OTZmZjg0NzAyMzAzNzIyYmY1ZWNkOGIzZjc4ZTNcIixcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYmlnaSNyZWFkbWVcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJjcnlwdG9ncmFwaHlcIixcbiAgICBcIm1hdGhcIixcbiAgICBcImJpdGNvaW5cIixcbiAgICBcImFyYml0cmFyeVwiLFxuICAgIFwicHJlY2lzaW9uXCIsXG4gICAgXCJhcml0aG1ldGljXCIsXG4gICAgXCJiaWdcIixcbiAgICBcImludGVnZXJcIixcbiAgICBcImludFwiLFxuICAgIFwibnVtYmVyXCIsXG4gICAgXCJiaWdpbnRlZ2VyXCIsXG4gICAgXCJiaWdpbnRcIixcbiAgICBcImJpZ251bWJlclwiLFxuICAgIFwiZGVjaW1hbFwiLFxuICAgIFwiZmxvYXRcIlxuICBdLFxuICBcIm1haW5cIjogXCIuL2xpYi9pbmRleC5qc1wiLFxuICBcIm1haW50YWluZXJzXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJtaWRuaWdodGxpZ2h0bmluZ1wiLFxuICAgICAgXCJlbWFpbFwiOiBcImJveWRiQG1pZG5pZ2h0ZGVzaWduLndzXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcInNpZGF6aGFuZ1wiLFxuICAgICAgXCJlbWFpbFwiOiBcInNpZGF6aGFuZzg5QGdtYWlsLmNvbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJuYWRhdlwiLFxuICAgICAgXCJlbWFpbFwiOiBcIm5wbUBzaGVzZWsuaW5mb1wiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJqcHJpY2hhcmRzb25cIixcbiAgICAgIFwiZW1haWxcIjogXCJqcHJpY2hhcmRzb25AZ21haWwuY29tXCJcbiAgICB9XG4gIF0sXG4gIFwibmFtZVwiOiBcImJpZ2lcIixcbiAgXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7fSxcbiAgXCJyZWFkbWVcIjogXCJFUlJPUjogTm8gUkVBRE1FIGRhdGEgZm91bmQhXCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9iaWdpLmdpdFwiLFxuICAgIFwidHlwZVwiOiBcImdpdFwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJicm93c2VyLXRlc3RcIjogXCJtb2NoaWZ5IC0td2QgLVIgc3BlY1wiLFxuICAgIFwiY292ZXJhZ2VcIjogXCJpc3RhbmJ1bCBjb3ZlciAuL25vZGVfbW9kdWxlcy8uYmluL19tb2NoYSAtLSAtLXJlcG9ydGVyIGxpc3QgdGVzdC8qLmpzXCIsXG4gICAgXCJjb3ZlcmFsbHNcIjogXCJucG0gcnVuLXNjcmlwdCBjb3ZlcmFnZSAmJiBub2RlIC4vbm9kZV9tb2R1bGVzLy5iaW4vY292ZXJhbGxzIDwgY292ZXJhZ2UvbGNvdi5pbmZvXCIsXG4gICAgXCJqc2hpbnRcIjogXCJqc2hpbnQgLS1jb25maWcganNoaW50Lmpzb24gbGliLyouanMgOyB0cnVlXCIsXG4gICAgXCJ0ZXN0XCI6IFwiX21vY2hhIC0tIHRlc3QvKi5qc1wiLFxuICAgIFwidW5pdFwiOiBcIm1vY2hhXCJcbiAgfSxcbiAgXCJ0ZXN0bGluZ1wiOiB7XG4gICAgXCJmaWxlc1wiOiBcInRlc3QvKi5qc1wiLFxuICAgIFwiaGFybmVzc1wiOiBcIm1vY2hhXCIsXG4gICAgXCJicm93c2Vyc1wiOiBbXG4gICAgICBcImllLzkuLmxhdGVzdFwiLFxuICAgICAgXCJmaXJlZm94L2xhdGVzdFwiLFxuICAgICAgXCJjaHJvbWUvbGF0ZXN0XCIsXG4gICAgICBcInNhZmFyaS82LjAuLmxhdGVzdFwiLFxuICAgICAgXCJpcGhvbmUvNi4wLi5sYXRlc3RcIixcbiAgICAgIFwiYW5kcm9pZC1icm93c2VyLzQuMi4ubGF0ZXN0XCJcbiAgICBdXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjEuNC4yXCJcbn1cbiIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZVwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIHZhciBvZmZzZXQgPSAwO1xuXG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgb2Zmc2V0LCBpKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSAoaSAtIG9mZnNldCk7XG4gICAgb2Zmc2V0ID0gaTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChpID09IGJ1ZmZlci5sZW5ndGgpIHJldHVybiBjaGFyU3RyO1xuXG4gICAgLy8gb3RoZXJ3aXNlIGN1dCBvZmYgdGhlIGNoYXJhY3RlcnMgZW5kIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGlzIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShpLCBidWZmZXIubGVuZ3RoKTtcbiAgICBicmVhaztcbiAgfVxuXG4gIHZhciBsZW5JbmNvbXBsZXRlID0gdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSBsZW5JbmNvbXBsZXRlLCBlbmQpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gbGVuSW5jb21wbGV0ZTtcbiAgICBlbmQgLT0gbGVuSW5jb21wbGV0ZTtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIHRoaXMuY2hhckJ1ZmZlci53cml0ZShjaGFyU3RyLmNoYXJBdChjaGFyU3RyLmxlbmd0aCAtIDEpLCB0aGlzLmVuY29kaW5nKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHZhciBpbmNvbXBsZXRlID0gdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gaW5jb21wbGV0ZSA/IDIgOiAwO1xuICByZXR1cm4gaW5jb21wbGV0ZTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHZhciBpbmNvbXBsZXRlID0gdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gaW5jb21wbGV0ZSA/IDMgOiAwO1xuICByZXR1cm4gaW5jb21wbGV0ZTtcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgYmFzZXggPSByZXF1aXJlKCdiYXNlLXgnKVxudmFyIEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG52YXIgYmFzZTU4ID0gYmFzZXgoQUxQSEFCRVQpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNvZGU6IGJhc2U1OC5lbmNvZGUsXG4gIGRlY29kZTogYmFzZTU4LmRlY29kZVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2JzNThcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5fdXNlVHlwZWRBcnJheXNgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAoY29tcGF0aWJsZSBkb3duIHRvIElFNilcbiAqL1xuQnVmZmVyLl91c2VUeXBlZEFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCBpZiBicm93c2VyIHN1cHBvcnRzIFR5cGVkIEFycmF5cy4gU3VwcG9ydGVkIGJyb3dzZXJzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssXG4gIC8vIENocm9tZSA3KywgU2FmYXJpIDUuMSssIE9wZXJhIDExLjYrLCBpT1MgNC4yKy4gSWYgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhZGRpbmdcbiAgLy8gcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLCB0aGVuIHRoYXQncyB0aGUgc2FtZSBhcyBubyBgVWludDhBcnJheWAgc3VwcG9ydFxuICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBhZGQgYWxsIHRoZSBub2RlIEJ1ZmZlciBBUEkgbWV0aG9kcy4gVGhpcyBpcyBhbiBpc3N1ZVxuICAvLyBpbiBGaXJlZm94IDQtMjkuIE5vdyBmaXhlZDogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4XG4gIHRyeSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigwKVxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICByZXR1cm4gNDIgPT09IGFyci5mb28oKSAmJlxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nIC8vIENocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBXb3JrYXJvdW5kOiBub2RlJ3MgYmFzZTY0IGltcGxlbWVudGF0aW9uIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBzdHJpbmdzXG4gIC8vIHdoaWxlIGJhc2U2NC1qcyBkb2VzIG5vdC5cbiAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JyAmJiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHN1YmplY3QgPSBzdHJpbmd0cmltKHN1YmplY3QpXG4gICAgd2hpbGUgKHN1YmplY3QubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgc3ViamVjdCA9IHN1YmplY3QgKyAnPSdcbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKVxuICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKVxuICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpIC8vIGFzc3VtZSB0aGF0IG9iamVjdCBpcyBhcnJheS1saWtlXG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCBhcnJheSBvciBzdHJpbmcuJylcblxuICB2YXIgYnVmXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgdHlwZW9mIHN1YmplY3QuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBTcGVlZCBvcHRpbWl6YXRpb24gLS0gdXNlIHNldCBpZiB3ZSdyZSBjb3B5aW5nIGZyb20gYSB0eXBlZCBhcnJheVxuICAgIGJ1Zi5fc2V0KHN1YmplY3QpXG4gIH0gZWxzZSBpZiAoaXNBcnJheWlzaChzdWJqZWN0KSkge1xuICAgIC8vIFRyZWF0IGFycmF5LWlzaCBvYmplY3RzIGFzIGEgYnl0ZSBhcnJheVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSlcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdC5yZWFkVUludDgoaSlcbiAgICAgIGVsc2VcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdFtpXVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGJ1Zi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBTVEFUSUMgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9PSBudWxsICYmIGIgIT09IHVuZGVmaW5lZCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggLyAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgYXNzZXJ0KGlzQXJyYXkobGlzdCksICdVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbicgK1xuICAgICAgJ2xpc3Qgc2hvdWxkIGJlIGFuIEFycmF5LicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHRvdGFsTGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbi8vIEJVRkZFUiBJTlNUQU5DRSBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBfaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBhc3NlcnQoc3RyTGVuICUgMiA9PT0gMCwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGFzc2VydCghaXNOYU4oYnl0ZSksICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGkgKiAyXG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIF91dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gX2FzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBfYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF91dGYxNmxlV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBfaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gX3V0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBfYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gX2JpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBfYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IF91dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuICBzdGFydCA9IE51bWJlcihzdGFydCkgfHwgMFxuICBlbmQgPSAoZW5kICE9PSB1bmRlZmluZWQpXG4gICAgPyBOdW1iZXIoZW5kKVxuICAgIDogZW5kID0gc2VsZi5sZW5ndGhcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmIChlbmQgPT09IHN0YXJ0KVxuICAgIHJldHVybiAnJ1xuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBfaGV4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gX3V0ZjhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBfYXNjaWlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gX2JpbmFyeVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBfYmFzZTY0U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IF91dGYxNmxlU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ3NvdXJjZUVuZCA8IHNvdXJjZVN0YXJ0JylcbiAgYXNzZXJ0KHRhcmdldF9zdGFydCA+PSAwICYmIHRhcmdldF9zdGFydCA8IHRhcmdldC5sZW5ndGgsXG4gICAgICAndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgc291cmNlLmxlbmd0aCwgJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMCB8fCAhQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldF9zdGFydClcbiAgfVxufVxuXG5mdW5jdGlvbiBfYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIF91dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gX2FzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKVxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBfYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gX2FzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKVxufVxuXG5mdW5jdGlvbiBfaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBfdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpKzFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IGNsYW1wKHN0YXJ0LCBsZW4sIDApXG4gIGVuZCA9IGNsYW1wKGVuZCwgbGVuLCBsZW4pXG5cbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRVSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmW29mZnNldF0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMl0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICAgIHZhbCB8PSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXQgKyAzXSA8PCAyNCA+Pj4gMClcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAxXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAyXSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDNdXG4gICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXRdIDw8IDI0ID4+PiAwKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHZhciBuZWcgPSB0aGlzW29mZnNldF0gJiAweDgwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiBfcmVhZEludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IF9yZWFkVUludDE2KGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQzMihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwMDAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRGbG9hdCAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRmxvYXQodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZERvdWJsZSAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmYpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm5cblxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxufVxuXG5mdW5jdGlvbiBfd3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZiwgLTB4ODApXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHRoaXMud3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHRoaXMud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmYsIC0weDgwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICBfd3JpdGVVSW50MTYoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDMyKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQzMihidWYsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLmNoYXJDb2RlQXQoMClcbiAgfVxuXG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSksICd2YWx1ZSBpcyBub3QgYSBudW1iZXInKVxuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCB0aGlzLmxlbmd0aCwgJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHRoaXMubGVuZ3RoLCAnZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdGhpc1tpXSA9IHZhbHVlXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3V0ID0gW11cbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKVxuICAgIGlmIChpID09PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLidcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+J1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSlcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBnZXQvc2V0IG1ldGhvZHMgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fZ2V0ID0gYXJyLmdldFxuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuZnVuY3Rpb24gY2xhbXAgKGluZGV4LCBsZW4sIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykgcmV0dXJuIGRlZmF1bHRWYWx1ZVxuICBpbmRleCA9IH5+aW5kZXg7ICAvLyBDb2VyY2UgdG8gaW50ZWdlci5cbiAgaWYgKGluZGV4ID49IGxlbikgcmV0dXJuIGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIGluZGV4ICs9IGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGNvZXJjZSAobGVuZ3RoKSB7XG4gIC8vIENvZXJjZSBsZW5ndGggdG8gYSBudW1iZXIgKHBvc3NpYmx5IE5hTiksIHJvdW5kIHVwXG4gIC8vIGluIGNhc2UgaXQncyBmcmFjdGlvbmFsIChlLmcuIDEyMy40NTYpIHRoZW4gZG8gYVxuICAvLyBkb3VibGUgbmVnYXRlIHRvIGNvZXJjZSBhIE5hTiB0byAwLiBFYXN5LCByaWdodD9cbiAgbGVuZ3RoID0gfn5NYXRoLmNlaWwoK2xlbmd0aClcbiAgcmV0dXJuIGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkgKHN1YmplY3QpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChzdWJqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdWJqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICB9KShzdWJqZWN0KVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKVxuICAgICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpXG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KHN0cilcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBwb3NcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG5cbi8qXG4gKiBXZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGludGVnZXIuIFRoaXMgbWVhbnMgdGhhdCBpdFxuICogaXMgbm9uLW5lZ2F0aXZlLiBJdCBoYXMgbm8gZnJhY3Rpb25hbCBjb21wb25lbnQgYW5kIHRoYXQgaXQgZG9lcyBub3RcbiAqIGV4Y2VlZCB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlLlxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQgKHZhbHVlLCBtYXgpIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlID49IDAsICdzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiB1bnNpZ25lZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHZhbHVlIGZvciB0eXBlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZzaW50ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZJRUVFNzU0ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbn1cblxuZnVuY3Rpb24gYXNzZXJ0ICh0ZXN0LCBtZXNzYWdlKSB7XG4gIGlmICghdGVzdCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0ZhaWxlZCBhc3NlcnRpb24nKVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYnVmZmVyXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLypcclxuIENvcHlyaWdodCAyMDEzLTIwMTQgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuXHJcbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG4vKipcclxuICogQGxpY2Vuc2UgYnl0ZWJ1ZmZlci5qcyAoYykgMjAxNSBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gKiBCYWNraW5nIGJ1ZmZlcjogQXJyYXlCdWZmZXIsIEFjY2Vzc29yOiBVaW50OEFycmF5XHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9ieXRlYnVmZmVyLmpzIGZvciBkZXRhaWxzXHJcbiAqL1xyXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XHJcblxyXG4gICAgLyogQU1EICovIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVtcImFtZFwiXSlcclxuICAgICAgICBkZWZpbmUoW1wibG9uZ1wiXSwgZmFjdG9yeSk7XHJcbiAgICAvKiBDb21tb25KUyAqLyBlbHNlIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZSAmJiBtb2R1bGVbXCJleHBvcnRzXCJdKVxyXG4gICAgICAgIG1vZHVsZVsnZXhwb3J0cyddID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgTG9uZzsgdHJ5IHsgTG9uZyA9IHJlcXVpcmUoXCJsb25nXCIpOyB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeShMb25nKTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgLyogR2xvYmFsICovIGVsc2VcclxuICAgICAgICAoZ2xvYmFsW1wiZGNvZGVJT1wiXSA9IGdsb2JhbFtcImRjb2RlSU9cIl0gfHwge30pW1wiQnl0ZUJ1ZmZlclwiXSA9IGZhY3RvcnkoZ2xvYmFsW1wiZGNvZGVJT1wiXVtcIkxvbmdcIl0pO1xyXG5cclxufSkodGhpcywgZnVuY3Rpb24oTG9uZykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEJ5dGVCdWZmZXIuXHJcbiAgICAgKiBAY2xhc3MgVGhlIHN3aXNzIGFybXkga25pZmUgZm9yIGJpbmFyeSBkYXRhIGluIEphdmFTY3JpcHQuXHJcbiAgICAgKiBAZXhwb3J0cyBCeXRlQnVmZmVyXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gY2FwYWNpdHkgSW5pdGlhbCBjYXBhY2l0eS4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWX0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVH0uXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIHZhciBCeXRlQnVmZmVyID0gZnVuY3Rpb24oY2FwYWNpdHksIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNhcGFjaXR5ID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgY2FwYWNpdHkgPSBCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBsaXR0bGVFbmRpYW4gPSBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygbm9Bc3NlcnQgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBub0Fzc2VydCA9IEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVDtcclxuICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGNhcGFjaXR5ID0gY2FwYWNpdHkgfCAwO1xyXG4gICAgICAgICAgICBpZiAoY2FwYWNpdHkgPCAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgY2FwYWNpdHlcIik7XHJcbiAgICAgICAgICAgIGxpdHRsZUVuZGlhbiA9ICEhbGl0dGxlRW5kaWFuO1xyXG4gICAgICAgICAgICBub0Fzc2VydCA9ICEhbm9Bc3NlcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCYWNraW5nIEFycmF5QnVmZmVyLlxyXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXlCdWZmZXJ9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gY2FwYWNpdHkgPT09IDAgPyBFTVBUWV9CVUZGRVIgOiBuZXcgQXJyYXlCdWZmZXIoY2FwYWNpdHkpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVaW50OEFycmF5IHV0aWxpemVkIHRvIG1hbmlwdWxhdGUgdGhlIGJhY2tpbmcgYnVmZmVyLiBCZWNvbWVzIGBudWxsYCBpZiB0aGUgYmFja2luZyBidWZmZXIgaGFzIGEgY2FwYWNpdHkgb2YgYDBgLlxyXG4gICAgICAgICAqIEB0eXBlIHs/VWludDhBcnJheX1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52aWV3ID0gY2FwYWNpdHkgPT09IDAgPyBudWxsIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBYnNvbHV0ZSByZWFkL3dyaXRlIG9mZnNldC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjZmxpcFxyXG4gICAgICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNjbGVhclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWFya2VkIG9mZnNldC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjbWFya1xyXG4gICAgICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNyZXNldFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWFya2VkT2Zmc2V0ID0gLTE7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFic29sdXRlIGxpbWl0IG9mIHRoZSBjb250YWluZWQgZGF0YS4gU2V0IHRvIHRoZSBiYWNraW5nIGJ1ZmZlcidzIGNhcGFjaXR5IHVwb24gYWxsb2NhdGlvbi5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjZmxpcFxyXG4gICAgICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNjbGVhclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGltaXQgPSBjYXBhY2l0eTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0byB1c2UgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBiaWcgZW5kaWFuLlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLCBkZWZhdWx0cyB0byBgZmFsc2VgLlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm5vQXNzZXJ0ID0gbm9Bc3NlcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnl0ZUJ1ZmZlciB2ZXJzaW9uLlxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLlZFUlNJT04gPSBcIjUuMC4xXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaXR0bGUgZW5kaWFuIGNvbnN0YW50IHRoYXQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBpdHMgYm9vbGVhbiB2YWx1ZS4gRXZhbHVhdGVzIHRvIGB0cnVlYC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTiA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCaWcgZW5kaWFuIGNvbnN0YW50IHRoYXQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBpdHMgYm9vbGVhbiB2YWx1ZS4gRXZhbHVhdGVzIHRvIGBmYWxzZWAuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLkJJR19FTkRJQU4gPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgaW5pdGlhbCBjYXBhY2l0eSBvZiBgMTZgLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5ERUZBVUxUX0NBUEFDSVRZID0gMTY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IGVuZGlhbmVzcyBvZiBgZmFsc2VgIGZvciBiaWcgZW5kaWFuLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU4gPSBCeXRlQnVmZmVyLkJJR19FTkRJQU47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IG5vIGFzc2VydGlvbnMgZmxhZyBvZiBgZmFsc2VgLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBgTG9uZ2AgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0LWJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuIE1heSBiZSBgbnVsbGAgaWYgTG9uZy5qcyBoYXMgbm90IGJlZW4gbG9hZGVkXHJcbiAgICAgKiAgYW5kIGludDY0IHN1cHBvcnQgaXMgbm90IGF2YWlsYWJsZS5cclxuICAgICAqIEB0eXBlIHs/TG9uZ31cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9sb25nLmpzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuTG9uZyA9IExvbmcgfHwgbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBhbGlhcyBCeXRlQnVmZmVyLnByb3RvdHlwZVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBCeXRlQnVmZmVyUHJvdG90eXBlID0gQnl0ZUJ1ZmZlci5wcm90b3R5cGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBpbmRpY2F0b3IgdXNlZCB0byByZWxpYWJseSBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnl0ZUJ1ZmZlciBvciBub3QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5fX2lzQnl0ZUJ1ZmZlcl9fO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCeXRlQnVmZmVyUHJvdG90eXBlLCBcIl9faXNCeXRlQnVmZmVyX19cIiwge1xyXG4gICAgICAgIHZhbHVlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGhlbHBlcnNcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshQXJyYXlCdWZmZXJ9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIEVNUFRZX0JVRkZFUiA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0cmluZy5mcm9tQ2hhckNvZGUgcmVmZXJlbmNlIGZvciBjb21waWxlLXRpbWUgcmVuYW1pbmcuXHJcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oLi4ubnVtYmVyKTpzdHJpbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgc291cmNlIGZ1bmN0aW9uIGZvciBhIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzIFN0cmluZyB0byByZWFkIGZyb21cclxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbigpOm51bWJlcnxudWxsfSBTb3VyY2UgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNoYXIgY29kZSByZXNwZWN0aXZlbHkgYG51bGxgIGlmIHRoZXJlIGFyZVxyXG4gICAgICogIG5vIG1vcmUgY2hhcmFjdGVycyBsZWZ0LlxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgYXJndW1lbnQgaXMgaW52YWxpZFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHN0cmluZ1NvdXJjZShzKSB7XHJcbiAgICAgICAgdmFyIGk9MDsgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaSA8IHMubGVuZ3RoID8gcy5jaGFyQ29kZUF0KGkrKykgOiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZGVzdGluYXRpb24gZnVuY3Rpb24gZm9yIGEgc3RyaW5nLlxyXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uKG51bWJlcj0pOnVuZGVmaW5lZHxzdHJpbmd9IERlc3RpbmF0aW9uIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCB0aGUgbmV4dCBjaGFyIGNvZGUuXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgZmluYWwgc3RyaW5nIHdoZW4gY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzLlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHN0cmluZ0Rlc3RpbmF0aW9uKCkge1xyXG4gICAgICAgIHZhciBjcyA9IFtdLCBwcyA9IFtdOyByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBzLmpvaW4oJycpK3N0cmluZ0Zyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNzKTtcclxuICAgICAgICAgICAgaWYgKGNzLmxlbmd0aCArIGFyZ3VtZW50cy5sZW5ndGggPiAxMDI0KVxyXG4gICAgICAgICAgICAgICAgcHMucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjcykpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGNzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBhY2Nlc3NvciB0eXBlLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBgQnVmZmVyYCB1bmRlciBub2RlLmpzLCBgVWludDhBcnJheWAgcmVzcGVjdGl2ZWx5IGBEYXRhVmlld2AgaW4gdGhlIGJyb3dzZXIgKGNsYXNzZXMpXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuYWNjZXNzb3IgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gVWludDhBcnJheTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFsbG9jYXRlcyBhIG5ldyBCeXRlQnVmZmVyIGJhY2tlZCBieSBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIGNhcGFjaXR5LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBjYXBhY2l0eSBJbml0aWFsIGNhcGFjaXR5LiBEZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0NBUEFDSVRZfS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gc2tpcCBhc3NlcnRpb25zIG9mIG9mZnNldHMgYW5kIHZhbHVlcy4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUfS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5hbGxvY2F0ZSA9IGZ1bmN0aW9uKGNhcGFjaXR5LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlQnVmZmVyKGNhcGFjaXR5LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25jYXRlbmF0ZXMgbXVsdGlwbGUgQnl0ZUJ1ZmZlcnMgaW50byBvbmUuXHJcbiAgICAgKiBAcGFyYW0geyFBcnJheS48IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFVaW50OEFycmF5fHN0cmluZz59IGJ1ZmZlcnMgQnVmZmVycyB0byBjb25jYXRlbmF0ZVxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfGJvb2xlYW4pPX0gZW5jb2RpbmcgU3RyaW5nIGVuY29kaW5nIGlmIGBidWZmZXJzYCBjb250YWlucyBhIHN0cmluZyAoXCJiYXNlNjRcIiwgXCJoZXhcIiwgXCJiaW5hcnlcIixcclxuICAgICAqICBkZWZhdWx0cyB0byBcInV0ZjhcIilcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyIGZvciB0aGUgcmVzdWx0aW5nIEJ5dGVCdWZmZXIuIERlZmF1bHRzXHJcbiAgICAgKiAgdG8ge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzIGZvciB0aGUgcmVzdWx0aW5nIEJ5dGVCdWZmZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IENvbmNhdGVuYXRlZCBCeXRlQnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24oYnVmZmVycywgZW5jb2RpbmcsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBub0Fzc2VydCA9IGxpdHRsZUVuZGlhbjtcclxuICAgICAgICAgICAgbGl0dGxlRW5kaWFuID0gZW5jb2Rpbmc7XHJcbiAgICAgICAgICAgIGVuY29kaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2FwYWNpdHkgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGk9MCwgaz1idWZmZXJzLmxlbmd0aCwgbGVuZ3RoOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoIUJ5dGVCdWZmZXIuaXNCeXRlQnVmZmVyKGJ1ZmZlcnNbaV0pKVxyXG4gICAgICAgICAgICAgICAgYnVmZmVyc1tpXSA9IEJ5dGVCdWZmZXIud3JhcChidWZmZXJzW2ldLCBlbmNvZGluZyk7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IGJ1ZmZlcnNbaV0ubGltaXQgLSBidWZmZXJzW2ldLm9mZnNldDtcclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDApIGNhcGFjaXR5ICs9IGxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNhcGFjaXR5ID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVCdWZmZXIoMCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCk7XHJcbiAgICAgICAgdmFyIGJiID0gbmV3IEJ5dGVCdWZmZXIoY2FwYWNpdHksIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpLFxyXG4gICAgICAgICAgICBiaTtcclxuICAgICAgICBpPTA7IHdoaWxlIChpPGspIHtcclxuICAgICAgICAgICAgYmkgPSBidWZmZXJzW2krK107XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IGJpLmxpbWl0IC0gYmkub2Zmc2V0O1xyXG4gICAgICAgICAgICBpZiAobGVuZ3RoIDw9IDApIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBiYi52aWV3LnNldChiaS52aWV3LnN1YmFycmF5KGJpLm9mZnNldCwgYmkubGltaXQpLCBiYi5vZmZzZXQpO1xyXG4gICAgICAgICAgICBiYi5vZmZzZXQgKz0gbGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBiYi5saW1pdCA9IGJiLm9mZnNldDtcclxuICAgICAgICBiYi5vZmZzZXQgPSAwO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHR5cGUgaXMgYSBCeXRlQnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHsqfSBiYiBCeXRlQnVmZmVyIHRvIHRlc3RcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgaXQgaXMgYSBCeXRlQnVmZmVyLCBvdGhlcndpc2UgYGZhbHNlYFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmlzQnl0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGJiKSB7XHJcbiAgICAgICAgcmV0dXJuIChiYiAmJiBiYltcIl9faXNCeXRlQnVmZmVyX19cIl0pID09PSB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgYmFja2luZyBidWZmZXIgdHlwZS5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYEJ1ZmZlcmAgdW5kZXIgbm9kZS5qcywgYEFycmF5QnVmZmVyYCBpbiB0aGUgYnJvd3NlciAoY2xhc3NlcylcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci50eXBlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5QnVmZmVyO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV3JhcHMgYSBidWZmZXIgb3IgYSBzdHJpbmcuIFNldHMgdGhlIGFsbG9jYXRlZCBCeXRlQnVmZmVyJ3Mge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSB0byBgMGAgYW5kIGl0c1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fSB0byB0aGUgbGVuZ3RoIG9mIHRoZSB3cmFwcGVkIGRhdGEuXHJcbiAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfCFBcnJheUJ1ZmZlcnwhVWludDhBcnJheXxzdHJpbmd8IUFycmF5LjxudW1iZXI+fSBidWZmZXIgQW55dGhpbmcgdGhhdCBjYW4gYmUgd3JhcHBlZFxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfGJvb2xlYW4pPX0gZW5jb2RpbmcgU3RyaW5nIGVuY29kaW5nIGlmIGBidWZmZXJgIGlzIGEgc3RyaW5nIChcImJhc2U2NFwiLCBcImhleFwiLCBcImJpbmFyeVwiLCBkZWZhdWx0cyB0b1xyXG4gICAgICogIFwidXRmOFwiKVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBBIEJ5dGVCdWZmZXIgd3JhcHBpbmcgYGJ1ZmZlcmBcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci53cmFwID0gZnVuY3Rpb24oYnVmZmVyLCBlbmNvZGluZywgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIG5vQXNzZXJ0ID0gbGl0dGxlRW5kaWFuO1xyXG4gICAgICAgICAgICBsaXR0bGVFbmRpYW4gPSBlbmNvZGluZztcclxuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgIGVuY29kaW5nID0gXCJ1dGY4XCI7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tQmFzZTY0KGJ1ZmZlciwgbGl0dGxlRW5kaWFuKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJoZXhcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tSGV4KGJ1ZmZlciwgbGl0dGxlRW5kaWFuKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tQmluYXJ5KGJ1ZmZlciwgbGl0dGxlRW5kaWFuKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1dGY4XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbVVURjgoYnVmZmVyLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbURlYnVnKGJ1ZmZlciwgbGl0dGxlRW5kaWFuKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbnN1cHBvcnRlZCBlbmNvZGluZzogXCIrZW5jb2RpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChidWZmZXIgPT09IG51bGwgfHwgdHlwZW9mIGJ1ZmZlciAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYnVmZmVyXCIpO1xyXG4gICAgICAgIHZhciBiYjtcclxuICAgICAgICBpZiAoQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIoYnVmZmVyKSkge1xyXG4gICAgICAgICAgICBiYiA9IEJ5dGVCdWZmZXJQcm90b3R5cGUuY2xvbmUuY2FsbChidWZmZXIpO1xyXG4gICAgICAgICAgICBiYi5tYXJrZWRPZmZzZXQgPSAtMTtcclxuICAgICAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkgeyAvLyBFeHRyYWN0IEFycmF5QnVmZmVyIGZyb20gVWludDhBcnJheVxyXG4gICAgICAgICAgICBiYiA9IG5ldyBCeXRlQnVmZmVyKDAsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpO1xyXG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHsgLy8gQXZvaWQgcmVmZXJlbmNlcyB0byBtb3JlIHRoYW4gb25lIEVNUFRZX0JVRkZFUlxyXG4gICAgICAgICAgICAgICAgYmIuYnVmZmVyID0gYnVmZmVyLmJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIGJiLm9mZnNldCA9IGJ1ZmZlci5ieXRlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgYmIubGltaXQgPSBidWZmZXIuYnl0ZU9mZnNldCArIGJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgYmIudmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgeyAvLyBSZXVzZSBBcnJheUJ1ZmZlclxyXG4gICAgICAgICAgICBiYiA9IG5ldyBCeXRlQnVmZmVyKDAsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpO1xyXG4gICAgICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBiYi5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgICAgICAgICBiYi5vZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgYmIubGltaXQgPSBidWZmZXIuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGJiLnZpZXcgPSBidWZmZXIuYnl0ZUxlbmd0aCA+IDAgPyBuZXcgVWludDhBcnJheShidWZmZXIpIDogbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJ1ZmZlcikgPT09IFwiW29iamVjdCBBcnJheV1cIikgeyAvLyBDcmVhdGUgZnJvbSBvY3RldHNcclxuICAgICAgICAgICAgYmIgPSBuZXcgQnl0ZUJ1ZmZlcihidWZmZXIubGVuZ3RoLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KTtcclxuICAgICAgICAgICAgYmIubGltaXQgPSBidWZmZXIubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8YnVmZmVyLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICAgICAgYmIudmlld1tpXSA9IGJ1ZmZlcltpXTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBidWZmZXJcIik7IC8vIE90aGVyd2lzZSBmYWlsXHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyB0aGUgYXJyYXkgYXMgYSBiaXRzZXQuXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PGJvb2xlYW4+fSB2YWx1ZSBBcnJheSBvZiBib29sZWFucyB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYGxlbmd0aGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUJpdFNldCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkpXHJcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIEJpdFNldDogTm90IGFuIGFycmF5XCIpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICAgIGJpdHMgPSB2YWx1ZS5sZW5ndGgsXHJcbiAgICAgICAgICBieXRlcyA9IChiaXRzID4+IDMpLFxyXG4gICAgICAgICAgYml0ID0gMCxcclxuICAgICAgICAgIGs7XHJcblxyXG4gICAgICBvZmZzZXQgKz0gdGhpcy53cml0ZVZhcmludDMyKGJpdHMsb2Zmc2V0KTtcclxuXHJcbiAgICAgIHdoaWxlKGJ5dGVzLS0pIHtcclxuICAgICAgICBrID0gKCEhdmFsdWVbYml0KytdICYgMSkgfFxyXG4gICAgICAgICAgICAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgMSkgfFxyXG4gICAgICAgICAgICAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgMikgfFxyXG4gICAgICAgICAgICAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgMykgfFxyXG4gICAgICAgICAgICAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgNCkgfFxyXG4gICAgICAgICAgICAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgNSkgfFxyXG4gICAgICAgICAgICAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgNikgfFxyXG4gICAgICAgICAgICAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgNyk7XHJcbiAgICAgICAgdGhpcy53cml0ZUJ5dGUoayxvZmZzZXQrKyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKGJpdCA8IGJpdHMpIHtcclxuICAgICAgICB2YXIgbSA9IDA7IGsgPSAwO1xyXG4gICAgICAgIHdoaWxlKGJpdCA8IGJpdHMpIGsgPSBrIHwgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IChtKyspKTtcclxuICAgICAgICB0aGlzLndyaXRlQnl0ZShrLG9mZnNldCsrKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSBCaXRTZXQgYXMgYW4gYXJyYXkgb2YgYm9vbGVhbnMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgbGVuZ3RoYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge0FycmF5PGJvb2xlYW4+XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEJpdFNldCA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG5cclxuICAgICAgdmFyIHJldCA9IHRoaXMucmVhZFZhcmludDMyKG9mZnNldCksXHJcbiAgICAgICAgICBiaXRzID0gcmV0LnZhbHVlLFxyXG4gICAgICAgICAgYnl0ZXMgPSAoYml0cyA+PiAzKSxcclxuICAgICAgICAgIGJpdCA9IDAsXHJcbiAgICAgICAgICB2YWx1ZSA9IFtdLFxyXG4gICAgICAgICAgaztcclxuXHJcbiAgICAgIG9mZnNldCArPSByZXQubGVuZ3RoO1xyXG5cclxuICAgICAgd2hpbGUoYnl0ZXMtLSkge1xyXG4gICAgICAgIGsgPSB0aGlzLnJlYWRCeXRlKG9mZnNldCsrKTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHgwMSk7XHJcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4MDIpO1xyXG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDA0KTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHgwOCk7XHJcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4MTApO1xyXG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDIwKTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHg0MCk7XHJcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4ODApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZihiaXQgPCBiaXRzKSB7XHJcbiAgICAgICAgdmFyIG0gPSAwO1xyXG4gICAgICAgIGsgPSB0aGlzLnJlYWRCeXRlKG9mZnNldCsrKTtcclxuICAgICAgICB3aGlsZShiaXQgPCBiaXRzKSB2YWx1ZVtiaXQrK10gPSAhISgoayA+PiAobSsrKSkgJiAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBieXRlcy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGBsZW5ndGhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEJ5dGVzID0gZnVuY3Rpb24obGVuZ3RoLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyBsZW5ndGggPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIitsZW5ndGgrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNsaWNlID0gdGhpcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgIHJldHVybiBzbGljZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSBwYXlsb2FkIG9mIGJ5dGVzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI2FwcGVuZH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFVaW50OEFycmF5fHN0cmluZ30gc291cmNlIERhdGEgdG8gd3JpdGUuIElmIGBzb3VyY2VgIGlzIGEgQnl0ZUJ1ZmZlciwgaXRzIG9mZnNldHNcclxuICAgICAqICB3aWxsIGJlIG1vZGlmaWVkIGFjY29yZGluZyB0byB0aGUgcGVyZm9ybWVkIHJlYWQgb3BlcmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcik9fSBlbmNvZGluZyBFbmNvZGluZyBpZiBgZGF0YWAgaXMgYSBzdHJpbmcgKFwiYmFzZTY0XCIsIFwiaGV4XCIsIFwiYmluYXJ5XCIsIGRlZmF1bHRzIHRvIFwidXRmOFwiKVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVCeXRlcyA9IEJ5dGVCdWZmZXJQcm90b3R5cGUuYXBwZW5kO1xyXG5cclxuICAgIC8vIHR5cGVzL2ludHMvaW50OFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIDhiaXQgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgdmFyIGNhcGFjaXR5MCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTApXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkwICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkwIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDE7XG4gICAgICAgIHRoaXMudmlld1tvZmZzZXRdID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gOGJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZUludDh9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlQnl0ZSA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQ4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYW4gOGJpdCBzaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZpZXdbb2Zmc2V0XTtcclxuICAgICAgICBpZiAoKHZhbHVlICYgMHg4MCkgPT09IDB4ODApIHZhbHVlID0gLSgweEZGIC0gdmFsdWUgKyAxKTsgLy8gQ2FzdCB0byBzaWduZWRcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhbiA4Yml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRJbnQ4fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkQnl0ZSA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gOGJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgIHZhciBjYXBhY2l0eTEgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MSAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MSA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSAxO1xuICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0XSA9IHZhbHVlO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIDhiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZVVpbnQ4fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVJbnQ4ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQ4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYW4gOGJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDggPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZpZXdbb2Zmc2V0XTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhbiA4Yml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZFVpbnQ4fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVUludDggPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50ODtcclxuXHJcbiAgICAvLyB0eXBlcy9pbnRzL2ludDE2XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAxNmJpdCBzaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBvciBgdmFsdWVgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50MTYgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlIHw9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIHZhciBjYXBhY2l0eTIgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkyKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MiAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MiA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSAyO1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSAmIDB4RkYwMCkgPj4+IDg7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgdmFsdWUgJiAweDAwRkY7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldF0gICA9ICh2YWx1ZSAmIDB4RkYwMCkgPj4+IDg7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAgdmFsdWUgJiAweDAwRkY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMTZiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVJbnQxNn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBvciBgdmFsdWVgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlU2hvcnQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50MTY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDE2Yml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMmAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBvdXQgb2YgYm91bmRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDE2ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMiA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzIrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gMDtcclxuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCAgXTtcclxuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCA4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgODtcclxuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh2YWx1ZSAmIDB4ODAwMCkgPT09IDB4ODAwMCkgdmFsdWUgPSAtKDB4RkZGRiAtIHZhbHVlICsgMSk7IC8vIENhc3QgdG8gc2lnbmVkXHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAxNmJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkSW50MTZ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkU2hvcnQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQxNjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDE2Yml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMmAgaWYgb21pdHRlZC5cclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgb3IgYHZhbHVlYCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQxNiA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICB2YXIgY2FwYWNpdHkzID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MylcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTMgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTMgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gMjtcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAodmFsdWUgJiAweEZGMDApID4+PiA4O1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIHZhbHVlICYgMHgwMEZGO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXRdICAgPSAodmFsdWUgJiAweEZGMDApID4+PiA4O1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gIHZhbHVlICYgMHgwMEZGO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDE2Yml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVVaW50MTZ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMmAgaWYgb21pdHRlZC5cclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgb3IgYHZhbHVlYCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVJbnQxNiA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50MTY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDE2Yml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDE2ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMiA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzIrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gMDtcclxuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCAgXTtcclxuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCA4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgODtcclxuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAxNmJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRVaW50MTZ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVUludDE2ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDE2O1xyXG5cclxuICAgIC8vIHR5cGVzL2ludHMvaW50MzJcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDMyYml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50MzIgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlIHw9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHZhciBjYXBhY2l0eTQgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk0KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5NCAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5NCA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSA0O1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAodmFsdWUgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKHZhbHVlID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgdmFsdWUgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKHZhbHVlID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAodmFsdWUgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIHZhbHVlICAgICAgICAgJiAweEZGO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMzJiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVJbnQzMn0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50MzI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgNCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzQrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gMDtcclxuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgMTY7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8ICA4O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgIHZhbHVlICs9IHRoaXMudmlld1tvZmZzZXQrM10gPDwgMjQgPj4+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDE2O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAgODtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICB2YWx1ZSArPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDI0ID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlIHw9IDA7IC8vIENhc3QgdG8gc2lnbmVkXHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAzMmJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkSW50MzJ9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50MzI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAzMmJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDMyID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHZhciBjYXBhY2l0eTUgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk1KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5NSAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5NSA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSA0O1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAodmFsdWUgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKHZhbHVlID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgdmFsdWUgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKHZhbHVlID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAodmFsdWUgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIHZhbHVlICAgICAgICAgJiAweEZGO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMzJiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZVVpbnQzMn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVJbnQzMiA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50MzI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgNCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzQrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gMDtcclxuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgMTY7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8ICA4O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgIHZhbHVlICs9IHRoaXMudmlld1tvZmZzZXQrM10gPDwgMjQgPj4+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDE2O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAgODtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICB2YWx1ZSArPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDI0ID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMzJiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkVWludDMyfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVJbnQzMiA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVpbnQzMjtcclxuXHJcbiAgICAvLyB0eXBlcy9pbnRzL2ludDY0XHJcblxyXG4gICAgaWYgKExvbmcpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JpdGVzIGEgNjRiaXQgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludDY0ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEodmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBMb25nKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyIG9yIExvbmcpXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICAgICAgdmFyIGNhcGFjaXR5NiA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk2KVxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTYgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTYgOiBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0IC09IDg7XG4gICAgICAgICAgICB2YXIgbG8gPSB2YWx1ZS5sb3csXHJcbiAgICAgICAgICAgICAgICBoaSA9IHZhbHVlLmhpZ2g7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9IChsbyA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGxvID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAobG8gPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICBsbyAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAoaGkgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChoaSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGhpID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgaGkgICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9IChoaSA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGhpID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAoaGkgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICBoaSAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAobG8gPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChsbyA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGxvID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgbG8gICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIDY0Yml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlSW50NjR9LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVMb25nID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludDY0O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIDY0Yml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50NjQgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgOCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis4K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxvID0gMCxcclxuICAgICAgICAgICAgICAgIGhpID0gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgICAgICBsbyAgPSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgIDg7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgICAgICBsbyArPSB0aGlzLnZpZXdbb2Zmc2V0KzNdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgaGkgID0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQgIF07XG4gICAgICAgICAgICAgICAgaGkgKz0gdGhpcy52aWV3W29mZnNldCszXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoaSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgIDg7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCszXTtcbiAgICAgICAgICAgICAgICBoaSArPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgbG8gID0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICAgICAgbG8gKz0gdGhpcy52aWV3W29mZnNldCAgXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3IExvbmcobG8sIGhpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIDY0Yml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRJbnQ2NH0uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRMb25nID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50NjQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIDY0Yml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQ2NCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgTG9uZykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlciBvciBMb25nKVwiKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHZhciBjYXBhY2l0eTcgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5NylcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHk3ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHk3IDogb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCAtPSA4O1xuICAgICAgICAgICAgdmFyIGxvID0gdmFsdWUubG93LFxyXG4gICAgICAgICAgICAgICAgaGkgPSB2YWx1ZS5oaWdoO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAobG8gPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChsbyA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGxvID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgbG8gICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gKGhpID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAoaGkgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChoaSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIGhpICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAoaGkgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChoaSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGhpID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgaGkgICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKGxvID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAobG8gPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChsbyA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIGxvICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSA2NGJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlVWludDY0fS5cclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVUludDY0ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQ2NDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVhZHMgYSA2NGJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDY0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDggPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrOCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsbyA9IDAsXHJcbiAgICAgICAgICAgICAgICBoaSA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICAgICAgbG8gID0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQgIF07XG4gICAgICAgICAgICAgICAgbG8gKz0gdGhpcy52aWV3W29mZnNldCszXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIGhpICA9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgMTY7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAgODtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xuICAgICAgICAgICAgICAgIGhpICs9IHRoaXMudmlld1tvZmZzZXQrM10gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGkgID0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICAgICAgaGkgKz0gdGhpcy52aWV3W29mZnNldCAgXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIGxvICA9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgMTY7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAgODtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0KzNdO1xuICAgICAgICAgICAgICAgIGxvICs9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5ldyBMb25nKGxvLCBoaSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIDY0Yml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZFVpbnQ2NH0uXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVSW50NjQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50NjQ7XHJcblxyXG4gICAgfSAvLyBMb25nXHJcblxyXG5cclxuICAgIC8vIHR5cGVzL2Zsb2F0cy9mbG9hdDMyXHJcblxyXG4gICAgLypcclxuICAgICBpZWVlNzU0IC0gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XHJcblxyXG4gICAgIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG5cclxuICAgICBDb3B5cmlnaHQgKGMpIEZlcm9zcyBBYm91a2hhZGlqZWhcclxuXHJcbiAgICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gICAgIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuICAgICBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAgICAgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gICAgIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gICAgIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAgICAgYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICAgICBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICAgICBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICAgICBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAgICAgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAgICAgVEhFIFNPRlRXQVJFLlxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGFuIElFRUU3NTQgZmxvYXQgZnJvbSBhIGJ5dGUgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0geyFBcnJheX0gYnVmZmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTEVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtTGVuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGllZWU3NTRfcmVhZChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XHJcbiAgICAgICAgdmFyIGUsIG0sXHJcbiAgICAgICAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXHJcbiAgICAgICAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXHJcbiAgICAgICAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxyXG4gICAgICAgICAgICBuQml0cyA9IC03LFxyXG4gICAgICAgICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXHJcbiAgICAgICAgICAgIGQgPSBpc0xFID8gLTEgOiAxLFxyXG4gICAgICAgICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xyXG5cclxuICAgICAgICBpICs9IGQ7XHJcblxyXG4gICAgICAgIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xyXG4gICAgICAgIHMgPj49ICgtbkJpdHMpO1xyXG4gICAgICAgIG5CaXRzICs9IGVMZW47XHJcbiAgICAgICAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cclxuXHJcbiAgICAgICAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XHJcbiAgICAgICAgZSA+Pj0gKC1uQml0cyk7XHJcbiAgICAgICAgbkJpdHMgKz0gbUxlbjtcclxuICAgICAgICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxyXG5cclxuICAgICAgICBpZiAoZSA9PT0gMCkge1xyXG4gICAgICAgICAgICBlID0gMSAtIGVCaWFzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcclxuICAgICAgICAgICAgZSA9IGUgLSBlQmlhcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gSUVFRTc1NCBmbG9hdCB0byBhIGJ5dGUgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0geyFBcnJheX0gYnVmZmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMRVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1MZW5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQnl0ZXNcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpZWVlNzU0X3dyaXRlKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XHJcbiAgICAgICAgdmFyIGUsIG0sIGMsXHJcbiAgICAgICAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXHJcbiAgICAgICAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXHJcbiAgICAgICAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxyXG4gICAgICAgICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXHJcbiAgICAgICAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcclxuICAgICAgICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXHJcbiAgICAgICAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XHJcblxyXG4gICAgICAgIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xyXG5cclxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGUgPSBlTWF4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgZS0tO1xyXG4gICAgICAgICAgICAgICAgYyAqPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gcnQgLyBjO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xyXG4gICAgICAgICAgICAgICAgZSsrO1xyXG4gICAgICAgICAgICAgICAgYyAvPSAyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcclxuICAgICAgICAgICAgICAgIG0gPSAwO1xyXG4gICAgICAgICAgICAgICAgZSA9IGVNYXg7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcclxuICAgICAgICAgICAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcclxuICAgICAgICAgICAgICAgIGUgPSBlICsgZUJpYXM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cclxuXHJcbiAgICAgICAgZSA9IChlIDw8IG1MZW4pIHwgbTtcclxuICAgICAgICBlTGVuICs9IG1MZW47XHJcbiAgICAgICAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxyXG5cclxuICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAzMmJpdCBmbG9hdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlRmxvYXQzMiA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhIG51bWJlcilcIik7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgdmFyIGNhcGFjaXR5OCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTgpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHk4ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHk4IDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDQ7XG4gICAgICAgIGllZWU3NTRfd3JpdGUodGhpcy52aWV3LCB2YWx1ZSwgb2Zmc2V0LCB0aGlzLmxpdHRsZUVuZGlhbiwgMjMsIDQpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMzJiaXQgZmxvYXQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVGbG9hdDMyfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdDMyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAzMmJpdCBmbG9hdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkRmxvYXQzMiA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis0K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IGllZWU3NTRfcmVhZCh0aGlzLnZpZXcsIG9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4sIDIzLCA0KTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IGZsb2F0LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRGbG9hdDMyfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRGbG9hdCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEZsb2F0MzI7XHJcblxyXG4gICAgLy8gdHlwZXMvZmxvYXRzL2Zsb2F0NjRcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDY0Yml0IGZsb2F0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdDY0ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGEgbnVtYmVyKVwiKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICB2YXIgY2FwYWNpdHk5ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5OSlcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTkgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTkgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gODtcbiAgICAgICAgaWVlZTc1NF93cml0ZSh0aGlzLnZpZXcsIHZhbHVlLCBvZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuLCA1MiwgOCk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSA2NGJpdCBmbG9hdC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZUZsb2F0NjR9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZURvdWJsZSA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdDY0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSA2NGJpdCBmbG9hdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkRmxvYXQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDggPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis4K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IGllZWU3NTRfcmVhZCh0aGlzLnZpZXcsIG9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4sIDUyLCA4KTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDY0Yml0IGZsb2F0LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRGbG9hdDY0fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWREb3VibGUgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRGbG9hdDY0O1xyXG5cclxuXHJcbiAgICAvLyB0eXBlcy92YXJpbnRzL3ZhcmludDMyXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBhIDMyYml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLk1BWF9WQVJJTlQzMl9CWVRFUyA9IDU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkIHRvIHN0b3JlIGEgMzJiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gZW5jb2RlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQuIENhcHBlZCB0byB7QGxpbmsgQnl0ZUJ1ZmZlci5NQVhfVkFSSU5UMzJfQllURVN9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIC8vIHJlZjogc3JjL2dvb2dsZS9wcm90b2J1Zi9pby9jb2RlZF9zdHJlYW0uY2NcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlID4+PiAwO1xyXG4gICAgICAgICAgICAgaWYgKHZhbHVlIDwgMSA8PCA3ICkgcmV0dXJuIDE7XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCAxIDw8IDE0KSByZXR1cm4gMjtcclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IDEgPDwgMjEpIHJldHVybiAzO1xyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgMSA8PCAyOCkgcmV0dXJuIDQ7XHJcbiAgICAgICAgZWxzZSAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBaaWd6YWcgZW5jb2RlcyBhIHNpZ25lZCAzMmJpdCBpbnRlZ2VyIHNvIHRoYXQgaXQgY2FuIGJlIGVmZmVjdGl2ZWx5IHVzZWQgd2l0aCB2YXJpbnQgZW5jb2RpbmcuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBTaWduZWQgMzJiaXQgaW50ZWdlclxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgemlnemFnIGVuY29kZWQgMzJiaXQgaW50ZWdlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTMyID0gZnVuY3Rpb24obikge1xyXG4gICAgICAgIHJldHVybiAoKChuIHw9IDApIDw8IDEpIF4gKG4gPj4gMzEpKSA+Pj4gMDsgLy8gcmVmOiBzcmMvZ29vZ2xlL3Byb3RvYnVmL3dpcmVfZm9ybWF0X2xpdGUuaFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYSB6aWd6YWcgZW5jb2RlZCBzaWduZWQgMzJiaXQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFVuc2lnbmVkIHppZ3phZyBlbmNvZGVkIDMyYml0IGludGVnZXJcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCAzMmJpdCBpbnRlZ2VyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlMzIgPSBmdW5jdGlvbihuKSB7XHJcbiAgICAgICAgcmV0dXJuICgobiA+Pj4gMSkgXiAtKG4gJiAxKSkgfCAwOyAvLyAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvd2lyZV9mb3JtYXRfbGl0ZS5oXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMzJiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IHRoaXMgaWYgYG9mZnNldGAgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVWYXJpbnQzMiA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2l6ZSA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUpLFxyXG4gICAgICAgICAgICBiO1xyXG4gICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgICB2YXIgY2FwYWNpdHkxMCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTEwKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTAgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTEwIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IHNpemU7XG4gICAgICAgIHZhbHVlID4+Pj0gMDtcclxuICAgICAgICB3aGlsZSAodmFsdWUgPj0gMHg4MCkge1xyXG4gICAgICAgICAgICBiID0gKHZhbHVlICYgMHg3ZikgfCAweDgwO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gYjtcclxuICAgICAgICAgICAgdmFsdWUgPj4+PSA3O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNpemU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgemlnLXphZyBlbmNvZGVkIChzaWduZWQpIDMyYml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSB0aGlzIGlmIGBvZmZzZXRgIGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVmFyaW50MzJaaWdaYWcgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVWYXJpbnQzMihCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTMyKHZhbHVlKSwgb2Zmc2V0KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8IXt2YWx1ZTogbnVtYmVyLCBsZW5ndGg6IG51bWJlcn19IFRoZSB2YWx1ZSByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSB2YWx1ZSByZWFkXHJcbiAgICAgKiAgYW5kIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXHJcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQncyBub3QgYSB2YWxpZCB2YXJpbnQuIEhhcyBhIHByb3BlcnR5IGB0cnVuY2F0ZWQgPSB0cnVlYCBpZiB0aGVyZSBpcyBub3QgZW5vdWdoIGRhdGEgYXZhaWxhYmxlXHJcbiAgICAgKiAgdG8gZnVsbHkgZGVjb2RlIHRoZSB2YXJpbnQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFZhcmludDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzErXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGMgPSAwLFxyXG4gICAgICAgICAgICB2YWx1ZSA9IDAgPj4+IDAsXHJcbiAgICAgICAgICAgIGI7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQgJiYgb2Zmc2V0ID4gdGhpcy5saW1pdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFwiVHJ1bmNhdGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgZXJyWyd0cnVuY2F0ZWQnXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107XHJcbiAgICAgICAgICAgIGlmIChjIDwgNSlcclxuICAgICAgICAgICAgICAgIHZhbHVlIHw9IChiICYgMHg3ZikgPDwgKDcqYyk7XHJcbiAgICAgICAgICAgICsrYztcclxuICAgICAgICB9IHdoaWxlICgoYiAmIDB4ODApICE9PSAwKTtcclxuICAgICAgICB2YWx1ZSB8PSAwO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLFxyXG4gICAgICAgICAgICBcImxlbmd0aFwiOiBjXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCAoc2lnbmVkKSAzMmJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfCF7dmFsdWU6IG51bWJlciwgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgdmFsdWUgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgdmFsdWUgcmVhZFxyXG4gICAgICogIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIGl0J3Mgbm90IGEgdmFsaWQgdmFyaW50XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFZhcmludDMyWmlnWmFnID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMucmVhZFZhcmludDMyKG9mZnNldCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICB2YWxbXCJ2YWx1ZVwiXSA9IEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlMzIodmFsW1widmFsdWVcIl0pO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdmFsID0gQnl0ZUJ1ZmZlci56aWdaYWdEZWNvZGUzMih2YWwpO1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHR5cGVzL3ZhcmludHMvdmFyaW50NjRcclxuXHJcbiAgICBpZiAoTG9uZykge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBhIDY0Yml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXIuTUFYX1ZBUklOVDY0X0JZVEVTID0gMTA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQgdG8gc3RvcmUgYSA2NGJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgVmFsdWUgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkLiBDYXBwZWQgdG8ge0BsaW5rIEJ5dGVCdWZmZXIuTUFYX1ZBUklOVDY0X0JZVEVTfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvaW8vY29kZWRfc3RyZWFtLmNjXHJcbiAgICAgICAgICAgIHZhciBwYXJ0MCA9IHZhbHVlLnRvSW50KCkgPj4+IDAsXHJcbiAgICAgICAgICAgICAgICBwYXJ0MSA9IHZhbHVlLnNoaWZ0UmlnaHRVbnNpZ25lZCgyOCkudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgICAgIHBhcnQyID0gdmFsdWUuc2hpZnRSaWdodFVuc2lnbmVkKDU2KS50b0ludCgpID4+PiAwO1xyXG4gICAgICAgICAgICBpZiAocGFydDIgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnQxID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydDAgPCAxIDw8IDE0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydDAgPCAxIDw8IDcgPyAxIDogMjtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0MCA8IDEgPDwgMjEgPyAzIDogNDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQxIDwgMSA8PCAxNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQxIDwgMSA8PCA3ID8gNSA6IDY7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydDEgPCAxIDw8IDIxID8gNyA6IDg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQyIDwgMSA8PCA3ID8gOSA6IDEwO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFppZ3phZyBlbmNvZGVzIGEgc2lnbmVkIDY0Yml0IGludGVnZXIgc28gdGhhdCBpdCBjYW4gYmUgZWZmZWN0aXZlbHkgdXNlZCB3aXRoIHZhcmludCBlbmNvZGluZy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgU2lnbmVkIGxvbmdcclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIHppZ3phZyBlbmNvZGVkIGxvbmdcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlci56aWdaYWdFbmNvZGU2NCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS51bnNpZ25lZCAhPT0gZmFsc2UpIHZhbHVlID0gdmFsdWUudG9TaWduZWQoKTtcbiAgICAgICAgICAgIC8vIHJlZjogc3JjL2dvb2dsZS9wcm90b2J1Zi93aXJlX2Zvcm1hdF9saXRlLmhcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNoaWZ0TGVmdCgxKS54b3IodmFsdWUuc2hpZnRSaWdodCg2MykpLnRvVW5zaWduZWQoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIGEgemlnemFnIGVuY29kZWQgc2lnbmVkIDY0Yml0IGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ9IHZhbHVlIFVuc2lnbmVkIHppZ3phZyBlbmNvZGVkIGxvbmcgb3IgSmF2YVNjcmlwdCBudW1iZXJcclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNpZ25lZCBsb25nXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlNjQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUudW5zaWduZWQgIT09IGZhbHNlKSB2YWx1ZSA9IHZhbHVlLnRvU2lnbmVkKCk7XG4gICAgICAgICAgICAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvd2lyZV9mb3JtYXRfbGl0ZS5oXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zaGlmdFJpZ2h0VW5zaWduZWQoMSkueG9yKHZhbHVlLmFuZChMb25nLk9ORSkudG9TaWduZWQoKS5uZWdhdGUoKSkudG9TaWduZWQoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSA2NGJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxMb25nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gYHRoaXNgIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4uXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVWYXJpbnQ2NCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgTG9uZykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlciBvciBMb25nKVwiKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLnVuc2lnbmVkICE9PSBmYWxzZSkgdmFsdWUgPSB2YWx1ZS50b1NpZ25lZCgpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDY0KHZhbHVlKSxcclxuICAgICAgICAgICAgICAgIHBhcnQwID0gdmFsdWUudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgICAgIHBhcnQxID0gdmFsdWUuc2hpZnRSaWdodFVuc2lnbmVkKDI4KS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICAgICAgcGFydDIgPSB2YWx1ZS5zaGlmdFJpZ2h0VW5zaWduZWQoNTYpLnRvSW50KCkgPj4+IDA7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgICAgICAgdmFyIGNhcGFjaXR5MTEgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTEpXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTEgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTExIDogb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCAtPSBzaXplO1xuICAgICAgICAgICAgc3dpdGNoIChzaXplKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiB0aGlzLnZpZXdbb2Zmc2V0KzldID0gKHBhcnQyID4+PiAgNykgJiAweDAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA5IDogdGhpcy52aWV3W29mZnNldCs4XSA9IHNpemUgIT09IDkgPyAocGFydDIgICAgICAgKSB8IDB4ODAgOiAocGFydDIgICAgICAgKSAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDggOiB0aGlzLnZpZXdbb2Zmc2V0KzddID0gc2l6ZSAhPT0gOCA/IChwYXJ0MSA+Pj4gMjEpIHwgMHg4MCA6IChwYXJ0MSA+Pj4gMjEpICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgNyA6IHRoaXMudmlld1tvZmZzZXQrNl0gPSBzaXplICE9PSA3ID8gKHBhcnQxID4+PiAxNCkgfCAweDgwIDogKHBhcnQxID4+PiAxNCkgJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2IDogdGhpcy52aWV3W29mZnNldCs1XSA9IHNpemUgIT09IDYgPyAocGFydDEgPj4+ICA3KSB8IDB4ODAgOiAocGFydDEgPj4+ICA3KSAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDUgOiB0aGlzLnZpZXdbb2Zmc2V0KzRdID0gc2l6ZSAhPT0gNSA/IChwYXJ0MSAgICAgICApIHwgMHg4MCA6IChwYXJ0MSAgICAgICApICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgNCA6IHRoaXMudmlld1tvZmZzZXQrM10gPSBzaXplICE9PSA0ID8gKHBhcnQwID4+PiAyMSkgfCAweDgwIDogKHBhcnQwID4+PiAyMSkgJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzIDogdGhpcy52aWV3W29mZnNldCsyXSA9IHNpemUgIT09IDMgPyAocGFydDAgPj4+IDE0KSB8IDB4ODAgOiAocGFydDAgPj4+IDE0KSAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDIgOiB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gc2l6ZSAhPT0gMiA/IChwYXJ0MCA+Pj4gIDcpIHwgMHg4MCA6IChwYXJ0MCA+Pj4gIDcpICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgMSA6IHRoaXMudmlld1tvZmZzZXQgIF0gPSBzaXplICE9PSAxID8gKHBhcnQwICAgICAgICkgfCAweDgwIDogKHBhcnQwICAgICAgICkgJiAweDdGO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc2l6ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSB6aWctemFnIGVuY29kZWQgNjRiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8TG9uZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IGB0aGlzYCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuLlxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVmFyaW50NjRaaWdaYWcgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlVmFyaW50NjQoQnl0ZUJ1ZmZlci56aWdaYWdFbmNvZGU2NCh2YWx1ZSksIG9mZnNldCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVhZHMgYSA2NGJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci4gUmVxdWlyZXMgTG9uZy5qcy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd8IXt2YWx1ZTogTG9uZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgdmFsdWUgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgdmFsdWUgcmVhZCBhbmRcclxuICAgICAgICAgKiAgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQncyBub3QgYSB2YWxpZCB2YXJpbnRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVmFyaW50NjQgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisxK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVmOiBzcmMvZ29vZ2xlL3Byb3RvYnVmL2lvL2NvZGVkX3N0cmVhbS5jY1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBwYXJ0MCA9IDAsXHJcbiAgICAgICAgICAgICAgICBwYXJ0MSA9IDAsXHJcbiAgICAgICAgICAgICAgICBwYXJ0MiA9IDAsXHJcbiAgICAgICAgICAgICAgICBiICA9IDA7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MCAgPSAoYiAmIDB4N0YpICAgICAgOyBpZiAoIGIgJiAweDgwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MCB8PSAoYiAmIDB4N0YpIDw8ICA3OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MCB8PSAoYiAmIDB4N0YpIDw8IDE0OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MCB8PSAoYiAmIDB4N0YpIDw8IDIxOyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MSAgPSAoYiAmIDB4N0YpICAgICAgOyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MSB8PSAoYiAmIDB4N0YpIDw8ICA3OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MSB8PSAoYiAmIDB4N0YpIDw8IDE0OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MSB8PSAoYiAmIDB4N0YpIDw8IDIxOyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MiAgPSAoYiAmIDB4N0YpICAgICAgOyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MiB8PSAoYiAmIDB4N0YpIDw8ICA3OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQnVmZmVyIG92ZXJydW5cIik7IH19fX19fX19fX1cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gTG9uZy5mcm9tQml0cyhwYXJ0MCB8IChwYXJ0MSA8PCAyOCksIChwYXJ0MSA+Pj4gNCkgfCAocGFydDIpIDw8IDI0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICdsZW5ndGgnOiBvZmZzZXQtc3RhcnRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCA2NGJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci4gUmVxdWlyZXMgTG9uZy5qcy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd8IXt2YWx1ZTogTG9uZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgdmFsdWUgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgdmFsdWUgcmVhZCBhbmRcclxuICAgICAgICAgKiAgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQncyBub3QgYSB2YWxpZCB2YXJpbnRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVmFyaW50NjRaaWdaYWcgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMucmVhZFZhcmludDY0KG9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmICh2YWwgJiYgdmFsWyd2YWx1ZSddIGluc3RhbmNlb2YgTG9uZylcclxuICAgICAgICAgICAgICAgIHZhbFtcInZhbHVlXCJdID0gQnl0ZUJ1ZmZlci56aWdaYWdEZWNvZGU2NCh2YWxbXCJ2YWx1ZVwiXSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHZhbCA9IEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlNjQodmFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgIH0gLy8gTG9uZ1xyXG5cclxuXHJcbiAgICAvLyB0eXBlcy9zdHJpbmdzL2NzdHJpbmdcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIE5VTEwtdGVybWluYXRlZCBVVEY4IGVuY29kZWQgc3RyaW5nLiBGb3IgdGhpcyB0byB3b3JrIHRoZSBzcGVjaWZpZWQgc3RyaW5nIG11c3Qgbm90IGNvbnRhaW4gYW55IE5VTExcclxuICAgICAqICBjaGFyYWN0ZXJzIGl0c2VsZi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICBjb250YWluZWQgaW4gYHN0cmAgKyAxIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSB0aGlzIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUNTdHJpbmcgPSBmdW5jdGlvbihzdHIsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgayA9IHN0ci5sZW5ndGg7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgIGZvciAoaT0wOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkpID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHN0cjogQ29udGFpbnMgTlVMTC1jaGFyYWN0ZXJzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICAvLyBVVEY4IHN0cmluZ3MgZG8gbm90IGNvbnRhaW4gemVybyBieXRlcyBpbiBiZXR3ZWVuIGV4Y2VwdCBmb3IgdGhlIHplcm8gY2hhcmFjdGVyLCBzbzpcclxuICAgICAgICBrID0gdXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSlbMV07XHJcbiAgICAgICAgb2Zmc2V0ICs9IGsrMTtcbiAgICAgICAgdmFyIGNhcGFjaXR5MTIgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxMilcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTEyICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkxMiA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSBrKzE7XG4gICAgICAgIHV0ZnguZW5jb2RlVVRGMTZ0b1VURjgoc3RyaW5nU291cmNlKHN0ciksIGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsrXSA9IGI7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gMDtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIE5VTEwtdGVybWluYXRlZCBVVEY4IGVuY29kZWQgc3RyaW5nLiBGb3IgdGhpcyB0byB3b3JrIHRoZSBzdHJpbmcgcmVhZCBtdXN0IG5vdCBjb250YWluIGFueSBOVUxMIGNoYXJhY3RlcnNcclxuICAgICAqICBpdHNlbGYuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3whe3N0cmluZzogc3RyaW5nLCBsZW5ndGg6IG51bWJlcn19IFRoZSBzdHJpbmcgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgc3RyaW5nXHJcbiAgICAgKiAgcmVhZCBhbmQgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkQ1N0cmluZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDEgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisxK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICAgICAgdGVtcDtcclxuICAgICAgICAvLyBVVEY4IHN0cmluZ3MgZG8gbm90IGNvbnRhaW4gemVybyBieXRlcyBpbiBiZXR3ZWVuIGV4Y2VwdCBmb3IgdGhlIHplcm8gY2hhcmFjdGVyIGl0c2VsZiwgc286XHJcbiAgICAgICAgdmFyIHNkLCBiID0gLTE7XHJcbiAgICAgICAgdXRmeC5kZWNvZGVVVEY4dG9VVEYxNihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKGIgPT09IDApIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID49IHRoaXMubGltaXQpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK29mZnNldCtcIiA8IFwiK3RoaXMubGltaXQpO1xyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTtcclxuICAgICAgICAgICAgcmV0dXJuIGIgPT09IDAgPyBudWxsIDogYjtcclxuICAgICAgICB9LmJpbmQodGhpcyksIHNkID0gc3RyaW5nRGVzdGluYXRpb24oKSwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gc2QoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIjogc2QoKSxcclxuICAgICAgICAgICAgICAgIFwibGVuZ3RoXCI6IG9mZnNldCAtIHN0YXJ0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyB0eXBlcy9zdHJpbmdzL2lzdHJpbmdcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIGxlbmd0aCBhcyB1aW50MzIgcHJlZml4ZWQgVVRGOCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSBgdGhpc2AgaWYgYG9mZnNldGAgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjd3JpdGVWYXJpbnQzMlxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSVN0cmluZyA9IGZ1bmN0aW9uKHN0ciwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgICAgICBrO1xyXG4gICAgICAgIGsgPSB1dGZ4LmNhbGN1bGF0ZVVURjE2YXNVVEY4KHN0cmluZ1NvdXJjZShzdHIpLCB0aGlzLm5vQXNzZXJ0KVsxXTtcclxuICAgICAgICBvZmZzZXQgKz0gNCtrO1xuICAgICAgICB2YXIgY2FwYWNpdHkxMyA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTEzKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTMgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTEzIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDQraztcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gKGsgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGsgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGsgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIGsgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKGsgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGsgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGsgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIGsgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgdXRmeC5lbmNvZGVVVEYxNnRvVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gYjtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgIT09IHN0YXJ0ICsgNCArIGspXHJcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrb2Zmc2V0K1wiID09IFwiKyhvZmZzZXQrNCtrKSk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgbGVuZ3RoIGFzIHVpbnQzMiBwcmVmaXhlZCBVVEY4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8IXtzdHJpbmc6IHN0cmluZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgc3RyaW5nIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHN0cmluZ1xyXG4gICAgICogIHJlYWQgYW5kIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjcmVhZFZhcmludDMyXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZElTdHJpbmcgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyA0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrNCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XHJcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMucmVhZFVpbnQzMihvZmZzZXQpO1xyXG4gICAgICAgIHZhciBzdHIgPSB0aGlzLnJlYWRVVEY4U3RyaW5nKGxlbiwgQnl0ZUJ1ZmZlci5NRVRSSUNTX0JZVEVTLCBvZmZzZXQgKz0gNCk7XHJcbiAgICAgICAgb2Zmc2V0ICs9IHN0clsnbGVuZ3RoJ107XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyWydzdHJpbmcnXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgJ3N0cmluZyc6IHN0clsnc3RyaW5nJ10sXHJcbiAgICAgICAgICAgICAgICAnbGVuZ3RoJzogb2Zmc2V0IC0gc3RhcnRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHR5cGVzL3N0cmluZ3MvdXRmOHN0cmluZ1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWV0cmljcyByZXByZXNlbnRpbmcgbnVtYmVyIG9mIFVURjggY2hhcmFjdGVycy4gRXZhbHVhdGVzIHRvIGBjYC5cclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5NRVRSSUNTX0NIQVJTID0gJ2MnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWV0cmljcyByZXByZXNlbnRpbmcgbnVtYmVyIG9mIGJ5dGVzLiBFdmFsdWF0ZXMgdG8gYGJgLlxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLk1FVFJJQ1NfQllURVMgPSAnYic7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gVVRGOCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSB0aGlzIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4uXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVVEY4U3RyaW5nID0gZnVuY3Rpb24oc3RyLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaztcclxuICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XHJcbiAgICAgICAgayA9IHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0cikpWzFdO1xyXG4gICAgICAgIG9mZnNldCArPSBrO1xuICAgICAgICB2YXIgY2FwYWNpdHkxNCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTE0KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTQgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTE0IDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IGs7XG4gICAgICAgIHV0ZnguZW5jb2RlVVRGMTZ0b1VURjgoc3RyaW5nU291cmNlKHN0ciksIGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsrXSA9IGI7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIFVURjggZW5jb2RlZCBzdHJpbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVVVEY4U3RyaW5nfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IHRoaXMgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbi5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVN0cmluZyA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVVEY4U3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIFVURjggY2hhcmFjdGVycyBvZiBhIHN0cmluZy4gSmF2YVNjcmlwdCBpdHNlbGYgdXNlcyBVVEYtMTYsIHNvIHRoYXQgYSBzdHJpbmcnc1xyXG4gICAgICogIGBsZW5ndGhgIHByb3BlcnR5IGRvZXMgbm90IHJlZmxlY3QgaXRzIGFjdHVhbCBVVEY4IHNpemUgaWYgaXQgY29udGFpbnMgY29kZSBwb2ludHMgbGFyZ2VyIHRoYW4gMHhGRkZGLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY2FsY3VsYXRlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgVVRGOCBjaGFyYWN0ZXJzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVVRGOENoYXJzID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0cikpWzBdO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBVVEY4IGJ5dGVzIG9mIGEgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY2FsY3VsYXRlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgVVRGOCBieXRlc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmNhbGN1bGF0ZVVURjhCeXRlcyA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgIHJldHVybiB1dGZ4LmNhbGN1bGF0ZVVURjE2YXNVVEY4KHN0cmluZ1NvdXJjZShzdHIpKVsxXTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgVVRGOCBieXRlcyBvZiBhIHN0cmluZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVVVEY4Qnl0ZXN9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjYWxjdWxhdGVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBVVEY4IGJ5dGVzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlU3RyaW5nID0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVVVEY4Qnl0ZXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhbiBVVEY4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgY2hhcmFjdGVycyBvciBieXRlcyB0byByZWFkLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBtZXRyaWNzIE1ldHJpY3Mgc3BlY2lmeWluZyB3aGF0IGBsZW5ndGhgIGlzIG1lYW50IHRvIGNvdW50LiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLk1FVFJJQ1NfQ0hBUlN9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8IXtzdHJpbmc6IHN0cmluZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgc3RyaW5nIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHN0cmluZ1xyXG4gICAgICogIHJlYWQgYW5kIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVURjhTdHJpbmcgPSBmdW5jdGlvbihsZW5ndGgsIG1ldHJpY3MsIG9mZnNldCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWV0cmljcyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gbWV0cmljcztcclxuICAgICAgICAgICAgbWV0cmljcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0cmljcyA9PT0gJ3VuZGVmaW5lZCcpIG1ldHJpY3MgPSBCeXRlQnVmZmVyLk1FVFJJQ1NfQ0hBUlM7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBsZW5ndGggJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgbGVuZ3RoOiBcIitsZW5ndGgrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIGxlbmd0aCB8PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpID0gMCxcclxuICAgICAgICAgICAgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgICAgIHNkO1xyXG4gICAgICAgIGlmIChtZXRyaWNzID09PSBCeXRlQnVmZmVyLk1FVFJJQ1NfQ0hBUlMpIHsgLy8gVGhlIHNhbWUgZm9yIG5vZGUgYW5kIHRoZSBicm93c2VyXHJcbiAgICAgICAgICAgIHNkID0gc3RyaW5nRGVzdGluYXRpb24oKTtcclxuICAgICAgICAgICAgdXRmeC5kZWNvZGVVVEY4KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgPCBsZW5ndGggJiYgb2Zmc2V0IDwgdGhpcy5saW1pdCA/IHRoaXMudmlld1tvZmZzZXQrK10gOiBudWxsO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIGZ1bmN0aW9uKGNwKSB7XHJcbiAgICAgICAgICAgICAgICArK2k7IHV0ZnguVVRGOHRvVVRGMTYoY3AsIHNkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChpICE9PSBsZW5ndGgpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK2krXCIgPT0gXCIrbGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiOiBzZCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibGVuZ3RoXCI6IG9mZnNldCAtIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXRyaWNzID09PSBCeXRlQnVmZmVyLk1FVFJJQ1NfQllURVMpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgbGVuZ3RoID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiK2xlbmd0aCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBrID0gb2Zmc2V0ICsgbGVuZ3RoO1xyXG4gICAgICAgICAgICB1dGZ4LmRlY29kZVVURjh0b1VURjE2KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCA8IGsgPyB0aGlzLnZpZXdbb2Zmc2V0KytdIDogbnVsbDtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCBzZCA9IHN0cmluZ0Rlc3RpbmF0aW9uKCksIHRoaXMubm9Bc3NlcnQpO1xyXG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBrKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitvZmZzZXQrXCIgPT0gXCIrayk7XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2QoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmluZyc6IHNkKCksXHJcbiAgICAgICAgICAgICAgICAgICAgJ2xlbmd0aCc6IG9mZnNldCAtIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIG1ldHJpY3M6IFwiK21ldHJpY3MpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGFuIFVURjggZW5jb2RlZCBzdHJpbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZFVURjhTdHJpbmd9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBjaGFyYWN0ZXJzIG9yIGJ5dGVzIHRvIHJlYWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbWV0cmljcyBNZXRyaWNzIHNwZWNpZnlpbmcgd2hhdCBgbmAgaXMgbWVhbnQgdG8gY291bnQuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuTUVUUklDU19DSEFSU30uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3whe3N0cmluZzogc3RyaW5nLCBsZW5ndGg6IG51bWJlcn19IFRoZSBzdHJpbmcgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgc3RyaW5nXHJcbiAgICAgKiAgcmVhZCBhbmQgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkU3RyaW5nID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVVRGOFN0cmluZztcclxuXHJcbiAgICAvLyB0eXBlcy9zdHJpbmdzL3ZzdHJpbmdcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIGxlbmd0aCBhcyB2YXJpbnQzMiBwcmVmaXhlZCBVVEY4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IGB0aGlzYCBpZiBgb2Zmc2V0YCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciN3cml0ZVZhcmludDMyXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVWU3RyaW5nID0gZnVuY3Rpb24oc3RyLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgICAgIGssIGw7XHJcbiAgICAgICAgayA9IHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0ciksIHRoaXMubm9Bc3NlcnQpWzFdO1xyXG4gICAgICAgIGwgPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKGspO1xyXG4gICAgICAgIG9mZnNldCArPSBsK2s7XG4gICAgICAgIHZhciBjYXBhY2l0eTE1ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTUpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxNSAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MTUgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gbCtrO1xuICAgICAgICBvZmZzZXQgKz0gdGhpcy53cml0ZVZhcmludDMyKGssIG9mZnNldCk7XHJcbiAgICAgICAgdXRmeC5lbmNvZGVVVEYxNnRvVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gYjtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgIT09IHN0YXJ0K2srbClcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitvZmZzZXQrXCIgPT0gXCIrKG9mZnNldCtrK2wpKTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSBsZW5ndGggYXMgdmFyaW50MzIgcHJlZml4ZWQgVVRGOCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICByZWFkIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCF7c3RyaW5nOiBzdHJpbmcsIGxlbmd0aDogbnVtYmVyfX0gVGhlIHN0cmluZyByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBzdHJpbmdcclxuICAgICAqICByZWFkIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI3JlYWRWYXJpbnQzMlxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRWU3RyaW5nID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzErXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xyXG4gICAgICAgIHZhciBsZW4gPSB0aGlzLnJlYWRWYXJpbnQzMihvZmZzZXQpO1xyXG4gICAgICAgIHZhciBzdHIgPSB0aGlzLnJlYWRVVEY4U3RyaW5nKGxlblsndmFsdWUnXSwgQnl0ZUJ1ZmZlci5NRVRSSUNTX0JZVEVTLCBvZmZzZXQgKz0gbGVuWydsZW5ndGgnXSk7XHJcbiAgICAgICAgb2Zmc2V0ICs9IHN0clsnbGVuZ3RoJ107XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyWydzdHJpbmcnXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgJ3N0cmluZyc6IHN0clsnc3RyaW5nJ10sXHJcbiAgICAgICAgICAgICAgICAnbGVuZ3RoJzogb2Zmc2V0IC0gc3RhcnRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZHMgc29tZSBkYXRhIHRvIHRoaXMgQnl0ZUJ1ZmZlci4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgY29udGVudHMgYmVoaW5kIHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHVwIHRvIHRoZSBhcHBlbmRlZFxyXG4gICAgICogIGRhdGEncyBsZW5ndGguXHJcbiAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfCFBcnJheUJ1ZmZlcnwhVWludDhBcnJheXxzdHJpbmd9IHNvdXJjZSBEYXRhIHRvIGFwcGVuZC4gSWYgYHNvdXJjZWAgaXMgYSBCeXRlQnVmZmVyLCBpdHMgb2Zmc2V0c1xyXG4gICAgICogIHdpbGwgYmUgbW9kaWZpZWQgYWNjb3JkaW5nIHRvIHRoZSBwZXJmb3JtZWQgcmVhZCBvcGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKT19IGVuY29kaW5nIEVuY29kaW5nIGlmIGBkYXRhYCBpcyBhIHN0cmluZyAoXCJiYXNlNjRcIiwgXCJoZXhcIiwgXCJiaW5hcnlcIiwgZGVmYXVsdHMgdG8gXCJ1dGY4XCIpXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gYXBwZW5kIGF0LiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAZXhhbXBsZSBBIHJlbGF0aXZlIGA8MDEgMDI+MDMuYXBwZW5kKDwwNCAwNT4pYCB3aWxsIHJlc3VsdCBpbiBgPDAxIDAyIDA0IDA1PiwgMDQgMDV8YFxyXG4gICAgICogQGV4YW1wbGUgQW4gYWJzb2x1dGUgYDwwMSAwMj4wMy5hcHBlbmQoMDQgMDU+LCAxKWAgd2lsbCByZXN1bHQgaW4gYDwwMSAwND4wNSwgMDQgMDV8YFxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKHNvdXJjZSwgZW5jb2RpbmcsIG9mZnNldCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdudW1iZXInIHx8IHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5jb2Rpbmc7XHJcbiAgICAgICAgICAgIGVuY29kaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBCeXRlQnVmZmVyKSlcclxuICAgICAgICAgICAgc291cmNlID0gQnl0ZUJ1ZmZlci53cmFwKHNvdXJjZSwgZW5jb2RpbmcpO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBzb3VyY2UubGltaXQgLSBzb3VyY2Uub2Zmc2V0O1xyXG4gICAgICAgIGlmIChsZW5ndGggPD0gMCkgcmV0dXJuIHRoaXM7IC8vIE5vdGhpbmcgdG8gYXBwZW5kXHJcbiAgICAgICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgdmFyIGNhcGFjaXR5MTYgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxNilcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTE2ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkxNiA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSBsZW5ndGg7XG4gICAgICAgIHRoaXMudmlldy5zZXQoc291cmNlLnZpZXcuc3ViYXJyYXkoc291cmNlLm9mZnNldCwgc291cmNlLmxpbWl0KSwgb2Zmc2V0KTtcclxuICAgICAgICBzb3VyY2Uub2Zmc2V0ICs9IGxlbmd0aDtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cyB0byBhbm90aGVyIEJ5dGVCdWZmZXIuIFRoaXMgd2lsbCBvdmVyd3JpdGUgYW55IGNvbnRlbnRzIGF0IGFuZCBhZnRlciB0aGVcclxuICAgICAgICBzcGVjaWZpZWQgb2Zmc2V0IHVwIHRvIHRoZSBsZW5ndGggb2YgdGhpcyBCeXRlQnVmZmVyJ3MgZGF0YS5cclxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ9IHRhcmdldCBUYXJnZXQgQnl0ZUJ1ZmZlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIGFwcGVuZCB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI2FwcGVuZFxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmFwcGVuZFRvID0gZnVuY3Rpb24odGFyZ2V0LCBvZmZzZXQpIHtcclxuICAgICAgICB0YXJnZXQuYXBwZW5kKHRoaXMsIG9mZnNldCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBhc3NlcnRpb25zIG9mIGFyZ3VtZW50IHR5cGVzIGFuZCBvZmZzZXRzLiBBc3NlcnRpb25zIGFyZSBlbmFibGVkIGJ5IGRlZmF1bHQgYnV0IHlvdSBjYW4gb3B0IHRvXHJcbiAgICAgKiAgZGlzYWJsZSB0aGVtIGlmIHlvdXIgY29kZSBhbHJlYWR5IG1ha2VzIHN1cmUgdGhhdCBldmVyeXRoaW5nIGlzIHZhbGlkLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhc3NlcnQgYHRydWVgIHRvIGVuYWJsZSBhc3NlcnRpb25zLCBvdGhlcndpc2UgYGZhbHNlYFxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuYXNzZXJ0ID0gZnVuY3Rpb24oYXNzZXJ0KSB7XHJcbiAgICAgICAgdGhpcy5ub0Fzc2VydCA9ICFhc3NlcnQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY2FwYWNpdHkgb2YgdGhpcyBCeXRlQnVmZmVyJ3MgYmFja2luZyBidWZmZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBDYXBhY2l0eSBvZiB0aGUgYmFja2luZyBidWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5jYXBhY2l0eSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoaXMgQnl0ZUJ1ZmZlcidzIG9mZnNldHMgYnkgc2V0dGluZyB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IHRvIGAwYCBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9IHRvIHRoZVxyXG4gICAgICogIGJhY2tpbmcgYnVmZmVyJ3MgY2FwYWNpdHkuIERpc2NhcmRzIHtAbGluayBCeXRlQnVmZmVyI21hcmtlZE9mZnNldH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLmxpbWl0ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcclxuICAgICAgICB0aGlzLm1hcmtlZE9mZnNldCA9IC0xO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjbG9uZWQgaW5zdGFuY2Ugb2YgdGhpcyBCeXRlQnVmZmVyLCBwcmVzZXQgd2l0aCB0aGlzIEJ5dGVCdWZmZXIncyB2YWx1ZXMgZm9yIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0sXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjbWFya2VkT2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gY29weSBXaGV0aGVyIHRvIGNvcHkgdGhlIGJhY2tpbmcgYnVmZmVyIG9yIHRvIHJldHVybiBhbm90aGVyIHZpZXcgb24gdGhlIHNhbWUsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQ2xvbmVkIGluc3RhbmNlXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbihjb3B5KSB7XHJcbiAgICAgICAgdmFyIGJiID0gbmV3IEJ5dGVCdWZmZXIoMCwgdGhpcy5saXR0bGVFbmRpYW4sIHRoaXMubm9Bc3NlcnQpO1xyXG4gICAgICAgIGlmIChjb3B5KSB7XHJcbiAgICAgICAgICAgIGJiLmJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgYmIudmlldyA9IG5ldyBVaW50OEFycmF5KGJiLmJ1ZmZlcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYmIuYnVmZmVyID0gdGhpcy5idWZmZXI7XHJcbiAgICAgICAgICAgIGJiLnZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJiLm9mZnNldCA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGJiLm1hcmtlZE9mZnNldCA9IHRoaXMubWFya2VkT2Zmc2V0O1xyXG4gICAgICAgIGJiLmxpbWl0ID0gdGhpcy5saW1pdDtcclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFjdHMgdGhpcyBCeXRlQnVmZmVyIHRvIGJlIGJhY2tlZCBieSBhIHtAbGluayBCeXRlQnVmZmVyI2J1ZmZlcn0gb2YgaXRzIGNvbnRlbnRzJyBsZW5ndGguIENvbnRlbnRzIGFyZSB0aGUgYnl0ZXNcclxuICAgICAqICBiZXR3ZWVuIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS4gV2lsbCBzZXQgYG9mZnNldCA9IDBgIGFuZCBgbGltaXQgPSBjYXBhY2l0eWAgYW5kXHJcbiAgICAgKiAgYWRhcHQge0BsaW5rIEJ5dGVCdWZmZXIjbWFya2VkT2Zmc2V0fSB0byB0aGUgc2FtZSByZWxhdGl2ZSBwb3NpdGlvbiBpZiBzZXQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBzdGFydCBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgT2Zmc2V0IHRvIGVuZCBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9XHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKSBiZWdpbiA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykgZW5kID0gdGhpcy5saW1pdDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiAhPT0gJ251bWJlcicgfHwgYmVnaW4gJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgYmVnaW4gPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IGVuZCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgZW5kID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDAgfHwgYmVnaW4gPiBlbmQgfHwgZW5kID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitiZWdpbitcIiA8PSBcIitlbmQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmVnaW4gPT09IDAgJiYgZW5kID09PSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gQWxyZWFkeSBjb21wYWN0ZWRcclxuICAgICAgICB2YXIgbGVuID0gZW5kIC0gYmVnaW47XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEVNUFRZX0JVRkZFUjtcclxuICAgICAgICAgICAgdGhpcy52aWV3ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VkT2Zmc2V0ID49IDApIHRoaXMubWFya2VkT2Zmc2V0IC09IGJlZ2luO1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubGltaXQgPSAwO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihsZW4pO1xyXG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcclxuICAgICAgICB2aWV3LnNldCh0aGlzLnZpZXcuc3ViYXJyYXkoYmVnaW4sIGVuZCkpO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgICAgaWYgKHRoaXMubWFya2VkT2Zmc2V0ID49IDApIHRoaXMubWFya2VkT2Zmc2V0IC09IGJlZ2luO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLmxpbWl0ID0gbGVuO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzLiBDb250ZW50cyBhcmUgdGhlIGJ5dGVzIGJldHdlZW4ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmRcclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIEJlZ2luIG9mZnNldCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIEVuZCBvZmZzZXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQ29weVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiZWdpbiA9PT0gZW5kKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVCdWZmZXIoMCwgdGhpcy5saXR0bGVFbmRpYW4sIHRoaXMubm9Bc3NlcnQpO1xyXG4gICAgICAgIHZhciBjYXBhY2l0eSA9IGVuZCAtIGJlZ2luLFxyXG4gICAgICAgICAgICBiYiA9IG5ldyBCeXRlQnVmZmVyKGNhcGFjaXR5LCB0aGlzLmxpdHRsZUVuZGlhbiwgdGhpcy5ub0Fzc2VydCk7XHJcbiAgICAgICAgYmIub2Zmc2V0ID0gMDtcclxuICAgICAgICBiYi5saW1pdCA9IGNhcGFjaXR5O1xyXG4gICAgICAgIGlmIChiYi5tYXJrZWRPZmZzZXQgPj0gMCkgYmIubWFya2VkT2Zmc2V0IC09IGJlZ2luO1xyXG4gICAgICAgIHRoaXMuY29weVRvKGJiLCAwLCBiZWdpbiwgZW5kKTtcclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29waWVzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIHRvIGFub3RoZXIgQnl0ZUJ1ZmZlci4gQ29udGVudHMgYXJlIHRoZSBieXRlcyBiZXR3ZWVuIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcn0gdGFyZ2V0IFRhcmdldCBCeXRlQnVmZmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHRhcmdldE9mZnNldCBPZmZzZXQgdG8gY29weSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHRoZSB0YXJnZXQncyB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9XHJcbiAgICAgKiAgYnkgdGhlIG51bWJlciBvZiBieXRlcyBjb3BpZWQgaWYgb21pdHRlZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gc291cmNlT2Zmc2V0IE9mZnNldCB0byBzdGFydCBjb3B5aW5nIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZVxyXG4gICAgICogIG51bWJlciBvZiBieXRlcyBjb3BpZWQgaWYgb21pdHRlZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gc291cmNlTGltaXQgT2Zmc2V0IHRvIGVuZCBjb3B5aW5nIGZyb20sIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fVxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuY29weVRvID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRPZmZzZXQsIHNvdXJjZU9mZnNldCwgc291cmNlTGltaXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUsXHJcbiAgICAgICAgICAgIHRhcmdldFJlbGF0aXZlO1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAoIUJ5dGVCdWZmZXIuaXNCeXRlQnVmZmVyKHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHRhcmdldDogTm90IGEgQnl0ZUJ1ZmZlclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFyZ2V0T2Zmc2V0ID0gKHRhcmdldFJlbGF0aXZlID0gdHlwZW9mIHRhcmdldE9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpID8gdGFyZ2V0Lm9mZnNldCA6IHRhcmdldE9mZnNldCB8IDA7XHJcbiAgICAgICAgc291cmNlT2Zmc2V0ID0gKHJlbGF0aXZlID0gdHlwZW9mIHNvdXJjZU9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpID8gdGhpcy5vZmZzZXQgOiBzb3VyY2VPZmZzZXQgfCAwO1xyXG4gICAgICAgIHNvdXJjZUxpbWl0ID0gdHlwZW9mIHNvdXJjZUxpbWl0ID09PSAndW5kZWZpbmVkJyA/IHRoaXMubGltaXQgOiBzb3VyY2VMaW1pdCB8IDA7XHJcblxyXG4gICAgICAgIGlmICh0YXJnZXRPZmZzZXQgPCAwIHx8IHRhcmdldE9mZnNldCA+IHRhcmdldC5idWZmZXIuYnl0ZUxlbmd0aClcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgdGFyZ2V0IHJhbmdlOiAwIDw9IFwiK3RhcmdldE9mZnNldCtcIiA8PSBcIit0YXJnZXQuYnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIGlmIChzb3VyY2VPZmZzZXQgPCAwIHx8IHNvdXJjZUxpbWl0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgc291cmNlIHJhbmdlOiAwIDw9IFwiK3NvdXJjZU9mZnNldCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcclxuXHJcbiAgICAgICAgdmFyIGxlbiA9IHNvdXJjZUxpbWl0IC0gc291cmNlT2Zmc2V0O1xyXG4gICAgICAgIGlmIChsZW4gPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7IC8vIE5vdGhpbmcgdG8gY29weVxyXG5cclxuICAgICAgICB0YXJnZXQuZW5zdXJlQ2FwYWNpdHkodGFyZ2V0T2Zmc2V0ICsgbGVuKTtcclxuXHJcbiAgICAgICAgdGFyZ2V0LnZpZXcuc2V0KHRoaXMudmlldy5zdWJhcnJheShzb3VyY2VPZmZzZXQsIHNvdXJjZUxpbWl0KSwgdGFyZ2V0T2Zmc2V0KTtcclxuXHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSBsZW47XHJcbiAgICAgICAgaWYgKHRhcmdldFJlbGF0aXZlKSB0YXJnZXQub2Zmc2V0ICs9IGxlbjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFrZXMgc3VyZSB0aGF0IHRoaXMgQnl0ZUJ1ZmZlciBpcyBiYWNrZWQgYnkgYSB7QGxpbmsgQnl0ZUJ1ZmZlciNidWZmZXJ9IG9mIGF0IGxlYXN0IHRoZSBzcGVjaWZpZWQgY2FwYWNpdHkuIElmIHRoZVxyXG4gICAgICogIGN1cnJlbnQgY2FwYWNpdHkgaXMgZXhjZWVkZWQsIGl0IHdpbGwgYmUgZG91YmxlZC4gSWYgZG91YmxlIHRoZSBjdXJyZW50IGNhcGFjaXR5IGlzIGxlc3MgdGhhbiB0aGUgcmVxdWlyZWQgY2FwYWNpdHksXHJcbiAgICAgKiAgdGhlIHJlcXVpcmVkIGNhcGFjaXR5IHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNhcGFjaXR5IFJlcXVpcmVkIGNhcGFjaXR5XHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5lbnN1cmVDYXBhY2l0eSA9IGZ1bmN0aW9uKGNhcGFjaXR5KSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIGlmIChjdXJyZW50IDwgY2FwYWNpdHkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZSgoY3VycmVudCAqPSAyKSA+IGNhcGFjaXR5ID8gY3VycmVudCA6IGNhcGFjaXR5KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVyd3JpdGVzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZS4gQ29udGVudHMgYXJlIHRoZSBieXRlcyBiZXR3ZWVuXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZSBCeXRlIHZhbHVlIHRvIGZpbGwgd2l0aC4gSWYgZ2l2ZW4gYXMgYSBzdHJpbmcsIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgdXNlZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gQmVnaW4gb2Zmc2V0LiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLiBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgRW5kIG9mZnNldCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAZXhhbXBsZSBgc29tZUJ5dGVCdWZmZXIuY2xlYXIoKS5maWxsKDApYCBmaWxscyB0aGUgZW50aXJlIGJhY2tpbmcgYnVmZmVyIHdpdGggemVyb2VzXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uKHZhbHVlLCBiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBiZWdpbiA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlIHw9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiZWdpbiA+PSBlbmQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBOb3RoaW5nIHRvIGZpbGxcclxuICAgICAgICB3aGlsZSAoYmVnaW4gPCBlbmQpIHRoaXMudmlld1tiZWdpbisrXSA9IHZhbHVlO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgPSBiZWdpbjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyB0aGlzIEJ5dGVCdWZmZXIgcmVhZHkgZm9yIGEgbmV3IHNlcXVlbmNlIG9mIHdyaXRlIG9yIHJlbGF0aXZlIHJlYWQgb3BlcmF0aW9ucy4gU2V0cyBgbGltaXQgPSBvZmZzZXRgIGFuZFxyXG4gICAgICogIGBvZmZzZXQgPSAwYC4gTWFrZSBzdXJlIGFsd2F5cyB0byBmbGlwIGEgQnl0ZUJ1ZmZlciB3aGVuIGFsbCByZWxhdGl2ZSByZWFkIG9yIHdyaXRlIG9wZXJhdGlvbnMgYXJlIGNvbXBsZXRlLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuZmxpcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMubGltaXQgPSB0aGlzLm9mZnNldDtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYXJrcyBhbiBvZmZzZXQgb24gdGhpcyBCeXRlQnVmZmVyIHRvIGJlIHVzZWQgbGF0ZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gbWFyay4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNyZXNldFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLm1hcmsgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICBvZmZzZXQgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJyA/IHRoaXMub2Zmc2V0IDogb2Zmc2V0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXJrZWRPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBieXRlIG9yZGVyLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBsaXR0bGVFbmRpYW4gYHRydWVgIGZvciBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIsIGBmYWxzZWAgZm9yIGJpZyBlbmRpYW5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLm9yZGVyID0gZnVuY3Rpb24obGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGl0dGxlRW5kaWFuICE9PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxpdHRsZUVuZGlhbjogTm90IGEgYm9vbGVhblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saXR0bGVFbmRpYW4gPSAhIWxpdHRsZUVuZGlhbjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTd2l0Y2hlcyAodG8pIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBEZWZhdWx0cyB0byBgdHJ1ZWAsIG90aGVyd2lzZSB1c2VzIGJpZyBlbmRpYW5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLkxFID0gZnVuY3Rpb24obGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgdGhpcy5saXR0bGVFbmRpYW4gPSB0eXBlb2YgbGl0dGxlRW5kaWFuICE9PSAndW5kZWZpbmVkJyA/ICEhbGl0dGxlRW5kaWFuIDogdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTd2l0Y2hlcyAodG8pIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGJpZ0VuZGlhbiBEZWZhdWx0cyB0byBgdHJ1ZWAsIG90aGVyd2lzZSB1c2VzIGxpdHRsZSBlbmRpYW5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLkJFID0gZnVuY3Rpb24oYmlnRW5kaWFuKSB7XHJcbiAgICAgICAgdGhpcy5saXR0bGVFbmRpYW4gPSB0eXBlb2YgYmlnRW5kaWFuICE9PSAndW5kZWZpbmVkJyA/ICFiaWdFbmRpYW4gOiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFByZXBlbmRzIHNvbWUgZGF0YSB0byB0aGlzIEJ5dGVCdWZmZXIuIFRoaXMgd2lsbCBvdmVyd3JpdGUgYW55IGNvbnRlbnRzIGJlZm9yZSB0aGUgc3BlY2lmaWVkIG9mZnNldCB1cCB0byB0aGVcclxuICAgICAqICBwcmVwZW5kZWQgZGF0YSdzIGxlbmd0aC4gSWYgdGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSBhdmFpbGFibGUgYmVmb3JlIHRoZSBzcGVjaWZpZWQgYG9mZnNldGAsIHRoZSBiYWNraW5nIGJ1ZmZlclxyXG4gICAgICogIHdpbGwgYmUgcmVzaXplZCBhbmQgaXRzIGNvbnRlbnRzIG1vdmVkIGFjY29yZGluZ2x5LlxyXG4gICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcnxzdHJpbmd8IUFycmF5QnVmZmVyfSBzb3VyY2UgRGF0YSB0byBwcmVwZW5kLiBJZiBgc291cmNlYCBpcyBhIEJ5dGVCdWZmZXIsIGl0cyBvZmZzZXQgd2lsbCBiZVxyXG4gICAgICogIG1vZGlmaWVkIGFjY29yZGluZyB0byB0aGUgcGVyZm9ybWVkIHJlYWQgb3BlcmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcik9fSBlbmNvZGluZyBFbmNvZGluZyBpZiBgZGF0YWAgaXMgYSBzdHJpbmcgKFwiYmFzZTY0XCIsIFwiaGV4XCIsIFwiYmluYXJ5XCIsIGRlZmF1bHRzIHRvIFwidXRmOFwiKVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHByZXBlbmQgYXQuIFdpbGwgdXNlIGFuZCBkZWNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICBwcmVwZW5kZWQgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQGV4YW1wbGUgQSByZWxhdGl2ZSBgMDA8MDEgMDIgMDM+LnByZXBlbmQoPDA0IDA1PilgIHJlc3VsdHMgaW4gYDwwNCAwNSAwMSAwMiAwMz4sIDA0IDA1fGBcclxuICAgICAqIEBleGFtcGxlIEFuIGFic29sdXRlIGAwMDwwMSAwMiAwMz4ucHJlcGVuZCg8MDQgMDU+LCAyKWAgcmVzdWx0cyBpbiBgMDQ8MDUgMDIgMDM+LCAwNCAwNXxgXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uKHNvdXJjZSwgZW5jb2RpbmcsIG9mZnNldCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdudW1iZXInIHx8IHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5jb2Rpbmc7XHJcbiAgICAgICAgICAgIGVuY29kaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBCeXRlQnVmZmVyKSlcclxuICAgICAgICAgICAgc291cmNlID0gQnl0ZUJ1ZmZlci53cmFwKHNvdXJjZSwgZW5jb2RpbmcpO1xyXG4gICAgICAgIHZhciBsZW4gPSBzb3VyY2UubGltaXQgLSBzb3VyY2Uub2Zmc2V0O1xyXG4gICAgICAgIGlmIChsZW4gPD0gMCkgcmV0dXJuIHRoaXM7IC8vIE5vdGhpbmcgdG8gcHJlcGVuZFxyXG4gICAgICAgIHZhciBkaWZmID0gbGVuIC0gb2Zmc2V0O1xyXG4gICAgICAgIGlmIChkaWZmID4gMCkgeyAvLyBOb3QgZW5vdWdoIHNwYWNlIGJlZm9yZSBvZmZzZXQsIHNvIHJlc2l6ZSArIG1vdmVcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoICsgZGlmZik7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcclxuICAgICAgICAgICAgdmlldy5zZXQodGhpcy52aWV3LnN1YmFycmF5KG9mZnNldCwgdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCksIGxlbik7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCArPSBkaWZmO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZWRPZmZzZXQgPj0gMCkgdGhpcy5tYXJrZWRPZmZzZXQgKz0gZGlmZjtcclxuICAgICAgICAgICAgdGhpcy5saW1pdCArPSBkaWZmO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gZGlmZjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgYXJyYXlWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZpZXcuc2V0KHNvdXJjZS52aWV3LnN1YmFycmF5KHNvdXJjZS5vZmZzZXQsIHNvdXJjZS5saW1pdCksIG9mZnNldCAtIGxlbik7XHJcblxyXG4gICAgICAgIHNvdXJjZS5vZmZzZXQgPSBzb3VyY2UubGltaXQ7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKVxyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCAtPSBsZW47XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJlcGVuZHMgdGhpcyBCeXRlQnVmZmVyIHRvIGFub3RoZXIgQnl0ZUJ1ZmZlci4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgY29udGVudHMgYmVmb3JlIHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHVwIHRvIHRoZVxyXG4gICAgICogIHByZXBlbmRlZCBkYXRhJ3MgbGVuZ3RoLiBJZiB0aGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSBiZWZvcmUgdGhlIHNwZWNpZmllZCBgb2Zmc2V0YCwgdGhlIGJhY2tpbmcgYnVmZmVyXHJcbiAgICAgKiAgd2lsbCBiZSByZXNpemVkIGFuZCBpdHMgY29udGVudHMgbW92ZWQgYWNjb3JkaW5nbHkuXHJcbiAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfSB0YXJnZXQgVGFyZ2V0IEJ5dGVCdWZmZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byBwcmVwZW5kIGF0LiBXaWxsIHVzZSBhbmQgZGVjcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcHJlcGVuZGVkIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNwcmVwZW5kXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucHJlcGVuZFRvID0gZnVuY3Rpb24odGFyZ2V0LCBvZmZzZXQpIHtcclxuICAgICAgICB0YXJnZXQucHJlcGVuZCh0aGlzLCBvZmZzZXQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUHJpbnRzIGRlYnVnIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpPX0gb3V0IE91dHB1dCBmdW5jdGlvbiB0byBjYWxsLCBkZWZhdWx0cyB0byBjb25zb2xlLmxvZ1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnByaW50RGVidWcgPSBmdW5jdGlvbihvdXQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG91dCAhPT0gJ2Z1bmN0aW9uJykgb3V0ID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcclxuICAgICAgICBvdXQoXHJcbiAgICAgICAgICAgIHRoaXMudG9TdHJpbmcoKStcIlxcblwiK1xyXG4gICAgICAgICAgICBcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIitcclxuICAgICAgICAgICAgdGhpcy50b0RlYnVnKC8qIGNvbHVtbnMgKi8gdHJ1ZSlcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiByZW1haW5pbmcgcmVhZGFibGUgYnl0ZXMuIENvbnRlbnRzIGFyZSB0aGUgYnl0ZXMgYmV0d2VlbiB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGFuZFxyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fSwgc28gdGhpcyByZXR1cm5zIGBsaW1pdCAtIG9mZnNldGAuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZW1haW5pbmcgcmVhZGFibGUgYnl0ZXMuIE1heSBiZSBuZWdhdGl2ZSBpZiBgb2Zmc2V0ID4gbGltaXRgLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlbWFpbmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpbWl0IC0gdGhpcy5vZmZzZXQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhpcyBCeXRlQnVmZmVyJ3Mge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS4gSWYgYW4gb2Zmc2V0IGhhcyBiZWVuIG1hcmtlZCB0aHJvdWdoIHtAbGluayBCeXRlQnVmZmVyI21hcmt9XHJcbiAgICAgKiAgYmVmb3JlLCBgb2Zmc2V0YCB3aWxsIGJlIHNldCB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNtYXJrZWRPZmZzZXR9LCB3aGljaCB3aWxsIHRoZW4gYmUgZGlzY2FyZGVkLiBJZiBubyBvZmZzZXQgaGFzIGJlZW5cclxuICAgICAqICBtYXJrZWQsIHNldHMgYG9mZnNldCA9IDBgLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjbWFya1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubWFya2VkT2Zmc2V0ID49IDApIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLm1hcmtlZE9mZnNldDtcclxuICAgICAgICAgICAgdGhpcy5tYXJrZWRPZmZzZXQgPSAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplcyB0aGlzIEJ5dGVCdWZmZXIgdG8gYmUgYmFja2VkIGJ5IGEgYnVmZmVyIG9mIGF0IGxlYXN0IHRoZSBnaXZlbiBjYXBhY2l0eS4gV2lsbCBkbyBub3RoaW5nIGlmIGFscmVhZHkgdGhhdFxyXG4gICAgICogIGxhcmdlIG9yIGxhcmdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjYXBhY2l0eSBDYXBhY2l0eSByZXF1aXJlZFxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBjYXBhY2l0eWAgaXMgbm90IGEgbnVtYmVyXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgY2FwYWNpdHkgPCAwYFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKGNhcGFjaXR5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FwYWNpdHkgIT09ICdudW1iZXInIHx8IGNhcGFjaXR5ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGNhcGFjaXR5OiBcIitjYXBhY2l0eStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgY2FwYWNpdHkgfD0gMDtcbiAgICAgICAgICAgIGlmIChjYXBhY2l0eSA8IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBjYXBhY2l0eTogMCA8PSBcIitjYXBhY2l0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoIDwgY2FwYWNpdHkpIHtcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihjYXBhY2l0eSk7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcclxuICAgICAgICAgICAgdmlldy5zZXQodGhpcy52aWV3KTtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV2ZXJzZXMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBzdGFydCBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgT2Zmc2V0IHRvIGVuZCBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9XHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKSBiZWdpbiA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykgZW5kID0gdGhpcy5saW1pdDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiAhPT0gJ251bWJlcicgfHwgYmVnaW4gJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgYmVnaW4gPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IGVuZCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgZW5kID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDAgfHwgYmVnaW4gPiBlbmQgfHwgZW5kID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitiZWdpbitcIiA8PSBcIitlbmQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmVnaW4gPT09IGVuZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIE5vdGhpbmcgdG8gcmV2ZXJzZVxyXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwodGhpcy52aWV3LnN1YmFycmF5KGJlZ2luLCBlbmQpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNraXBzIHRoZSBuZXh0IGBsZW5ndGhgIGJ5dGVzLiBUaGlzIHdpbGwganVzdCBhZHZhbmNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byBza2lwLiBNYXkgYWxzbyBiZSBuZWdhdGl2ZSB0byBtb3ZlIHRoZSBvZmZzZXQgYmFjay5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbihsZW5ndGgpIHtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInIHx8IGxlbmd0aCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBsZW5ndGg6IFwiK2xlbmd0aCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgbGVuZ3RoIHw9IDA7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyBsZW5ndGg7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBsZW5ndGg6IDAgPD0gXCIrdGhpcy5vZmZzZXQrXCIgKyBcIitsZW5ndGgrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNsaWNlcyB0aGlzIEJ5dGVCdWZmZXIgYnkgY3JlYXRpbmcgYSBjbG9uZWQgaW5zdGFuY2Ugd2l0aCBgb2Zmc2V0ID0gYmVnaW5gIGFuZCBgbGltaXQgPSBlbmRgLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBCZWdpbiBvZmZzZXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBFbmQgb2Zmc2V0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IENsb25lIG9mIHRoaXMgQnl0ZUJ1ZmZlciB3aXRoIHNsaWNpbmcgYXBwbGllZCwgYmFja2VkIGJ5IHRoZSBzYW1lIHtAbGluayBCeXRlQnVmZmVyI2J1ZmZlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJykgYmVnaW4gPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJiID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgIGJiLm9mZnNldCA9IGJlZ2luO1xyXG4gICAgICAgIGJiLmxpbWl0ID0gZW5kO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBiYWNraW5nIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzLiBDb250ZW50cyBhcmUgdGhlIGJ5dGVzIGJldHdlZW5cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGFuZCB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZUNvcHkgSWYgYHRydWVgIHJldHVybnMgYSBjb3B5LCBvdGhlcndpc2UgcmV0dXJucyBhIHZpZXcgcmVmZXJlbmNpbmcgdGhlIHNhbWUgbWVtb3J5IGlmXHJcbiAgICAgKiAgcG9zc2libGUuIERlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAqIEByZXR1cm5zIHshQXJyYXlCdWZmZXJ9IENvbnRlbnRzIGFzIGFuIEFycmF5QnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbihmb3JjZUNvcHkpIHtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQsXHJcbiAgICAgICAgICAgIGxpbWl0ID0gdGhpcy5saW1pdDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGltaXQgIT09ICdudW1iZXInIHx8IGxpbWl0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxpbWl0OiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGxpbWl0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGxpbWl0IHx8IGxpbWl0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitvZmZzZXQrXCIgPD0gXCIrbGltaXQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICAvLyBOT1RFOiBJdCdzIG5vdCBwb3NzaWJsZSB0byBoYXZlIGFub3RoZXIgQXJyYXlCdWZmZXIgcmVmZXJlbmNlIHRoZSBzYW1lIG1lbW9yeSBhcyB0aGUgYmFja2luZyBidWZmZXIuIFRoaXMgaXNcclxuICAgICAgICAvLyBwb3NzaWJsZSB3aXRoIFVpbnQ4QXJyYXkjc3ViYXJyYXkgb25seSwgYnV0IHdlIGhhdmUgdG8gcmV0dXJuIGFuIEFycmF5QnVmZmVyIGJ5IGNvbnRyYWN0LiBTbzpcclxuICAgICAgICBpZiAoIWZvcmNlQ29weSAmJiBvZmZzZXQgPT09IDAgJiYgbGltaXQgPT09IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcjtcclxuICAgICAgICBpZiAob2Zmc2V0ID09PSBsaW1pdClcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0JVRkZFUjtcclxuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGxpbWl0IC0gb2Zmc2V0KTtcclxuICAgICAgICBuZXcgVWludDhBcnJheShidWZmZXIpLnNldChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcikuc3ViYXJyYXkob2Zmc2V0LCBsaW1pdCksIDApO1xyXG4gICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhdyBidWZmZXIgY29tcGFjdGVkIHRvIGNvbnRhaW4gdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMuIENvbnRlbnRzIGFyZSB0aGUgYnl0ZXMgYmV0d2VlblxyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN0b0J1ZmZlcn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlQ29weSBJZiBgdHJ1ZWAgcmV0dXJucyBhIGNvcHksIG90aGVyd2lzZSByZXR1cm5zIGEgdmlldyByZWZlcmVuY2luZyB0aGUgc2FtZSBtZW1vcnkuXHJcbiAgICAgKiAgRGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICogQHJldHVybnMgeyFBcnJheUJ1ZmZlcn0gQ29udGVudHMgYXMgYW4gQXJyYXlCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS50b0J1ZmZlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBCeXRlQnVmZmVyJ3MgY29udGVudHMgdG8gYSBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGVuY29kaW5nIE91dHB1dCBlbmNvZGluZy4gUmV0dXJucyBhbiBpbmZvcm1hdGl2ZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gaWYgb21pdHRlZCBidXQgYWxzbyBhbGxvd3NcclxuICAgICAqICBkaXJlY3QgY29udmVyc2lvbiB0byBcInV0ZjhcIiwgXCJoZXhcIiwgXCJiYXNlNjRcIiBhbmQgXCJiaW5hcnlcIiBlbmNvZGluZy4gXCJkZWJ1Z1wiIHJldHVybnMgYSBoZXggcmVwcmVzZW50YXRpb24gd2l0aFxyXG4gICAgICogIGhpZ2hsaWdodGVkIG9mZnNldHMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBiZWdpbiBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgT2Zmc2V0IHRvIGVuZCBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9XHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb25cclxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgZW5jb2RpbmdgIGlzIGludmFsaWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIHJldHVybiBcIkJ5dGVCdWZmZXJBQihvZmZzZXQ9XCIrdGhpcy5vZmZzZXQrXCIsbWFya2VkT2Zmc2V0PVwiK3RoaXMubWFya2VkT2Zmc2V0K1wiLGxpbWl0PVwiK3RoaXMubGltaXQrXCIsY2FwYWNpdHk9XCIrdGhpcy5jYXBhY2l0eSgpK1wiKVwiO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICBlbmNvZGluZyA9IFwidXRmOFwiLFxyXG4gICAgICAgICAgICBiZWdpbiA9IGVuY29kaW5nLFxyXG4gICAgICAgICAgICBlbmQgPSBiZWdpbjtcclxuICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ1dGY4XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b1VURjgoYmVnaW4sIGVuZCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQmFzZTY0KGJlZ2luLCBlbmQpO1xyXG4gICAgICAgICAgICBjYXNlIFwiaGV4XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0hleChiZWdpbiwgZW5kKTtcclxuICAgICAgICAgICAgY2FzZSBcImJpbmFyeVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CaW5hcnkoYmVnaW4sIGVuZCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EZWJ1ZygpO1xyXG4gICAgICAgICAgICBjYXNlIFwiY29sdW1uc1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Db2x1bW5zKCk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuc3VwcG9ydGVkIGVuY29kaW5nOiBcIitlbmNvZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBseGl2LWVtYmVkZGFibGVcclxuXHJcbiAgICAvKipcclxuICAgICAqIGx4aXYtZW1iZWRkYWJsZSAoYykgMjAxNCBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gICAgICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxyXG4gICAgICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9seGl2IGZvciBkZXRhaWxzXHJcbiAgICAgKi9cclxuICAgIHZhciBseGl2ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGx4aXYgbmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICogQGV4cG9ydHMgbHhpdlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBseGl2ID0ge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoYXJhY3RlciBjb2RlcyBmb3Igb3V0cHV0LlxyXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXkuPG51bWJlcj59XHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGFvdXQgPSBbXHJcbiAgICAgICAgICAgIDY1LCA2NiwgNjcsIDY4LCA2OSwgNzAsIDcxLCA3MiwgNzMsIDc0LCA3NSwgNzYsIDc3LCA3OCwgNzksIDgwLFxyXG4gICAgICAgICAgICA4MSwgODIsIDgzLCA4NCwgODUsIDg2LCA4NywgODgsIDg5LCA5MCwgOTcsIDk4LCA5OSwgMTAwLCAxMDEsIDEwMixcclxuICAgICAgICAgICAgMTAzLCAxMDQsIDEwNSwgMTA2LCAxMDcsIDEwOCwgMTA5LCAxMTAsIDExMSwgMTEyLCAxMTMsIDExNCwgMTE1LCAxMTYsIDExNywgMTE4LFxyXG4gICAgICAgICAgICAxMTksIDEyMCwgMTIxLCAxMjIsIDQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA0MywgNDdcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGFyYWN0ZXIgY29kZXMgZm9yIGlucHV0LlxyXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXkuPG51bWJlcj59XHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGk9MCwgaz1hb3V0Lmxlbmd0aDsgaTxrOyArK2kpXHJcbiAgICAgICAgICAgIGFpblthb3V0W2ldXSA9IGk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgYnl0ZXMgdG8gYmFzZTY0IGNoYXIgY29kZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIEJ5dGVzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBieXRlIHJlc3BlY3RpdmVseSBgbnVsbGAgaWZcclxuICAgICAgICAgKiAgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgbGVmdC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQ2hhcmFjdGVycyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCBlYWNoIGVuY29kZWQgY2hhclxyXG4gICAgICAgICAqICBjb2RlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGx4aXYuZW5jb2RlID0gZnVuY3Rpb24oc3JjLCBkc3QpIHtcclxuICAgICAgICAgICAgdmFyIGIsIHQ7XHJcbiAgICAgICAgICAgIHdoaWxlICgoYiA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZHN0KGFvdXRbKGI+PjIpJjB4M2ZdKTtcclxuICAgICAgICAgICAgICAgIHQgPSAoYiYweDMpPDw0O1xyXG4gICAgICAgICAgICAgICAgaWYgKChiID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdCB8PSAoYj4+NCkmMHhmO1xyXG4gICAgICAgICAgICAgICAgICAgIGRzdChhb3V0Wyh0fCgoYj4+NCkmMHhmKSkmMHgzZl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHQgPSAoYiYweGYpPDwyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYiA9IHNyYygpKSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHN0KGFvdXRbKHR8KChiPj42KSYweDMpKSYweDNmXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRzdChhb3V0W2ImMHgzZl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHN0KGFvdXRbdCYweDNmXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRzdCg2MSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBkc3QoYW91dFt0JjB4M2ZdKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoNjEpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCg2MSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIGJhc2U2NCBjaGFyIGNvZGVzIHRvIGJ5dGVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCk6bnVtYmVyfG51bGx9IHNyYyBDaGFyYWN0ZXJzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBjaGFyIGNvZGUgcmVzcGVjdGl2ZWx5XHJcbiAgICAgICAgICogIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzIGxlZnQuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gZHN0IEJ5dGVzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIHRoZSBuZXh0IGJ5dGUuXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGEgY2hhcmFjdGVyIGNvZGUgaXMgaW52YWxpZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGx4aXYuZGVjb2RlID0gZnVuY3Rpb24oc3JjLCBkc3QpIHtcclxuICAgICAgICAgICAgdmFyIGMsIHQxLCB0MjtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZmFpbChjKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgY2hhcmFjdGVyIGNvZGU6IFwiK2MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlICgoYyA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdDEgPSBhaW5bY107XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHQxID09PSAndW5kZWZpbmVkJykgZmFpbChjKTtcclxuICAgICAgICAgICAgICAgIGlmICgoYyA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHQyID0gYWluW2NdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdDIgPT09ICd1bmRlZmluZWQnKSBmYWlsKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgodDE8PDIpPj4+MHwodDImMHgzMCk+PjQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYyA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0MSA9IGFpbltjXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0MSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gNjEpIGJyZWFrOyBlbHNlIGZhaWwoYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRzdCgoKHQyJjB4Zik8PDQpPj4+MHwodDEmMHgzYyk+PjIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGMgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQyID0gYWluW2NdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0MiA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IDYxKSBicmVhazsgZWxzZSBmYWlsKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHN0KCgodDEmMHgzKTw8Nik+Pj4wfHQyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIGlmIGEgc3RyaW5nIGlzIHZhbGlkIGJhc2U2NC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byB0ZXN0XHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIGBmYWxzZWBcclxuICAgICAgICAgKi9cclxuICAgICAgICBseGl2LnRlc3QgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KHN0cik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGx4aXY7XHJcbiAgICB9KCk7XHJcblxyXG4gICAgLy8gZW5jb2RpbmdzL2Jhc2U2NFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cyB0byBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gT2Zmc2V0IHRvIGJlZ2luIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgT2Zmc2V0IHRvIGVuZCBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgYmVnaW5gIG9yIGBlbmRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b0Jhc2U2NCA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgYmVnaW4gPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgYmVnaW4gPSBiZWdpbiB8IDA7IGVuZCA9IGVuZCB8IDA7XHJcbiAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBlbmQgPiB0aGlzLmNhcGFjaXR5IHx8IGJlZ2luID4gZW5kKVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiYmVnaW4sIGVuZFwiKTtcclxuICAgICAgICB2YXIgc2Q7IGx4aXYuZW5jb2RlKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYmVnaW4gPCBlbmQgPyB0aGlzLnZpZXdbYmVnaW4rK10gOiBudWxsO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSwgc2QgPSBzdHJpbmdEZXN0aW5hdGlvbigpKTtcclxuICAgICAgICByZXR1cm4gc2QoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgQnl0ZUJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBCeXRlQnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuZnJvbUJhc2U2NCA9IGZ1bmN0aW9uKHN0ciwgbGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJzdHJcIik7XHJcbiAgICAgICAgdmFyIGJiID0gbmV3IEJ5dGVCdWZmZXIoc3RyLmxlbmd0aC80KjMsIGxpdHRsZUVuZGlhbiksXHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIGx4aXYuZGVjb2RlKHN0cmluZ1NvdXJjZShzdHIpLCBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICAgIGJiLnZpZXdbaSsrXSA9IGI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYmIubGltaXQgPSBpO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIGEgYmluYXJ5IHN0cmluZyB0byBiYXNlNjQgbGlrZSBgd2luZG93LmJ0b2FgIGRvZXMuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIEJpbmFyeSBzdHJpbmdcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93LmJ0b2FcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5idG9hID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbUJpbmFyeShzdHIpLnRvQmFzZTY0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byBiaW5hcnkgbGlrZSBgd2luZG93LmF0b2JgIGRvZXMuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYjY0IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQmluYXJ5IHN0cmluZ1xyXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93LmF0b2JcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5hdG9iID0gZnVuY3Rpb24oYjY0KSB7XHJcbiAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbUJhc2U2NChiNjQpLnRvQmluYXJ5KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGVuY29kaW5ncy9iaW5hcnlcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgdGhpcyBCeXRlQnVmZmVyIHRvIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nLCB0aGF0IGlzIHVzaW5nIG9ubHkgY2hhcmFjdGVycyAweDAwLTB4RkYgYXMgYnl0ZXMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBiZWdpbiBhdC4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIE9mZnNldCB0byBlbmQgYXQuIERlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEJpbmFyeSBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldCA+IGxpbWl0YFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvQmluYXJ5ID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBiZWdpbiA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgZW5kID0gdGhpcy5saW1pdDtcclxuICAgICAgICBiZWdpbiB8PSAwOyBlbmQgfD0gMDtcclxuICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGVuZCA+IHRoaXMuY2FwYWNpdHkoKSB8fCBiZWdpbiA+IGVuZClcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcImJlZ2luLCBlbmRcIik7XHJcbiAgICAgICAgaWYgKGJlZ2luID09PSBlbmQpXHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIHZhciBjaGFycyA9IFtdLFxyXG4gICAgICAgICAgICBwYXJ0cyA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChiZWdpbiA8IGVuZCkge1xyXG4gICAgICAgICAgICBjaGFycy5wdXNoKHRoaXMudmlld1tiZWdpbisrXSk7XHJcbiAgICAgICAgICAgIGlmIChjaGFycy5sZW5ndGggPj0gMTAyNClcclxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNoYXJzKSksXHJcbiAgICAgICAgICAgICAgICBjaGFycyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignJykgKyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2hhcnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcsIHRoYXQgaXMgdXNpbmcgb25seSBjaGFyYWN0ZXJzIDB4MDAtMHhGRiBhcyBieXRlcywgdG8gYSBCeXRlQnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IEJ5dGVCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5mcm9tQmluYXJ5ID0gZnVuY3Rpb24oc3RyLCBsaXR0bGVFbmRpYW4pIHtcclxuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcInN0clwiKTtcclxuICAgICAgICB2YXIgaSA9IDAsXHJcbiAgICAgICAgICAgIGsgPSBzdHIubGVuZ3RoLFxyXG4gICAgICAgICAgICBjaGFyQ29kZSxcclxuICAgICAgICAgICAgYmIgPSBuZXcgQnl0ZUJ1ZmZlcihrLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIHdoaWxlIChpPGspIHtcclxuICAgICAgICAgICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgaWYgKGNoYXJDb2RlID4gMHhmZilcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJpbGxlZ2FsIGNoYXIgY29kZTogXCIrY2hhckNvZGUpO1xyXG4gICAgICAgICAgICBiYi52aWV3W2krK10gPSBjaGFyQ29kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmIubGltaXQgPSBrO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLy8gZW5jb2RpbmdzL2RlYnVnXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIHRoaXMgQnl0ZUJ1ZmZlciB0byBhIGhleCBlbmNvZGVkIHN0cmluZyB3aXRoIG1hcmtlZCBvZmZzZXRzLiBPZmZzZXQgc3ltYm9scyBhcmU6XHJcbiAgICAgKiAqIGA8YCA6IG9mZnNldCxcclxuICAgICAqICogYCdgIDogbWFya2VkT2Zmc2V0LFxyXG4gICAgICogKiBgPmAgOiBsaW1pdCxcclxuICAgICAqICogYHxgIDogb2Zmc2V0IGFuZCBsaW1pdCxcclxuICAgICAqICogYFtgIDogb2Zmc2V0IGFuZCBtYXJrZWRPZmZzZXQsXHJcbiAgICAgKiAqIGBdYCA6IG1hcmtlZE9mZnNldCBhbmQgbGltaXQsXHJcbiAgICAgKiAqIGAhYCA6IG9mZnNldCwgbWFya2VkT2Zmc2V0IGFuZCBsaW1pdFxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gY29sdW1ucyBJZiBgdHJ1ZWAgcmV0dXJucyB0d28gY29sdW1ucyBoZXggKyBhc2NpaSwgZGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3whQXJyYXkuPHN0cmluZz59IERlYnVnIHN0cmluZyBvciBhcnJheSBvZiBsaW5lcyBpZiBgYXNBcnJheSA9IHRydWVgXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAZXhhbXBsZSBgPjAwJzAxIDAyPDAzYCBjb250YWlucyBmb3VyIGJ5dGVzIHdpdGggYGxpbWl0PTAsIG1hcmtlZE9mZnNldD0xLCBvZmZzZXQ9M2BcclxuICAgICAqIEBleGFtcGxlIGAwMFswMSAwMiAwMz5gIGNvbnRhaW5zIGZvdXIgYnl0ZXMgd2l0aCBgb2Zmc2V0PW1hcmtlZE9mZnNldD0xLCBsaW1pdD00YFxyXG4gICAgICogQGV4YW1wbGUgYDAwfDAxIDAyIDAzYCBjb250YWlucyBmb3VyIGJ5dGVzIHdpdGggYG9mZnNldD1saW1pdD0xLCBtYXJrZWRPZmZzZXQ9LTFgXHJcbiAgICAgKiBAZXhhbXBsZSBgfGAgY29udGFpbnMgemVybyBieXRlcyB3aXRoIGBvZmZzZXQ9bGltaXQ9MCwgbWFya2VkT2Zmc2V0PS0xYFxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvRGVidWcgPSBmdW5jdGlvbihjb2x1bW5zKSB7XHJcbiAgICAgICAgdmFyIGkgPSAtMSxcclxuICAgICAgICAgICAgayA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgsXHJcbiAgICAgICAgICAgIGIsXHJcbiAgICAgICAgICAgIGhleCA9IFwiXCIsXHJcbiAgICAgICAgICAgIGFzYyA9IFwiXCIsXHJcbiAgICAgICAgICAgIG91dCA9IFwiXCI7XHJcbiAgICAgICAgd2hpbGUgKGk8aykge1xyXG4gICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoYiA8IDB4MTApIGhleCArPSBcIjBcIitiLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBoZXggKz0gYi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5zKVxyXG4gICAgICAgICAgICAgICAgICAgIGFzYyArPSBiID4gMzIgJiYgYiA8IDEyNyA/IFN0cmluZy5mcm9tQ2hhckNvZGUoYikgOiAnLic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBpZiAoY29sdW1ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwICYmIGkgJSAxNiA9PT0gMCAmJiBpICE9PSBrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGhleC5sZW5ndGggPCAzKjE2KzMpIGhleCArPSBcIiBcIjtcclxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gaGV4K2FzYytcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGhleCA9IGFzYyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMub2Zmc2V0ICYmIGkgPT09IHRoaXMubGltaXQpXHJcbiAgICAgICAgICAgICAgICBoZXggKz0gaSA9PT0gdGhpcy5tYXJrZWRPZmZzZXQgPyBcIiFcIiA6IFwifFwiO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpID09PSB0aGlzLm9mZnNldClcclxuICAgICAgICAgICAgICAgIGhleCArPSBpID09PSB0aGlzLm1hcmtlZE9mZnNldCA/IFwiW1wiIDogXCI8XCI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPT09IHRoaXMubGltaXQpXHJcbiAgICAgICAgICAgICAgICBoZXggKz0gaSA9PT0gdGhpcy5tYXJrZWRPZmZzZXQgPyBcIl1cIiA6IFwiPlwiO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBoZXggKz0gaSA9PT0gdGhpcy5tYXJrZWRPZmZzZXQgPyBcIidcIiA6IChjb2x1bW5zIHx8IChpICE9PSAwICYmIGkgIT09IGspID8gXCIgXCIgOiBcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbHVtbnMgJiYgaGV4ICE9PSBcIiBcIikge1xyXG4gICAgICAgICAgICB3aGlsZSAoaGV4Lmxlbmd0aCA8IDMqMTYrMylcclxuICAgICAgICAgICAgICAgIGhleCArPSBcIiBcIjtcclxuICAgICAgICAgICAgb3V0ICs9IGhleCArIGFzYyArIFwiXFxuXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2x1bW5zID8gb3V0IDogaGV4O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYSBoZXggZW5jb2RlZCBzdHJpbmcgd2l0aCBtYXJrZWQgb2Zmc2V0cyB0byBhIEJ5dGVCdWZmZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIERlYnVnIHN0cmluZyB0byBkZWNvZGUgKG5vdCBiZSBnZW5lcmF0ZWQgd2l0aCBgY29sdW1ucyA9IHRydWVgKVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBCeXRlQnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjdG9EZWJ1Z1xyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmZyb21EZWJ1ZyA9IGZ1bmN0aW9uKHN0ciwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xyXG4gICAgICAgIHZhciBrID0gc3RyLmxlbmd0aCxcclxuICAgICAgICAgICAgYmIgPSBuZXcgQnl0ZUJ1ZmZlcigoKGsrMSkvMyl8MCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCk7XHJcbiAgICAgICAgdmFyIGkgPSAwLCBqID0gMCwgY2gsIGIsXHJcbiAgICAgICAgICAgIHJzID0gZmFsc2UsIC8vIFJlcXVpcmUgc3ltYm9sIG5leHRcclxuICAgICAgICAgICAgaG8gPSBmYWxzZSwgaG0gPSBmYWxzZSwgaGwgPSBmYWxzZSwgLy8gQWxyZWFkeSBoYXMgb2Zmc2V0IChobyksIG1hcmtlZE9mZnNldCAoaG0pLCBsaW1pdCAoaGwpP1xyXG4gICAgICAgICAgICBmYWlsID0gZmFsc2U7XHJcbiAgICAgICAgd2hpbGUgKGk8aykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGNoID0gc3RyLmNoYXJBdChpKyspKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICchJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChobyB8fCBobSB8fCBobCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBobyA9IGhtID0gaGwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5vZmZzZXQgPSBiYi5tYXJrZWRPZmZzZXQgPSBiYi5saW1pdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3wnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvIHx8IGhsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvID0gaGwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5vZmZzZXQgPSBiYi5saW1pdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ1snOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvIHx8IGhtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvID0gaG0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5vZmZzZXQgPSBiYi5tYXJrZWRPZmZzZXQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIHJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICc8JzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChobykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBobyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJiLm9mZnNldCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ10nOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhsIHx8IGhtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhsID0gaG0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5saW1pdCA9IGJiLm1hcmtlZE9mZnNldCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYmIubGltaXQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIHJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiJ1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhtID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYmIubWFya2VkT2Zmc2V0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnICc6XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IHBhcnNlSW50KGNoK3N0ci5jaGFyQXQoaSsrKSwgMTYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGIpIHx8IGIgPCAwIHx8IGIgPiAyNTUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgZGVidWcgZW5jb2RlZCBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJiLnZpZXdbaisrXSA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmYWlsKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IEludmFsaWQgc3ltYm9sIGF0IFwiK2kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICghaG8gfHwgIWhsKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE1pc3Npbmcgb2Zmc2V0IG9yIGxpbWl0XCIpO1xyXG4gICAgICAgICAgICBpZiAoajxiYi5idWZmZXIuYnl0ZUxlbmd0aClcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBkZWJ1ZyBlbmNvZGVkIHN0cmluZyAoaXMgaXQgaGV4PykgXCIraitcIiA8IFwiK2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGVuY29kaW5ncy9oZXhcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMgdG8gYSBoZXggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBiZWdpbiBhdC4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIE9mZnNldCB0byBlbmQgYXQuIERlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEhleCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGJlZ2luID0gdHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJyA/IHRoaXMub2Zmc2V0IDogYmVnaW47XHJcbiAgICAgICAgZW5kID0gdHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmxpbWl0IDogZW5kO1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXkoZW5kIC0gYmVnaW4pLFxyXG4gICAgICAgICAgICBiO1xyXG4gICAgICAgIHdoaWxlIChiZWdpbiA8IGVuZCkge1xyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W2JlZ2luKytdO1xyXG4gICAgICAgICAgICBpZiAoYiA8IDB4MTApXHJcbiAgICAgICAgICAgICAgICBvdXQucHVzaChcIjBcIiwgYi50b1N0cmluZygxNikpO1xyXG4gICAgICAgICAgICBlbHNlIG91dC5wdXNoKGIudG9TdHJpbmcoMTYpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dC5qb2luKCcnKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIGEgaGV4IGVuY29kZWQgc3RyaW5nIHRvIGEgQnl0ZUJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBCeXRlQnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuZnJvbUhleCA9IGZ1bmN0aW9uKHN0ciwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xyXG4gICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggJSAyICE9PSAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IExlbmd0aCBub3QgYSBtdWx0aXBsZSBvZiAyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgayA9IHN0ci5sZW5ndGgsXHJcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoKGsgLyAyKSB8IDAsIGxpdHRsZUVuZGlhbiksXHJcbiAgICAgICAgICAgIGI7XHJcbiAgICAgICAgZm9yICh2YXIgaT0wLCBqPTA7IGk8azsgaSs9Mikge1xyXG4gICAgICAgICAgICBiID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpKzIpLCAxNik7XHJcbiAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGIpIHx8IGIgPCAwIHx8IGIgPiAyNTUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IENvbnRhaW5zIG5vbi1oZXggY2hhcmFjdGVyc1wiKTtcclxuICAgICAgICAgICAgYmIudmlld1tqKytdID0gYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmIubGltaXQgPSBqO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLy8gdXRmeC1lbWJlZGRhYmxlXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB1dGZ4LWVtYmVkZGFibGUgKGMpIDIwMTQgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuICAgICAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vdXRmeCBmb3IgZGV0YWlsc1xyXG4gICAgICovXHJcbiAgICB2YXIgdXRmeCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiB1dGZ4IG5hbWVzcGFjZS5cclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciB1dGZ4ID0ge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1heGltdW0gdmFsaWQgY29kZSBwb2ludC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBjb25zdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguTUFYX0NPREVQT0lOVCA9IDB4MTBGRkZGO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIFVURjggY29kZSBwb2ludHMgdG8gVVRGOCBieXRlcy5cclxuICAgICAgICAgKiBAcGFyYW0geyghZnVuY3Rpb24oKTpudW1iZXJ8bnVsbCkgfCBudW1iZXJ9IHNyYyBDb2RlIHBvaW50cyBzb3VyY2UsIGVpdGhlciBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBjb2RlIHBvaW50XHJcbiAgICAgICAgICogIHJlc3BlY3RpdmVseSBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY29kZSBwb2ludHMgbGVmdCBvciBhIHNpbmdsZSBudW1lcmljIGNvZGUgcG9pbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gZHN0IEJ5dGVzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIHRoZSBuZXh0IGJ5dGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LmVuY29kZVVURjggPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB2YXIgY3AgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICBjcCA9IHNyYyxcclxuICAgICAgICAgICAgICAgIHNyYyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbnVsbDsgfTtcclxuICAgICAgICAgICAgd2hpbGUgKGNwICE9PSBudWxsIHx8IChjcCA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNwIDwgMHg4MClcclxuICAgICAgICAgICAgICAgICAgICBkc3QoY3AmMHg3Rik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjcCA8IDB4ODAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj42KSYweDFGKXwweEMwKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKGNwJjB4M0YpfDB4ODApO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3AgPCAweDEwMDAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj4xMikmMHgwRil8MHhFMCksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoY3A+PjYpJjB4M0YpfDB4ODApLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoY3AmMHgzRil8MHg4MCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoY3A+PjE4KSYweDA3KXwweEYwKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKChjcD4+MTIpJjB4M0YpfDB4ODApLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj42KSYweDNGKXwweDgwKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKGNwJjB4M0YpfDB4ODApO1xyXG4gICAgICAgICAgICAgICAgY3AgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBVVEY4IGJ5dGVzIHRvIFVURjggY29kZSBwb2ludHMuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIEJ5dGVzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBieXRlIHJlc3BlY3RpdmVseSBgbnVsbGAgaWYgdGhlcmVcclxuICAgICAgICAgKiAgYXJlIG5vIG1vcmUgYnl0ZXMgbGVmdC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQ29kZSBwb2ludHMgZGVzdGluYXRpb24gYXMgYSBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggZWFjaCBkZWNvZGVkIGNvZGUgcG9pbnQuXHJcbiAgICAgICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYSBzdGFydGluZyBieXRlIGlzIGludmFsaWQgaW4gVVRGOFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbGFzdCBzZXF1ZW5jZSBpcyB0cnVuY2F0ZWQuIEhhcyBhbiBhcnJheSBwcm9wZXJ0eSBgYnl0ZXNgIGhvbGRpbmcgdGhlXHJcbiAgICAgICAgICogIHJlbWFpbmluZyBieXRlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LmRlY29kZVVURjggPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB2YXIgYSwgYiwgYywgZCwgZmFpbCA9IGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBiLnNsaWNlKDAsIGIuaW5kZXhPZihudWxsKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoYi50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIGVyci5uYW1lID0gXCJUcnVuY2F0ZWRFcnJvclwiO1xyXG4gICAgICAgICAgICAgICAgZXJyWydieXRlcyddID0gYjtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd2hpbGUgKChhID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGEmMHg4MCkgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KGEpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGEmMHhFMCkgPT09IDB4QzApXHJcbiAgICAgICAgICAgICAgICAgICAgKChiID0gc3JjKCkpID09PSBudWxsKSAmJiBmYWlsKFthLCBiXSksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoYSYweDFGKTw8NikgfCAoYiYweDNGKSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYSYweEYwKSA9PT0gMHhFMClcclxuICAgICAgICAgICAgICAgICAgICAoKGI9c3JjKCkpID09PSBudWxsIHx8IChjPXNyYygpKSA9PT0gbnVsbCkgJiYgZmFpbChbYSwgYiwgY10pLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGEmMHgwRik8PDEyKSB8ICgoYiYweDNGKTw8NikgfCAoYyYweDNGKSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYSYweEY4KSA9PT0gMHhGMClcclxuICAgICAgICAgICAgICAgICAgICAoKGI9c3JjKCkpID09PSBudWxsIHx8IChjPXNyYygpKSA9PT0gbnVsbCB8fCAoZD1zcmMoKSkgPT09IG51bGwpICYmIGZhaWwoW2EsIGIsIGMgLGRdKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKChhJjB4MDcpPDwxOCkgfCAoKGImMHgzRik8PDEyKSB8ICgoYyYweDNGKTw8NikgfCAoZCYweDNGKSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHN0YXJ0aW5nIGJ5dGU6IFwiK2EpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgVVRGMTYgY2hhcmFjdGVycyB0byBVVEY4IGNvZGUgcG9pbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCk6bnVtYmVyfG51bGx9IHNyYyBDaGFyYWN0ZXJzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBjaGFyIGNvZGUgcmVzcGVjdGl2ZWx5XHJcbiAgICAgICAgICogIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzIGxlZnQuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gZHN0IENvZGUgcG9pbnRzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIGVhY2ggY29udmVydGVkIGNvZGVcclxuICAgICAgICAgKiAgcG9pbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5VVEYxNnRvVVRGOCA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHZhciBjMSwgYzIgPSBudWxsO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChjMSA9IGMyICE9PSBudWxsID8gYzIgOiBzcmMoKSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBpZiAoYzEgPj0gMHhEODAwICYmIGMxIDw9IDB4REZGRikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoYzIgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMyID49IDB4REMwMCAmJiBjMiA8PSAweERGRkYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRzdCgoYzEtMHhEODAwKSoweDQwMCtjMi0weERDMDArMHgxMDAwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMiA9IG51bGw7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZHN0KGMxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYzIgIT09IG51bGwpIGRzdChjMik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgVVRGOCBjb2RlIHBvaW50cyB0byBVVEYxNiBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KCFmdW5jdGlvbigpOm51bWJlcnxudWxsKSB8IG51bWJlcn0gc3JjIENvZGUgcG9pbnRzIHNvdXJjZSwgZWl0aGVyIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNvZGUgcG9pbnRcclxuICAgICAgICAgKiAgcmVzcGVjdGl2ZWx5IGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjb2RlIHBvaW50cyBsZWZ0IG9yIGEgc2luZ2xlIG51bWVyaWMgY29kZSBwb2ludC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQ2hhcmFjdGVycyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCBlYWNoIGNvbnZlcnRlZCBjaGFyIGNvZGUuXHJcbiAgICAgICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYSBjb2RlIHBvaW50IGlzIG91dCBvZiByYW5nZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguVVRGOHRvVVRGMTYgPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB2YXIgY3AgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICBjcCA9IHNyYywgc3JjID0gZnVuY3Rpb24oKSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgICAgICAgICB3aGlsZSAoY3AgIT09IG51bGwgfHwgKGNwID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3AgPD0gMHhGRkZGKVxyXG4gICAgICAgICAgICAgICAgICAgIGRzdChjcCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY3AgLT0gMHgxMDAwMCxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKGNwPj4xMCkrMHhEODAwKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKGNwJTB4NDAwKSsweERDMDApO1xyXG4gICAgICAgICAgICAgICAgY3AgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYW5kIGVuY29kZXMgVVRGMTYgY2hhcmFjdGVycyB0byBVVEY4IGJ5dGVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCk6bnVtYmVyfG51bGx9IHNyYyBDaGFyYWN0ZXJzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBjaGFyIGNvZGUgcmVzcGVjdGl2ZWx5IGBudWxsYFxyXG4gICAgICAgICAqICBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzIGxlZnQuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gZHN0IEJ5dGVzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIHRoZSBuZXh0IGJ5dGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5lbmNvZGVVVEYxNnRvVVRGOCA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHV0ZnguVVRGMTZ0b1VURjgoc3JjLCBmdW5jdGlvbihjcCkge1xyXG4gICAgICAgICAgICAgICAgdXRmeC5lbmNvZGVVVEY4KGNwLCBkc3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIGFuZCBjb252ZXJ0cyBVVEY4IGJ5dGVzIHRvIFVURjE2IGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIEJ5dGVzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBieXRlIHJlc3BlY3RpdmVseSBgbnVsbGAgaWYgdGhlcmVcclxuICAgICAgICAgKiAgYXJlIG5vIG1vcmUgYnl0ZXMgbGVmdC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQ2hhcmFjdGVycyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCBlYWNoIGNvbnZlcnRlZCBjaGFyIGNvZGUuXHJcbiAgICAgICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYSBzdGFydGluZyBieXRlIGlzIGludmFsaWQgaW4gVVRGOFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbGFzdCBzZXF1ZW5jZSBpcyB0cnVuY2F0ZWQuIEhhcyBhbiBhcnJheSBwcm9wZXJ0eSBgYnl0ZXNgIGhvbGRpbmcgdGhlIHJlbWFpbmluZyBieXRlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LmRlY29kZVVURjh0b1VURjE2ID0gZnVuY3Rpb24oc3JjLCBkc3QpIHtcclxuICAgICAgICAgICAgdXRmeC5kZWNvZGVVVEY4KHNyYywgZnVuY3Rpb24oY3ApIHtcclxuICAgICAgICAgICAgICAgIHV0ZnguVVRGOHRvVVRGMTYoY3AsIGRzdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIFVURjggY29kZSBwb2ludC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY3AgVVRGOCBjb2RlIHBvaW50XHJcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LmNhbGN1bGF0ZUNvZGVQb2ludCA9IGZ1bmN0aW9uKGNwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoY3AgPCAweDgwKSA/IDEgOiAoY3AgPCAweDgwMCkgPyAyIDogKGNwIDwgMHgxMDAwMCkgPyAzIDogNDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgVVRGOCBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBVVEY4IGNvZGUgcG9pbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KCFmdW5jdGlvbigpOm51bWJlcnxudWxsKX0gc3JjIENvZGUgcG9pbnRzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBjb2RlIHBvaW50IHJlc3BlY3RpdmVseVxyXG4gICAgICAgICAqICBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY29kZSBwb2ludHMgbGVmdC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIFVURjggYnl0ZXMgcmVxdWlyZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LmNhbGN1bGF0ZVVURjggPSBmdW5jdGlvbihzcmMpIHtcclxuICAgICAgICAgICAgdmFyIGNwLCBsPTA7XHJcbiAgICAgICAgICAgIHdoaWxlICgoY3AgPSBzcmMoKSkgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICBsICs9IChjcCA8IDB4ODApID8gMSA6IChjcCA8IDB4ODAwKSA/IDIgOiAoY3AgPCAweDEwMDAwKSA/IDMgOiA0O1xyXG4gICAgICAgICAgICByZXR1cm4gbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgVVRGOCBjb2RlIHBvaW50cyByZXNwZWN0aXZlbHkgVVRGOCBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBVVEYxNiBjaGFyIGNvZGVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KCFmdW5jdGlvbigpOm51bWJlcnxudWxsKX0gc3JjIENoYXJhY3RlcnMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNoYXIgY29kZSByZXNwZWN0aXZlbHlcclxuICAgICAgICAgKiAgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMgbGVmdC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBUaGUgbnVtYmVyIG9mIFVURjggY29kZSBwb2ludHMgYXQgaW5kZXggMCBhbmQgdGhlIG51bWJlciBvZiBVVEY4IGJ5dGVzIHJlcXVpcmVkIGF0IGluZGV4IDEuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOCA9IGZ1bmN0aW9uKHNyYykge1xyXG4gICAgICAgICAgICB2YXIgbj0wLCBsPTA7XHJcbiAgICAgICAgICAgIHV0ZnguVVRGMTZ0b1VURjgoc3JjLCBmdW5jdGlvbihjcCkge1xyXG4gICAgICAgICAgICAgICAgKytuOyBsICs9IChjcCA8IDB4ODApID8gMSA6IChjcCA8IDB4ODAwKSA/IDIgOiAoY3AgPCAweDEwMDAwKSA/IDMgOiA0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIFtuLGxdO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiB1dGZ4O1xyXG4gICAgfSgpO1xyXG5cclxuICAgIC8vIGVuY29kaW5ncy91dGY4XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIGJldHdlZW4ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9IHRvIGFuIFVURjggZW5jb2RlZFxyXG4gICAgICogIHN0cmluZy5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEhleCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldCA+IGxpbWl0YFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvVVRGOCA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJykgYmVnaW4gPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNkOyB0cnkge1xyXG4gICAgICAgICAgICB1dGZ4LmRlY29kZVVURjh0b1VURjE2KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlZ2luIDwgZW5kID8gdGhpcy52aWV3W2JlZ2luKytdIDogbnVsbDtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCBzZCA9IHN0cmluZ0Rlc3RpbmF0aW9uKCkpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKGJlZ2luICE9PSBlbmQpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK2JlZ2luK1wiICE9IFwiK2VuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYW4gVVRGOCBlbmNvZGVkIHN0cmluZyB0byBhIEJ5dGVCdWZmZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBkZWNvZGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gc2tpcCBhc3NlcnRpb25zIG9mIG9mZnNldHMgYW5kIHZhbHVlcy4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUfS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQnl0ZUJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmZyb21VVEY4ID0gZnVuY3Rpb24oc3RyLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgaWYgKCFub0Fzc2VydClcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtcclxuICAgICAgICB2YXIgYmIgPSBuZXcgQnl0ZUJ1ZmZlcih1dGZ4LmNhbGN1bGF0ZVVURjE2YXNVVEY4KHN0cmluZ1NvdXJjZShzdHIpLCB0cnVlKVsxXSwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCksXHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIHV0ZnguZW5jb2RlVVRGMTZ0b1VURjgoc3RyaW5nU291cmNlKHN0ciksIGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgYmIudmlld1tpKytdID0gYjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBiYi5saW1pdCA9IGk7XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gQnl0ZUJ1ZmZlcjtcclxufSk7XHJcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYnl0ZWJ1ZmZlci9kaXN0L2J5dGVidWZmZXIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYnl0ZWJ1ZmZlci9kaXN0XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpLlN0cmluZ0RlY29kZXJcbm1vZHVsZS5leHBvcnRzID0gQ2lwaGVyQmFzZVxuaW5oZXJpdHMoQ2lwaGVyQmFzZSwgVHJhbnNmb3JtKVxuZnVuY3Rpb24gQ2lwaGVyQmFzZSAoaGFzaE1vZGUpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5oYXNoTW9kZSA9IHR5cGVvZiBoYXNoTW9kZSA9PT0gJ3N0cmluZydcbiAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICB0aGlzW2hhc2hNb2RlXSA9IHRoaXMuX2ZpbmFsT3JEaWdlc3RcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZpbmFsID0gdGhpcy5fZmluYWxPckRpZ2VzdFxuICB9XG4gIHRoaXMuX2RlY29kZXIgPSBudWxsXG4gIHRoaXMuX2VuY29kaW5nID0gbnVsbFxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGlucHV0RW5jLCBvdXRwdXRFbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGlucHV0RW5jKVxuICB9XG4gIHZhciBvdXREYXRhID0gdGhpcy5fdXBkYXRlKGRhdGEpXG4gIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYylcbiAgfVxuICByZXR1cm4gb3V0RGF0YVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uICgpIHt9XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLmdldEF1dGhUYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIGdldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dGhUYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEFBRCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gc2V0IGFhZCBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZGF0YSwgXywgbmV4dCkge1xuICB2YXIgZXJyXG4gIHRyeSB7XG4gICAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShkYXRhKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5fdXBkYXRlKGRhdGEpKVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfSBmaW5hbGx5IHtcbiAgICBuZXh0KGVycilcbiAgfVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgdmFyIGVyclxuICB0cnkge1xuICAgIHRoaXMucHVzaCh0aGlzLl9maW5hbCgpKVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyID0gZVxuICB9IGZpbmFsbHkge1xuICAgIGRvbmUoZXJyKVxuICB9XG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fZmluYWxPckRpZ2VzdCA9IGZ1bmN0aW9uIChvdXRwdXRFbmMpIHtcbiAgdmFyIG91dERhdGEgPSB0aGlzLl9maW5hbCgpIHx8IG5ldyBCdWZmZXIoJycpXG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jLCB0cnVlKVxuICB9XG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jLCBmaW4pIHtcbiAgaWYgKCF0aGlzLl9kZWNvZGVyKSB7XG4gICAgdGhpcy5fZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYylcbiAgICB0aGlzLl9lbmNvZGluZyA9IGVuY1xuICB9XG4gIGlmICh0aGlzLl9lbmNvZGluZyAhPT0gZW5jKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IHN3aXRjaCBlbmNvZGluZ3MnKVxuICB9XG4gIHZhciBvdXQgPSB0aGlzLl9kZWNvZGVyLndyaXRlKHZhbHVlKVxuICBpZiAoZmluKSB7XG4gICAgb3V0ICs9IHRoaXMuX2RlY29kZXIuZW5kKClcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2NpcGhlci1iYXNlL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2NpcGhlci1iYXNlXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIG1kNSA9IHJlcXVpcmUoJy4vbWQ1JylcbnZhciBybWQxNjAgPSByZXF1aXJlKCdyaXBlbWQxNjAnKVxudmFyIHNoYSA9IHJlcXVpcmUoJ3NoYS5qcycpXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxuXG5mdW5jdGlvbiBIYXNoTm9Db25zdHJ1Y3RvcihoYXNoKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnZGlnZXN0JylcblxuICB0aGlzLl9oYXNoID0gaGFzaFxuICB0aGlzLmJ1ZmZlcnMgPSBbXVxufVxuXG5pbmhlcml0cyhIYXNoTm9Db25zdHJ1Y3RvciwgQmFzZSlcblxuSGFzaE5vQ29uc3RydWN0b3IucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChkYXRhKVxufVxuXG5IYXNoTm9Db25zdHJ1Y3Rvci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdCh0aGlzLmJ1ZmZlcnMpXG4gIHZhciByID0gdGhpcy5faGFzaChidWYpXG4gIHRoaXMuYnVmZmVycyA9IG51bGxcblxuICByZXR1cm4gclxufVxuXG5mdW5jdGlvbiBIYXNoKGhhc2gpIHtcbiAgQmFzZS5jYWxsKHRoaXMsICdkaWdlc3QnKVxuXG4gIHRoaXMuX2hhc2ggPSBoYXNoXG59XG5cbmluaGVyaXRzKEhhc2gsIEJhc2UpXG5cbkhhc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxufVxuXG5IYXNoLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9oYXNoLmRpZ2VzdCgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlSGFzaCAoYWxnKSB7XG4gIGFsZyA9IGFsZy50b0xvd2VyQ2FzZSgpXG4gIGlmICgnbWQ1JyA9PT0gYWxnKSByZXR1cm4gbmV3IEhhc2hOb0NvbnN0cnVjdG9yKG1kNSlcbiAgaWYgKCdybWQxNjAnID09PSBhbGcgfHwgJ3JpcGVtZDE2MCcgPT09IGFsZykgcmV0dXJuIG5ldyBIYXNoTm9Db25zdHJ1Y3RvcihybWQxNjApXG5cbiAgcmV0dXJuIG5ldyBIYXNoKHNoYShhbGcpKVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9icm93c2VyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIGludFNpemUgPSA0O1xudmFyIHplcm9CdWZmZXIgPSBuZXcgQnVmZmVyKGludFNpemUpOyB6ZXJvQnVmZmVyLmZpbGwoMCk7XG52YXIgY2hyc3ogPSA4O1xuXG5mdW5jdGlvbiB0b0FycmF5KGJ1ZiwgYmlnRW5kaWFuKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAlIGludFNpemUpICE9PSAwKSB7XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggKyAoaW50U2l6ZSAtIChidWYubGVuZ3RoICUgaW50U2l6ZSkpO1xuICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW2J1ZiwgemVyb0J1ZmZlcl0sIGxlbik7XG4gIH1cblxuICB2YXIgYXJyID0gW107XG4gIHZhciBmbiA9IGJpZ0VuZGlhbiA/IGJ1Zi5yZWFkSW50MzJCRSA6IGJ1Zi5yZWFkSW50MzJMRTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IGludFNpemUpIHtcbiAgICBhcnIucHVzaChmbi5jYWxsKGJ1ZiwgaSkpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIHRvQnVmZmVyKGFyciwgc2l6ZSwgYmlnRW5kaWFuKSB7XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICB2YXIgZm4gPSBiaWdFbmRpYW4gPyBidWYud3JpdGVJbnQzMkJFIDogYnVmLndyaXRlSW50MzJMRTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBmbi5jYWxsKGJ1ZiwgYXJyW2ldLCBpICogNCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuZnVuY3Rpb24gaGFzaChidWYsIGZuLCBoYXNoU2l6ZSwgYmlnRW5kaWFuKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IG5ldyBCdWZmZXIoYnVmKTtcbiAgdmFyIGFyciA9IGZuKHRvQXJyYXkoYnVmLCBiaWdFbmRpYW4pLCBidWYubGVuZ3RoICogY2hyc3opO1xuICByZXR1cm4gdG9CdWZmZXIoYXJyLCBoYXNoU2l6ZSwgYmlnRW5kaWFuKTtcbn1cbmV4cG9ydHMuaGFzaCA9IGhhc2g7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9oZWxwZXJzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMSBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gY29yZV9tZDUoeCwgbGVuKVxue1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8ICgobGVuKSAlIDMyKTtcbiAgeFsoKChsZW4gKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbGVuO1xuXG4gIHZhciBhID0gIDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAgMjcxNzMzODc4O1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcbiAge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcblxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyAwXSwgNyAsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTcsICA2MDYxMDU4MTkpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDcgLCAtMTc2NDE4ODk3KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgNV0sIDEyLCAgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDhdLCA3ICwgIDE3NzAwMzU0MTYpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE3LCAtNDIwNjMpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDcgLCAgMTgwNDYwMzY4Mik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xuXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDFdLCA1ICwgLTE2NTc5NjUxMCk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDZdLCA5ICwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzExXSwgMTQsICA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyAwXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA1XSwgNSAsIC03MDE1NTg2OTEpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzEwXSwgOSAsICAzODAxNjA4Myk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDldLCA1ICwgIDU2ODQ0NjQzOCk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTRdLCA5ICwgLTEwMTk4MDM2OTApO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyAzXSwgMTQsIC0xODczNjM5NjEpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA4XSwgMjAsICAxMTYzNTMxNTAxKTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsxM10sIDUgLCAtMTQ0NDY4MTQ2Nyk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDJdLCA5ICwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE0LCAgMTczNTMyODQ3Myk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDVdLCA0ICwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzExXSwgMTYsICAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyAxXSwgNCAsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKzEzXSwgNCAsICA2ODEyNzkxNzQpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyAwXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyA2XSwgMjMsICA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDldLCA0ICwgLTY0MDM2NDQ4Nyk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTVdLCAxNiwgIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDJdLCAyMywgLTk5NTMzODY1MSk7XG5cbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDYgLCAtMTk4NjMwODQ0KTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgN10sIDEwLCAgMTEyNjg5MTQxNSk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krMTJdLCA2ICwgIDE3MDA0ODU1NzEpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA4XSwgNiAsICAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsxM10sIDIxLCAgMTMwOTE1MTY0OSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDRdLCA2ICwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTUsICA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuXG4gICAgYSA9IHNhZmVfYWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVfYWRkKGQsIG9sZGQpO1xuICB9XG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkKTtcblxufVxuXG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuZnVuY3Rpb24gbWQ1X2NtbihxLCBhLCBiLCB4LCBzLCB0KVxue1xuICByZXR1cm4gc2FmZV9hZGQoYml0X3JvbChzYWZlX2FkZChzYWZlX2FkZChhLCBxKSwgc2FmZV9hZGQoeCwgdCkpLCBzKSxiKTtcbn1cbmZ1bmN0aW9uIG1kNV9mZihhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfZ2coYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2hoKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfaWkoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcbntcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gYml0X3JvbChudW0sIGNudClcbntcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1kNShidWYpIHtcbiAgcmV0dXJuIGhlbHBlcnMuaGFzaChidWYsIGNvcmVfbWQ1LCAxNik7XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbWQ1LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaC9icm93c2VyJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cblxudmFyIFpFUk9TID0gbmV3IEJ1ZmZlcigxMjgpXG5aRVJPUy5maWxsKDApXG5cbmZ1bmN0aW9uIEhtYWMoYWxnLCBrZXkpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgYWxnID0gYWxnLnRvTG93ZXJDYXNlKClcbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAga2V5ID0gbmV3IEJ1ZmZlcihrZXkpXG4gIH1cblxuICB2YXIgYmxvY2tzaXplID0gKGFsZyA9PT0gJ3NoYTUxMicgfHwgYWxnID09PSAnc2hhMzg0JykgPyAxMjggOiA2NFxuXG4gIHRoaXMuX2FsZyA9IGFsZ1xuICB0aGlzLl9rZXkgPSBrZXlcblxuICBpZiAoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IGNyZWF0ZUhhc2goYWxnKS51cGRhdGUoa2V5KS5kaWdlc3QoKVxuXG4gIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgWkVST1NdLCBibG9ja3NpemUpXG4gIH1cblxuICB2YXIgaXBhZCA9IHRoaXMuX2lwYWQgPSBuZXcgQnVmZmVyKGJsb2Nrc2l6ZSlcbiAgdmFyIG9wYWQgPSB0aGlzLl9vcGFkID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3NpemU7IGkrKykge1xuICAgIGlwYWRbaV0gPSBrZXlbaV0gXiAweDM2XG4gICAgb3BhZFtpXSA9IGtleVtpXSBeIDB4NUNcbiAgfVxuXG4gIHRoaXMuX2hhc2ggPSBjcmVhdGVIYXNoKGFsZykudXBkYXRlKGlwYWQpXG59XG5cbmluaGVyaXRzKEhtYWMsIFRyYW5zZm9ybSlcblxuSG1hYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhLCBlbmMpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuSG1hYy5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChkYXRhLCBfLCBuZXh0KSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG5cbiAgbmV4dCgpXG59XG5cbkhtYWMucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gIHRoaXMucHVzaCh0aGlzLmRpZ2VzdCgpKVxuXG4gIG5leHQoKVxufVxuXG5IbWFjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHZhciBoID0gdGhpcy5faGFzaC5kaWdlc3QoKVxuXG4gIHJldHVybiBjcmVhdGVIYXNoKHRoaXMuX2FsZykudXBkYXRlKHRoaXMuX29wYWQpLnVwZGF0ZShoKS5kaWdlc3QoZW5jKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUhtYWMoYWxnLCBrZXkpIHtcbiAgcmV0dXJuIG5ldyBIbWFjKGFsZywga2V5KVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jcmVhdGUtaG1hYy9icm93c2VyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1obWFjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2VuYy1iYXNlNjRcIiksIHJlcXVpcmUoXCIuL21kNVwiKSwgcmVxdWlyZShcIi4vZXZwa2RmXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9lbmMtYmFzZTY0XCIsIFwiLi9tZDVcIiwgXCIuL2V2cGtkZlwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gTG9va3VwIHRhYmxlc1xuXHQgICAgdmFyIFNCT1ggPSBbXTtcblx0ICAgIHZhciBJTlZfU0JPWCA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMCA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMSA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMiA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMyA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzAgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8xID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMiA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzMgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBsb29rdXAgdGFibGVzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vIENvbXB1dGUgZG91YmxlIHRhYmxlXG5cdCAgICAgICAgdmFyIGQgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChpIDwgMTI4KSB7XG5cdCAgICAgICAgICAgICAgICBkW2ldID0gaSA8PCAxO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZFtpXSA9IChpIDw8IDEpIF4gMHgxMWI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBXYWxrIEdGKDJeOClcblx0ICAgICAgICB2YXIgeCA9IDA7XG5cdCAgICAgICAgdmFyIHhpID0gMDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgc2JveFxuXHQgICAgICAgICAgICB2YXIgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcblx0ICAgICAgICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xuXHQgICAgICAgICAgICBTQk9YW3hdID0gc3g7XG5cdCAgICAgICAgICAgIElOVl9TQk9YW3N4XSA9IHg7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuXHQgICAgICAgICAgICB2YXIgeDIgPSBkW3hdO1xuXHQgICAgICAgICAgICB2YXIgeDQgPSBkW3gyXTtcblx0ICAgICAgICAgICAgdmFyIHg4ID0gZFt4NF07XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuXHQgICAgICAgICAgICB2YXIgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMFt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8xW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8yW3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8zW3hdID0gdDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcblx0ICAgICAgICAgICAgdmFyIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8xW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbc3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfM1tzeF0gPSB0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG5cdCAgICAgICAgICAgIGlmICgheCkge1xuXHQgICAgICAgICAgICAgICAgeCA9IHhpID0gMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG5cdCAgICAgICAgICAgICAgICB4aSBePSBkW2RbeGldXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8vIFByZWNvbXB1dGVkIFJjb24gbG9va3VwXG5cdCAgICB2YXIgUkNPTiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBRVMgYmxvY2sgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEFFUyA9IENfYWxnby5BRVMgPSBCbG9ja0NpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fa2V5O1xuXHQgICAgICAgICAgICB2YXIga2V5V29yZHMgPSBrZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBrZXlTaXplID0ga2V5LnNpZ0J5dGVzIC8gNDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiByb3VuZHNcblx0ICAgICAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzID0ga2V5U2l6ZSArIDZcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiBrZXkgc2NoZWR1bGUgcm93c1xuXHQgICAgICAgICAgICB2YXIga3NSb3dzID0gKG5Sb3VuZHMgKyAxKSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBrZXkgc2NoZWR1bGVcblx0ICAgICAgICAgICAgdmFyIGtleVNjaGVkdWxlID0gdGhpcy5fa2V5U2NoZWR1bGUgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIga3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVdvcmRzW2tzUm93XTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDFdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEoa3NSb3cgJSBrZXlTaXplKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3Qgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWl4IFJjb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCBePSBSQ09OWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWIgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnYga2V5IHNjaGVkdWxlXG5cdCAgICAgICAgICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuX2ludktleVNjaGVkdWxlID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gSU5WX1NVQl9NSVhfMFtTQk9YW3QgPj4+IDI0XV0gXiBJTlZfU1VCX01JWF8xW1NCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdXSBeIElOVl9TVUJfTUlYXzNbU0JPWFt0ICYgMHhmZl1dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGVuY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9rZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGVjcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgMm5kIGFuZCA0dGggcm93c1xuXHQgICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcblxuXHQgICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgSU5WX1NVQl9NSVhfMCwgSU5WX1NVQl9NSVhfMSwgSU5WX1NVQl9NSVhfMiwgSU5WX1NVQl9NSVhfMywgSU5WX1NCT1gpO1xuXG5cdCAgICAgICAgICAgIC8vIEludiBzd2FwIDJuZCBhbmQgNHRoIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIHQgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0NyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQsIGtleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzO1xuXG5cdCAgICAgICAgICAgIC8vIEdldCBpbnB1dCwgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICB2YXIgczAgPSBNW29mZnNldF0gICAgIF4ga2V5U2NoZWR1bGVbMF07XG5cdCAgICAgICAgICAgIHZhciBzMSA9IE1bb2Zmc2V0ICsgMV0gXiBrZXlTY2hlZHVsZVsxXTtcblx0ICAgICAgICAgICAgdmFyIHMyID0gTVtvZmZzZXQgKyAyXSBeIGtleVNjaGVkdWxlWzJdO1xuXHQgICAgICAgICAgICB2YXIgczMgPSBNW29mZnNldCArIDNdIF4ga2V5U2NoZWR1bGVbM107XG5cblx0ICAgICAgICAgICAgLy8gS2V5IHNjaGVkdWxlIHJvdyBjb3VudGVyXG5cdCAgICAgICAgICAgIHZhciBrc1JvdyA9IDQ7XG5cblx0ICAgICAgICAgICAgLy8gUm91bmRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIHJvdW5kID0gMTsgcm91bmQgPCBuUm91bmRzOyByb3VuZCsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zLCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgICAgICB2YXIgdDAgPSBTVUJfTUlYXzBbczAgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczEgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMiA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMyAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDEgPSBTVUJfTUlYXzBbczEgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczIgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMyA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMCAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDIgPSBTVUJfTUlYXzBbczIgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczMgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMCA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMSAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDMgPSBTVUJfTUlYXzBbczMgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczAgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMSA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMiAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cblx0ICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuXHQgICAgICAgICAgICAgICAgczAgPSB0MDtcblx0ICAgICAgICAgICAgICAgIHMxID0gdDE7XG5cdCAgICAgICAgICAgICAgICBzMiA9IHQyO1xuXHQgICAgICAgICAgICAgICAgczMgPSB0Mztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICB2YXIgdDAgPSAoKFNCT1hbczAgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczEgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMiA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczMgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQxID0gKChTQk9YW3MxID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMyID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczMgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MwICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MiA9ICgoU0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMyA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMwID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMSAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDMgPSAoKFNCT1hbczMgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczAgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMSA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczIgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgb3V0cHV0XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0XSAgICAgPSB0MDtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IHQxO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDJdID0gdDI7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0Mztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogMjU2LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5BRVMuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5BRVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuQUVTID0gQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihBRVMpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLkFFUztcblxufSkpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2Flcy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBDaXBoZXIgY29yZSBjb21wb25lbnRzLlxuXHQgKi9cblx0Q3J5cHRvSlMubGliLkNpcGhlciB8fCAoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0Zjg7XG5cdCAgICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblx0ICAgIHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgY2lwaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoaXMgY2lwaGVyJ3Mga2V5IHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl2U2l6ZSBUaGlzIGNpcGhlcidzIElWIHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9FTkNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBlbmNyeXB0aW9uIG1vZGUuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX0RFQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGRlY3J5cHRpb24gbW9kZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENpcGhlciA9IENfbGliLkNpcGhlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBlbmNyeXB0aW9uIG1vZGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlcn0gQSBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGVFbmNyeXB0b3Ioa2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVFbmNyeXB0b3I6IGZ1bmN0aW9uIChrZXksIGNmZykge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fRU5DX1hGT1JNX01PREUsIGtleSwgY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBkZWNyeXB0aW9uIG1vZGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlcn0gQSBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGVEZWNyeXB0b3Ioa2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVEZWNyeXB0b3I6IGZ1bmN0aW9uIChrZXksIGNmZykge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fREVDX1hGT1JNX01PREUsIGtleSwgY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4Zm9ybU1vZGUgRWl0aGVyIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gdHJhbnNvcm1hdGlvbiBtb2RlIGNvbnN0YW50LlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlKENyeXB0b0pTLmFsZ28uQUVTLl9FTkNfWEZPUk1fTU9ERSwga2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoeGZvcm1Nb2RlLCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBTdG9yZSB0cmFuc2Zvcm0gbW9kZSBhbmQga2V5XG5cdCAgICAgICAgICAgIHRoaXMuX3hmb3JtTW9kZSA9IHhmb3JtTW9kZTtcblx0ICAgICAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGNpcGhlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgY2lwaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcblx0ICAgICAgICAgICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtY2lwaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHRoaXMuX2RvUmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyBkYXRhIHRvIGJlIGVuY3J5cHRlZCBvciBkZWNyeXB0ZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBwcm9jZXNzaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3MoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGRhdGFVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIGF2YWlsYWJsZSBibG9ja3Ncblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3MoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcy5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBmaW5hbCBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgZmluYWwgcHJvY2Vzc2luZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKGRhdGFVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gRmluYWwgZGF0YSB1cGRhdGVcblx0ICAgICAgICAgICAgaWYgKGRhdGFVcGRhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtY2lwaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZERhdGEgPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkRGF0YTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogMTI4LzMyLFxuXG5cdCAgICAgICAgaXZTaXplOiAxMjgvMzIsXG5cblx0ICAgICAgICBfRU5DX1hGT1JNX01PREU6IDEsXG5cblx0ICAgICAgICBfREVDX1hGT1JNX01PREU6IDIsXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHNob3J0Y3V0IGZ1bmN0aW9ucyB0byBhIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggZW5jcnlwdCBhbmQgZGVjcnlwdCBzaG9ydGN1dCBmdW5jdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBBRVMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5BRVMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIZWxwZXI6IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGFzc3dvcmRCYXNlZENpcGhlcjtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUNpcGhlcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2lwaGVyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChtZXNzYWdlLCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5lbmNyeXB0KGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVydGV4dCwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZGVjcnlwdChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0oKSlcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2Ugc3RyZWFtIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxICgzMiBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgU3RyZWFtQ2lwaGVyID0gQ19saWIuU3RyZWFtQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBwYXJ0aWFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDFcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIE1vZGUgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19tb2RlID0gQy5tb2RlID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgbW9kZSB0ZW1wbGF0ZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyTW9kZSA9IENfbGliLkJsb2NrQ2lwaGVyTW9kZSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZW5jcnlwdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZUVuY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVFbmNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBkZWNyeXB0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRGVjcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG1vZGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYud29yZHMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NpcGhlciA9IGNpcGhlcjtcblx0ICAgICAgICAgICAgdGhpcy5faXYgPSBpdjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDaXBoZXIgQmxvY2sgQ2hhaW5pbmcgbW9kZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENCQyA9IENfbW9kZS5DQkMgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFic3RyYWN0IGJhc2UgQ0JDIG1vZGUuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdmFyIENCQyA9IEJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENCQyBlbmNyeXB0b3IuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgQ0JDLkVuY3J5cHRvciA9IENCQy5leHRlbmQoe1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBkYXRhIGJsb2NrIGF0IG9mZnNldC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cblx0ICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHdoZXJlIHRoZSBibG9jayBzdGFydHMuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFhPUiBhbmQgZW5jcnlwdFxuXHQgICAgICAgICAgICAgICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xuXHQgICAgICAgICAgICAgICAgY2lwaGVyLmVuY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENCQyBkZWNyeXB0b3IuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgQ0JDLkRlY3J5cHRvciA9IENCQy5leHRlbmQoe1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBkYXRhIGJsb2NrIGF0IG9mZnNldC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cblx0ICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHdoZXJlIHRoZSBibG9jayBzdGFydHMuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXHQgICAgICAgICAgICAgICAgdmFyIHRoaXNCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gRGVjcnlwdCBhbmQgWE9SXG5cdCAgICAgICAgICAgICAgICBjaXBoZXIuZGVjcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBUaGlzIGJsb2NrIGJlY29tZXMgdGhlIHByZXZpb3VzIGJsb2NrXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB0aGlzQmxvY2s7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIGZ1bmN0aW9uIHhvckJsb2NrKHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaXYgPSB0aGlzLl9pdjtcblxuXHQgICAgICAgICAgICAvLyBDaG9vc2UgbWl4aW5nIGJsb2NrXG5cdCAgICAgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gaXY7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gdGhpcy5fcHJldkJsb2NrO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gWE9SIGJsb2Nrc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tvZmZzZXQgKyBpXSBePSBibG9ja1tpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBDQkM7XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFBhZGRpbmcgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19wYWQgPSBDLnBhZCA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFBLQ1MgIzUvNyBwYWRkaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgUGtjczcgPSBDX3BhZC5Qa2NzNyA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBQYWRzIGRhdGEgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHBhZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tTaXplIFRoZSBtdWx0aXBsZSB0aGF0IHRoZSBkYXRhIHNob3VsZCBiZSBwYWRkZWQgdG8uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy5wYWQod29yZEFycmF5LCA0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBwYWRkaW5nIGJ5dGVzXG5cdCAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSBkYXRhLnNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIHBhZGRpbmcgd29yZFxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ1dvcmQgPSAoblBhZGRpbmdCeXRlcyA8PCAyNCkgfCAoblBhZGRpbmdCeXRlcyA8PCAxNikgfCAoblBhZGRpbmdCeXRlcyA8PCA4KSB8IG5QYWRkaW5nQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdXb3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYWRkaW5nQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgcGFkZGluZ1dvcmRzLnB1c2gocGFkZGluZ1dvcmQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nID0gV29yZEFycmF5LmNyZWF0ZShwYWRkaW5nV29yZHMsIG5QYWRkaW5nQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGEuY29uY2F0KHBhZGRpbmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVbnBhZHMgZGF0YSB0aGF0IGhhZCBiZWVuIHBhZGRlZCB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gdW5wYWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy51bnBhZCh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcblx0ICAgICAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBkYXRhLndvcmRzWyhkYXRhLnNpZ0J5dGVzIC0gMSkgPj4+IDJdICYgMHhmZjtcblxuXHQgICAgICAgICAgICAvLyBSZW1vdmUgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5QYWRkaW5nQnl0ZXM7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXIgPSBDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdG8gdXNlLiBEZWZhdWx0OiBDQkNcblx0ICAgICAgICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBQa2NzN1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQ2lwaGVyLmNmZy5leHRlbmQoe1xuXHQgICAgICAgICAgICBtb2RlOiBDQkMsXG5cdCAgICAgICAgICAgIHBhZGRpbmc6IFBrY3M3XG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBjaXBoZXJcblx0ICAgICAgICAgICAgQ2lwaGVyLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjZmcgPSB0aGlzLmNmZztcblx0ICAgICAgICAgICAgdmFyIGl2ID0gY2ZnLml2O1xuXHQgICAgICAgICAgICB2YXIgbW9kZSA9IGNmZy5tb2RlO1xuXG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGJsb2NrIG1vZGVcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVFbmNyeXB0b3I7XG5cdCAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbW9kZUNyZWF0b3IgPSBtb2RlLmNyZWF0ZURlY3J5cHRvcjtcblxuXHQgICAgICAgICAgICAgICAgLy8gS2VlcCBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gdGhlIGJ1ZmZlciBmb3IgdW5wYWRkaW5nXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9taW5CdWZmZXJTaXplID0gMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9tb2RlID0gbW9kZUNyZWF0b3IuY2FsbChtb2RlLCB0aGlzLCBpdiAmJiBpdi53b3Jkcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbW9kZS5wcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5jZmcucGFkZGluZztcblxuXHQgICAgICAgICAgICAvLyBGaW5hbGl6ZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBQYWQgZGF0YVxuXHQgICAgICAgICAgICAgICAgcGFkZGluZy5wYWQodGhpcy5fZGF0YSwgdGhpcy5ibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXHQgICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xuXHQgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVW5wYWQgZGF0YVxuXHQgICAgICAgICAgICAgICAgcGFkZGluZy51bnBhZChmaW5hbFByb2Nlc3NlZEJsb2Nrcyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMTI4LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIGNvbGxlY3Rpb24gb2YgY2lwaGVyIHBhcmFtZXRlcnMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGNpcGhlcnRleHQgVGhlIHJhdyBjaXBoZXJ0ZXh0LlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGtleSBUaGUga2V5IHRvIHRoaXMgY2lwaGVydGV4dC5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBzYWx0IFRoZSBzYWx0IHVzZWQgd2l0aCBhIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtDaXBoZXJ9IGFsZ29yaXRobSBUaGUgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHNjaGVtZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgYmxvY2sgc2l6ZSBvZiB0aGUgY2lwaGVyLlxuXHQgICAgICogQHByb3BlcnR5IHtGb3JtYXR9IGZvcm1hdHRlciBUaGUgZGVmYXVsdCBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cblx0ICAgICAqL1xuXHQgICAgdmFyIENpcGhlclBhcmFtcyA9IENfbGliLkNpcGhlclBhcmFtcyA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2lwaGVyUGFyYW1zIEFuIG9iamVjdCB3aXRoIGFueSBvZiB0aGUgcG9zc2libGUgY2lwaGVyIHBhcmFtZXRlcnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG5cdCAgICAgICAgICogICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAga2V5OiBrZXlXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBpdjogaXZXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBzYWx0OiBzYWx0V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgYWxnb3JpdGhtOiBDcnlwdG9KUy5hbGdvLkFFUyxcblx0ICAgICAgICAgKiAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuXHQgICAgICAgICAqICAgICAgICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLlBLQ1M3LFxuXHQgICAgICAgICAqICAgICAgICAgYmxvY2tTaXplOiA0LFxuXHQgICAgICAgICAqICAgICAgICAgZm9ybWF0dGVyOiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTFxuXHQgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIHRoaXMubWl4SW4oY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Rm9ybWF0fSBmb3JtYXR0ZXIgKE9wdGlvbmFsKSBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCBjaXBoZXIgcGFyYW1zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHRocm93cyBFcnJvciBJZiBuZWl0aGVyIHRoZSBmb3JtYXR0ZXIgbm9yIHRoZSBkZWZhdWx0IGZvcm1hdHRlciBpcyBzZXQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGZvcm1hdHRlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGZvcm1hdHRlciB8fCB0aGlzLmZvcm1hdHRlcikuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEZvcm1hdCBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2Zvcm1hdCA9IEMuZm9ybWF0ID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogT3BlblNTTCBmb3JtYXR0aW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgT3BlblNTTEZvcm1hdHRlciA9IENfZm9ybWF0Lk9wZW5TU0wgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgb3BlblNTTFN0cmluZyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgdmFyIHNhbHQgPSBjaXBoZXJQYXJhbXMuc2FsdDtcblxuXHQgICAgICAgICAgICAvLyBGb3JtYXRcblx0ICAgICAgICAgICAgaWYgKHNhbHQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3b3JkQXJyYXkgPSBXb3JkQXJyYXkuY3JlYXRlKFsweDUzNjE2Yzc0LCAweDY1NjQ1ZjVmXSkuY29uY2F0KHNhbHQpLmNvbmNhdChjaXBoZXJ0ZXh0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3b3JkQXJyYXkgPSBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHdvcmRBcnJheS50b1N0cmluZyhCYXNlNjQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nIHRvIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlblNTTFN0ciBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wucGFyc2Uob3BlblNTTFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChvcGVuU1NMU3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFBhcnNlIGJhc2U2NFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IEJhc2U2NC5wYXJzZShvcGVuU1NMU3RyKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dFdvcmRzID0gY2lwaGVydGV4dC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBUZXN0IGZvciBzYWx0XG5cdCAgICAgICAgICAgIGlmIChjaXBoZXJ0ZXh0V29yZHNbMF0gPT0gMHg1MzYxNmM3NCAmJiBjaXBoZXJ0ZXh0V29yZHNbMV0gPT0gMHg2NTY0NWY1Zikge1xuXHQgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBzYWx0XG5cdCAgICAgICAgICAgICAgICB2YXIgc2FsdCA9IFdvcmRBcnJheS5jcmVhdGUoY2lwaGVydGV4dFdvcmRzLnNsaWNlKDIsIDQpKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHNhbHQgZnJvbSBjaXBoZXJ0ZXh0XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0V29yZHMuc3BsaWNlKDAsIDQpO1xuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dC5zaWdCeXRlcyAtPSAxNjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsgY2lwaGVydGV4dDogY2lwaGVydGV4dCwgc2FsdDogc2FsdCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgY2lwaGVyIHdyYXBwZXIgdGhhdCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgKi9cblx0ICAgIHZhciBTZXJpYWxpemFibGVDaXBoZXIgPSBDX2xpYi5TZXJpYWxpemFibGVDaXBoZXIgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IGNpcGhlciBwYXJhbSBvYmplY3RzIHRvIGFuZCBmcm9tIGEgc3RyaW5nLiBEZWZhdWx0OiBPcGVuU1NMXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGZvcm1hdDogT3BlblNTTEZvcm1hdHRlclxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRW5jcnlwdHMgYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXkpO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgdmFyIGVuY3J5cHRvciA9IGNpcGhlci5jcmVhdGVFbmNyeXB0b3Ioa2V5LCBjZmcpO1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGVuY3J5cHRvci5maW5hbGl6ZShtZXNzYWdlKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVyQ2ZnID0gZW5jcnlwdG9yLmNmZztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgYW5kIHJldHVybiBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtc1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LFxuXHQgICAgICAgICAgICAgICAga2V5OiBrZXksXG5cdCAgICAgICAgICAgICAgICBpdjogY2lwaGVyQ2ZnLml2LFxuXHQgICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBjaXBoZXIsXG5cdCAgICAgICAgICAgICAgICBtb2RlOiBjaXBoZXJDZmcubW9kZSxcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmc6IGNpcGhlckNmZy5wYWRkaW5nLFxuXHQgICAgICAgICAgICAgICAgYmxvY2tTaXplOiBjaXBoZXIuYmxvY2tTaXplLFxuXHQgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBjZmcuZm9ybWF0XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuXHQgICAgICAgICAgICAvLyBEZWNyeXB0XG5cdCAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBjaXBoZXIuY3JlYXRlRGVjcnlwdG9yKGtleSwgY2ZnKS5maW5hbGl6ZShjaXBoZXJ0ZXh0LmNpcGhlcnRleHQpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB0byBDaXBoZXJQYXJhbXMsXG5cdCAgICAgICAgICogZWxzZSBhc3N1bWVkIENpcGhlclBhcmFtcyBhbHJlYWR5IGFuZCByZXR1cm5zIGNpcGhlcnRleHQgdW5jaGFuZ2VkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlIHRvIHBhcnNlIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIHVuc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuX3BhcnNlKGNpcGhlcnRleHRTdHJpbmdPclBhcmFtcywgZm9ybWF0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfcGFyc2U6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBmb3JtYXQpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjaXBoZXJ0ZXh0ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0LnBhcnNlKGNpcGhlcnRleHQsIHRoaXMpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBLZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2tkZiA9IEMua2RmID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogT3BlblNTTCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgdmFyIE9wZW5TU0xLZGYgPSBDX2tkZi5PcGVuU1NMID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlcml2ZXMgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gZGVyaXZlIGZyb20uXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtleVNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIGtleSB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaXZTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBJViB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgKE9wdGlvbmFsKSBBIDY0LWJpdCBzYWx0IHRvIHVzZS4gSWYgb21pdHRlZCwgYSBzYWx0IHdpbGwgYmUgZ2VuZXJhdGVkIHJhbmRvbWx5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0IHdpdGggdGhlIGtleSwgSVYsIGFuZCBzYWx0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIpO1xuXHQgICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIsICdzYWx0c2FsdCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwga2V5U2l6ZSwgaXZTaXplLCBzYWx0KSB7XG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBzYWx0XG5cdCAgICAgICAgICAgIGlmICghc2FsdCkge1xuXHQgICAgICAgICAgICAgICAgc2FsdCA9IFdvcmRBcnJheS5yYW5kb20oNjQvOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBJVlxuXHQgICAgICAgICAgICB2YXIga2V5ID0gRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IGtleVNpemUgKyBpdlNpemUgfSkuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cblx0ICAgICAgICAgICAgLy8gU2VwYXJhdGUga2V5IGFuZCBJVlxuXHQgICAgICAgICAgICB2YXIgaXYgPSBXb3JkQXJyYXkuY3JlYXRlKGtleS53b3Jkcy5zbGljZShrZXlTaXplKSwgaXZTaXplICogNCk7XG5cdCAgICAgICAgICAgIGtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBwYXJhbXNcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBrZXk6IGtleSwgaXY6IGl2LCBzYWx0OiBzYWx0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBzZXJpYWxpemFibGUgY2lwaGVyIHdyYXBwZXIgdGhhdCBkZXJpdmVzIHRoZSBrZXkgZnJvbSBhIHBhc3N3b3JkLFxuXHQgICAgICogYW5kIHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgdmFyIFBhc3N3b3JkQmFzZWRDaXBoZXIgPSBDX2xpYi5QYXNzd29yZEJhc2VkQ2lwaGVyID0gU2VyaWFsaXphYmxlQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtLREZ9IGtkZiBUaGUga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gdG8gdXNlIHRvIGdlbmVyYXRlIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuIERlZmF1bHQ6IE9wZW5TU0xcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IFNlcmlhbGl6YWJsZUNpcGhlci5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAga2RmOiBPcGVuU1NMS2RmXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UgdXNpbmcgYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwgcGFzc3dvcmQsIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xuXHQgICAgICAgICAgICBjZmcuaXYgPSBkZXJpdmVkUGFyYW1zLml2O1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgbWVzc2FnZSwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gTWl4IGluIGRlcml2ZWQgcGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQubWl4SW4oZGVyaXZlZFBhcmFtcyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB1c2luZyBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIHBhc3N3b3JkLCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoY2lwaGVydGV4dCwgY2ZnLmZvcm1hdCk7XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSwgY2lwaGVydGV4dC5zYWx0KTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXG5cdCAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cblx0ICAgICAgICAgICAgLy8gRGVjcnlwdFxuXHQgICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQuY2FsbCh0aGlzLCBjaXBoZXIsIGNpcGhlcnRleHQsIGRlcml2ZWRQYXJhbXMua2V5LCBjZmcpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH0oKSk7XG5cblxufSkpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NpcGhlci1jb3JlLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRyb290LkNyeXB0b0pTID0gZmFjdG9yeSgpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuXHQvKipcblx0ICogQ3J5cHRvSlMgY29yZSBjb21wb25lbnRzLlxuXHQgKi9cblx0dmFyIENyeXB0b0pTID0gQ3J5cHRvSlMgfHwgKGZ1bmN0aW9uIChNYXRoLCB1bmRlZmluZWQpIHtcblx0ICAgIC8qKlxuXHQgICAgICogQ3J5cHRvSlMgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExpYnJhcnkgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYiA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhc2Ugb2JqZWN0IGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2UgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyBQcm9wZXJ0aWVzIHRvIGNvcHkgaW50byB0aGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZScsXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNwYXduXG5cdCAgICAgICAgICAgICAgICBGLnByb3RvdHlwZSA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3VidHlwZSA9IG5ldyBGKCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEF1Z21lbnRcblx0ICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLm1peEluKG92ZXJyaWRlcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IGluaXRpYWxpemVyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXN1YnR5cGUuaGFzT3duUHJvcGVydHkoJ2luaXQnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemVyJ3MgcHJvdG90eXBlIGlzIHRoZSBzdWJ0eXBlIG9iamVjdFxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0LnByb3RvdHlwZSA9IHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZSBzdXBlcnR5cGVcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyID0gdGhpcztcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEV4dGVuZHMgdGhpcyBvYmplY3QgYW5kIHJ1bnMgdGhlIGluaXQgbWV0aG9kLlxuXHQgICAgICAgICAgICAgKiBBcmd1bWVudHMgdG8gY3JlYXRlKCkgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgaW5zdGFuY2UgPSBNeVR5cGUuY3JlYXRlKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZXh0ZW5kKCk7XG5cdCAgICAgICAgICAgICAgICBpbnN0YW5jZS5pbml0LmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBvYmplY3QuXG5cdCAgICAgICAgICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFkZCBzb21lIGxvZ2ljIHdoZW4geW91ciBvYmplY3RzIGFyZSBjcmVhdGVkLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgICAgICAvLyAuLi5cblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ29waWVzIHByb3BlcnRpZXMgaW50byB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgVGhlIHByb3BlcnRpZXMgdG8gbWl4IGluLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgTXlUeXBlLm1peEluKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJ1xuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBtaXhJbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJRSB3b24ndCBjb3B5IHRvU3RyaW5nIHVzaW5nIHRoZSBsb29wIGFib3ZlXG5cdCAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgndG9TdHJpbmcnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJpbmcgPSBwcm9wZXJ0aWVzLnRvU3RyaW5nO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBpbnN0YW5jZS5jbG9uZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge0FycmF5fSB3b3JkcyBUaGUgYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZ0J5dGVzIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICovXG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5ID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgKE9wdGlvbmFsKSBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSwgNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHdvcmRzLCBzaWdCeXRlcykge1xuXHQgICAgICAgICAgICB3b3JkcyA9IHRoaXMud29yZHMgPSB3b3JkcyB8fCBbXTtcblxuXHQgICAgICAgICAgICBpZiAoc2lnQnl0ZXMgIT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gd29yZHMubGVuZ3RoICogNDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIHdvcmQgYXJyYXkgdG8gYSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXIgKE9wdGlvbmFsKSBUaGUgZW5jb2Rpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBDcnlwdG9KUy5lbmMuSGV4XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5ICsgJyc7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChlbmNvZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoZW5jb2RlciB8fCBIZXgpLnN0cmluZ2lmeSh0aGlzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uY2F0ZW5hdGVzIGEgd29yZCBhcnJheSB0byB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5IHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkxLmNvbmNhdCh3b3JkQXJyYXkyKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb25jYXQ6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB0aGlzV29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhpc1NpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRTaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICB0aGlzLmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29uY2F0XG5cdCAgICAgICAgICAgIGlmICh0aGlzU2lnQnl0ZXMgJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSBieXRlIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0Qnl0ZSA9ICh0aGF0V29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdIHw9IHRoYXRCeXRlIDw8ICgyNCAtICgodGhpc1NpZ0J5dGVzICsgaSkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgd29yZCBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSA9IHRoYXRXb3Jkc1tpID4+PiAyXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzICs9IHRoYXRTaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlbW92ZXMgaW5zaWduaWZpY2FudCBiaXRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbGFtcDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcFxuXHQgICAgICAgICAgICB3b3Jkc1tzaWdCeXRlcyA+Pj4gMl0gJj0gMHhmZmZmZmZmZiA8PCAoMzIgLSAoc2lnQnl0ZXMgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB3b3Jkcy5sZW5ndGggPSBNYXRoLmNlaWwoc2lnQnl0ZXMgLyA0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IHdvcmRBcnJheS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHdvcmQgYXJyYXkgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlcyBUaGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHJhbmRvbSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oMTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJhbmRvbTogZnVuY3Rpb24gKG5CeXRlcykge1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblxuXHQgICAgICAgICAgICB2YXIgciA9IChmdW5jdGlvbiAobV93KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbV93ID0gbV93O1xuXHQgICAgICAgICAgICAgICAgdmFyIG1feiA9IDB4M2FkZTY4YjE7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFzayA9IDB4ZmZmZmZmZmY7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbV96ID0gKDB4OTA2OSAqIChtX3ogJiAweEZGRkYpICsgKG1feiA+PiAweDEwKSkgJiBtYXNrO1xuXHQgICAgICAgICAgICAgICAgICAgIG1fdyA9ICgweDQ2NTAgKiAobV93ICYgMHhGRkZGKSArIChtX3cgPj4gMHgxMCkpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gKChtX3ogPDwgMHgxMCkgKyBtX3cpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgLz0gMHgxMDAwMDAwMDA7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IDAuNTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKE1hdGgucmFuZG9tKCkgPiAuNSA/IDEgOiAtMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCByY2FjaGU7IGkgPCBuQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9yID0gcigocmNhY2hlIHx8IE1hdGgucmFuZG9tKCkpICogMHgxMDAwMDAwMDApO1xuXG5cdCAgICAgICAgICAgICAgICByY2FjaGUgPSBfcigpICogMHgzYWRlNjdiNztcblx0ICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goKF9yKCkgKiAweDEwMDAwMDAwMCkgfCAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIG5CeXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRW5jb2RlciBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogSGV4IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgSGV4ID0gQ19lbmMuSGV4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBoZXhDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgPj4+IDQpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlICYgMHgwZikudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBoZXhDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHIgVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShoZXhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoaGV4U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoZXhTdHJMZW5ndGggPSBoZXhTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGV4U3RyTGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDNdIHw9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoaSwgMiksIDE2KSA8PCAoMjQgLSAoaSAlIDgpICogNCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBoZXhTdHJMZW5ndGggLyAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExhdGluMSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIExhdGluMSA9IENfZW5jLkxhdGluMSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBsYXRpbjFTdHJpbmcgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xQ2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBsYXRpbjFDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYml0ZSkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGxhdGluMUNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIExhdGluMSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhdGluMVN0ciBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnBhcnNlKGxhdGluMVN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChsYXRpbjFTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMVN0ckxlbmd0aCA9IGxhdGluMVN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRpbjFTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gKGxhdGluMVN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZikgPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbGF0aW4xU3RyTGVuZ3RoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi04IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0ZjggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmOC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKExhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KSkpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBVVEYtOCBkYXRhJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtOCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjhTdHIgVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjhTdHIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIExhdGluMS5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cikpKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJ1ZmZlcmVkIGJsb2NrIGFsZ29yaXRobSB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBUaGUgcHJvcGVydHkgYmxvY2tTaXplIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfbWluQnVmZmVyU2l6ZSBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBrZXB0IHVucHJvY2Vzc2VkIGluIHRoZSBidWZmZXIuIERlZmF1bHQ6IDBcblx0ICAgICAqL1xuXHQgICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGRhdGEgYnVmZmVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBXb3JkQXJyYXkuaW5pdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzID0gMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyBuZXcgZGF0YSB0byB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGJ1ZmZlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9hcHBlbmQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhID0gVXRmOC5wYXJzZShkYXRhKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9kYXRhLmNvbmNhdChkYXRhKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyArPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBQcm9jZXNzZXMgYXZhaWxhYmxlIGRhdGEgYmxvY2tzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBfZG9Qcm9jZXNzQmxvY2sob2Zmc2V0KSwgd2hpY2ggbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvRmx1c2ggV2hldGhlciBhbGwgYmxvY2tzIGFuZCBwYXJ0aWFsIGJsb2NrcyBzaG91bGQgYmUgcHJvY2Vzc2VkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcHJvY2Vzc2VkIGRhdGEuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcygpO1xuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoISEnZmx1c2gnKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfcHJvY2VzczogZnVuY3Rpb24gKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gdGhpcy5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYmxvY2tzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQmxvY2tzUmVhZHkgPSBkYXRhU2lnQnl0ZXMgLyBibG9ja1NpemVCeXRlcztcblx0ICAgICAgICAgICAgaWYgKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGguY2VpbChuQmxvY2tzUmVhZHkpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgZG93biB0byBpbmNsdWRlIG9ubHkgZnVsbCBibG9ja3MsXG5cdCAgICAgICAgICAgICAgICAvLyBsZXNzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIGJ1ZmZlclxuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb3VudCB3b3JkcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbldvcmRzUmVhZHkgPSBuQmxvY2tzUmVhZHkgKiBibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYnl0ZXMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CeXRlc1JlYWR5ID0gTWF0aC5taW4obldvcmRzUmVhZHkgKiA0LCBkYXRhU2lnQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYmxvY2tzXG5cdCAgICAgICAgICAgIGlmIChuV29yZHNSZWFkeSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NlZFdvcmRzID0gZGF0YVdvcmRzLnNwbGljZSgwLCBuV29yZHNSZWFkeSk7XG5cdCAgICAgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5CeXRlc1JlYWR5O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHByb2Nlc3NlZFdvcmRzLCBuQnl0ZXNSZWFkeSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9kYXRhID0gdGhpcy5fZGF0YS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX21pbkJ1ZmZlclNpemU6IDBcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGhhc2hlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgaGFzaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxNiAoNTEyIGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2hlciA9IENyeXB0b0pTLmFsZ28uU0hBMjU2LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgaGFzaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVcGRhdGVzIHRoaXMgaGFzaGVyIHdpdGggYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0hhc2hlcn0gVGhpcyBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGhhc2hcblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gRmluYWwgbWVzc2FnZSB1cGRhdGVcblx0ICAgICAgICAgICAgaWYgKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDUxMi8zMixcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byBhIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaGFzaGVyLmluaXQoY2ZnKS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byB1c2UgaW4gdGhpcyBITUFDIGhlbHBlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBIbWFjU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhtYWNIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ19hbGdvLkhNQUMuaW5pdChoYXNoZXIsIGtleSkuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWxnb3JpdGhtIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbyA9IHt9O1xuXG5cdCAgICByZXR1cm4gQztcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlM7XG5cbn0pKTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhc2U2NCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBiYXNlNjRTdHJpbmcgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgYmFzZTY0Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTEgPSAod29yZHNbaSA+Pj4gMl0gICAgICAgPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgICAgICAgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUyID0gKHdvcmRzWyhpICsgMSkgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAxKSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMyA9ICh3b3Jkc1soaSArIDIpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMikgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0cmlwbGV0ID0gKGJ5dGUxIDw8IDE2KSB8IChieXRlMiA8PCA4KSB8IGJ5dGUzO1xuXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgKGogPCA0KSAmJiAoaSArIGogKiAwLjc1IDwgc2lnQnl0ZXMpOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+ICg2ICogKDMgLSBqKSkpICYgMHgzZikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG5cdCAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGJhc2U2NENoYXJzLmxlbmd0aCAlIDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKHBhZGRpbmdDaGFyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBiYXNlNjRDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRTdHIgVGhlIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShiYXNlNjRTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoYmFzZTY0U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgYmFzZTY0U3RyTGVuZ3RoID0gYmFzZTY0U3RyLmxlbmd0aDtcblx0ICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHQgICAgICAgICAgICAvLyBJZ25vcmUgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0luZGV4ID0gYmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhZGRpbmdJbmRleCAhPSAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NFN0ckxlbmd0aCA9IHBhZGRpbmdJbmRleDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIHZhciBuQnl0ZXMgPSAwO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2U2NFN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaSAlIDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYml0czEgPSBtYXAuaW5kZXhPZihiYXNlNjRTdHIuY2hhckF0KGkgLSAxKSkgPDwgKChpICUgNCkgKiAyKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYml0czIgPSBtYXAuaW5kZXhPZihiYXNlNjRTdHIuY2hhckF0KGkpKSA+Pj4gKDYgLSAoaSAlIDQpICogMik7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGJpdHNDb21iaW5lZCA9IGJpdHMxIHwgYml0czI7XG5cdCAgICAgICAgICAgICAgICAgICAgd29yZHNbbkJ5dGVzID4+PiAyXSB8PSAoYml0c0NvbWJpbmVkKSA8PCAoMjQgLSAobkJ5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICAgICAgICBuQnl0ZXMrKztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCBuQnl0ZXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWFwOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXG5cdCAgICB9O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5CYXNlNjQ7XG5cbn0pKTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtYmFzZTY0LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5IZXg7XG5cbn0pKTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtaGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9zaGExXCIpLCByZXF1aXJlKFwiLi9obWFjXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL3NoYTFcIiwgXCIuL2htYWNcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIE1ENSA9IENfYWxnby5NRDU7XG5cblx0ICAgIC8qKlxuXHQgICAgICogVGhpcyBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBpcyBtZWFudCB0byBjb25mb3JtIHdpdGggRVZQX0J5dGVzVG9LZXkuXG5cdCAgICAgKiB3d3cub3BlbnNzbC5vcmcvZG9jcy9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxuXHQgICAgICovXG5cdCAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERiA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGUga2V5IHNpemUgaW4gd29yZHMgdG8gZ2VuZXJhdGUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZS4gRGVmYXVsdDogTUQ1XG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl0ZXJhdGlvbnMgVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm0uIERlZmF1bHQ6IDFcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAga2V5U2l6ZTogMTI4LzMyLFxuXHQgICAgICAgICAgICBoYXNoZXI6IE1ENSxcblx0ICAgICAgICAgICAgaXRlcmF0aW9uczogMVxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgZGVyaXZhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGtleSA9IGtkZi5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb21wdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSBjZmcuaGFzaGVyLmNyZWF0ZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5ID0gV29yZEFycmF5LmNyZWF0ZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBjZmcua2V5U2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBjZmcuaXRlcmF0aW9ucztcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlcblx0ICAgICAgICAgICAgd2hpbGUgKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGggPCBrZXlTaXplKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICBoYXNoZXIudXBkYXRlKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGhhc2hlci51cGRhdGUocGFzc3dvcmQpLmZpbmFsaXplKHNhbHQpO1xuXHQgICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGlvbnNcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBoYXNoZXIuZmluYWxpemUoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBkZXJpdmVkS2V5LmNvbmNhdChibG9jayk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZGVyaXZlZEtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIHJldHVybiBkZXJpdmVkS2V5O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBjb21wdXRhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAqL1xuXHQgICAgQy5FdnBLREYgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGNmZykge1xuXHQgICAgICAgIHJldHVybiBFdnBLREYuY3JlYXRlKGNmZykuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cdCAgICB9O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLkV2cEtERjtcblxufSkpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2V2cGtkZi5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBITUFDIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEhNQUMgPSBDX2FsZ28uSE1BQyA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgSE1BQy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWNIYXNoZXIgPSBDcnlwdG9KUy5hbGdvLkhNQUMuY3JlYXRlKENyeXB0b0pTLmFsZ28uU0hBMjU2LCBrZXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChoYXNoZXIsIGtleSkge1xuXHQgICAgICAgICAgICAvLyBJbml0IGhhc2hlclxuXHQgICAgICAgICAgICBoYXNoZXIgPSB0aGlzLl9oYXNoZXIgPSBuZXcgaGFzaGVyLmluaXQoKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSBVdGY4LnBhcnNlKGtleSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZSA9IGhhc2hlci5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXJCbG9ja1NpemVCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQWxsb3cgYXJiaXRyYXJ5IGxlbmd0aCBrZXlzXG5cdCAgICAgICAgICAgIGlmIChrZXkuc2lnQnl0ZXMgPiBoYXNoZXJCbG9ja1NpemVCeXRlcykge1xuXHQgICAgICAgICAgICAgICAga2V5ID0gaGFzaGVyLmZpbmFsaXplKGtleSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICBrZXkuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDbG9uZSBrZXkgZm9yIGlubmVyIGFuZCBvdXRlciBwYWRzXG5cdCAgICAgICAgICAgIHZhciBvS2V5ID0gdGhpcy5fb0tleSA9IGtleS5jbG9uZSgpO1xuXHQgICAgICAgICAgICB2YXIgaUtleSA9IHRoaXMuX2lLZXkgPSBrZXkuY2xvbmUoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIG9LZXlXb3JkcyA9IG9LZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBpS2V5V29yZHMgPSBpS2V5LndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFhPUiBrZXlzIHdpdGggcGFkIGNvbnN0YW50c1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhc2hlckJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBvS2V5V29yZHNbaV0gXj0gMHg1YzVjNWM1Yztcblx0ICAgICAgICAgICAgICAgIGlLZXlXb3Jkc1tpXSBePSAweDM2MzYzNjM2O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9LZXkuc2lnQnl0ZXMgPSBpS2V5LnNpZ0J5dGVzID0gaGFzaGVyQmxvY2tTaXplQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgSE1BQyB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XG5cblx0ICAgICAgICAgICAgLy8gUmVzZXRcblx0ICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgIGhhc2hlci51cGRhdGUodGhpcy5faUtleSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBITUFDIHdpdGggYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0hNQUN9IFRoaXMgSE1BQyBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci51cGRhdGUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2hlci51cGRhdGUobWVzc2FnZVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIEhNQUMgY29tcHV0YXRpb24uXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gdGhpcy5faGFzaGVyO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgSE1BQ1xuXHQgICAgICAgICAgICB2YXIgaW5uZXJIYXNoID0gaGFzaGVyLmZpbmFsaXplKG1lc3NhZ2VVcGRhdGUpO1xuXHQgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgdmFyIGhtYWMgPSBoYXNoZXIuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChpbm5lckhhc2gpKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gaG1hYztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fSgpKTtcblxuXG59KSk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvaG1hYy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIENvbnN0YW50cyB0YWJsZVxuXHQgICAgdmFyIFQgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgIFRbaV0gPSAoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNRDUgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NlxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuXHQgICAgICAgICAgICAgICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcblxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXRfaV0gPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8wICA9IE1bb2Zmc2V0ICsgMF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xICA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8yICA9IE1bb2Zmc2V0ICsgMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8zICA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF80ICA9IE1bb2Zmc2V0ICsgNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF81ICA9IE1bb2Zmc2V0ICsgNV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF82ICA9IE1bb2Zmc2V0ICsgNl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF83ICA9IE1bb2Zmc2V0ICsgN107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF84ICA9IE1bb2Zmc2V0ICsgOF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF85ICA9IE1bb2Zmc2V0ICsgOV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMCA9IE1bb2Zmc2V0ICsgMTBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTEgPSBNW29mZnNldCArIDExXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEyID0gTVtvZmZzZXQgKyAxMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMyA9IE1bb2Zmc2V0ICsgMTNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTQgPSBNW29mZnNldCArIDE0XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE1ID0gTVtvZmZzZXQgKyAxNV07XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWxiZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNywgIFRbMF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMSwgIDEyLCBUWzFdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNywgVFsyXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8zLCAgMjIsIFRbM10pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDcsICBUWzRdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzUsICAxMiwgVFs1XSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTcsIFRbNl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfNywgIDIyLCBUWzddKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA3LCAgVFs4XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF85LCAgMTIsIFRbOV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE3LCBUWzEwXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xMSwgMjIsIFRbMTFdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA3LCAgVFsxMl0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTMsIDEyLCBUWzEzXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTcsIFRbMTRdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE1LCAyMiwgVFsxNV0pO1xuXG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNSwgIFRbMTZdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzYsICA5LCAgVFsxN10pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE0LCBUWzE4XSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8wLCAgMjAsIFRbMTldKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA1LCAgVFsyMF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTAsIDksICBUWzIxXSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTQsIFRbMjJdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzQsICAyMCwgVFsyM10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDUsICBUWzI0XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xNCwgOSwgIFRbMjVdKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNCwgVFsyNl0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfOCwgIDIwLCBUWzI3XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNSwgIFRbMjhdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzIsICA5LCAgVFsyOV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE0LCBUWzMwXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8xMiwgMjAsIFRbMzFdKTtcblxuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDQsICBUWzMyXSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF84LCAgMTEsIFRbMzNdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNiwgVFszNF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNCwgIFRbMzZdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzQsICAxMSwgVFszN10pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE2LCBUWzM4XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA0LCAgVFs0MF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgIDExLCBUWzQxXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTYsIFRbNDJdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzYsICAyMywgVFs0M10pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDQsICBUWzQ0XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNiwgVFs0Nl0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMiwgIDIzLCBUWzQ3XSk7XG5cblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA2LCAgVFs0OF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfNywgIDEwLCBUWzQ5XSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTUsIFRbNTBdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzUsICAyMSwgVFs1MV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDYsICBUWzUyXSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8zLCAgMTAsIFRbNTNdKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNSwgVFs1NF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMSwgIDIxLCBUWzU1XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNiwgIFRbNTZdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE1LCAxMCwgVFs1N10pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE1LCBUWzU4XSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xMywgMjEsIFRbNTldKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA2LCAgVFs2MF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTEsIDEwLCBUWzYxXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTUsIFRbNjJdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzksICAyMSwgVFs2M10pO1xuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsSCA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCA4KSAgfCAobkJpdHNUb3RhbEggPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCAyNCkgfCAobkJpdHNUb3RhbEggPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDgpICB8IChuQml0c1RvdGFsTCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDI0KSB8IChuQml0c1RvdGFsTCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xuXHQgICAgICAgICAgICB2YXIgSCA9IGhhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgSF9pID0gSFtpXTtcblxuXHQgICAgICAgICAgICAgICAgSFtpXSA9ICgoKEhfaSA8PCA4KSAgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gRkYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGMpIHwgKH5iICYgZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gR0coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGQpIHwgKGMgJiB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSEgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChiIF4gYyBeIGQpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSUkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuTUQ1ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoTUQ1KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNNRDUobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjTUQ1ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKE1ENSk7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLk1ENTtcblxufSkpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL21kNS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0XG5cdCAgICB2YXIgVyA9IFtdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0xIGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBMSA9IENfYWxnby5TSEExID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3Nixcblx0ICAgICAgICAgICAgICAgIDB4YzNkMmUxZjBcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXHQgICAgICAgICAgICB2YXIgZSA9IEhbNF07XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDE2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IE1bb2Zmc2V0ICsgaV0gfCAwO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IChuIDw8IDEpIHwgKG4gPj4+IDMxKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGUgKyBXW2ldO1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAyMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKChiICYgYykgfCAofmIgJiBkKSkgKyAweDVhODI3OTk5O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgNDApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9IChiIF4gYyBeIGQpICsgMHg2ZWQ5ZWJhMTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDYwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpKSAtIDB4NzBlNDQzMjQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgLyogaWYgKGkgPCA4MCkgKi8ge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKGIgXiBjIF4gZCkgLSAweDM1OWQzZTJhO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBlID0gZDtcblx0ICAgICAgICAgICAgICAgIGQgPSBjO1xuXHQgICAgICAgICAgICAgICAgYyA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcblx0ICAgICAgICAgICAgICAgIGIgPSBhO1xuXHQgICAgICAgICAgICAgICAgYSA9IHQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNF0gPSAoSFs0XSArIGUpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMSgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMSh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTEgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEExKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEExKG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTEgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMSk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMTtcblxufSkpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTEuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGN1cnJlbmN5U3ltYm9sTWFwID0gcmVxdWlyZSgnLi9tYXAnKTtcblxudmFyIHN5bWJvbEN1cnJlbmN5TWFwID0ge307XG5PYmplY3Qua2V5cyhjdXJyZW5jeVN5bWJvbE1hcCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIHN5bWJvbEN1cnJlbmN5TWFwW2N1cnJlbmN5U3ltYm9sTWFwW2tleV1dID0ga2V5XG59KVxuXG5mdW5jdGlvbiBnZXRTeW1ib2xGcm9tQ3VycmVuY3koY3VycmVuY3lDb2RlKSB7XG4gIGlmICh0eXBlb2YgY3VycmVuY3lDb2RlICE9PSAnc3RyaW5nJykgcmV0dXJuIHVuZGVmaW5lZFxuICB2YXIgY29kZSA9IGN1cnJlbmN5Q29kZS50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWN1cnJlbmN5U3ltYm9sTWFwLmhhc093blByb3BlcnR5KGNvZGUpKSByZXR1cm4gdW5kZWZpbmVkXG4gIHJldHVybiBjdXJyZW5jeVN5bWJvbE1hcFtjb2RlXTtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVuY3lGcm9tU3ltYm9sKHN5bWJvbCkge1xuICBpZiAoIXN5bWJvbEN1cnJlbmN5TWFwLmhhc093blByb3BlcnR5KHN5bWJvbCkpIHJldHVybiB1bmRlZmluZWRcbiAgcmV0dXJuIHN5bWJvbEN1cnJlbmN5TWFwW3N5bWJvbF1cbn1cblxuZnVuY3Rpb24gZ2V0U3ltYm9sKGN1cnJlbmN5Q29kZSkge1xuICBpZiAodHlwZW9mIGN1cnJlbmN5Q29kZSAhPT0gJ3N0cmluZycpIHJldHVybiAnPydcbiAgdmFyIHN5bWJvbCA9IGdldFN5bWJvbEZyb21DdXJyZW5jeShjdXJyZW5jeUNvZGUudG9VcHBlckNhc2UoKSlcbiAgcmV0dXJuIHN5bWJvbCAhPT0gdW5kZWZpbmVkID8gc3ltYm9sIDogJz8nXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9sXG5tb2R1bGUuZXhwb3J0cy5nZXRTeW1ib2xGcm9tQ3VycmVuY3kgPSBnZXRTeW1ib2xGcm9tQ3VycmVuY3lcbm1vZHVsZS5leHBvcnRzLmdldEN1cnJlbmN5RnJvbVN5bWJvbCA9IGdldEN1cnJlbmN5RnJvbVN5bWJvbFxubW9kdWxlLmV4cG9ydHMuc3ltYm9sQ3VycmVuY3lNYXAgPSBzeW1ib2xDdXJyZW5jeU1hcFxubW9kdWxlLmV4cG9ydHMuY3VycmVuY3lTeW1ib2xNYXAgPSBjdXJyZW5jeVN5bWJvbE1hcFxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jdXJyZW5jeS1zeW1ib2wtbWFwL2N1cnJlbmN5LXN5bWJvbC1tYXAuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY3VycmVuY3ktc3ltYm9sLW1hcFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbm1vZHVsZS5leHBvcnRzID1cbnsgXCJBTExcIjogXCJMXCJcbiwgXCJBRk5cIjogXCLYi1wiXG4sIFwiQVJTXCI6IFwiJFwiXG4sIFwiQVdHXCI6IFwixpJcIlxuLCBcIkFVRFwiOiBcIiRcIlxuLCBcIkFaTlwiOiBcIuKCvFwiXG4sIFwiQlNEXCI6IFwiJFwiXG4sIFwiQkJEXCI6IFwiJFwiXG4sIFwiQllSXCI6IFwicC5cIlxuLCBcIkJaRFwiOiBcIkJaJFwiXG4sIFwiQk1EXCI6IFwiJFwiXG4sIFwiQk9CXCI6IFwiQnMuXCJcbiwgXCJCQU1cIjogXCJLTVwiXG4sIFwiQldQXCI6IFwiUFwiXG4sIFwiQkdOXCI6IFwi0LvQslwiXG4sIFwiQlJMXCI6IFwiUiRcIlxuLCBcIkJORFwiOiBcIiRcIlxuLCBcIkJUQ1wiOiBcIsmDXCJcbiwgXCJLSFJcIjogXCLhn5tcIlxuLCBcIkNBRFwiOiBcIiRcIlxuLCBcIktZRFwiOiBcIiRcIlxuLCBcIkNMUFwiOiBcIiRcIlxuLCBcIkNOWVwiOiBcIsKlXCJcbiwgXCJDT1BcIjogXCIkXCJcbiwgXCJDUkNcIjogXCLigqFcIlxuLCBcIkhSS1wiOiBcImtuXCJcbiwgXCJDVVBcIjogXCLigrFcIlxuLCBcIkNaS1wiOiBcIkvEjVwiXG4sIFwiREtLXCI6IFwia3JcIlxuLCBcIkRPUFwiOiBcIlJEJFwiXG4sIFwiWENEXCI6IFwiJFwiXG4sIFwiRUdQXCI6IFwiwqNcIlxuLCBcIlNWQ1wiOiBcIiRcIlxuLCBcIkVFS1wiOiBcImtyXCJcbiwgXCJFVVJcIjogXCLigqxcIlxuLCBcIkZLUFwiOiBcIsKjXCJcbiwgXCJGSkRcIjogXCIkXCJcbiwgXCJHSENcIjogXCLigrVcIlxuLCBcIkdJUFwiOiBcIsKjXCJcbiwgXCJHVFFcIjogXCJRXCJcbiwgXCJHR1BcIjogXCLCo1wiXG4sIFwiR1lEXCI6IFwiJFwiXG4sIFwiSE5MXCI6IFwiTFwiXG4sIFwiSEtEXCI6IFwiJFwiXG4sIFwiSFVGXCI6IFwiRnRcIlxuLCBcIklTS1wiOiBcImtyXCJcbiwgXCJJTlJcIjogXCLigrlcIlxuLCBcIklEUlwiOiBcIlJwXCJcbiwgXCJJUlJcIjogXCLvt7xcIlxuLCBcIklNUFwiOiBcIsKjXCJcbiwgXCJJTFNcIjogXCLigqpcIlxuLCBcIkpNRFwiOiBcIkokXCJcbiwgXCJKUFlcIjogXCLCpVwiXG4sIFwiSkVQXCI6IFwiwqNcIlxuLCBcIktFU1wiOiBcIktTaFwiXG4sIFwiS1pUXCI6IFwi0LvQslwiXG4sIFwiS1BXXCI6IFwi4oKpXCJcbiwgXCJLUldcIjogXCLigqlcIlxuLCBcIktHU1wiOiBcItC70LJcIlxuLCBcIkxBS1wiOiBcIuKCrVwiXG4sIFwiTFZMXCI6IFwiTHNcIlxuLCBcIkxCUFwiOiBcIsKjXCJcbiwgXCJMUkRcIjogXCIkXCJcbiwgXCJMVExcIjogXCJMdFwiXG4sIFwiTUtEXCI6IFwi0LTQtdC9XCJcbiwgXCJNWVJcIjogXCJSTVwiXG4sIFwiTVVSXCI6IFwi4oKoXCJcbiwgXCJNWE5cIjogXCIkXCJcbiwgXCJNTlRcIjogXCLigq5cIlxuLCBcIk1aTlwiOiBcIk1UXCJcbiwgXCJOQURcIjogXCIkXCJcbiwgXCJOUFJcIjogXCLigqhcIlxuLCBcIkFOR1wiOiBcIsaSXCJcbiwgXCJOWkRcIjogXCIkXCJcbiwgXCJOSU9cIjogXCJDJFwiXG4sIFwiTkdOXCI6IFwi4oKmXCJcbiwgXCJOT0tcIjogXCJrclwiXG4sIFwiT01SXCI6IFwi77e8XCJcbiwgXCJQS1JcIjogXCLigqhcIlxuLCBcIlBBQlwiOiBcIkIvLlwiXG4sIFwiUFlHXCI6IFwiR3NcIlxuLCBcIlBFTlwiOiBcIlMvLlwiXG4sIFwiUEhQXCI6IFwi4oKxXCJcbiwgXCJQTE5cIjogXCJ6xYJcIlxuLCBcIlFBUlwiOiBcIu+3vFwiXG4sIFwiUk9OXCI6IFwibGVpXCJcbiwgXCJSVUJcIjogXCLigr1cIlxuLCBcIlJNQlwiOiBcIu+/pVwiXG4sIFwiU0hQXCI6IFwiwqNcIlxuLCBcIlNBUlwiOiBcIu+3vFwiXG4sIFwiUlNEXCI6IFwi0JTQuNC9LlwiXG4sIFwiU0NSXCI6IFwi4oKoXCJcbiwgXCJTR0RcIjogXCIkXCJcbiwgXCJTQkRcIjogXCIkXCJcbiwgXCJTT1NcIjogXCJTXCJcbiwgXCJaQVJcIjogXCJSXCJcbiwgXCJMS1JcIjogXCLigqhcIlxuLCBcIlNFS1wiOiBcImtyXCJcbiwgXCJDSEZcIjogXCJDSEZcIlxuLCBcIlNSRFwiOiBcIiRcIlxuLCBcIlNZUFwiOiBcIsKjXCJcbiwgXCJUWlNcIjogXCJUU2hcIlxuLCBcIlRXRFwiOiBcIk5UJFwiXG4sIFwiVEhCXCI6IFwi4Li/XCJcbiwgXCJUVERcIjogXCJUVCRcIlxuLCBcIlRSWVwiOiBcIuKCulwiXG4sIFwiVFJMXCI6IFwi4oKkXCJcbiwgXCJUVkRcIjogXCIkXCJcbiwgXCJVR1hcIjogXCJVU2hcIlxuLCBcIlVBSFwiOiBcIuKCtFwiXG4sIFwiR0JQXCI6IFwiwqNcIlxuLCBcIlVTRFwiOiBcIiRcIlxuLCBcIlVZVVwiOiBcIiRVXCJcbiwgXCJVWlNcIjogXCLQu9CyXCJcbiwgXCJWRUZcIjogXCJCc1wiXG4sIFwiVk5EXCI6IFwi4oKrXCJcbiwgXCJZRVJcIjogXCLvt7xcIlxuLCBcIlpXRFwiOiBcIlokXCJcbiwgXCJHRUxcIjogXCLigr5cIlxuLCBcIktaVFwiOiBcIuKCuFwiXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2N1cnJlbmN5LXN5bWJvbC1tYXAvbWFwLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2N1cnJlbmN5LXN5bWJvbC1tYXBcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCdcclxuXHJcbi8qKlxyXG4gKiBEaWZmIE1hdGNoIGFuZCBQYXRjaFxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgMjAwNiBHb29nbGUgSW5jLlxyXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWRpZmYtbWF0Y2gtcGF0Y2gvXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBDb21wdXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byB0ZXh0cyB0byBjcmVhdGUgYSBwYXRjaC5cclxuICogQXBwbGllcyB0aGUgcGF0Y2ggb250byBhbm90aGVyIHRleHQsIGFsbG93aW5nIGZvciBlcnJvcnMuXHJcbiAqIEBhdXRob3IgZnJhc2VyQGdvb2dsZS5jb20gKE5laWwgRnJhc2VyKVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDbGFzcyBjb250YWluaW5nIHRoZSBkaWZmLCBtYXRjaCBhbmQgcGF0Y2ggbWV0aG9kcy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBkaWZmX21hdGNoX3BhdGNoKCkge1xyXG5cclxuICAvLyBEZWZhdWx0cy5cclxuICAvLyBSZWRlZmluZSB0aGVzZSBpbiB5b3VyIHByb2dyYW0gdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxyXG5cclxuICAvLyBOdW1iZXIgb2Ygc2Vjb25kcyB0byBtYXAgYSBkaWZmIGJlZm9yZSBnaXZpbmcgdXAgKDAgZm9yIGluZmluaXR5KS5cclxuICB0aGlzLkRpZmZfVGltZW91dCA9IDEuMDtcclxuICAvLyBDb3N0IG9mIGFuIGVtcHR5IGVkaXQgb3BlcmF0aW9uIGluIHRlcm1zIG9mIGVkaXQgY2hhcmFjdGVycy5cclxuICB0aGlzLkRpZmZfRWRpdENvc3QgPSA0O1xyXG4gIC8vIEF0IHdoYXQgcG9pbnQgaXMgbm8gbWF0Y2ggZGVjbGFyZWQgKDAuMCA9IHBlcmZlY3Rpb24sIDEuMCA9IHZlcnkgbG9vc2UpLlxyXG4gIHRoaXMuTWF0Y2hfVGhyZXNob2xkID0gMC41O1xyXG4gIC8vIEhvdyBmYXIgdG8gc2VhcmNoIGZvciBhIG1hdGNoICgwID0gZXhhY3QgbG9jYXRpb24sIDEwMDArID0gYnJvYWQgbWF0Y2gpLlxyXG4gIC8vIEEgbWF0Y2ggdGhpcyBtYW55IGNoYXJhY3RlcnMgYXdheSBmcm9tIHRoZSBleHBlY3RlZCBsb2NhdGlvbiB3aWxsIGFkZFxyXG4gIC8vIDEuMCB0byB0aGUgc2NvcmUgKDAuMCBpcyBhIHBlcmZlY3QgbWF0Y2gpLlxyXG4gIHRoaXMuTWF0Y2hfRGlzdGFuY2UgPSAxMDAwO1xyXG4gIC8vIFdoZW4gZGVsZXRpbmcgYSBsYXJnZSBibG9jayBvZiB0ZXh0IChvdmVyIH42NCBjaGFyYWN0ZXJzKSwgaG93IGNsb3NlIGRvXHJcbiAgLy8gdGhlIGNvbnRlbnRzIGhhdmUgdG8gYmUgdG8gbWF0Y2ggdGhlIGV4cGVjdGVkIGNvbnRlbnRzLiAoMC4wID0gcGVyZmVjdGlvbixcclxuICAvLyAxLjAgPSB2ZXJ5IGxvb3NlKS4gIE5vdGUgdGhhdCBNYXRjaF9UaHJlc2hvbGQgY29udHJvbHMgaG93IGNsb3NlbHkgdGhlXHJcbiAgLy8gZW5kIHBvaW50cyBvZiBhIGRlbGV0ZSBuZWVkIHRvIG1hdGNoLlxyXG4gIHRoaXMuUGF0Y2hfRGVsZXRlVGhyZXNob2xkID0gMC41O1xyXG4gIC8vIENodW5rIHNpemUgZm9yIGNvbnRleHQgbGVuZ3RoLlxyXG4gIHRoaXMuUGF0Y2hfTWFyZ2luID0gNDtcclxuXHJcbiAgLy8gVGhlIG51bWJlciBvZiBiaXRzIGluIGFuIGludC5cclxuICB0aGlzLk1hdGNoX01heEJpdHMgPSAzMjtcclxufVxyXG5cclxuXHJcbi8vICBESUZGIEZVTkNUSU9OU1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGEgZGlmZiBpcyBhbiBhcnJheSBvZiB0dXBsZXM6XHJcbiAqIFtbRElGRl9ERUxFVEUsICdIZWxsbyddLCBbRElGRl9JTlNFUlQsICdHb29kYnllJ10sIFtESUZGX0VRVUFMLCAnIHdvcmxkLiddXVxyXG4gKiB3aGljaCBtZWFuczogZGVsZXRlICdIZWxsbycsIGFkZCAnR29vZGJ5ZScgYW5kIGtlZXAgJyB3b3JsZC4nXHJcbiAqL1xyXG52YXIgRElGRl9ERUxFVEUgPSAtMTtcclxudmFyIERJRkZfSU5TRVJUID0gMTtcclxudmFyIERJRkZfRVFVQUwgPSAwO1xyXG5cclxuLyoqIEB0eXBlZGVmIHt7MDogbnVtYmVyLCAxOiBzdHJpbmd9fSAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLkRpZmY7XHJcblxyXG5cclxuLyoqXHJcbiAqIEZpbmQgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIHRleHRzLiAgU2ltcGxpZmllcyB0aGUgcHJvYmxlbSBieSBzdHJpcHBpbmdcclxuICogYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4IG9mZiB0aGUgdGV4dHMgYmVmb3JlIGRpZmZpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfY2hlY2tsaW5lcyBPcHRpb25hbCBzcGVlZHVwIGZsYWcuIElmIHByZXNlbnQgYW5kIGZhbHNlLFxyXG4gKiAgICAgdGhlbiBkb24ndCBydW4gYSBsaW5lLWxldmVsIGRpZmYgZmlyc3QgdG8gaWRlbnRpZnkgdGhlIGNoYW5nZWQgYXJlYXMuXHJcbiAqICAgICBEZWZhdWx0cyB0byB0cnVlLCB3aGljaCBkb2VzIGEgZmFzdGVyLCBzbGlnaHRseSBsZXNzIG9wdGltYWwgZGlmZi5cclxuICogQHBhcmFtIHtudW1iZXJ9IG9wdF9kZWFkbGluZSBPcHRpb25hbCB0aW1lIHdoZW4gdGhlIGRpZmYgc2hvdWxkIGJlIGNvbXBsZXRlXHJcbiAqICAgICBieS4gIFVzZWQgaW50ZXJuYWxseSBmb3IgcmVjdXJzaXZlIGNhbGxzLiAgVXNlcnMgc2hvdWxkIHNldCBEaWZmVGltZW91dFxyXG4gKiAgICAgaW5zdGVhZC5cclxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX21haW4gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIsIG9wdF9jaGVja2xpbmVzLFxyXG4gICAgb3B0X2RlYWRsaW5lKSB7XHJcbiAgLy8gU2V0IGEgZGVhZGxpbmUgYnkgd2hpY2ggdGltZSB0aGUgZGlmZiBtdXN0IGJlIGNvbXBsZXRlLlxyXG4gIGlmICh0eXBlb2Ygb3B0X2RlYWRsaW5lID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBpZiAodGhpcy5EaWZmX1RpbWVvdXQgPD0gMCkge1xyXG4gICAgICBvcHRfZGVhZGxpbmUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb3B0X2RlYWRsaW5lID0gKG5ldyBEYXRlKS5nZXRUaW1lKCkgKyB0aGlzLkRpZmZfVGltZW91dCAqIDEwMDA7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHZhciBkZWFkbGluZSA9IG9wdF9kZWFkbGluZTtcclxuXHJcbiAgLy8gQ2hlY2sgZm9yIG51bGwgaW5wdXRzLlxyXG4gIGlmICh0ZXh0MSA9PSBudWxsIHx8IHRleHQyID09IG51bGwpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTnVsbCBpbnB1dC4gKGRpZmZfbWFpbiknKTtcclxuICB9XHJcblxyXG4gIC8vIENoZWNrIGZvciBlcXVhbGl0eSAoc3BlZWR1cCkuXHJcbiAgaWYgKHRleHQxID09IHRleHQyKSB7XHJcbiAgICBpZiAodGV4dDEpIHtcclxuICAgICAgcmV0dXJuIFtbRElGRl9FUVVBTCwgdGV4dDFdXTtcclxuICAgIH1cclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2Ygb3B0X2NoZWNrbGluZXMgPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIG9wdF9jaGVja2xpbmVzID0gdHJ1ZTtcclxuICB9XHJcbiAgdmFyIGNoZWNrbGluZXMgPSBvcHRfY2hlY2tsaW5lcztcclxuXHJcbiAgLy8gVHJpbSBvZmYgY29tbW9uIHByZWZpeCAoc3BlZWR1cCkuXHJcbiAgdmFyIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25QcmVmaXgodGV4dDEsIHRleHQyKTtcclxuICB2YXIgY29tbW9ucHJlZml4ID0gdGV4dDEuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XHJcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcclxuICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xyXG5cclxuICAvLyBUcmltIG9mZiBjb21tb24gc3VmZml4IChzcGVlZHVwKS5cclxuICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mik7XHJcbiAgdmFyIGNvbW1vbnN1ZmZpeCA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xyXG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKDAsIHRleHQxLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCk7XHJcbiAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcclxuXHJcbiAgLy8gQ29tcHV0ZSB0aGUgZGlmZiBvbiB0aGUgbWlkZGxlIGJsb2NrLlxyXG4gIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9jb21wdXRlXyh0ZXh0MSwgdGV4dDIsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcclxuXHJcbiAgLy8gUmVzdG9yZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXHJcbiAgaWYgKGNvbW1vbnByZWZpeCkge1xyXG4gICAgZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgY29tbW9ucHJlZml4XSk7XHJcbiAgfVxyXG4gIGlmIChjb21tb25zdWZmaXgpIHtcclxuICAgIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIGNvbW1vbnN1ZmZpeF0pO1xyXG4gIH1cclxuICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcclxuICByZXR1cm4gZGlmZnM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEZpbmQgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIHRleHRzLiAgQXNzdW1lcyB0aGF0IHRoZSB0ZXh0cyBkbyBub3RcclxuICogaGF2ZSBhbnkgY29tbW9uIHByZWZpeCBvciBzdWZmaXguXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrbGluZXMgU3BlZWR1cCBmbGFnLiAgSWYgZmFsc2UsIHRoZW4gZG9uJ3QgcnVuIGFcclxuICogICAgIGxpbmUtbGV2ZWwgZGlmZiBmaXJzdCB0byBpZGVudGlmeSB0aGUgY2hhbmdlZCBhcmVhcy5cclxuICogICAgIElmIHRydWUsIHRoZW4gcnVuIGEgZmFzdGVyLCBzbGlnaHRseSBsZXNzIG9wdGltYWwgZGlmZi5cclxuICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgd2hlbiB0aGUgZGlmZiBzaG91bGQgYmUgY29tcGxldGUgYnkuXHJcbiAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21wdXRlXyA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0MiwgY2hlY2tsaW5lcyxcclxuICAgIGRlYWRsaW5lKSB7XHJcbiAgdmFyIGRpZmZzO1xyXG5cclxuICBpZiAoIXRleHQxKSB7XHJcbiAgICAvLyBKdXN0IGFkZCBzb21lIHRleHQgKHNwZWVkdXApLlxyXG4gICAgcmV0dXJuIFtbRElGRl9JTlNFUlQsIHRleHQyXV07XHJcbiAgfVxyXG5cclxuICBpZiAoIXRleHQyKSB7XHJcbiAgICAvLyBKdXN0IGRlbGV0ZSBzb21lIHRleHQgKHNwZWVkdXApLlxyXG4gICAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXV07XHJcbiAgfVxyXG5cclxuICB2YXIgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyO1xyXG4gIHZhciBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xyXG4gIHZhciBpID0gbG9uZ3RleHQuaW5kZXhPZihzaG9ydHRleHQpO1xyXG4gIGlmIChpICE9IC0xKSB7XHJcbiAgICAvLyBTaG9ydGVyIHRleHQgaXMgaW5zaWRlIHRoZSBsb25nZXIgdGV4dCAoc3BlZWR1cCkuXHJcbiAgICBkaWZmcyA9IFtbRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpKV0sXHJcbiAgICAgICAgICAgICBbRElGRl9FUVVBTCwgc2hvcnR0ZXh0XSxcclxuICAgICAgICAgICAgIFtESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBzaG9ydHRleHQubGVuZ3RoKV1dO1xyXG4gICAgLy8gU3dhcCBpbnNlcnRpb25zIGZvciBkZWxldGlvbnMgaWYgZGlmZiBpcyByZXZlcnNlZC5cclxuICAgIGlmICh0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGgpIHtcclxuICAgICAgZGlmZnNbMF1bMF0gPSBkaWZmc1syXVswXSA9IERJRkZfREVMRVRFO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpZmZzO1xyXG4gIH1cclxuXHJcbiAgaWYgKHNob3J0dGV4dC5sZW5ndGggPT0gMSkge1xyXG4gICAgLy8gU2luZ2xlIGNoYXJhY3RlciBzdHJpbmcuXHJcbiAgICAvLyBBZnRlciB0aGUgcHJldmlvdXMgc3BlZWR1cCwgdGhlIGNoYXJhY3RlciBjYW4ndCBiZSBhbiBlcXVhbGl0eS5cclxuICAgIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV0sIFtESUZGX0lOU0VSVCwgdGV4dDJdXTtcclxuICB9XHJcblxyXG4gIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgcHJvYmxlbSBjYW4gYmUgc3BsaXQgaW4gdHdvLlxyXG4gIHZhciBobSA9IHRoaXMuZGlmZl9oYWxmTWF0Y2hfKHRleHQxLCB0ZXh0Mik7XHJcbiAgaWYgKGhtKSB7XHJcbiAgICAvLyBBIGhhbGYtbWF0Y2ggd2FzIGZvdW5kLCBzb3J0IG91dCB0aGUgcmV0dXJuIGRhdGEuXHJcbiAgICB2YXIgdGV4dDFfYSA9IGhtWzBdO1xyXG4gICAgdmFyIHRleHQxX2IgPSBobVsxXTtcclxuICAgIHZhciB0ZXh0Ml9hID0gaG1bMl07XHJcbiAgICB2YXIgdGV4dDJfYiA9IGhtWzNdO1xyXG4gICAgdmFyIG1pZF9jb21tb24gPSBobVs0XTtcclxuICAgIC8vIFNlbmQgYm90aCBwYWlycyBvZmYgZm9yIHNlcGFyYXRlIHByb2Nlc3NpbmcuXHJcbiAgICB2YXIgZGlmZnNfYSA9IHRoaXMuZGlmZl9tYWluKHRleHQxX2EsIHRleHQyX2EsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcclxuICAgIHZhciBkaWZmc19iID0gdGhpcy5kaWZmX21haW4odGV4dDFfYiwgdGV4dDJfYiwgY2hlY2tsaW5lcywgZGVhZGxpbmUpO1xyXG4gICAgLy8gTWVyZ2UgdGhlIHJlc3VsdHMuXHJcbiAgICByZXR1cm4gZGlmZnNfYS5jb25jYXQoW1tESUZGX0VRVUFMLCBtaWRfY29tbW9uXV0sIGRpZmZzX2IpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNoZWNrbGluZXMgJiYgdGV4dDEubGVuZ3RoID4gMTAwICYmIHRleHQyLmxlbmd0aCA+IDEwMCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGlmZl9saW5lTW9kZV8odGV4dDEsIHRleHQyLCBkZWFkbGluZSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcy5kaWZmX2Jpc2VjdF8odGV4dDEsIHRleHQyLCBkZWFkbGluZSk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIERvIGEgcXVpY2sgbGluZS1sZXZlbCBkaWZmIG9uIGJvdGggc3RyaW5ncywgdGhlbiByZWRpZmYgdGhlIHBhcnRzIGZvclxyXG4gKiBncmVhdGVyIGFjY3VyYWN5LlxyXG4gKiBUaGlzIHNwZWVkdXAgY2FuIHByb2R1Y2Ugbm9uLW1pbmltYWwgZGlmZnMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVhZGxpbmUgVGltZSB3aGVuIHRoZSBkaWZmIHNob3VsZCBiZSBjb21wbGV0ZSBieS5cclxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2xpbmVNb2RlXyA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0MiwgZGVhZGxpbmUpIHtcclxuICAvLyBTY2FuIHRoZSB0ZXh0IG9uIGEgbGluZS1ieS1saW5lIGJhc2lzIGZpcnN0LlxyXG4gIHZhciBhID0gdGhpcy5kaWZmX2xpbmVzVG9DaGFyc18odGV4dDEsIHRleHQyKTtcclxuICB0ZXh0MSA9IGEuY2hhcnMxO1xyXG4gIHRleHQyID0gYS5jaGFyczI7XHJcbiAgdmFyIGxpbmVhcnJheSA9IGEubGluZUFycmF5O1xyXG5cclxuICB2YXIgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MSwgdGV4dDIsIGZhbHNlLCBkZWFkbGluZSk7XHJcblxyXG4gIC8vIENvbnZlcnQgdGhlIGRpZmYgYmFjayB0byBvcmlnaW5hbCB0ZXh0LlxyXG4gIHRoaXMuZGlmZl9jaGFyc1RvTGluZXNfKGRpZmZzLCBsaW5lYXJyYXkpO1xyXG4gIC8vIEVsaW1pbmF0ZSBmcmVhayBtYXRjaGVzIChlLmcuIGJsYW5rIGxpbmVzKVxyXG4gIHRoaXMuZGlmZl9jbGVhbnVwU2VtYW50aWMoZGlmZnMpO1xyXG5cclxuICAvLyBSZWRpZmYgYW55IHJlcGxhY2VtZW50IGJsb2NrcywgdGhpcyB0aW1lIGNoYXJhY3Rlci1ieS1jaGFyYWN0ZXIuXHJcbiAgLy8gQWRkIGEgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cclxuICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCAnJ10pO1xyXG4gIHZhciBwb2ludGVyID0gMDtcclxuICB2YXIgY291bnRfZGVsZXRlID0gMDtcclxuICB2YXIgY291bnRfaW5zZXJ0ID0gMDtcclxuICB2YXIgdGV4dF9kZWxldGUgPSAnJztcclxuICB2YXIgdGV4dF9pbnNlcnQgPSAnJztcclxuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xyXG4gICAgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xyXG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxyXG4gICAgICAgIGNvdW50X2luc2VydCsrO1xyXG4gICAgICAgIHRleHRfaW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxyXG4gICAgICAgIGNvdW50X2RlbGV0ZSsrO1xyXG4gICAgICAgIHRleHRfZGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfRVFVQUw6XHJcbiAgICAgICAgLy8gVXBvbiByZWFjaGluZyBhbiBlcXVhbGl0eSwgY2hlY2sgZm9yIHByaW9yIHJlZHVuZGFuY2llcy5cclxuICAgICAgICBpZiAoY291bnRfZGVsZXRlID49IDEgJiYgY291bnRfaW5zZXJ0ID49IDEpIHtcclxuICAgICAgICAgIC8vIERlbGV0ZSB0aGUgb2ZmZW5kaW5nIHJlY29yZHMgYW5kIGFkZCB0aGUgbWVyZ2VkIG9uZXMuXHJcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCxcclxuICAgICAgICAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQpO1xyXG4gICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQ7XHJcbiAgICAgICAgICB2YXIgYSA9IHRoaXMuZGlmZl9tYWluKHRleHRfZGVsZXRlLCB0ZXh0X2luc2VydCwgZmFsc2UsIGRlYWRsaW5lKTtcclxuICAgICAgICAgIGZvciAodmFyIGogPSBhLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBhW2pdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyICsgYS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvdW50X2luc2VydCA9IDA7XHJcbiAgICAgICAgY291bnRfZGVsZXRlID0gMDtcclxuICAgICAgICB0ZXh0X2RlbGV0ZSA9ICcnO1xyXG4gICAgICAgIHRleHRfaW5zZXJ0ID0gJyc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBwb2ludGVyKys7XHJcbiAgfVxyXG4gIGRpZmZzLnBvcCgpOyAgLy8gUmVtb3ZlIHRoZSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxyXG5cclxuICByZXR1cm4gZGlmZnM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEZpbmQgdGhlICdtaWRkbGUgc25ha2UnIG9mIGEgZGlmZiwgc3BsaXQgdGhlIHByb2JsZW0gaW4gdHdvXHJcbiAqIGFuZCByZXR1cm4gdGhlIHJlY3Vyc2l2ZWx5IGNvbnN0cnVjdGVkIGRpZmYuXHJcbiAqIFNlZSBNeWVycyAxOTg2IHBhcGVyOiBBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgSXRzIFZhcmlhdGlvbnMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVhZGxpbmUgVGltZSBhdCB3aGljaCB0byBiYWlsIGlmIG5vdCB5ZXQgY29tcGxldGUuXHJcbiAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9iaXNlY3RfID0gZnVuY3Rpb24odGV4dDEsIHRleHQyLCBkZWFkbGluZSkge1xyXG4gIC8vIENhY2hlIHRoZSB0ZXh0IGxlbmd0aHMgdG8gcHJldmVudCBtdWx0aXBsZSBjYWxscy5cclxuICB2YXIgdGV4dDFfbGVuZ3RoID0gdGV4dDEubGVuZ3RoO1xyXG4gIHZhciB0ZXh0Ml9sZW5ndGggPSB0ZXh0Mi5sZW5ndGg7XHJcbiAgdmFyIG1heF9kID0gTWF0aC5jZWlsKCh0ZXh0MV9sZW5ndGggKyB0ZXh0Ml9sZW5ndGgpIC8gMik7XHJcbiAgdmFyIHZfb2Zmc2V0ID0gbWF4X2Q7XHJcbiAgdmFyIHZfbGVuZ3RoID0gMiAqIG1heF9kO1xyXG4gIHZhciB2MSA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XHJcbiAgdmFyIHYyID0gbmV3IEFycmF5KHZfbGVuZ3RoKTtcclxuICAvLyBTZXR0aW5nIGFsbCBlbGVtZW50cyB0byAtMSBpcyBmYXN0ZXIgaW4gQ2hyb21lICYgRmlyZWZveCB0aGFuIG1peGluZ1xyXG4gIC8vIGludGVnZXJzIGFuZCB1bmRlZmluZWQuXHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB2X2xlbmd0aDsgeCsrKSB7XHJcbiAgICB2MVt4XSA9IC0xO1xyXG4gICAgdjJbeF0gPSAtMTtcclxuICB9XHJcbiAgdjFbdl9vZmZzZXQgKyAxXSA9IDA7XHJcbiAgdjJbdl9vZmZzZXQgKyAxXSA9IDA7XHJcbiAgdmFyIGRlbHRhID0gdGV4dDFfbGVuZ3RoIC0gdGV4dDJfbGVuZ3RoO1xyXG4gIC8vIElmIHRoZSB0b3RhbCBudW1iZXIgb2YgY2hhcmFjdGVycyBpcyBvZGQsIHRoZW4gdGhlIGZyb250IHBhdGggd2lsbCBjb2xsaWRlXHJcbiAgLy8gd2l0aCB0aGUgcmV2ZXJzZSBwYXRoLlxyXG4gIHZhciBmcm9udCA9IChkZWx0YSAlIDIgIT0gMCk7XHJcbiAgLy8gT2Zmc2V0cyBmb3Igc3RhcnQgYW5kIGVuZCBvZiBrIGxvb3AuXHJcbiAgLy8gUHJldmVudHMgbWFwcGluZyBvZiBzcGFjZSBiZXlvbmQgdGhlIGdyaWQuXHJcbiAgdmFyIGsxc3RhcnQgPSAwO1xyXG4gIHZhciBrMWVuZCA9IDA7XHJcbiAgdmFyIGsyc3RhcnQgPSAwO1xyXG4gIHZhciBrMmVuZCA9IDA7XHJcbiAgZm9yICh2YXIgZCA9IDA7IGQgPCBtYXhfZDsgZCsrKSB7XHJcbiAgICAvLyBCYWlsIG91dCBpZiBkZWFkbGluZSBpcyByZWFjaGVkLlxyXG4gICAgaWYgKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgPiBkZWFkbGluZSkge1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICAvLyBXYWxrIHRoZSBmcm9udCBwYXRoIG9uZSBzdGVwLlxyXG4gICAgZm9yICh2YXIgazEgPSAtZCArIGsxc3RhcnQ7IGsxIDw9IGQgLSBrMWVuZDsgazEgKz0gMikge1xyXG4gICAgICB2YXIgazFfb2Zmc2V0ID0gdl9vZmZzZXQgKyBrMTtcclxuICAgICAgdmFyIHgxO1xyXG4gICAgICBpZiAoazEgPT0gLWQgfHwgKGsxICE9IGQgJiYgdjFbazFfb2Zmc2V0IC0gMV0gPCB2MVtrMV9vZmZzZXQgKyAxXSkpIHtcclxuICAgICAgICB4MSA9IHYxW2sxX29mZnNldCArIDFdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHgxID0gdjFbazFfb2Zmc2V0IC0gMV0gKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB5MSA9IHgxIC0gazE7XHJcbiAgICAgIHdoaWxlICh4MSA8IHRleHQxX2xlbmd0aCAmJiB5MSA8IHRleHQyX2xlbmd0aCAmJlxyXG4gICAgICAgICAgICAgdGV4dDEuY2hhckF0KHgxKSA9PSB0ZXh0Mi5jaGFyQXQoeTEpKSB7XHJcbiAgICAgICAgeDErKztcclxuICAgICAgICB5MSsrO1xyXG4gICAgICB9XHJcbiAgICAgIHYxW2sxX29mZnNldF0gPSB4MTtcclxuICAgICAgaWYgKHgxID4gdGV4dDFfbGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgcmlnaHQgb2YgdGhlIGdyYXBoLlxyXG4gICAgICAgIGsxZW5kICs9IDI7XHJcbiAgICAgIH0gZWxzZSBpZiAoeTEgPiB0ZXh0Ml9sZW5ndGgpIHtcclxuICAgICAgICAvLyBSYW4gb2ZmIHRoZSBib3R0b20gb2YgdGhlIGdyYXBoLlxyXG4gICAgICAgIGsxc3RhcnQgKz0gMjtcclxuICAgICAgfSBlbHNlIGlmIChmcm9udCkge1xyXG4gICAgICAgIHZhciBrMl9vZmZzZXQgPSB2X29mZnNldCArIGRlbHRhIC0gazE7XHJcbiAgICAgICAgaWYgKGsyX29mZnNldCA+PSAwICYmIGsyX29mZnNldCA8IHZfbGVuZ3RoICYmIHYyW2syX29mZnNldF0gIT0gLTEpIHtcclxuICAgICAgICAgIC8vIE1pcnJvciB4MiBvbnRvIHRvcC1sZWZ0IGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gICAgICAgICAgdmFyIHgyID0gdGV4dDFfbGVuZ3RoIC0gdjJbazJfb2Zmc2V0XTtcclxuICAgICAgICAgIGlmICh4MSA+PSB4Mikge1xyXG4gICAgICAgICAgICAvLyBPdmVybGFwIGRldGVjdGVkLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaWZmX2Jpc2VjdFNwbGl0Xyh0ZXh0MSwgdGV4dDIsIHgxLCB5MSwgZGVhZGxpbmUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFdhbGsgdGhlIHJldmVyc2UgcGF0aCBvbmUgc3RlcC5cclxuICAgIGZvciAodmFyIGsyID0gLWQgKyBrMnN0YXJ0OyBrMiA8PSBkIC0gazJlbmQ7IGsyICs9IDIpIHtcclxuICAgICAgdmFyIGsyX29mZnNldCA9IHZfb2Zmc2V0ICsgazI7XHJcbiAgICAgIHZhciB4MjtcclxuICAgICAgaWYgKGsyID09IC1kIHx8IChrMiAhPSBkICYmIHYyW2syX29mZnNldCAtIDFdIDwgdjJbazJfb2Zmc2V0ICsgMV0pKSB7XHJcbiAgICAgICAgeDIgPSB2MltrMl9vZmZzZXQgKyAxXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4MiA9IHYyW2syX29mZnNldCAtIDFdICsgMTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgeTIgPSB4MiAtIGsyO1xyXG4gICAgICB3aGlsZSAoeDIgPCB0ZXh0MV9sZW5ndGggJiYgeTIgPCB0ZXh0Ml9sZW5ndGggJiZcclxuICAgICAgICAgICAgIHRleHQxLmNoYXJBdCh0ZXh0MV9sZW5ndGggLSB4MiAtIDEpID09XHJcbiAgICAgICAgICAgICB0ZXh0Mi5jaGFyQXQodGV4dDJfbGVuZ3RoIC0geTIgLSAxKSkge1xyXG4gICAgICAgIHgyKys7XHJcbiAgICAgICAgeTIrKztcclxuICAgICAgfVxyXG4gICAgICB2MltrMl9vZmZzZXRdID0geDI7XHJcbiAgICAgIGlmICh4MiA+IHRleHQxX2xlbmd0aCkge1xyXG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIGxlZnQgb2YgdGhlIGdyYXBoLlxyXG4gICAgICAgIGsyZW5kICs9IDI7XHJcbiAgICAgIH0gZWxzZSBpZiAoeTIgPiB0ZXh0Ml9sZW5ndGgpIHtcclxuICAgICAgICAvLyBSYW4gb2ZmIHRoZSB0b3Agb2YgdGhlIGdyYXBoLlxyXG4gICAgICAgIGsyc3RhcnQgKz0gMjtcclxuICAgICAgfSBlbHNlIGlmICghZnJvbnQpIHtcclxuICAgICAgICB2YXIgazFfb2Zmc2V0ID0gdl9vZmZzZXQgKyBkZWx0YSAtIGsyO1xyXG4gICAgICAgIGlmIChrMV9vZmZzZXQgPj0gMCAmJiBrMV9vZmZzZXQgPCB2X2xlbmd0aCAmJiB2MVtrMV9vZmZzZXRdICE9IC0xKSB7XHJcbiAgICAgICAgICB2YXIgeDEgPSB2MVtrMV9vZmZzZXRdO1xyXG4gICAgICAgICAgdmFyIHkxID0gdl9vZmZzZXQgKyB4MSAtIGsxX29mZnNldDtcclxuICAgICAgICAgIC8vIE1pcnJvciB4MiBvbnRvIHRvcC1sZWZ0IGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gICAgICAgICAgeDIgPSB0ZXh0MV9sZW5ndGggLSB4MjtcclxuICAgICAgICAgIGlmICh4MSA+PSB4Mikge1xyXG4gICAgICAgICAgICAvLyBPdmVybGFwIGRldGVjdGVkLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaWZmX2Jpc2VjdFNwbGl0Xyh0ZXh0MSwgdGV4dDIsIHgxLCB5MSwgZGVhZGxpbmUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAvLyBEaWZmIHRvb2sgdG9vIGxvbmcgYW5kIGhpdCB0aGUgZGVhZGxpbmUgb3JcclxuICAvLyBudW1iZXIgb2YgZGlmZnMgZXF1YWxzIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBubyBjb21tb25hbGl0eSBhdCBhbGwuXHJcbiAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiB0aGUgbG9jYXRpb24gb2YgdGhlICdtaWRkbGUgc25ha2UnLCBzcGxpdCB0aGUgZGlmZiBpbiB0d28gcGFydHNcclxuICogYW5kIHJlY3Vyc2UuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0geCBJbmRleCBvZiBzcGxpdCBwb2ludCBpbiB0ZXh0MS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHkgSW5kZXggb2Ygc3BsaXQgcG9pbnQgaW4gdGV4dDIuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWFkbGluZSBUaW1lIGF0IHdoaWNoIHRvIGJhaWwgaWYgbm90IHlldCBjb21wbGV0ZS5cclxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2Jpc2VjdFNwbGl0XyA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0MiwgeCwgeSxcclxuICAgIGRlYWRsaW5lKSB7XHJcbiAgdmFyIHRleHQxYSA9IHRleHQxLnN1YnN0cmluZygwLCB4KTtcclxuICB2YXIgdGV4dDJhID0gdGV4dDIuc3Vic3RyaW5nKDAsIHkpO1xyXG4gIHZhciB0ZXh0MWIgPSB0ZXh0MS5zdWJzdHJpbmcoeCk7XHJcbiAgdmFyIHRleHQyYiA9IHRleHQyLnN1YnN0cmluZyh5KTtcclxuXHJcbiAgLy8gQ29tcHV0ZSBib3RoIGRpZmZzIHNlcmlhbGx5LlxyXG4gIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9tYWluKHRleHQxYSwgdGV4dDJhLCBmYWxzZSwgZGVhZGxpbmUpO1xyXG4gIHZhciBkaWZmc2IgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MWIsIHRleHQyYiwgZmFsc2UsIGRlYWRsaW5lKTtcclxuXHJcbiAgcmV0dXJuIGRpZmZzLmNvbmNhdChkaWZmc2IpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBTcGxpdCB0d28gdGV4dHMgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzLiAgUmVkdWNlIHRoZSB0ZXh0cyB0byBhIHN0cmluZyBvZlxyXG4gKiBoYXNoZXMgd2hlcmUgZWFjaCBVbmljb2RlIGNoYXJhY3RlciByZXByZXNlbnRzIG9uZSBsaW5lLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cclxuICogQHJldHVybiB7e2NoYXJzMTogc3RyaW5nLCBjaGFyczI6IHN0cmluZywgbGluZUFycmF5OiAhQXJyYXkuPHN0cmluZz59fVxyXG4gKiAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVuY29kZWQgdGV4dDEsIHRoZSBlbmNvZGVkIHRleHQyIGFuZFxyXG4gKiAgICAgdGhlIGFycmF5IG9mIHVuaXF1ZSBzdHJpbmdzLlxyXG4gKiAgICAgVGhlIHplcm90aCBlbGVtZW50IG9mIHRoZSBhcnJheSBvZiB1bmlxdWUgc3RyaW5ncyBpcyBpbnRlbnRpb25hbGx5IGJsYW5rLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9saW5lc1RvQ2hhcnNfID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XHJcbiAgdmFyIGxpbmVBcnJheSA9IFtdOyAgLy8gZS5nLiBsaW5lQXJyYXlbNF0gPT0gJ0hlbGxvXFxuJ1xyXG4gIHZhciBsaW5lSGFzaCA9IHt9OyAgIC8vIGUuZy4gbGluZUhhc2hbJ0hlbGxvXFxuJ10gPT0gNFxyXG5cclxuICAvLyAnXFx4MDAnIGlzIGEgdmFsaWQgY2hhcmFjdGVyLCBidXQgdmFyaW91cyBkZWJ1Z2dlcnMgZG9uJ3QgbGlrZSBpdC5cclxuICAvLyBTbyB3ZSdsbCBpbnNlcnQgYSBqdW5rIGVudHJ5IHRvIGF2b2lkIGdlbmVyYXRpbmcgYSBudWxsIGNoYXJhY3Rlci5cclxuICBsaW5lQXJyYXlbMF0gPSAnJztcclxuXHJcbiAgLyoqXHJcbiAgICogU3BsaXQgYSB0ZXh0IGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncy4gIFJlZHVjZSB0aGUgdGV4dHMgdG8gYSBzdHJpbmcgb2ZcclxuICAgKiBoYXNoZXMgd2hlcmUgZWFjaCBVbmljb2RlIGNoYXJhY3RlciByZXByZXNlbnRzIG9uZSBsaW5lLlxyXG4gICAqIE1vZGlmaWVzIGxpbmVhcnJheSBhbmQgbGluZWhhc2ggdGhyb3VnaCBiZWluZyBhIGNsb3N1cmUuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgU3RyaW5nIHRvIGVuY29kZS5cclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEVuY29kZWQgc3RyaW5nLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZV8odGV4dCkge1xyXG4gICAgdmFyIGNoYXJzID0gJyc7XHJcbiAgICAvLyBXYWxrIHRoZSB0ZXh0LCBwdWxsaW5nIG91dCBhIHN1YnN0cmluZyBmb3IgZWFjaCBsaW5lLlxyXG4gICAgLy8gdGV4dC5zcGxpdCgnXFxuJykgd291bGQgd291bGQgdGVtcG9yYXJpbHkgZG91YmxlIG91ciBtZW1vcnkgZm9vdHByaW50LlxyXG4gICAgLy8gTW9kaWZ5aW5nIHRleHQgd291bGQgY3JlYXRlIG1hbnkgbGFyZ2Ugc3RyaW5ncyB0byBnYXJiYWdlIGNvbGxlY3QuXHJcbiAgICB2YXIgbGluZVN0YXJ0ID0gMDtcclxuICAgIHZhciBsaW5lRW5kID0gLTE7XHJcbiAgICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhcmlhYmxlIGlzIGZhc3RlciB0aGFuIGxvb2tpbmcgaXQgdXAuXHJcbiAgICB2YXIgbGluZUFycmF5TGVuZ3RoID0gbGluZUFycmF5Lmxlbmd0aDtcclxuICAgIHdoaWxlIChsaW5lRW5kIDwgdGV4dC5sZW5ndGggLSAxKSB7XHJcbiAgICAgIGxpbmVFbmQgPSB0ZXh0LmluZGV4T2YoJ1xcbicsIGxpbmVTdGFydCk7XHJcbiAgICAgIGlmIChsaW5lRW5kID09IC0xKSB7XHJcbiAgICAgICAgbGluZUVuZCA9IHRleHQubGVuZ3RoIC0gMTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgbGluZSA9IHRleHQuc3Vic3RyaW5nKGxpbmVTdGFydCwgbGluZUVuZCArIDEpO1xyXG4gICAgICBsaW5lU3RhcnQgPSBsaW5lRW5kICsgMTtcclxuXHJcbiAgICAgIGlmIChsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eSA/IGxpbmVIYXNoLmhhc093blByb3BlcnR5KGxpbmUpIDpcclxuICAgICAgICAgIChsaW5lSGFzaFtsaW5lXSAhPT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUhhc2hbbGluZV0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUFycmF5TGVuZ3RoKTtcclxuICAgICAgICBsaW5lSGFzaFtsaW5lXSA9IGxpbmVBcnJheUxlbmd0aDtcclxuICAgICAgICBsaW5lQXJyYXlbbGluZUFycmF5TGVuZ3RoKytdID0gbGluZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoYXJzO1xyXG4gIH1cclxuXHJcbiAgdmFyIGNoYXJzMSA9IGRpZmZfbGluZXNUb0NoYXJzTXVuZ2VfKHRleHQxKTtcclxuICB2YXIgY2hhcnMyID0gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZV8odGV4dDIpO1xyXG4gIHJldHVybiB7Y2hhcnMxOiBjaGFyczEsIGNoYXJzMjogY2hhcnMyLCBsaW5lQXJyYXk6IGxpbmVBcnJheX07XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlaHlkcmF0ZSB0aGUgdGV4dCBpbiBhIGRpZmYgZnJvbSBhIHN0cmluZyBvZiBsaW5lIGhhc2hlcyB0byByZWFsIGxpbmVzIG9mXHJcbiAqIHRleHQuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxzdHJpbmc+fSBsaW5lQXJyYXkgQXJyYXkgb2YgdW5pcXVlIHN0cmluZ3MuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NoYXJzVG9MaW5lc18gPSBmdW5jdGlvbihkaWZmcywgbGluZUFycmF5KSB7XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xyXG4gICAgdmFyIGNoYXJzID0gZGlmZnNbeF1bMV07XHJcbiAgICB2YXIgdGV4dCA9IFtdO1xyXG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjaGFycy5sZW5ndGg7IHkrKykge1xyXG4gICAgICB0ZXh0W3ldID0gbGluZUFycmF5W2NoYXJzLmNoYXJDb2RlQXQoeSldO1xyXG4gICAgfVxyXG4gICAgZGlmZnNbeF1bMV0gPSB0ZXh0LmpvaW4oJycpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lIHRoZSBjb21tb24gcHJlZml4IG9mIHR3byBzdHJpbmdzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29tbW9uIHRvIHRoZSBzdGFydCBvZiBlYWNoXHJcbiAqICAgICBzdHJpbmcuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NvbW1vblByZWZpeCA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Mikge1xyXG4gIC8vIFF1aWNrIGNoZWNrIGZvciBjb21tb24gbnVsbCBjYXNlcy5cclxuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MS5jaGFyQXQoMCkgIT0gdGV4dDIuY2hhckF0KDApKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgLy8gQmluYXJ5IHNlYXJjaC5cclxuICAvLyBQZXJmb3JtYW5jZSBhbmFseXNpczogaHR0cDovL25laWwuZnJhc2VyLm5hbWUvbmV3cy8yMDA3LzEwLzA5L1xyXG4gIHZhciBwb2ludGVybWluID0gMDtcclxuICB2YXIgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcclxuICB2YXIgcG9pbnRlcm1pZCA9IHBvaW50ZXJtYXg7XHJcbiAgdmFyIHBvaW50ZXJzdGFydCA9IDA7XHJcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XHJcbiAgICBpZiAodGV4dDEuc3Vic3RyaW5nKHBvaW50ZXJzdGFydCwgcG9pbnRlcm1pZCkgPT1cclxuICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSkge1xyXG4gICAgICBwb2ludGVybWluID0gcG9pbnRlcm1pZDtcclxuICAgICAgcG9pbnRlcnN0YXJ0ID0gcG9pbnRlcm1pbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xyXG4gICAgfVxyXG4gICAgcG9pbnRlcm1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJtYXggLSBwb2ludGVybWluKSAvIDIgKyBwb2ludGVybWluKTtcclxuICB9XHJcbiAgcmV0dXJuIHBvaW50ZXJtaWQ7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZSB0aGUgY29tbW9uIHN1ZmZpeCBvZiB0d28gc3RyaW5ncy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXHJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgZW5kIG9mIGVhY2ggc3RyaW5nLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21tb25TdWZmaXggPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcclxuICAvLyBRdWljayBjaGVjayBmb3IgY29tbW9uIG51bGwgY2FzZXMuXHJcbiAgaWYgKCF0ZXh0MSB8fCAhdGV4dDIgfHxcclxuICAgICAgdGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIDEpICE9IHRleHQyLmNoYXJBdCh0ZXh0Mi5sZW5ndGggLSAxKSkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIC8vIEJpbmFyeSBzZWFyY2guXHJcbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHA6Ly9uZWlsLmZyYXNlci5uYW1lL25ld3MvMjAwNy8xMC8wOS9cclxuICB2YXIgcG9pbnRlcm1pbiA9IDA7XHJcbiAgdmFyIHBvaW50ZXJtYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XHJcbiAgdmFyIHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xyXG4gIHZhciBwb2ludGVyZW5kID0gMDtcclxuICB3aGlsZSAocG9pbnRlcm1pbiA8IHBvaW50ZXJtaWQpIHtcclxuICAgIGlmICh0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDEubGVuZ3RoIC0gcG9pbnRlcmVuZCkgPT1cclxuICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcodGV4dDIubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDIubGVuZ3RoIC0gcG9pbnRlcmVuZCkpIHtcclxuICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XHJcbiAgICAgIHBvaW50ZXJlbmQgPSBwb2ludGVybWluO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcG9pbnRlcm1heCA9IHBvaW50ZXJtaWQ7XHJcbiAgICB9XHJcbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xyXG4gIH1cclxuICByZXR1cm4gcG9pbnRlcm1pZDtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lIGlmIHRoZSBzdWZmaXggb2Ygb25lIHN0cmluZyBpcyB0aGUgcHJlZml4IG9mIGFub3RoZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21tb24gdG8gdGhlIGVuZCBvZiB0aGUgZmlyc3RcclxuICogICAgIHN0cmluZyBhbmQgdGhlIHN0YXJ0IG9mIHRoZSBzZWNvbmQgc3RyaW5nLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21tb25PdmVybGFwXyA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Mikge1xyXG4gIC8vIENhY2hlIHRoZSB0ZXh0IGxlbmd0aHMgdG8gcHJldmVudCBtdWx0aXBsZSBjYWxscy5cclxuICB2YXIgdGV4dDFfbGVuZ3RoID0gdGV4dDEubGVuZ3RoO1xyXG4gIHZhciB0ZXh0Ml9sZW5ndGggPSB0ZXh0Mi5sZW5ndGg7XHJcbiAgLy8gRWxpbWluYXRlIHRoZSBudWxsIGNhc2UuXHJcbiAgaWYgKHRleHQxX2xlbmd0aCA9PSAwIHx8IHRleHQyX2xlbmd0aCA9PSAwKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgLy8gVHJ1bmNhdGUgdGhlIGxvbmdlciBzdHJpbmcuXHJcbiAgaWYgKHRleHQxX2xlbmd0aCA+IHRleHQyX2xlbmd0aCkge1xyXG4gICAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDFfbGVuZ3RoIC0gdGV4dDJfbGVuZ3RoKTtcclxuICB9IGVsc2UgaWYgKHRleHQxX2xlbmd0aCA8IHRleHQyX2xlbmd0aCkge1xyXG4gICAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDFfbGVuZ3RoKTtcclxuICB9XHJcbiAgdmFyIHRleHRfbGVuZ3RoID0gTWF0aC5taW4odGV4dDFfbGVuZ3RoLCB0ZXh0Ml9sZW5ndGgpO1xyXG4gIC8vIFF1aWNrIGNoZWNrIGZvciB0aGUgd29yc3QgY2FzZS5cclxuICBpZiAodGV4dDEgPT0gdGV4dDIpIHtcclxuICAgIHJldHVybiB0ZXh0X2xlbmd0aDtcclxuICB9XHJcblxyXG4gIC8vIFN0YXJ0IGJ5IGxvb2tpbmcgZm9yIGEgc2luZ2xlIGNoYXJhY3RlciBtYXRjaFxyXG4gIC8vIGFuZCBpbmNyZWFzZSBsZW5ndGggdW50aWwgbm8gbWF0Y2ggaXMgZm91bmQuXHJcbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHA6Ly9uZWlsLmZyYXNlci5uYW1lL25ld3MvMjAxMC8xMS8wNC9cclxuICB2YXIgYmVzdCA9IDA7XHJcbiAgdmFyIGxlbmd0aCA9IDE7XHJcbiAgd2hpbGUgKHRydWUpIHtcclxuICAgIHZhciBwYXR0ZXJuID0gdGV4dDEuc3Vic3RyaW5nKHRleHRfbGVuZ3RoIC0gbGVuZ3RoKTtcclxuICAgIHZhciBmb3VuZCA9IHRleHQyLmluZGV4T2YocGF0dGVybik7XHJcbiAgICBpZiAoZm91bmQgPT0gLTEpIHtcclxuICAgICAgcmV0dXJuIGJlc3Q7XHJcbiAgICB9XHJcbiAgICBsZW5ndGggKz0gZm91bmQ7XHJcbiAgICBpZiAoZm91bmQgPT0gMCB8fCB0ZXh0MS5zdWJzdHJpbmcodGV4dF9sZW5ndGggLSBsZW5ndGgpID09XHJcbiAgICAgICAgdGV4dDIuc3Vic3RyaW5nKDAsIGxlbmd0aCkpIHtcclxuICAgICAgYmVzdCA9IGxlbmd0aDtcclxuICAgICAgbGVuZ3RoKys7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBEbyB0aGUgdHdvIHRleHRzIHNoYXJlIGEgc3Vic3RyaW5nIHdoaWNoIGlzIGF0IGxlYXN0IGhhbGYgdGhlIGxlbmd0aCBvZiB0aGVcclxuICogbG9uZ2VyIHRleHQ/XHJcbiAqIFRoaXMgc3BlZWR1cCBjYW4gcHJvZHVjZSBub24tbWluaW1hbCBkaWZmcy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXHJcbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBGaXZlIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlIHByZWZpeCBvZlxyXG4gKiAgICAgdGV4dDEsIHRoZSBzdWZmaXggb2YgdGV4dDEsIHRoZSBwcmVmaXggb2YgdGV4dDIsIHRoZSBzdWZmaXggb2ZcclxuICogICAgIHRleHQyIGFuZCB0aGUgY29tbW9uIG1pZGRsZS4gIE9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9oYWxmTWF0Y2hfID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XHJcbiAgaWYgKHRoaXMuRGlmZl9UaW1lb3V0IDw9IDApIHtcclxuICAgIC8vIERvbid0IHJpc2sgcmV0dXJuaW5nIGEgbm9uLW9wdGltYWwgZGlmZiBpZiB3ZSBoYXZlIHVubGltaXRlZCB0aW1lLlxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHZhciBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XHJcbiAgdmFyIHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XHJcbiAgaWYgKGxvbmd0ZXh0Lmxlbmd0aCA8IDQgfHwgc2hvcnR0ZXh0Lmxlbmd0aCAqIDIgPCBsb25ndGV4dC5sZW5ndGgpIHtcclxuICAgIHJldHVybiBudWxsOyAgLy8gUG9pbnRsZXNzLlxyXG4gIH1cclxuICB2YXIgZG1wID0gdGhpczsgIC8vICd0aGlzJyBiZWNvbWVzICd3aW5kb3cnIGluIGEgY2xvc3VyZS5cclxuXHJcbiAgLyoqXHJcbiAgICogRG9lcyBhIHN1YnN0cmluZyBvZiBzaG9ydHRleHQgZXhpc3Qgd2l0aGluIGxvbmd0ZXh0IHN1Y2ggdGhhdCB0aGUgc3Vic3RyaW5nXHJcbiAgICogaXMgYXQgbGVhc3QgaGFsZiB0aGUgbGVuZ3RoIG9mIGxvbmd0ZXh0P1xyXG4gICAqIENsb3N1cmUsIGJ1dCBkb2VzIG5vdCByZWZlcmVuY2UgYW55IGV4dGVybmFsIHZhcmlhYmxlcy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9uZ3RleHQgTG9uZ2VyIHN0cmluZy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnR0ZXh0IFNob3J0ZXIgc3RyaW5nLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpIFN0YXJ0IGluZGV4IG9mIHF1YXJ0ZXIgbGVuZ3RoIHN1YnN0cmluZyB3aXRoaW4gbG9uZ3RleHQuXHJcbiAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEZpdmUgZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGUgcHJlZml4IG9mXHJcbiAgICogICAgIGxvbmd0ZXh0LCB0aGUgc3VmZml4IG9mIGxvbmd0ZXh0LCB0aGUgcHJlZml4IG9mIHNob3J0dGV4dCwgdGhlIHN1ZmZpeFxyXG4gICAqICAgICBvZiBzaG9ydHRleHQgYW5kIHRoZSBjb21tb24gbWlkZGxlLiAgT3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gbWF0Y2guXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBmdW5jdGlvbiBkaWZmX2hhbGZNYXRjaElfKGxvbmd0ZXh0LCBzaG9ydHRleHQsIGkpIHtcclxuICAgIC8vIFN0YXJ0IHdpdGggYSAxLzQgbGVuZ3RoIHN1YnN0cmluZyBhdCBwb3NpdGlvbiBpIGFzIGEgc2VlZC5cclxuICAgIHZhciBzZWVkID0gbG9uZ3RleHQuc3Vic3RyaW5nKGksIGkgKyBNYXRoLmZsb29yKGxvbmd0ZXh0Lmxlbmd0aCAvIDQpKTtcclxuICAgIHZhciBqID0gLTE7XHJcbiAgICB2YXIgYmVzdF9jb21tb24gPSAnJztcclxuICAgIHZhciBiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYiwgYmVzdF9zaG9ydHRleHRfYSwgYmVzdF9zaG9ydHRleHRfYjtcclxuICAgIHdoaWxlICgoaiA9IHNob3J0dGV4dC5pbmRleE9mKHNlZWQsIGogKyAxKSkgIT0gLTEpIHtcclxuICAgICAgdmFyIHByZWZpeExlbmd0aCA9IGRtcC5kaWZmX2NvbW1vblByZWZpeChsb25ndGV4dC5zdWJzdHJpbmcoaSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnR0ZXh0LnN1YnN0cmluZyhqKSk7XHJcbiAgICAgIHZhciBzdWZmaXhMZW5ndGggPSBkbXAuZGlmZl9jb21tb25TdWZmaXgobG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoMCwgaikpO1xyXG4gICAgICBpZiAoYmVzdF9jb21tb24ubGVuZ3RoIDwgc3VmZml4TGVuZ3RoICsgcHJlZml4TGVuZ3RoKSB7XHJcbiAgICAgICAgYmVzdF9jb21tb24gPSBzaG9ydHRleHQuc3Vic3RyaW5nKGogLSBzdWZmaXhMZW5ndGgsIGopICtcclxuICAgICAgICAgICAgc2hvcnR0ZXh0LnN1YnN0cmluZyhqLCBqICsgcHJlZml4TGVuZ3RoKTtcclxuICAgICAgICBiZXN0X2xvbmd0ZXh0X2EgPSBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSAtIHN1ZmZpeExlbmd0aCk7XHJcbiAgICAgICAgYmVzdF9sb25ndGV4dF9iID0gbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBwcmVmaXhMZW5ndGgpO1xyXG4gICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2EgPSBzaG9ydHRleHQuc3Vic3RyaW5nKDAsIGogLSBzdWZmaXhMZW5ndGgpO1xyXG4gICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2IgPSBzaG9ydHRleHQuc3Vic3RyaW5nKGogKyBwcmVmaXhMZW5ndGgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYmVzdF9jb21tb24ubGVuZ3RoICogMiA+PSBsb25ndGV4dC5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIFtiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYixcclxuICAgICAgICAgICAgICBiZXN0X3Nob3J0dGV4dF9hLCBiZXN0X3Nob3J0dGV4dF9iLCBiZXN0X2NvbW1vbl07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSBzZWNvbmQgcXVhcnRlciBpcyB0aGUgc2VlZCBmb3IgYSBoYWxmLW1hdGNoLlxyXG4gIHZhciBobTEgPSBkaWZmX2hhbGZNYXRjaElfKGxvbmd0ZXh0LCBzaG9ydHRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKGxvbmd0ZXh0Lmxlbmd0aCAvIDQpKTtcclxuICAvLyBDaGVjayBhZ2FpbiBiYXNlZCBvbiB0aGUgdGhpcmQgcXVhcnRlci5cclxuICB2YXIgaG0yID0gZGlmZl9oYWxmTWF0Y2hJXyhsb25ndGV4dCwgc2hvcnR0ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyAyKSk7XHJcbiAgdmFyIGhtO1xyXG4gIGlmICghaG0xICYmICFobTIpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0gZWxzZSBpZiAoIWhtMikge1xyXG4gICAgaG0gPSBobTE7XHJcbiAgfSBlbHNlIGlmICghaG0xKSB7XHJcbiAgICBobSA9IGhtMjtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gQm90aCBtYXRjaGVkLiAgU2VsZWN0IHRoZSBsb25nZXN0LlxyXG4gICAgaG0gPSBobTFbNF0ubGVuZ3RoID4gaG0yWzRdLmxlbmd0aCA/IGhtMSA6IGhtMjtcclxuICB9XHJcblxyXG4gIC8vIEEgaGFsZi1tYXRjaCB3YXMgZm91bmQsIHNvcnQgb3V0IHRoZSByZXR1cm4gZGF0YS5cclxuICB2YXIgdGV4dDFfYSwgdGV4dDFfYiwgdGV4dDJfYSwgdGV4dDJfYjtcclxuICBpZiAodGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoKSB7XHJcbiAgICB0ZXh0MV9hID0gaG1bMF07XHJcbiAgICB0ZXh0MV9iID0gaG1bMV07XHJcbiAgICB0ZXh0Ml9hID0gaG1bMl07XHJcbiAgICB0ZXh0Ml9iID0gaG1bM107XHJcbiAgfSBlbHNlIHtcclxuICAgIHRleHQyX2EgPSBobVswXTtcclxuICAgIHRleHQyX2IgPSBobVsxXTtcclxuICAgIHRleHQxX2EgPSBobVsyXTtcclxuICAgIHRleHQxX2IgPSBobVszXTtcclxuICB9XHJcbiAgdmFyIG1pZF9jb21tb24gPSBobVs0XTtcclxuICByZXR1cm4gW3RleHQxX2EsIHRleHQxX2IsIHRleHQyX2EsIHRleHQyX2IsIG1pZF9jb21tb25dO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZWR1Y2UgdGhlIG51bWJlciBvZiBlZGl0cyBieSBlbGltaW5hdGluZyBzZW1hbnRpY2FsbHkgdHJpdmlhbCBlcXVhbGl0aWVzLlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwU2VtYW50aWMgPSBmdW5jdGlvbihkaWZmcykge1xyXG4gIHZhciBjaGFuZ2VzID0gZmFsc2U7XHJcbiAgdmFyIGVxdWFsaXRpZXMgPSBbXTsgIC8vIFN0YWNrIG9mIGluZGljZXMgd2hlcmUgZXF1YWxpdGllcyBhcmUgZm91bmQuXHJcbiAgdmFyIGVxdWFsaXRpZXNMZW5ndGggPSAwOyAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXIgaXMgZmFzdGVyIGluIEpTLlxyXG4gIC8qKiBAdHlwZSB7P3N0cmluZ30gKi9cclxuICB2YXIgbGFzdGVxdWFsaXR5ID0gbnVsbDtcclxuICAvLyBBbHdheXMgZXF1YWwgdG8gZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV1dWzFdXHJcbiAgdmFyIHBvaW50ZXIgPSAwOyAgLy8gSW5kZXggb2YgY3VycmVudCBwb3NpdGlvbi5cclxuICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGNoYW5nZWQgcHJpb3IgdG8gdGhlIGVxdWFsaXR5LlxyXG4gIHZhciBsZW5ndGhfaW5zZXJ0aW9uczEgPSAwO1xyXG4gIHZhciBsZW5ndGhfZGVsZXRpb25zMSA9IDA7XHJcbiAgLy8gTnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBjaGFuZ2VkIGFmdGVyIHRoZSBlcXVhbGl0eS5cclxuICB2YXIgbGVuZ3RoX2luc2VydGlvbnMyID0gMDtcclxuICB2YXIgbGVuZ3RoX2RlbGV0aW9uczIgPSAwO1xyXG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XHJcbiAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9FUVVBTCkgeyAgLy8gRXF1YWxpdHkgZm91bmQuXHJcbiAgICAgIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXI7XHJcbiAgICAgIGxlbmd0aF9pbnNlcnRpb25zMSA9IGxlbmd0aF9pbnNlcnRpb25zMjtcclxuICAgICAgbGVuZ3RoX2RlbGV0aW9uczEgPSBsZW5ndGhfZGVsZXRpb25zMjtcclxuICAgICAgbGVuZ3RoX2luc2VydGlvbnMyID0gMDtcclxuICAgICAgbGVuZ3RoX2RlbGV0aW9uczIgPSAwO1xyXG4gICAgICBsYXN0ZXF1YWxpdHkgPSBkaWZmc1twb2ludGVyXVsxXTtcclxuICAgIH0gZWxzZSB7ICAvLyBBbiBpbnNlcnRpb24gb3IgZGVsZXRpb24uXHJcbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0lOU0VSVCkge1xyXG4gICAgICAgIGxlbmd0aF9pbnNlcnRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGg7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGVuZ3RoX2RlbGV0aW9uczIgKz0gZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIEVsaW1pbmF0ZSBhbiBlcXVhbGl0eSB0aGF0IGlzIHNtYWxsZXIgb3IgZXF1YWwgdG8gdGhlIGVkaXRzIG9uIGJvdGhcclxuICAgICAgLy8gc2lkZXMgb2YgaXQuXHJcbiAgICAgIGlmIChsYXN0ZXF1YWxpdHkgJiYgKGxhc3RlcXVhbGl0eS5sZW5ndGggPD1cclxuICAgICAgICAgIE1hdGgubWF4KGxlbmd0aF9pbnNlcnRpb25zMSwgbGVuZ3RoX2RlbGV0aW9uczEpKSAmJlxyXG4gICAgICAgICAgKGxhc3RlcXVhbGl0eS5sZW5ndGggPD0gTWF0aC5tYXgobGVuZ3RoX2luc2VydGlvbnMyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoX2RlbGV0aW9uczIpKSkge1xyXG4gICAgICAgIC8vIER1cGxpY2F0ZSByZWNvcmQuXHJcbiAgICAgICAgZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLFxyXG4gICAgICAgICAgICAgICAgICAgICBbRElGRl9ERUxFVEUsIGxhc3RlcXVhbGl0eV0pO1xyXG4gICAgICAgIC8vIENoYW5nZSBzZWNvbmQgY29weSB0byBpbnNlcnQuXHJcbiAgICAgICAgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJUO1xyXG4gICAgICAgIC8vIFRocm93IGF3YXkgdGhlIGVxdWFsaXR5IHdlIGp1c3QgZGVsZXRlZC5cclxuICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07XHJcbiAgICAgICAgLy8gVGhyb3cgYXdheSB0aGUgcHJldmlvdXMgZXF1YWxpdHkgKGl0IG5lZWRzIHRvIGJlIHJlZXZhbHVhdGVkKS5cclxuICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07XHJcbiAgICAgICAgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMTtcclxuICAgICAgICBsZW5ndGhfaW5zZXJ0aW9uczEgPSAwOyAgLy8gUmVzZXQgdGhlIGNvdW50ZXJzLlxyXG4gICAgICAgIGxlbmd0aF9kZWxldGlvbnMxID0gMDtcclxuICAgICAgICBsZW5ndGhfaW5zZXJ0aW9uczIgPSAwO1xyXG4gICAgICAgIGxlbmd0aF9kZWxldGlvbnMyID0gMDtcclxuICAgICAgICBsYXN0ZXF1YWxpdHkgPSBudWxsO1xyXG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwb2ludGVyKys7XHJcbiAgfVxyXG5cclxuICAvLyBOb3JtYWxpemUgdGhlIGRpZmYuXHJcbiAgaWYgKGNoYW5nZXMpIHtcclxuICAgIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xyXG4gIH1cclxuICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xyXG5cclxuICAvLyBGaW5kIGFueSBvdmVybGFwcyBiZXR3ZWVuIGRlbGV0aW9ucyBhbmQgaW5zZXJ0aW9ucy5cclxuICAvLyBlLmc6IDxkZWw+YWJjeHh4PC9kZWw+PGlucz54eHhkZWY8L2lucz5cclxuICAvLyAgIC0+IDxkZWw+YWJjPC9kZWw+eHh4PGlucz5kZWY8L2lucz5cclxuICAvLyBlLmc6IDxkZWw+eHh4YWJjPC9kZWw+PGlucz5kZWZ4eHg8L2lucz5cclxuICAvLyAgIC0+IDxpbnM+ZGVmPC9pbnM+eHh4PGRlbD5hYmM8L2RlbD5cclxuICAvLyBPbmx5IGV4dHJhY3QgYW4gb3ZlcmxhcCBpZiBpdCBpcyBhcyBiaWcgYXMgdGhlIGVkaXQgYWhlYWQgb3IgYmVoaW5kIGl0LlxyXG4gIHBvaW50ZXIgPSAxO1xyXG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XHJcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfREVMRVRFICYmXHJcbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9JTlNFUlQpIHtcclxuICAgICAgdmFyIGRlbGV0aW9uID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdO1xyXG4gICAgICB2YXIgaW5zZXJ0aW9uID0gZGlmZnNbcG9pbnRlcl1bMV07XHJcbiAgICAgIHZhciBvdmVybGFwX2xlbmd0aDEgPSB0aGlzLmRpZmZfY29tbW9uT3ZlcmxhcF8oZGVsZXRpb24sIGluc2VydGlvbik7XHJcbiAgICAgIHZhciBvdmVybGFwX2xlbmd0aDIgPSB0aGlzLmRpZmZfY29tbW9uT3ZlcmxhcF8oaW5zZXJ0aW9uLCBkZWxldGlvbik7XHJcbiAgICAgIGlmIChvdmVybGFwX2xlbmd0aDEgPj0gb3ZlcmxhcF9sZW5ndGgyKSB7XHJcbiAgICAgICAgaWYgKG92ZXJsYXBfbGVuZ3RoMSA+PSBkZWxldGlvbi5sZW5ndGggLyAyIHx8XHJcbiAgICAgICAgICAgIG92ZXJsYXBfbGVuZ3RoMSA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikge1xyXG4gICAgICAgICAgLy8gT3ZlcmxhcCBmb3VuZC4gIEluc2VydCBhbiBlcXVhbGl0eSBhbmQgdHJpbSB0aGUgc3Vycm91bmRpbmcgZWRpdHMuXHJcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCxcclxuICAgICAgICAgICAgICBbRElGRl9FUVVBTCwgaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwX2xlbmd0aDEpXSk7XHJcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gPVxyXG4gICAgICAgICAgICAgIGRlbGV0aW9uLnN1YnN0cmluZygwLCBkZWxldGlvbi5sZW5ndGggLSBvdmVybGFwX2xlbmd0aDEpO1xyXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gaW5zZXJ0aW9uLnN1YnN0cmluZyhvdmVybGFwX2xlbmd0aDEpO1xyXG4gICAgICAgICAgcG9pbnRlcisrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAob3ZlcmxhcF9sZW5ndGgyID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHxcclxuICAgICAgICAgICAgb3ZlcmxhcF9sZW5ndGgyID49IGluc2VydGlvbi5sZW5ndGggLyAyKSB7XHJcbiAgICAgICAgICAvLyBSZXZlcnNlIG92ZXJsYXAgZm91bmQuXHJcbiAgICAgICAgICAvLyBJbnNlcnQgYW4gZXF1YWxpdHkgYW5kIHN3YXAgYW5kIHRyaW0gdGhlIHN1cnJvdW5kaW5nIGVkaXRzLlxyXG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsXHJcbiAgICAgICAgICAgICAgW0RJRkZfRVFVQUwsIGRlbGV0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwX2xlbmd0aDIpXSk7XHJcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMF0gPSBESUZGX0lOU0VSVDtcclxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9XHJcbiAgICAgICAgICAgICAgaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBpbnNlcnRpb24ubGVuZ3RoIC0gb3ZlcmxhcF9sZW5ndGgyKTtcclxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9IERJRkZfREVMRVRFO1xyXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID1cclxuICAgICAgICAgICAgICBkZWxldGlvbi5zdWJzdHJpbmcob3ZlcmxhcF9sZW5ndGgyKTtcclxuICAgICAgICAgIHBvaW50ZXIrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcG9pbnRlcisrO1xyXG4gICAgfVxyXG4gICAgcG9pbnRlcisrO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogTG9vayBmb3Igc2luZ2xlIGVkaXRzIHN1cnJvdW5kZWQgb24gYm90aCBzaWRlcyBieSBlcXVhbGl0aWVzXHJcbiAqIHdoaWNoIGNhbiBiZSBzaGlmdGVkIHNpZGV3YXlzIHRvIGFsaWduIHRoZSBlZGl0IHRvIGEgd29yZCBib3VuZGFyeS5cclxuICogZS5nOiBUaGUgYzxpbnM+YXQgYzwvaW5zPmFtZS4gLT4gVGhlIDxpbnM+Y2F0IDwvaW5zPmNhbWUuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzID0gZnVuY3Rpb24oZGlmZnMpIHtcclxuICAvKipcclxuICAgKiBHaXZlbiB0d28gc3RyaW5ncywgY29tcHV0ZSBhIHNjb3JlIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoZSBpbnRlcm5hbFxyXG4gICAqIGJvdW5kYXJ5IGZhbGxzIG9uIGxvZ2ljYWwgYm91bmRhcmllcy5cclxuICAgKiBTY29yZXMgcmFuZ2UgZnJvbSA2IChiZXN0KSB0byAwICh3b3JzdCkuXHJcbiAgICogQ2xvc3VyZSwgYnV0IGRvZXMgbm90IHJlZmVyZW5jZSBhbnkgZXh0ZXJuYWwgdmFyaWFibGVzLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvbmUgRmlyc3Qgc3RyaW5nLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0d28gU2Vjb25kIHN0cmluZy5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzY29yZS5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmVfKG9uZSwgdHdvKSB7XHJcbiAgICBpZiAoIW9uZSB8fCAhdHdvKSB7XHJcbiAgICAgIC8vIEVkZ2VzIGFyZSB0aGUgYmVzdC5cclxuICAgICAgcmV0dXJuIDY7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRWFjaCBwb3J0IG9mIHRoaXMgZnVuY3Rpb24gYmVoYXZlcyBzbGlnaHRseSBkaWZmZXJlbnRseSBkdWUgdG9cclxuICAgIC8vIHN1YnRsZSBkaWZmZXJlbmNlcyBpbiBlYWNoIGxhbmd1YWdlJ3MgZGVmaW5pdGlvbiBvZiB0aGluZ3MgbGlrZVxyXG4gICAgLy8gJ3doaXRlc3BhY2UnLiAgU2luY2UgdGhpcyBmdW5jdGlvbidzIHB1cnBvc2UgaXMgbGFyZ2VseSBjb3NtZXRpYyxcclxuICAgIC8vIHRoZSBjaG9pY2UgaGFzIGJlZW4gbWFkZSB0byB1c2UgZWFjaCBsYW5ndWFnZSdzIG5hdGl2ZSBmZWF0dXJlc1xyXG4gICAgLy8gcmF0aGVyIHRoYW4gZm9yY2UgdG90YWwgY29uZm9ybWl0eS5cclxuICAgIHZhciBjaGFyMSA9IG9uZS5jaGFyQXQob25lLmxlbmd0aCAtIDEpO1xyXG4gICAgdmFyIGNoYXIyID0gdHdvLmNoYXJBdCgwKTtcclxuICAgIHZhciBub25BbHBoYU51bWVyaWMxID0gY2hhcjEubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC5ub25BbHBoYU51bWVyaWNSZWdleF8pO1xyXG4gICAgdmFyIG5vbkFscGhhTnVtZXJpYzIgPSBjaGFyMi5tYXRjaChkaWZmX21hdGNoX3BhdGNoLm5vbkFscGhhTnVtZXJpY1JlZ2V4Xyk7XHJcbiAgICB2YXIgd2hpdGVzcGFjZTEgPSBub25BbHBoYU51bWVyaWMxICYmXHJcbiAgICAgICAgY2hhcjEubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC53aGl0ZXNwYWNlUmVnZXhfKTtcclxuICAgIHZhciB3aGl0ZXNwYWNlMiA9IG5vbkFscGhhTnVtZXJpYzIgJiZcclxuICAgICAgICBjaGFyMi5tYXRjaChkaWZmX21hdGNoX3BhdGNoLndoaXRlc3BhY2VSZWdleF8pO1xyXG4gICAgdmFyIGxpbmVCcmVhazEgPSB3aGl0ZXNwYWNlMSAmJlxyXG4gICAgICAgIGNoYXIxLm1hdGNoKGRpZmZfbWF0Y2hfcGF0Y2gubGluZWJyZWFrUmVnZXhfKTtcclxuICAgIHZhciBsaW5lQnJlYWsyID0gd2hpdGVzcGFjZTIgJiZcclxuICAgICAgICBjaGFyMi5tYXRjaChkaWZmX21hdGNoX3BhdGNoLmxpbmVicmVha1JlZ2V4Xyk7XHJcbiAgICB2YXIgYmxhbmtMaW5lMSA9IGxpbmVCcmVhazEgJiZcclxuICAgICAgICBvbmUubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC5ibGFua2xpbmVFbmRSZWdleF8pO1xyXG4gICAgdmFyIGJsYW5rTGluZTIgPSBsaW5lQnJlYWsyICYmXHJcbiAgICAgICAgdHdvLm1hdGNoKGRpZmZfbWF0Y2hfcGF0Y2guYmxhbmtsaW5lU3RhcnRSZWdleF8pO1xyXG5cclxuICAgIGlmIChibGFua0xpbmUxIHx8IGJsYW5rTGluZTIpIHtcclxuICAgICAgLy8gRml2ZSBwb2ludHMgZm9yIGJsYW5rIGxpbmVzLlxyXG4gICAgICByZXR1cm4gNTtcclxuICAgIH0gZWxzZSBpZiAobGluZUJyZWFrMSB8fCBsaW5lQnJlYWsyKSB7XHJcbiAgICAgIC8vIEZvdXIgcG9pbnRzIGZvciBsaW5lIGJyZWFrcy5cclxuICAgICAgcmV0dXJuIDQ7XHJcbiAgICB9IGVsc2UgaWYgKG5vbkFscGhhTnVtZXJpYzEgJiYgIXdoaXRlc3BhY2UxICYmIHdoaXRlc3BhY2UyKSB7XHJcbiAgICAgIC8vIFRocmVlIHBvaW50cyBmb3IgZW5kIG9mIHNlbnRlbmNlcy5cclxuICAgICAgcmV0dXJuIDM7XHJcbiAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2UxIHx8IHdoaXRlc3BhY2UyKSB7XHJcbiAgICAgIC8vIFR3byBwb2ludHMgZm9yIHdoaXRlc3BhY2UuXHJcbiAgICAgIHJldHVybiAyO1xyXG4gICAgfSBlbHNlIGlmIChub25BbHBoYU51bWVyaWMxIHx8IG5vbkFscGhhTnVtZXJpYzIpIHtcclxuICAgICAgLy8gT25lIHBvaW50IGZvciBub24tYWxwaGFudW1lcmljLlxyXG4gICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgdmFyIHBvaW50ZXIgPSAxO1xyXG4gIC8vIEludGVudGlvbmFsbHkgaWdub3JlIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50IChkb24ndCBuZWVkIGNoZWNraW5nKS5cclxuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDEpIHtcclxuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT0gRElGRl9FUVVBTCAmJlxyXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PSBESUZGX0VRVUFMKSB7XHJcbiAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGUgZWRpdCBzdXJyb3VuZGVkIGJ5IGVxdWFsaXRpZXMuXHJcbiAgICAgIHZhciBlcXVhbGl0eTEgPSBkaWZmc1twb2ludGVyIC0gMV1bMV07XHJcbiAgICAgIHZhciBlZGl0ID0gZGlmZnNbcG9pbnRlcl1bMV07XHJcbiAgICAgIHZhciBlcXVhbGl0eTIgPSBkaWZmc1twb2ludGVyICsgMV1bMV07XHJcblxyXG4gICAgICAvLyBGaXJzdCwgc2hpZnQgdGhlIGVkaXQgYXMgZmFyIGxlZnQgYXMgcG9zc2libGUuXHJcbiAgICAgIHZhciBjb21tb25PZmZzZXQgPSB0aGlzLmRpZmZfY29tbW9uU3VmZml4KGVxdWFsaXR5MSwgZWRpdCk7XHJcbiAgICAgIGlmIChjb21tb25PZmZzZXQpIHtcclxuICAgICAgICB2YXIgY29tbW9uU3RyaW5nID0gZWRpdC5zdWJzdHJpbmcoZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xyXG4gICAgICAgIGVxdWFsaXR5MSA9IGVxdWFsaXR5MS5zdWJzdHJpbmcoMCwgZXF1YWxpdHkxLmxlbmd0aCAtIGNvbW1vbk9mZnNldCk7XHJcbiAgICAgICAgZWRpdCA9IGNvbW1vblN0cmluZyArIGVkaXQuc3Vic3RyaW5nKDAsIGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcclxuICAgICAgICBlcXVhbGl0eTIgPSBjb21tb25TdHJpbmcgKyBlcXVhbGl0eTI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNlY29uZCwgc3RlcCBjaGFyYWN0ZXIgYnkgY2hhcmFjdGVyIHJpZ2h0LCBsb29raW5nIGZvciB0aGUgYmVzdCBmaXQuXHJcbiAgICAgIHZhciBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxO1xyXG4gICAgICB2YXIgYmVzdEVkaXQgPSBlZGl0O1xyXG4gICAgICB2YXIgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MjtcclxuICAgICAgdmFyIGJlc3RTY29yZSA9IGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmVfKGVxdWFsaXR5MSwgZWRpdCkgK1xyXG4gICAgICAgICAgZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZV8oZWRpdCwgZXF1YWxpdHkyKTtcclxuICAgICAgd2hpbGUgKGVkaXQuY2hhckF0KDApID09PSBlcXVhbGl0eTIuY2hhckF0KDApKSB7XHJcbiAgICAgICAgZXF1YWxpdHkxICs9IGVkaXQuY2hhckF0KDApO1xyXG4gICAgICAgIGVkaXQgPSBlZGl0LnN1YnN0cmluZygxKSArIGVxdWFsaXR5Mi5jaGFyQXQoMCk7XHJcbiAgICAgICAgZXF1YWxpdHkyID0gZXF1YWxpdHkyLnN1YnN0cmluZygxKTtcclxuICAgICAgICB2YXIgc2NvcmUgPSBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlcXVhbGl0eTEsIGVkaXQpICtcclxuICAgICAgICAgICAgZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZV8oZWRpdCwgZXF1YWxpdHkyKTtcclxuICAgICAgICAvLyBUaGUgPj0gZW5jb3VyYWdlcyB0cmFpbGluZyByYXRoZXIgdGhhbiBsZWFkaW5nIHdoaXRlc3BhY2Ugb24gZWRpdHMuXHJcbiAgICAgICAgaWYgKHNjb3JlID49IGJlc3RTY29yZSkge1xyXG4gICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XHJcbiAgICAgICAgICBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxO1xyXG4gICAgICAgICAgYmVzdEVkaXQgPSBlZGl0O1xyXG4gICAgICAgICAgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMV0gIT0gYmVzdEVxdWFsaXR5MSkge1xyXG4gICAgICAgIC8vIFdlIGhhdmUgYW4gaW1wcm92ZW1lbnQsIHNhdmUgaXQgYmFjayB0byB0aGUgZGlmZi5cclxuICAgICAgICBpZiAoYmVzdEVxdWFsaXR5MSkge1xyXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gYmVzdEVxdWFsaXR5MTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKTtcclxuICAgICAgICAgIHBvaW50ZXItLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSBiZXN0RWRpdDtcclxuICAgICAgICBpZiAoYmVzdEVxdWFsaXR5Mikge1xyXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gYmVzdEVxdWFsaXR5MjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKTtcclxuICAgICAgICAgIHBvaW50ZXItLTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHBvaW50ZXIrKztcclxuICB9XHJcbn07XHJcblxyXG4vLyBEZWZpbmUgc29tZSByZWdleCBwYXR0ZXJucyBmb3IgbWF0Y2hpbmcgYm91bmRhcmllcy5cclxuZGlmZl9tYXRjaF9wYXRjaC5ub25BbHBoYU51bWVyaWNSZWdleF8gPSAvW15hLXpBLVowLTldLztcclxuZGlmZl9tYXRjaF9wYXRjaC53aGl0ZXNwYWNlUmVnZXhfID0gL1xccy87XHJcbmRpZmZfbWF0Y2hfcGF0Y2gubGluZWJyZWFrUmVnZXhfID0gL1tcXHJcXG5dLztcclxuZGlmZl9tYXRjaF9wYXRjaC5ibGFua2xpbmVFbmRSZWdleF8gPSAvXFxuXFxyP1xcbiQvO1xyXG5kaWZmX21hdGNoX3BhdGNoLmJsYW5rbGluZVN0YXJ0UmVnZXhfID0gL15cXHI/XFxuXFxyP1xcbi87XHJcblxyXG4vKipcclxuICogUmVkdWNlIHRoZSBudW1iZXIgb2YgZWRpdHMgYnkgZWxpbWluYXRpbmcgb3BlcmF0aW9uYWxseSB0cml2aWFsIGVxdWFsaXRpZXMuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBFZmZpY2llbmN5ID0gZnVuY3Rpb24oZGlmZnMpIHtcclxuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xyXG4gIHZhciBlcXVhbGl0aWVzID0gW107ICAvLyBTdGFjayBvZiBpbmRpY2VzIHdoZXJlIGVxdWFsaXRpZXMgYXJlIGZvdW5kLlxyXG4gIHZhciBlcXVhbGl0aWVzTGVuZ3RoID0gMDsgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cclxuICAvKiogQHR5cGUgez9zdHJpbmd9ICovXHJcbiAgdmFyIGxhc3RlcXVhbGl0eSA9IG51bGw7XHJcbiAgLy8gQWx3YXlzIGVxdWFsIHRvIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdXVsxXVxyXG4gIHZhciBwb2ludGVyID0gMDsgIC8vIEluZGV4IG9mIGN1cnJlbnQgcG9zaXRpb24uXHJcbiAgLy8gSXMgdGhlcmUgYW4gaW5zZXJ0aW9uIG9wZXJhdGlvbiBiZWZvcmUgdGhlIGxhc3QgZXF1YWxpdHkuXHJcbiAgdmFyIHByZV9pbnMgPSBmYWxzZTtcclxuICAvLyBJcyB0aGVyZSBhIGRlbGV0aW9uIG9wZXJhdGlvbiBiZWZvcmUgdGhlIGxhc3QgZXF1YWxpdHkuXHJcbiAgdmFyIHByZV9kZWwgPSBmYWxzZTtcclxuICAvLyBJcyB0aGVyZSBhbiBpbnNlcnRpb24gb3BlcmF0aW9uIGFmdGVyIHRoZSBsYXN0IGVxdWFsaXR5LlxyXG4gIHZhciBwb3N0X2lucyA9IGZhbHNlO1xyXG4gIC8vIElzIHRoZXJlIGEgZGVsZXRpb24gb3BlcmF0aW9uIGFmdGVyIHRoZSBsYXN0IGVxdWFsaXR5LlxyXG4gIHZhciBwb3N0X2RlbCA9IGZhbHNlO1xyXG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XHJcbiAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9FUVVBTCkgeyAgLy8gRXF1YWxpdHkgZm91bmQuXHJcbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggPCB0aGlzLkRpZmZfRWRpdENvc3QgJiZcclxuICAgICAgICAgIChwb3N0X2lucyB8fCBwb3N0X2RlbCkpIHtcclxuICAgICAgICAvLyBDYW5kaWRhdGUgZm91bmQuXHJcbiAgICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlcjtcclxuICAgICAgICBwcmVfaW5zID0gcG9zdF9pbnM7XHJcbiAgICAgICAgcHJlX2RlbCA9IHBvc3RfZGVsO1xyXG4gICAgICAgIGxhc3RlcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE5vdCBhIGNhbmRpZGF0ZSwgYW5kIGNhbiBuZXZlciBiZWNvbWUgb25lLlxyXG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGggPSAwO1xyXG4gICAgICAgIGxhc3RlcXVhbGl0eSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHsgIC8vIEFuIGluc2VydGlvbiBvciBkZWxldGlvbi5cclxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09IERJRkZfREVMRVRFKSB7XHJcbiAgICAgICAgcG9zdF9kZWwgPSB0cnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBvc3RfaW5zID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICAvKlxyXG4gICAgICAgKiBGaXZlIHR5cGVzIHRvIGJlIHNwbGl0OlxyXG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YWTxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxyXG4gICAgICAgKiA8aW5zPkE8L2lucz5YPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XHJcbiAgICAgICAqIDxpbnM+QTwvaW5zPjxkZWw+QjwvZGVsPlg8aW5zPkM8L2lucz5cclxuICAgICAgICogPGlucz5BPC9kZWw+WDxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxyXG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YPGRlbD5DPC9kZWw+XHJcbiAgICAgICAqL1xyXG4gICAgICBpZiAobGFzdGVxdWFsaXR5ICYmICgocHJlX2lucyAmJiBwcmVfZGVsICYmIHBvc3RfaW5zICYmIHBvc3RfZGVsKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKGxhc3RlcXVhbGl0eS5sZW5ndGggPCB0aGlzLkRpZmZfRWRpdENvc3QgLyAyKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByZV9pbnMgKyBwcmVfZGVsICsgcG9zdF9pbnMgKyBwb3N0X2RlbCkgPT0gMykpKSB7XHJcbiAgICAgICAgLy8gRHVwbGljYXRlIHJlY29yZC5cclxuICAgICAgICBkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgIFtESUZGX0RFTEVURSwgbGFzdGVxdWFsaXR5XSk7XHJcbiAgICAgICAgLy8gQ2hhbmdlIHNlY29uZCBjb3B5IHRvIGluc2VydC5cclxuICAgICAgICBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQ7XHJcbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tOyAgLy8gVGhyb3cgYXdheSB0aGUgZXF1YWxpdHkgd2UganVzdCBkZWxldGVkO1xyXG4gICAgICAgIGxhc3RlcXVhbGl0eSA9IG51bGw7XHJcbiAgICAgICAgaWYgKHByZV9pbnMgJiYgcHJlX2RlbCkge1xyXG4gICAgICAgICAgLy8gTm8gY2hhbmdlcyBtYWRlIHdoaWNoIGNvdWxkIGFmZmVjdCBwcmV2aW91cyBlbnRyeSwga2VlcCBnb2luZy5cclxuICAgICAgICAgIHBvc3RfaW5zID0gcG9zdF9kZWwgPSB0cnVlO1xyXG4gICAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTsgIC8vIFRocm93IGF3YXkgdGhlIHByZXZpb3VzIGVxdWFsaXR5LlxyXG4gICAgICAgICAgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID9cclxuICAgICAgICAgICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xO1xyXG4gICAgICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcG9pbnRlcisrO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNoYW5nZXMpIHtcclxuICAgIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmVvcmRlciBhbmQgbWVyZ2UgbGlrZSBlZGl0IHNlY3Rpb25zLiAgTWVyZ2UgZXF1YWxpdGllcy5cclxuICogQW55IGVkaXQgc2VjdGlvbiBjYW4gbW92ZSBhcyBsb25nIGFzIGl0IGRvZXNuJ3QgY3Jvc3MgYW4gZXF1YWxpdHkuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBNZXJnZSA9IGZ1bmN0aW9uKGRpZmZzKSB7XHJcbiAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgJyddKTsgIC8vIEFkZCBhIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXHJcbiAgdmFyIHBvaW50ZXIgPSAwO1xyXG4gIHZhciBjb3VudF9kZWxldGUgPSAwO1xyXG4gIHZhciBjb3VudF9pbnNlcnQgPSAwO1xyXG4gIHZhciB0ZXh0X2RlbGV0ZSA9ICcnO1xyXG4gIHZhciB0ZXh0X2luc2VydCA9ICcnO1xyXG4gIHZhciBjb21tb25sZW5ndGg7XHJcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcclxuICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcclxuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcclxuICAgICAgICBjb3VudF9pbnNlcnQrKztcclxuICAgICAgICB0ZXh0X2luc2VydCArPSBkaWZmc1twb2ludGVyXVsxXTtcclxuICAgICAgICBwb2ludGVyKys7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XHJcbiAgICAgICAgY291bnRfZGVsZXRlKys7XHJcbiAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XHJcbiAgICAgICAgcG9pbnRlcisrO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfRVFVQUw6XHJcbiAgICAgICAgLy8gVXBvbiByZWFjaGluZyBhbiBlcXVhbGl0eSwgY2hlY2sgZm9yIHByaW9yIHJlZHVuZGFuY2llcy5cclxuICAgICAgICBpZiAoY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0ID4gMSkge1xyXG4gICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSAhPT0gMCAmJiBjb3VudF9pbnNlcnQgIT09IDApIHtcclxuICAgICAgICAgICAgLy8gRmFjdG9yIG91dCBhbnkgY29tbW9uIHByZWZpeGllcy5cclxuICAgICAgICAgICAgY29tbW9ubGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblByZWZpeCh0ZXh0X2luc2VydCwgdGV4dF9kZWxldGUpO1xyXG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKChwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0KSA+IDAgJiZcclxuICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzBdID09XHJcbiAgICAgICAgICAgICAgICAgIERJRkZfRVFVQUwpIHtcclxuICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQgLSAxXVsxXSArPVxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UoMCwgMCwgW0RJRkZfRVFVQUwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpXSk7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyKys7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHRleHRfaW5zZXJ0ID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgdGV4dF9kZWxldGUgPSB0ZXh0X2RlbGV0ZS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBGYWN0b3Igb3V0IGFueSBjb21tb24gc3VmZml4aWVzLlxyXG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uU3VmZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XHJcbiAgICAgICAgICAgIGlmIChjb21tb25sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IHRleHRfaW5zZXJ0LnN1YnN0cmluZyh0ZXh0X2luc2VydC5sZW5ndGggLVxyXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpICsgZGlmZnNbcG9pbnRlcl1bMV07XHJcbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgdGV4dF9pbnNlcnQubGVuZ3RoIC1cclxuICAgICAgICAgICAgICAgICAgY29tbW9ubGVuZ3RoKTtcclxuICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9IHRleHRfZGVsZXRlLnN1YnN0cmluZygwLCB0ZXh0X2RlbGV0ZS5sZW5ndGggLVxyXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBEZWxldGUgdGhlIG9mZmVuZGluZyByZWNvcmRzIGFuZCBhZGQgdGhlIG1lcmdlZCBvbmVzLlxyXG4gICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2luc2VydCxcclxuICAgICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCwgW0RJRkZfSU5TRVJULCB0ZXh0X2luc2VydF0pO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChjb3VudF9pbnNlcnQgPT09IDApIHtcclxuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9kZWxldGUsXHJcbiAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQsIFtESUZGX0RFTEVURSwgdGV4dF9kZWxldGVdKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LFxyXG4gICAgICAgICAgICAgICAgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0LCBbRElGRl9ERUxFVEUsIHRleHRfZGVsZXRlXSxcclxuICAgICAgICAgICAgICAgIFtESUZGX0lOU0VSVCwgdGV4dF9pbnNlcnRdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0ICtcclxuICAgICAgICAgICAgICAgICAgICAoY291bnRfZGVsZXRlID8gMSA6IDApICsgKGNvdW50X2luc2VydCA/IDEgOiAwKSArIDE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyICE9PSAwICYmIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMKSB7XHJcbiAgICAgICAgICAvLyBNZXJnZSB0aGlzIGVxdWFsaXR5IHdpdGggdGhlIHByZXZpb3VzIG9uZS5cclxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyXVsxXTtcclxuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcG9pbnRlcisrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb3VudF9pbnNlcnQgPSAwO1xyXG4gICAgICAgIGNvdW50X2RlbGV0ZSA9IDA7XHJcbiAgICAgICAgdGV4dF9kZWxldGUgPSAnJztcclxuICAgICAgICB0ZXh0X2luc2VydCA9ICcnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gPT09ICcnKSB7XHJcbiAgICBkaWZmcy5wb3AoKTsgIC8vIFJlbW92ZSB0aGUgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cclxuICB9XHJcblxyXG4gIC8vIFNlY29uZCBwYXNzOiBsb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcclxuICAvLyB3aGljaCBjYW4gYmUgc2hpZnRlZCBzaWRld2F5cyB0byBlbGltaW5hdGUgYW4gZXF1YWxpdHkuXHJcbiAgLy8gZS5nOiBBPGlucz5CQTwvaW5zPkMgLT4gPGlucz5BQjwvaW5zPkFDXHJcbiAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcclxuICBwb2ludGVyID0gMTtcclxuICAvLyBJbnRlbnRpb25hbGx5IGlnbm9yZSB0aGUgZmlyc3QgYW5kIGxhc3QgZWxlbWVudCAoZG9uJ3QgbmVlZCBjaGVja2luZykuXHJcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XHJcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfRVFVQUwgJiZcclxuICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMF0gPT0gRElGRl9FUVVBTCkge1xyXG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIGVkaXQgc3Vycm91bmRlZCBieSBlcXVhbGl0aWVzLlxyXG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtXHJcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKSA9PSBkaWZmc1twb2ludGVyIC0gMV1bMV0pIHtcclxuICAgICAgICAvLyBTaGlmdCB0aGUgZWRpdCBvdmVyIHRoZSBwcmV2aW91cyBlcXVhbGl0eS5cclxuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArXHJcbiAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCk7XHJcbiAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xyXG4gICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSk7XHJcbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpID09XHJcbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0pIHtcclxuICAgICAgICAvLyBTaGlmdCB0aGUgZWRpdCBvdmVyIHRoZSBuZXh0IGVxdWFsaXR5LlxyXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyICsgMV1bMV07XHJcbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPVxyXG4gICAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgK1xyXG4gICAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV07XHJcbiAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKTtcclxuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcG9pbnRlcisrO1xyXG4gIH1cclxuICAvLyBJZiBzaGlmdHMgd2VyZSBtYWRlLCB0aGUgZGlmZiBuZWVkcyByZW9yZGVyaW5nIGFuZCBhbm90aGVyIHNoaWZ0IHN3ZWVwLlxyXG4gIGlmIChjaGFuZ2VzKSB7XHJcbiAgICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIGxvYyBpcyBhIGxvY2F0aW9uIGluIHRleHQxLCBjb21wdXRlIGFuZCByZXR1cm4gdGhlIGVxdWl2YWxlbnQgbG9jYXRpb24gaW5cclxuICogdGV4dDIuXHJcbiAqIGUuZy4gJ1RoZSBjYXQnIHZzICdUaGUgYmlnIGNhdCcsIDEtPjEsIDUtPjhcclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICogQHBhcmFtIHtudW1iZXJ9IGxvYyBMb2NhdGlvbiB3aXRoaW4gdGV4dDEuXHJcbiAqIEByZXR1cm4ge251bWJlcn0gTG9jYXRpb24gd2l0aGluIHRleHQyLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl94SW5kZXggPSBmdW5jdGlvbihkaWZmcywgbG9jKSB7XHJcbiAgdmFyIGNoYXJzMSA9IDA7XHJcbiAgdmFyIGNoYXJzMiA9IDA7XHJcbiAgdmFyIGxhc3RfY2hhcnMxID0gMDtcclxuICB2YXIgbGFzdF9jaGFyczIgPSAwO1xyXG4gIHZhciB4O1xyXG4gIGZvciAoeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xyXG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0lOU0VSVCkgeyAgLy8gRXF1YWxpdHkgb3IgZGVsZXRpb24uXHJcbiAgICAgIGNoYXJzMSArPSBkaWZmc1t4XVsxXS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFKSB7ICAvLyBFcXVhbGl0eSBvciBpbnNlcnRpb24uXHJcbiAgICAgIGNoYXJzMiArPSBkaWZmc1t4XVsxXS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBpZiAoY2hhcnMxID4gbG9jKSB7ICAvLyBPdmVyc2hvdCB0aGUgbG9jYXRpb24uXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgbGFzdF9jaGFyczEgPSBjaGFyczE7XHJcbiAgICBsYXN0X2NoYXJzMiA9IGNoYXJzMjtcclxuICB9XHJcbiAgLy8gV2FzIHRoZSBsb2NhdGlvbiB3YXMgZGVsZXRlZD9cclxuICBpZiAoZGlmZnMubGVuZ3RoICE9IHggJiYgZGlmZnNbeF1bMF0gPT09IERJRkZfREVMRVRFKSB7XHJcbiAgICByZXR1cm4gbGFzdF9jaGFyczI7XHJcbiAgfVxyXG4gIC8vIEFkZCB0aGUgcmVtYWluaW5nIGNoYXJhY3RlciBsZW5ndGguXHJcbiAgcmV0dXJuIGxhc3RfY2hhcnMyICsgKGxvYyAtIGxhc3RfY2hhcnMxKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ29udmVydCBhIGRpZmYgYXJyYXkgaW50byBhIHByZXR0eSBIVE1MIHJlcG9ydC5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICogQHJldHVybiB7c3RyaW5nfSBIVE1MIHJlcHJlc2VudGF0aW9uLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9wcmV0dHlIdG1sID0gZnVuY3Rpb24oZGlmZnMpIHtcclxuICB2YXIgaHRtbCA9IFtdO1xyXG4gIHZhciBwYXR0ZXJuX2FtcCA9IC8mL2c7XHJcbiAgdmFyIHBhdHRlcm5fbHQgPSAvPC9nO1xyXG4gIHZhciBwYXR0ZXJuX2d0ID0gLz4vZztcclxuICB2YXIgcGF0dGVybl9wYXJhID0gL1xcbi9nO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcclxuICAgIHZhciBvcCA9IGRpZmZzW3hdWzBdOyAgICAvLyBPcGVyYXRpb24gKGluc2VydCwgZGVsZXRlLCBlcXVhbClcclxuICAgIHZhciBkYXRhID0gZGlmZnNbeF1bMV07ICAvLyBUZXh0IG9mIGNoYW5nZS5cclxuICAgIHZhciB0ZXh0ID0gZGF0YS5yZXBsYWNlKHBhdHRlcm5fYW1wLCAnJmFtcDsnKS5yZXBsYWNlKHBhdHRlcm5fbHQsICcmbHQ7JylcclxuICAgICAgICAucmVwbGFjZShwYXR0ZXJuX2d0LCAnJmd0OycpLnJlcGxhY2UocGF0dGVybl9wYXJhLCAnJnBhcmE7PGJyPicpO1xyXG4gICAgc3dpdGNoIChvcCkge1xyXG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxyXG4gICAgICAgIGh0bWxbeF0gPSAnPGlucyBzdHlsZT1cImJhY2tncm91bmQ6I2U2ZmZlNjtcIj4nICsgdGV4dCArICc8L2lucz4nO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxyXG4gICAgICAgIGh0bWxbeF0gPSAnPGRlbCBzdHlsZT1cImJhY2tncm91bmQ6I2ZmZTZlNjtcIj4nICsgdGV4dCArICc8L2RlbD4nO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfRVFVQUw6XHJcbiAgICAgICAgaHRtbFt4XSA9ICc8c3Bhbj4nICsgdGV4dCArICc8L3NwYW4+JztcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGh0bWwuam9pbignJyk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgYW5kIHJldHVybiB0aGUgc291cmNlIHRleHQgKGFsbCBlcXVhbGl0aWVzIGFuZCBkZWxldGlvbnMpLlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFNvdXJjZSB0ZXh0LlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl90ZXh0MSA9IGZ1bmN0aW9uKGRpZmZzKSB7XHJcbiAgdmFyIHRleHQgPSBbXTtcclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICBpZiAoZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUKSB7XHJcbiAgICAgIHRleHRbeF0gPSBkaWZmc1t4XVsxXTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRleHQuam9pbignJyk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgYW5kIHJldHVybiB0aGUgZGVzdGluYXRpb24gdGV4dCAoYWxsIGVxdWFsaXRpZXMgYW5kIGluc2VydGlvbnMpLlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERlc3RpbmF0aW9uIHRleHQuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3RleHQyID0gZnVuY3Rpb24oZGlmZnMpIHtcclxuICB2YXIgdGV4dCA9IFtdO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcclxuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9ERUxFVEUpIHtcclxuICAgICAgdGV4dFt4XSA9IGRpZmZzW3hdWzFdO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGV4dC5qb2luKCcnKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ29tcHV0ZSB0aGUgTGV2ZW5zaHRlaW4gZGlzdGFuY2U7IHRoZSBudW1iZXIgb2YgaW5zZXJ0ZWQsIGRlbGV0ZWQgb3JcclxuICogc3Vic3RpdHV0ZWQgY2hhcmFjdGVycy5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgY2hhbmdlcy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfbGV2ZW5zaHRlaW4gPSBmdW5jdGlvbihkaWZmcykge1xyXG4gIHZhciBsZXZlbnNodGVpbiA9IDA7XHJcbiAgdmFyIGluc2VydGlvbnMgPSAwO1xyXG4gIHZhciBkZWxldGlvbnMgPSAwO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcclxuICAgIHZhciBvcCA9IGRpZmZzW3hdWzBdO1xyXG4gICAgdmFyIGRhdGEgPSBkaWZmc1t4XVsxXTtcclxuICAgIHN3aXRjaCAob3ApIHtcclxuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcclxuICAgICAgICBpbnNlcnRpb25zICs9IGRhdGEubGVuZ3RoO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxyXG4gICAgICAgIGRlbGV0aW9ucyArPSBkYXRhLmxlbmd0aDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBESUZGX0VRVUFMOlxyXG4gICAgICAgIC8vIEEgZGVsZXRpb24gYW5kIGFuIGluc2VydGlvbiBpcyBvbmUgc3Vic3RpdHV0aW9uLlxyXG4gICAgICAgIGxldmVuc2h0ZWluICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyk7XHJcbiAgICAgICAgaW5zZXJ0aW9ucyA9IDA7XHJcbiAgICAgICAgZGVsZXRpb25zID0gMDtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgbGV2ZW5zaHRlaW4gKz0gTWF0aC5tYXgoaW5zZXJ0aW9ucywgZGVsZXRpb25zKTtcclxuICByZXR1cm4gbGV2ZW5zaHRlaW47XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIENydXNoIHRoZSBkaWZmIGludG8gYW4gZW5jb2RlZCBzdHJpbmcgd2hpY2ggZGVzY3JpYmVzIHRoZSBvcGVyYXRpb25zXHJcbiAqIHJlcXVpcmVkIHRvIHRyYW5zZm9ybSB0ZXh0MSBpbnRvIHRleHQyLlxyXG4gKiBFLmcuID0zXFx0LTJcXHQraW5nICAtPiBLZWVwIDMgY2hhcnMsIGRlbGV0ZSAyIGNoYXJzLCBpbnNlcnQgJ2luZycuXHJcbiAqIE9wZXJhdGlvbnMgYXJlIHRhYi1zZXBhcmF0ZWQuICBJbnNlcnRlZCB0ZXh0IGlzIGVzY2FwZWQgdXNpbmcgJXh4IG5vdGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERlbHRhIHRleHQuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3RvRGVsdGEgPSBmdW5jdGlvbihkaWZmcykge1xyXG4gIHZhciB0ZXh0ID0gW107XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xyXG4gICAgc3dpdGNoIChkaWZmc1t4XVswXSkge1xyXG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxyXG4gICAgICAgIHRleHRbeF0gPSAnKycgKyBlbmNvZGVVUkkoZGlmZnNbeF1bMV0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxyXG4gICAgICAgIHRleHRbeF0gPSAnLScgKyBkaWZmc1t4XVsxXS5sZW5ndGg7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcclxuICAgICAgICB0ZXh0W3hdID0gJz0nICsgZGlmZnNbeF1bMV0ubGVuZ3RoO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGV4dC5qb2luKCdcXHQnKS5yZXBsYWNlKC8lMjAvZywgJyAnKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogR2l2ZW4gdGhlIG9yaWdpbmFsIHRleHQxLCBhbmQgYW4gZW5jb2RlZCBzdHJpbmcgd2hpY2ggZGVzY3JpYmVzIHRoZVxyXG4gKiBvcGVyYXRpb25zIHJlcXVpcmVkIHRvIHRyYW5zZm9ybSB0ZXh0MSBpbnRvIHRleHQyLCBjb21wdXRlIHRoZSBmdWxsIGRpZmYuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBTb3VyY2Ugc3RyaW5nIGZvciB0aGUgZGlmZi5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRlbHRhIERlbHRhIHRleHQuXHJcbiAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAdGhyb3dzIHshRXJyb3J9IElmIGludmFsaWQgaW5wdXQuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2Zyb21EZWx0YSA9IGZ1bmN0aW9uKHRleHQxLCBkZWx0YSkge1xyXG4gIHZhciBkaWZmcyA9IFtdO1xyXG4gIHZhciBkaWZmc0xlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXHJcbiAgdmFyIHBvaW50ZXIgPSAwOyAgLy8gQ3Vyc29yIGluIHRleHQxXHJcbiAgdmFyIHRva2VucyA9IGRlbHRhLnNwbGl0KC9cXHQvZyk7XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbnMubGVuZ3RoOyB4KyspIHtcclxuICAgIC8vIEVhY2ggdG9rZW4gYmVnaW5zIHdpdGggYSBvbmUgY2hhcmFjdGVyIHBhcmFtZXRlciB3aGljaCBzcGVjaWZpZXMgdGhlXHJcbiAgICAvLyBvcGVyYXRpb24gb2YgdGhpcyB0b2tlbiAoZGVsZXRlLCBpbnNlcnQsIGVxdWFsaXR5KS5cclxuICAgIHZhciBwYXJhbSA9IHRva2Vuc1t4XS5zdWJzdHJpbmcoMSk7XHJcbiAgICBzd2l0Y2ggKHRva2Vuc1t4XS5jaGFyQXQoMCkpIHtcclxuICAgICAgY2FzZSAnKyc6XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gW0RJRkZfSU5TRVJULCBkZWNvZGVVUkkocGFyYW0pXTtcclxuICAgICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgICAgLy8gTWFsZm9ybWVkIFVSSSBzZXF1ZW5jZS5cclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBlc2NhcGUgaW4gZGlmZl9mcm9tRGVsdGE6ICcgKyBwYXJhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICctJzpcclxuICAgICAgICAvLyBGYWxsIHRocm91Z2guXHJcbiAgICAgIGNhc2UgJz0nOlxyXG4gICAgICAgIHZhciBuID0gcGFyc2VJbnQocGFyYW0sIDEwKTtcclxuICAgICAgICBpZiAoaXNOYU4obikgfHwgbiA8IDApIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgaW4gZGlmZl9mcm9tRGVsdGE6ICcgKyBwYXJhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0ZXh0ID0gdGV4dDEuc3Vic3RyaW5nKHBvaW50ZXIsIHBvaW50ZXIgKz0gbik7XHJcbiAgICAgICAgaWYgKHRva2Vuc1t4XS5jaGFyQXQoMCkgPT0gJz0nKSB7XHJcbiAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9IFtESUZGX0VRVUFMLCB0ZXh0XTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGlmZnNbZGlmZnNMZW5ndGgrK10gPSBbRElGRl9ERUxFVEUsIHRleHRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICAvLyBCbGFuayB0b2tlbnMgYXJlIG9rIChmcm9tIGEgdHJhaWxpbmcgXFx0KS5cclxuICAgICAgICAvLyBBbnl0aGluZyBlbHNlIGlzIGFuIGVycm9yLlxyXG4gICAgICAgIGlmICh0b2tlbnNbeF0pIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkaWZmIG9wZXJhdGlvbiBpbiBkaWZmX2Zyb21EZWx0YTogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zW3hdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChwb2ludGVyICE9IHRleHQxLmxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZWx0YSBsZW5ndGggKCcgKyBwb2ludGVyICtcclxuICAgICAgICAnKSBkb2VzIG5vdCBlcXVhbCBzb3VyY2UgdGV4dCBsZW5ndGggKCcgKyB0ZXh0MS5sZW5ndGggKyAnKS4nKTtcclxuICB9XHJcbiAgcmV0dXJuIGRpZmZzO1xyXG59O1xyXG5cclxuXHJcbi8vICBNQVRDSCBGVU5DVElPTlNcclxuXHJcblxyXG4vKipcclxuICogTG9jYXRlIHRoZSBiZXN0IGluc3RhbmNlIG9mICdwYXR0ZXJuJyBpbiAndGV4dCcgbmVhciAnbG9jJy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gc2VhcmNoLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byBzZWFyY2ggZm9yLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG9jIFRoZSBsb2NhdGlvbiB0byBzZWFyY2ggYXJvdW5kLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEJlc3QgbWF0Y2ggaW5kZXggb3IgLTEuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5tYXRjaF9tYWluID0gZnVuY3Rpb24odGV4dCwgcGF0dGVybiwgbG9jKSB7XHJcbiAgLy8gQ2hlY2sgZm9yIG51bGwgaW5wdXRzLlxyXG4gIGlmICh0ZXh0ID09IG51bGwgfHwgcGF0dGVybiA9PSBudWxsIHx8IGxvYyA9PSBudWxsKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ051bGwgaW5wdXQuIChtYXRjaF9tYWluKScpO1xyXG4gIH1cclxuXHJcbiAgbG9jID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obG9jLCB0ZXh0Lmxlbmd0aCkpO1xyXG4gIGlmICh0ZXh0ID09IHBhdHRlcm4pIHtcclxuICAgIC8vIFNob3J0Y3V0IChwb3RlbnRpYWxseSBub3QgZ3VhcmFudGVlZCBieSB0aGUgYWxnb3JpdGhtKVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfSBlbHNlIGlmICghdGV4dC5sZW5ndGgpIHtcclxuICAgIC8vIE5vdGhpbmcgdG8gbWF0Y2guXHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfSBlbHNlIGlmICh0ZXh0LnN1YnN0cmluZyhsb2MsIGxvYyArIHBhdHRlcm4ubGVuZ3RoKSA9PSBwYXR0ZXJuKSB7XHJcbiAgICAvLyBQZXJmZWN0IG1hdGNoIGF0IHRoZSBwZXJmZWN0IHNwb3QhICAoSW5jbHVkZXMgY2FzZSBvZiBudWxsIHBhdHRlcm4pXHJcbiAgICByZXR1cm4gbG9jO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBEbyBhIGZ1enp5IGNvbXBhcmUuXHJcbiAgICByZXR1cm4gdGhpcy5tYXRjaF9iaXRhcF8odGV4dCwgcGF0dGVybiwgbG9jKTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIExvY2F0ZSB0aGUgYmVzdCBpbnN0YW5jZSBvZiAncGF0dGVybicgaW4gJ3RleHQnIG5lYXIgJ2xvYycgdXNpbmcgdGhlXHJcbiAqIEJpdGFwIGFsZ29yaXRobS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gc2VhcmNoLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byBzZWFyY2ggZm9yLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG9jIFRoZSBsb2NhdGlvbiB0byBzZWFyY2ggYXJvdW5kLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEJlc3QgbWF0Y2ggaW5kZXggb3IgLTEuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5tYXRjaF9iaXRhcF8gPSBmdW5jdGlvbih0ZXh0LCBwYXR0ZXJuLCBsb2MpIHtcclxuICBpZiAocGF0dGVybi5sZW5ndGggPiB0aGlzLk1hdGNoX01heEJpdHMpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignUGF0dGVybiB0b28gbG9uZyBmb3IgdGhpcyBicm93c2VyLicpO1xyXG4gIH1cclxuXHJcbiAgLy8gSW5pdGlhbGlzZSB0aGUgYWxwaGFiZXQuXHJcbiAgdmFyIHMgPSB0aGlzLm1hdGNoX2FscGhhYmV0XyhwYXR0ZXJuKTtcclxuXHJcbiAgdmFyIGRtcCA9IHRoaXM7ICAvLyAndGhpcycgYmVjb21lcyAnd2luZG93JyBpbiBhIGNsb3N1cmUuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXB1dGUgYW5kIHJldHVybiB0aGUgc2NvcmUgZm9yIGEgbWF0Y2ggd2l0aCBlIGVycm9ycyBhbmQgeCBsb2NhdGlvbi5cclxuICAgKiBBY2Nlc3NlcyBsb2MgYW5kIHBhdHRlcm4gdGhyb3VnaCBiZWluZyBhIGNsb3N1cmUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGUgTnVtYmVyIG9mIGVycm9ycyBpbiBtYXRjaC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geCBMb2NhdGlvbiBvZiBtYXRjaC5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE92ZXJhbGwgc2NvcmUgZm9yIG1hdGNoICgwLjAgPSBnb29kLCAxLjAgPSBiYWQpLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbWF0Y2hfYml0YXBTY29yZV8oZSwgeCkge1xyXG4gICAgdmFyIGFjY3VyYWN5ID0gZSAvIHBhdHRlcm4ubGVuZ3RoO1xyXG4gICAgdmFyIHByb3hpbWl0eSA9IE1hdGguYWJzKGxvYyAtIHgpO1xyXG4gICAgaWYgKCFkbXAuTWF0Y2hfRGlzdGFuY2UpIHtcclxuICAgICAgLy8gRG9kZ2UgZGl2aWRlIGJ5IHplcm8gZXJyb3IuXHJcbiAgICAgIHJldHVybiBwcm94aW1pdHkgPyAxLjAgOiBhY2N1cmFjeTtcclxuICAgIH1cclxuICAgIHJldHVybiBhY2N1cmFjeSArIChwcm94aW1pdHkgLyBkbXAuTWF0Y2hfRGlzdGFuY2UpO1xyXG4gIH1cclxuXHJcbiAgLy8gSGlnaGVzdCBzY29yZSBiZXlvbmQgd2hpY2ggd2UgZ2l2ZSB1cC5cclxuICB2YXIgc2NvcmVfdGhyZXNob2xkID0gdGhpcy5NYXRjaF9UaHJlc2hvbGQ7XHJcbiAgLy8gSXMgdGhlcmUgYSBuZWFyYnkgZXhhY3QgbWF0Y2g/IChzcGVlZHVwKVxyXG4gIHZhciBiZXN0X2xvYyA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBsb2MpO1xyXG4gIGlmIChiZXN0X2xvYyAhPSAtMSkge1xyXG4gICAgc2NvcmVfdGhyZXNob2xkID0gTWF0aC5taW4obWF0Y2hfYml0YXBTY29yZV8oMCwgYmVzdF9sb2MpLCBzY29yZV90aHJlc2hvbGQpO1xyXG4gICAgLy8gV2hhdCBhYm91dCBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uPyAoc3BlZWR1cClcclxuICAgIGJlc3RfbG9jID0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCk7XHJcbiAgICBpZiAoYmVzdF9sb2MgIT0gLTEpIHtcclxuICAgICAgc2NvcmVfdGhyZXNob2xkID1cclxuICAgICAgICAgIE1hdGgubWluKG1hdGNoX2JpdGFwU2NvcmVfKDAsIGJlc3RfbG9jKSwgc2NvcmVfdGhyZXNob2xkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEluaXRpYWxpc2UgdGhlIGJpdCBhcnJheXMuXHJcbiAgdmFyIG1hdGNobWFzayA9IDEgPDwgKHBhdHRlcm4ubGVuZ3RoIC0gMSk7XHJcbiAgYmVzdF9sb2MgPSAtMTtcclxuXHJcbiAgdmFyIGJpbl9taW4sIGJpbl9taWQ7XHJcbiAgdmFyIGJpbl9tYXggPSBwYXR0ZXJuLmxlbmd0aCArIHRleHQubGVuZ3RoO1xyXG4gIHZhciBsYXN0X3JkO1xyXG4gIGZvciAodmFyIGQgPSAwOyBkIDwgcGF0dGVybi5sZW5ndGg7IGQrKykge1xyXG4gICAgLy8gU2NhbiBmb3IgdGhlIGJlc3QgbWF0Y2g7IGVhY2ggaXRlcmF0aW9uIGFsbG93cyBmb3Igb25lIG1vcmUgZXJyb3IuXHJcbiAgICAvLyBSdW4gYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSBob3cgZmFyIGZyb20gJ2xvYycgd2UgY2FuIHN0cmF5IGF0IHRoaXNcclxuICAgIC8vIGVycm9yIGxldmVsLlxyXG4gICAgYmluX21pbiA9IDA7XHJcbiAgICBiaW5fbWlkID0gYmluX21heDtcclxuICAgIHdoaWxlIChiaW5fbWluIDwgYmluX21pZCkge1xyXG4gICAgICBpZiAobWF0Y2hfYml0YXBTY29yZV8oZCwgbG9jICsgYmluX21pZCkgPD0gc2NvcmVfdGhyZXNob2xkKSB7XHJcbiAgICAgICAgYmluX21pbiA9IGJpbl9taWQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYmluX21heCA9IGJpbl9taWQ7XHJcbiAgICAgIH1cclxuICAgICAgYmluX21pZCA9IE1hdGguZmxvb3IoKGJpbl9tYXggLSBiaW5fbWluKSAvIDIgKyBiaW5fbWluKTtcclxuICAgIH1cclxuICAgIC8vIFVzZSB0aGUgcmVzdWx0IGZyb20gdGhpcyBpdGVyYXRpb24gYXMgdGhlIG1heGltdW0gZm9yIHRoZSBuZXh0LlxyXG4gICAgYmluX21heCA9IGJpbl9taWQ7XHJcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heCgxLCBsb2MgLSBiaW5fbWlkICsgMSk7XHJcbiAgICB2YXIgZmluaXNoID0gTWF0aC5taW4obG9jICsgYmluX21pZCwgdGV4dC5sZW5ndGgpICsgcGF0dGVybi5sZW5ndGg7XHJcblxyXG4gICAgdmFyIHJkID0gQXJyYXkoZmluaXNoICsgMik7XHJcbiAgICByZFtmaW5pc2ggKyAxXSA9ICgxIDw8IGQpIC0gMTtcclxuICAgIGZvciAodmFyIGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGotLSkge1xyXG4gICAgICAvLyBUaGUgYWxwaGFiZXQgKHMpIGlzIGEgc3BhcnNlIGhhc2gsIHNvIHRoZSBmb2xsb3dpbmcgbGluZSBnZW5lcmF0ZXNcclxuICAgICAgLy8gd2FybmluZ3MuXHJcbiAgICAgIHZhciBjaGFyTWF0Y2ggPSBzW3RleHQuY2hhckF0KGogLSAxKV07XHJcbiAgICAgIGlmIChkID09PSAwKSB7ICAvLyBGaXJzdCBwYXNzOiBleGFjdCBtYXRjaC5cclxuICAgICAgICByZFtqXSA9ICgocmRbaiArIDFdIDw8IDEpIHwgMSkgJiBjaGFyTWF0Y2g7XHJcbiAgICAgIH0gZWxzZSB7ICAvLyBTdWJzZXF1ZW50IHBhc3NlczogZnV6enkgbWF0Y2guXHJcbiAgICAgICAgcmRbal0gPSAoKChyZFtqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaCkgfFxyXG4gICAgICAgICAgICAgICAgKCgobGFzdF9yZFtqICsgMV0gfCBsYXN0X3JkW2pdKSA8PCAxKSB8IDEpIHxcclxuICAgICAgICAgICAgICAgIGxhc3RfcmRbaiArIDFdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZFtqXSAmIG1hdGNobWFzaykge1xyXG4gICAgICAgIHZhciBzY29yZSA9IG1hdGNoX2JpdGFwU2NvcmVfKGQsIGogLSAxKTtcclxuICAgICAgICAvLyBUaGlzIG1hdGNoIHdpbGwgYWxtb3N0IGNlcnRhaW5seSBiZSBiZXR0ZXIgdGhhbiBhbnkgZXhpc3RpbmcgbWF0Y2guXHJcbiAgICAgICAgLy8gQnV0IGNoZWNrIGFueXdheS5cclxuICAgICAgICBpZiAoc2NvcmUgPD0gc2NvcmVfdGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAvLyBUb2xkIHlvdSBzby5cclxuICAgICAgICAgIHNjb3JlX3RocmVzaG9sZCA9IHNjb3JlO1xyXG4gICAgICAgICAgYmVzdF9sb2MgPSBqIC0gMTtcclxuICAgICAgICAgIGlmIChiZXN0X2xvYyA+IGxvYykge1xyXG4gICAgICAgICAgICAvLyBXaGVuIHBhc3NpbmcgbG9jLCBkb24ndCBleGNlZWQgb3VyIGN1cnJlbnQgZGlzdGFuY2UgZnJvbSBsb2MuXHJcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGxvYyAtIGJlc3RfbG9jKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEFscmVhZHkgcGFzc2VkIGxvYywgZG93bmhpbGwgZnJvbSBoZXJlIG9uIGluLlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIE5vIGhvcGUgZm9yIGEgKGJldHRlcikgbWF0Y2ggYXQgZ3JlYXRlciBlcnJvciBsZXZlbHMuXHJcbiAgICBpZiAobWF0Y2hfYml0YXBTY29yZV8oZCArIDEsIGxvYykgPiBzY29yZV90aHJlc2hvbGQpIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBsYXN0X3JkID0gcmQ7XHJcbiAgfVxyXG4gIHJldHVybiBiZXN0X2xvYztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogSW5pdGlhbGlzZSB0aGUgYWxwaGFiZXQgZm9yIHRoZSBCaXRhcCBhbGdvcml0aG0uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSB0ZXh0IHRvIGVuY29kZS5cclxuICogQHJldHVybiB7IU9iamVjdH0gSGFzaCBvZiBjaGFyYWN0ZXIgbG9jYXRpb25zLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUubWF0Y2hfYWxwaGFiZXRfID0gZnVuY3Rpb24ocGF0dGVybikge1xyXG4gIHZhciBzID0ge307XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBzW3BhdHRlcm4uY2hhckF0KGkpXSA9IDA7XHJcbiAgfVxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xyXG4gICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gfD0gMSA8PCAocGF0dGVybi5sZW5ndGggLSBpIC0gMSk7XHJcbiAgfVxyXG4gIHJldHVybiBzO1xyXG59O1xyXG5cclxuXHJcbi8vICBQQVRDSCBGVU5DVElPTlNcclxuXHJcblxyXG4vKipcclxuICogSW5jcmVhc2UgdGhlIGNvbnRleHQgdW50aWwgaXQgaXMgdW5pcXVlLFxyXG4gKiBidXQgZG9uJ3QgbGV0IHRoZSBwYXR0ZXJuIGV4cGFuZCBiZXlvbmQgTWF0Y2hfTWF4Qml0cy5cclxuICogQHBhcmFtIHshZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmp9IHBhdGNoIFRoZSBwYXRjaCB0byBncm93LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBTb3VyY2UgdGV4dC5cclxuICogQHByaXZhdGVcclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX2FkZENvbnRleHRfID0gZnVuY3Rpb24ocGF0Y2gsIHRleHQpIHtcclxuICBpZiAodGV4dC5sZW5ndGggPT0gMCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgcGF0dGVybiA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiwgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSk7XHJcbiAgdmFyIHBhZGRpbmcgPSAwO1xyXG5cclxuICAvLyBMb29rIGZvciB0aGUgZmlyc3QgYW5kIGxhc3QgbWF0Y2hlcyBvZiBwYXR0ZXJuIGluIHRleHQuICBJZiB0d28gZGlmZmVyZW50XHJcbiAgLy8gbWF0Y2hlcyBhcmUgZm91bmQsIGluY3JlYXNlIHRoZSBwYXR0ZXJuIGxlbmd0aC5cclxuICB3aGlsZSAodGV4dC5pbmRleE9mKHBhdHRlcm4pICE9IHRleHQubGFzdEluZGV4T2YocGF0dGVybikgJiZcclxuICAgICAgICAgcGF0dGVybi5sZW5ndGggPCB0aGlzLk1hdGNoX01heEJpdHMgLSB0aGlzLlBhdGNoX01hcmdpbiAtXHJcbiAgICAgICAgIHRoaXMuUGF0Y2hfTWFyZ2luKSB7XHJcbiAgICBwYWRkaW5nICs9IHRoaXMuUGF0Y2hfTWFyZ2luO1xyXG4gICAgcGF0dGVybiA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiAtIHBhZGRpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSArIHBhZGRpbmcpO1xyXG4gIH1cclxuICAvLyBBZGQgb25lIGNodW5rIGZvciBnb29kIGx1Y2suXHJcbiAgcGFkZGluZyArPSB0aGlzLlBhdGNoX01hcmdpbjtcclxuXHJcbiAgLy8gQWRkIHRoZSBwcmVmaXguXHJcbiAgdmFyIHByZWZpeCA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiAtIHBhZGRpbmcsIHBhdGNoLnN0YXJ0Mik7XHJcbiAgaWYgKHByZWZpeCkge1xyXG4gICAgcGF0Y2guZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgcHJlZml4XSk7XHJcbiAgfVxyXG4gIC8vIEFkZCB0aGUgc3VmZml4LlxyXG4gIHZhciBzdWZmaXggPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxICsgcGFkZGluZyk7XHJcbiAgaWYgKHN1ZmZpeCkge1xyXG4gICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgc3VmZml4XSk7XHJcbiAgfVxyXG5cclxuICAvLyBSb2xsIGJhY2sgdGhlIHN0YXJ0IHBvaW50cy5cclxuICBwYXRjaC5zdGFydDEgLT0gcHJlZml4Lmxlbmd0aDtcclxuICBwYXRjaC5zdGFydDIgLT0gcHJlZml4Lmxlbmd0aDtcclxuICAvLyBFeHRlbmQgdGhlIGxlbmd0aHMuXHJcbiAgcGF0Y2gubGVuZ3RoMSArPSBwcmVmaXgubGVuZ3RoICsgc3VmZml4Lmxlbmd0aDtcclxuICBwYXRjaC5sZW5ndGgyICs9IHByZWZpeC5sZW5ndGggKyBzdWZmaXgubGVuZ3RoO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlIGEgbGlzdCBvZiBwYXRjaGVzIHRvIHR1cm4gdGV4dDEgaW50byB0ZXh0Mi5cclxuICogVXNlIGRpZmZzIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgY29tcHV0ZSBpdCBvdXJzZWx2ZXMuXHJcbiAqIFRoZXJlIGFyZSBmb3VyIHdheXMgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uLCBkZXBlbmRpbmcgb24gd2hhdCBkYXRhIGlzXHJcbiAqIGF2YWlsYWJsZSB0byB0aGUgY2FsbGVyOlxyXG4gKiBNZXRob2QgMTpcclxuICogYSA9IHRleHQxLCBiID0gdGV4dDJcclxuICogTWV0aG9kIDI6XHJcbiAqIGEgPSBkaWZmc1xyXG4gKiBNZXRob2QgMyAob3B0aW1hbCk6XHJcbiAqIGEgPSB0ZXh0MSwgYiA9IGRpZmZzXHJcbiAqIE1ldGhvZCA0IChkZXByZWNhdGVkLCB1c2UgbWV0aG9kIDMpOlxyXG4gKiBhID0gdGV4dDEsIGIgPSB0ZXh0MiwgYyA9IGRpZmZzXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfCFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGEgdGV4dDEgKG1ldGhvZHMgMSwzLDQpIG9yXHJcbiAqIEFycmF5IG9mIGRpZmYgdHVwbGVzIGZvciB0ZXh0MSB0byB0ZXh0MiAobWV0aG9kIDIpLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3whQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBvcHRfYiB0ZXh0MiAobWV0aG9kcyAxLDQpIG9yXHJcbiAqIEFycmF5IG9mIGRpZmYgdHVwbGVzIGZvciB0ZXh0MSB0byB0ZXh0MiAobWV0aG9kIDMpIG9yIHVuZGVmaW5lZCAobWV0aG9kIDIpLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3whQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBvcHRfYyBBcnJheSBvZiBkaWZmIHR1cGxlc1xyXG4gKiBmb3IgdGV4dDEgdG8gdGV4dDIgKG1ldGhvZCA0KSBvciB1bmRlZmluZWQgKG1ldGhvZHMgMSwyLDMpLlxyXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9tYWtlID0gZnVuY3Rpb24oYSwgb3B0X2IsIG9wdF9jKSB7XHJcbiAgdmFyIHRleHQxLCBkaWZmcztcclxuICBpZiAodHlwZW9mIGEgPT0gJ3N0cmluZycgJiYgdHlwZW9mIG9wdF9iID09ICdzdHJpbmcnICYmXHJcbiAgICAgIHR5cGVvZiBvcHRfYyA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgLy8gTWV0aG9kIDE6IHRleHQxLCB0ZXh0MlxyXG4gICAgLy8gQ29tcHV0ZSBkaWZmcyBmcm9tIHRleHQxIGFuZCB0ZXh0Mi5cclxuICAgIHRleHQxID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovKGEpO1xyXG4gICAgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MSwgLyoqIEB0eXBlIHtzdHJpbmd9ICovKG9wdF9iKSwgdHJ1ZSk7XHJcbiAgICBpZiAoZGlmZnMubGVuZ3RoID4gMikge1xyXG4gICAgICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljKGRpZmZzKTtcclxuICAgICAgdGhpcy5kaWZmX2NsZWFudXBFZmZpY2llbmN5KGRpZmZzKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGEgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdF9iID09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgIHR5cGVvZiBvcHRfYyA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgLy8gTWV0aG9kIDI6IGRpZmZzXHJcbiAgICAvLyBDb21wdXRlIHRleHQxIGZyb20gZGlmZnMuXHJcbiAgICBkaWZmcyA9IC8qKiBAdHlwZSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gKi8oYSk7XHJcbiAgICB0ZXh0MSA9IHRoaXMuZGlmZl90ZXh0MShkaWZmcyk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiBvcHRfYiAmJiB0eXBlb2Ygb3B0X2IgPT0gJ29iamVjdCcgJiZcclxuICAgICAgdHlwZW9mIG9wdF9jID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyBNZXRob2QgMzogdGV4dDEsIGRpZmZzXHJcbiAgICB0ZXh0MSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyhhKTtcclxuICAgIGRpZmZzID0gLyoqIEB0eXBlIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSAqLyhvcHRfYik7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3B0X2IgPT0gJ3N0cmluZycgJiZcclxuICAgICAgb3B0X2MgJiYgdHlwZW9mIG9wdF9jID09ICdvYmplY3QnKSB7XHJcbiAgICAvLyBNZXRob2QgNDogdGV4dDEsIHRleHQyLCBkaWZmc1xyXG4gICAgLy8gdGV4dDIgaXMgbm90IHVzZWQuXHJcbiAgICB0ZXh0MSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyhhKTtcclxuICAgIGRpZmZzID0gLyoqIEB0eXBlIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSAqLyhvcHRfYyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjYWxsIGZvcm1hdCB0byBwYXRjaF9tYWtlLicpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGRpZmZzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIFtdOyAgLy8gR2V0IHJpZCBvZiB0aGUgbnVsbCBjYXNlLlxyXG4gIH1cclxuICB2YXIgcGF0Y2hlcyA9IFtdO1xyXG4gIHZhciBwYXRjaCA9IG5ldyBkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaigpO1xyXG4gIHZhciBwYXRjaERpZmZMZW5ndGggPSAwOyAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXIgaXMgZmFzdGVyIGluIEpTLlxyXG4gIHZhciBjaGFyX2NvdW50MSA9IDA7ICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbnRvIHRoZSB0ZXh0MSBzdHJpbmcuXHJcbiAgdmFyIGNoYXJfY291bnQyID0gMDsgIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIGludG8gdGhlIHRleHQyIHN0cmluZy5cclxuICAvLyBTdGFydCB3aXRoIHRleHQxIChwcmVwYXRjaF90ZXh0KSBhbmQgYXBwbHkgdGhlIGRpZmZzIHVudGlsIHdlIGFycml2ZSBhdFxyXG4gIC8vIHRleHQyIChwb3N0cGF0Y2hfdGV4dCkuICBXZSByZWNyZWF0ZSB0aGUgcGF0Y2hlcyBvbmUgYnkgb25lIHRvIGRldGVybWluZVxyXG4gIC8vIGNvbnRleHQgaW5mby5cclxuICB2YXIgcHJlcGF0Y2hfdGV4dCA9IHRleHQxO1xyXG4gIHZhciBwb3N0cGF0Y2hfdGV4dCA9IHRleHQxO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcclxuICAgIHZhciBkaWZmX3R5cGUgPSBkaWZmc1t4XVswXTtcclxuICAgIHZhciBkaWZmX3RleHQgPSBkaWZmc1t4XVsxXTtcclxuXHJcbiAgICBpZiAoIXBhdGNoRGlmZkxlbmd0aCAmJiBkaWZmX3R5cGUgIT09IERJRkZfRVFVQUwpIHtcclxuICAgICAgLy8gQSBuZXcgcGF0Y2ggc3RhcnRzIGhlcmUuXHJcbiAgICAgIHBhdGNoLnN0YXJ0MSA9IGNoYXJfY291bnQxO1xyXG4gICAgICBwYXRjaC5zdGFydDIgPSBjaGFyX2NvdW50MjtcclxuICAgIH1cclxuXHJcbiAgICBzd2l0Y2ggKGRpZmZfdHlwZSkge1xyXG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxyXG4gICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xyXG4gICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICBwb3N0cGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZygwLCBjaGFyX2NvdW50MikgKyBkaWZmX3RleHQgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKGNoYXJfY291bnQyKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBESUZGX0RFTEVURTpcclxuICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gZGlmZnNbeF07XHJcbiAgICAgICAgcG9zdHBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoMCwgY2hhcl9jb3VudDIpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZyhjaGFyX2NvdW50MiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZl90ZXh0Lmxlbmd0aCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcclxuICAgICAgICBpZiAoZGlmZl90ZXh0Lmxlbmd0aCA8PSAyICogdGhpcy5QYXRjaF9NYXJnaW4gJiZcclxuICAgICAgICAgICAgcGF0Y2hEaWZmTGVuZ3RoICYmIGRpZmZzLmxlbmd0aCAhPSB4ICsgMSkge1xyXG4gICAgICAgICAgLy8gU21hbGwgZXF1YWxpdHkgaW5zaWRlIGEgcGF0Y2guXHJcbiAgICAgICAgICBwYXRjaC5kaWZmc1twYXRjaERpZmZMZW5ndGgrK10gPSBkaWZmc1t4XTtcclxuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRpZmZfdGV4dC5sZW5ndGggPj0gMiAqIHRoaXMuUGF0Y2hfTWFyZ2luKSB7XHJcbiAgICAgICAgICAvLyBUaW1lIGZvciBhIG5ldyBwYXRjaC5cclxuICAgICAgICAgIGlmIChwYXRjaERpZmZMZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXRjaF9hZGRDb250ZXh0XyhwYXRjaCwgcHJlcGF0Y2hfdGV4dCk7XHJcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XHJcbiAgICAgICAgICAgIHBhdGNoID0gbmV3IGRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqKCk7XHJcbiAgICAgICAgICAgIHBhdGNoRGlmZkxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIC8vIFVubGlrZSBVbmlkaWZmLCBvdXIgcGF0Y2ggbGlzdHMgaGF2ZSBhIHJvbGxpbmcgY29udGV4dC5cclxuICAgICAgICAgICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL3dpa2kvVW5pZGlmZlxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgcHJlcGF0Y2ggdGV4dCAmIHBvcyB0byByZWZsZWN0IHRoZSBhcHBsaWNhdGlvbiBvZiB0aGVcclxuICAgICAgICAgICAgLy8ganVzdCBjb21wbGV0ZWQgcGF0Y2guXHJcbiAgICAgICAgICAgIHByZXBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dDtcclxuICAgICAgICAgICAgY2hhcl9jb3VudDEgPSBjaGFyX2NvdW50MjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGNoYXJhY3RlciBjb3VudC5cclxuICAgIGlmIChkaWZmX3R5cGUgIT09IERJRkZfSU5TRVJUKSB7XHJcbiAgICAgIGNoYXJfY291bnQxICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlmZl90eXBlICE9PSBESUZGX0RFTEVURSkge1xyXG4gICAgICBjaGFyX2NvdW50MiArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBQaWNrIHVwIHRoZSBsZWZ0b3ZlciBwYXRjaCBpZiBub3QgZW1wdHkuXHJcbiAgaWYgKHBhdGNoRGlmZkxlbmd0aCkge1xyXG4gICAgdGhpcy5wYXRjaF9hZGRDb250ZXh0XyhwYXRjaCwgcHJlcGF0Y2hfdGV4dCk7XHJcbiAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHBhdGNoZXM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHBhdGNoZXMsIHJldHVybiBhbm90aGVyIGFycmF5IHRoYXQgaXMgaWRlbnRpY2FsLlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxyXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9kZWVwQ29weSA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcclxuICAvLyBNYWtpbmcgZGVlcCBjb3BpZXMgaXMgaGFyZCBpbiBKYXZhU2NyaXB0LlxyXG4gIHZhciBwYXRjaGVzQ29weSA9IFtdO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xyXG4gICAgdmFyIHBhdGNoID0gcGF0Y2hlc1t4XTtcclxuICAgIHZhciBwYXRjaENvcHkgPSBuZXcgZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmooKTtcclxuICAgIHBhdGNoQ29weS5kaWZmcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBwYXRjaC5kaWZmcy5sZW5ndGg7IHkrKykge1xyXG4gICAgICBwYXRjaENvcHkuZGlmZnNbeV0gPSBwYXRjaC5kaWZmc1t5XS5zbGljZSgpO1xyXG4gICAgfVxyXG4gICAgcGF0Y2hDb3B5LnN0YXJ0MSA9IHBhdGNoLnN0YXJ0MTtcclxuICAgIHBhdGNoQ29weS5zdGFydDIgPSBwYXRjaC5zdGFydDI7XHJcbiAgICBwYXRjaENvcHkubGVuZ3RoMSA9IHBhdGNoLmxlbmd0aDE7XHJcbiAgICBwYXRjaENvcHkubGVuZ3RoMiA9IHBhdGNoLmxlbmd0aDI7XHJcbiAgICBwYXRjaGVzQ29weVt4XSA9IHBhdGNoQ29weTtcclxuICB9XHJcbiAgcmV0dXJuIHBhdGNoZXNDb3B5O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBNZXJnZSBhIHNldCBvZiBwYXRjaGVzIG9udG8gdGhlIHRleHQuICBSZXR1cm4gYSBwYXRjaGVkIHRleHQsIGFzIHdlbGxcclxuICogYXMgYSBsaXN0IG9mIHRydWUvZmFsc2UgdmFsdWVzIGluZGljYXRpbmcgd2hpY2ggcGF0Y2hlcyB3ZXJlIGFwcGxpZWQuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IE9sZCB0ZXh0LlxyXG4gKiBAcmV0dXJuIHshQXJyYXkuPHN0cmluZ3whQXJyYXkuPGJvb2xlYW4+Pn0gVHdvIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlXHJcbiAqICAgICAgbmV3IHRleHQgYW5kIGFuIGFycmF5IG9mIGJvb2xlYW4gdmFsdWVzLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfYXBwbHkgPSBmdW5jdGlvbihwYXRjaGVzLCB0ZXh0KSB7XHJcbiAgaWYgKHBhdGNoZXMubGVuZ3RoID09IDApIHtcclxuICAgIHJldHVybiBbdGV4dCwgW11dO1xyXG4gIH1cclxuXHJcbiAgLy8gRGVlcCBjb3B5IHRoZSBwYXRjaGVzIHNvIHRoYXQgbm8gY2hhbmdlcyBhcmUgbWFkZSB0byBvcmlnaW5hbHMuXHJcbiAgcGF0Y2hlcyA9IHRoaXMucGF0Y2hfZGVlcENvcHkocGF0Y2hlcyk7XHJcblxyXG4gIHZhciBudWxsUGFkZGluZyA9IHRoaXMucGF0Y2hfYWRkUGFkZGluZyhwYXRjaGVzKTtcclxuICB0ZXh0ID0gbnVsbFBhZGRpbmcgKyB0ZXh0ICsgbnVsbFBhZGRpbmc7XHJcblxyXG4gIHRoaXMucGF0Y2hfc3BsaXRNYXgocGF0Y2hlcyk7XHJcbiAgLy8gZGVsdGEga2VlcHMgdHJhY2sgb2YgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBleHBlY3RlZCBhbmQgYWN0dWFsIGxvY2F0aW9uXHJcbiAgLy8gb2YgdGhlIHByZXZpb3VzIHBhdGNoLiAgSWYgdGhlcmUgYXJlIHBhdGNoZXMgZXhwZWN0ZWQgYXQgcG9zaXRpb25zIDEwIGFuZFxyXG4gIC8vIDIwLCBidXQgdGhlIGZpcnN0IHBhdGNoIHdhcyBmb3VuZCBhdCAxMiwgZGVsdGEgaXMgMiBhbmQgdGhlIHNlY29uZCBwYXRjaFxyXG4gIC8vIGhhcyBhbiBlZmZlY3RpdmUgZXhwZWN0ZWQgcG9zaXRpb24gb2YgMjIuXHJcbiAgdmFyIGRlbHRhID0gMDtcclxuICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xyXG4gICAgdmFyIGV4cGVjdGVkX2xvYyA9IHBhdGNoZXNbeF0uc3RhcnQyICsgZGVsdGE7XHJcbiAgICB2YXIgdGV4dDEgPSB0aGlzLmRpZmZfdGV4dDEocGF0Y2hlc1t4XS5kaWZmcyk7XHJcbiAgICB2YXIgc3RhcnRfbG9jO1xyXG4gICAgdmFyIGVuZF9sb2MgPSAtMTtcclxuICAgIGlmICh0ZXh0MS5sZW5ndGggPiB0aGlzLk1hdGNoX01heEJpdHMpIHtcclxuICAgICAgLy8gcGF0Y2hfc3BsaXRNYXggd2lsbCBvbmx5IHByb3ZpZGUgYW4gb3ZlcnNpemVkIHBhdHRlcm4gaW4gdGhlIGNhc2Ugb2ZcclxuICAgICAgLy8gYSBtb25zdGVyIGRlbGV0ZS5cclxuICAgICAgc3RhcnRfbG9jID0gdGhpcy5tYXRjaF9tYWluKHRleHQsIHRleHQxLnN1YnN0cmluZygwLCB0aGlzLk1hdGNoX01heEJpdHMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRfbG9jKTtcclxuICAgICAgaWYgKHN0YXJ0X2xvYyAhPSAtMSkge1xyXG4gICAgICAgIGVuZF9sb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCxcclxuICAgICAgICAgICAgdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHRoaXMuTWF0Y2hfTWF4Qml0cyksXHJcbiAgICAgICAgICAgIGV4cGVjdGVkX2xvYyArIHRleHQxLmxlbmd0aCAtIHRoaXMuTWF0Y2hfTWF4Qml0cyk7XHJcbiAgICAgICAgaWYgKGVuZF9sb2MgPT0gLTEgfHwgc3RhcnRfbG9jID49IGVuZF9sb2MpIHtcclxuICAgICAgICAgIC8vIENhbid0IGZpbmQgdmFsaWQgdHJhaWxpbmcgY29udGV4dC4gIERyb3AgdGhpcyBwYXRjaC5cclxuICAgICAgICAgIHN0YXJ0X2xvYyA9IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RhcnRfbG9jID0gdGhpcy5tYXRjaF9tYWluKHRleHQsIHRleHQxLCBleHBlY3RlZF9sb2MpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0YXJ0X2xvYyA9PSAtMSkge1xyXG4gICAgICAvLyBObyBtYXRjaCBmb3VuZC4gIDooXHJcbiAgICAgIHJlc3VsdHNbeF0gPSBmYWxzZTtcclxuICAgICAgLy8gU3VidHJhY3QgdGhlIGRlbHRhIGZvciB0aGlzIGZhaWxlZCBwYXRjaCBmcm9tIHN1YnNlcXVlbnQgcGF0Y2hlcy5cclxuICAgICAgZGVsdGEgLT0gcGF0Y2hlc1t4XS5sZW5ndGgyIC0gcGF0Y2hlc1t4XS5sZW5ndGgxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gRm91bmQgYSBtYXRjaC4gIDopXHJcbiAgICAgIHJlc3VsdHNbeF0gPSB0cnVlO1xyXG4gICAgICBkZWx0YSA9IHN0YXJ0X2xvYyAtIGV4cGVjdGVkX2xvYztcclxuICAgICAgdmFyIHRleHQyO1xyXG4gICAgICBpZiAoZW5kX2xvYyA9PSAtMSkge1xyXG4gICAgICAgIHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jLCBzdGFydF9sb2MgKyB0ZXh0MS5sZW5ndGgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jLCBlbmRfbG9jICsgdGhpcy5NYXRjaF9NYXhCaXRzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGV4dDEgPT0gdGV4dDIpIHtcclxuICAgICAgICAvLyBQZXJmZWN0IG1hdGNoLCBqdXN0IHNob3ZlIHRoZSByZXBsYWNlbWVudCB0ZXh0IGluLlxyXG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MpICtcclxuICAgICAgICAgICAgICAgdGhpcy5kaWZmX3RleHQyKHBhdGNoZXNbeF0uZGlmZnMpICtcclxuICAgICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jICsgdGV4dDEubGVuZ3RoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBJbXBlcmZlY3QgbWF0Y2guICBSdW4gYSBkaWZmIHRvIGdldCBhIGZyYW1ld29yayBvZiBlcXVpdmFsZW50XHJcbiAgICAgICAgLy8gaW5kaWNlcy5cclxuICAgICAgICB2YXIgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MSwgdGV4dDIsIGZhbHNlKTtcclxuICAgICAgICBpZiAodGV4dDEubGVuZ3RoID4gdGhpcy5NYXRjaF9NYXhCaXRzICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGlmZl9sZXZlbnNodGVpbihkaWZmcykgLyB0ZXh0MS5sZW5ndGggPlxyXG4gICAgICAgICAgICB0aGlzLlBhdGNoX0RlbGV0ZVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgLy8gVGhlIGVuZCBwb2ludHMgbWF0Y2gsIGJ1dCB0aGUgY29udGVudCBpcyB1bmFjY2VwdGFibHkgYmFkLlxyXG4gICAgICAgICAgcmVzdWx0c1t4XSA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xyXG4gICAgICAgICAgdmFyIGluZGV4MSA9IDA7XHJcbiAgICAgICAgICB2YXIgaW5kZXgyO1xyXG4gICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBwYXRjaGVzW3hdLmRpZmZzLmxlbmd0aDsgeSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtb2QgPSBwYXRjaGVzW3hdLmRpZmZzW3ldO1xyXG4gICAgICAgICAgICBpZiAobW9kWzBdICE9PSBESUZGX0VRVUFMKSB7XHJcbiAgICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5kaWZmX3hJbmRleChkaWZmcywgaW5kZXgxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobW9kWzBdID09PSBESUZGX0lOU0VSVCkgeyAgLy8gSW5zZXJ0aW9uXHJcbiAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0X2xvYyArIGluZGV4MikgKyBtb2RbMV0gK1xyXG4gICAgICAgICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MgKyBpbmRleDIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vZFswXSA9PT0gRElGRl9ERUxFVEUpIHsgIC8vIERlbGV0aW9uXHJcbiAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0X2xvYyArIGluZGV4MikgK1xyXG4gICAgICAgICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MgKyB0aGlzLmRpZmZfeEluZGV4KGRpZmZzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgxICsgbW9kWzFdLmxlbmd0aCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtb2RbMF0gIT09IERJRkZfREVMRVRFKSB7XHJcbiAgICAgICAgICAgICAgaW5kZXgxICs9IG1vZFsxXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgLy8gU3RyaXAgdGhlIHBhZGRpbmcgb2ZmLlxyXG4gIHRleHQgPSB0ZXh0LnN1YnN0cmluZyhudWxsUGFkZGluZy5sZW5ndGgsIHRleHQubGVuZ3RoIC0gbnVsbFBhZGRpbmcubGVuZ3RoKTtcclxuICByZXR1cm4gW3RleHQsIHJlc3VsdHNdO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBZGQgc29tZSBwYWRkaW5nIG9uIHRleHQgc3RhcnQgYW5kIGVuZCBzbyB0aGF0IGVkZ2VzIGNhbiBtYXRjaCBzb21ldGhpbmcuXHJcbiAqIEludGVuZGVkIHRvIGJlIGNhbGxlZCBvbmx5IGZyb20gd2l0aGluIHBhdGNoX2FwcGx5LlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwYWRkaW5nIHN0cmluZyBhZGRlZCB0byBlYWNoIHNpZGUuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9hZGRQYWRkaW5nID0gZnVuY3Rpb24ocGF0Y2hlcykge1xyXG4gIHZhciBwYWRkaW5nTGVuZ3RoID0gdGhpcy5QYXRjaF9NYXJnaW47XHJcbiAgdmFyIG51bGxQYWRkaW5nID0gJyc7XHJcbiAgZm9yICh2YXIgeCA9IDE7IHggPD0gcGFkZGluZ0xlbmd0aDsgeCsrKSB7XHJcbiAgICBudWxsUGFkZGluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xyXG4gIH1cclxuXHJcbiAgLy8gQnVtcCBhbGwgdGhlIHBhdGNoZXMgZm9yd2FyZC5cclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcclxuICAgIHBhdGNoZXNbeF0uc3RhcnQxICs9IHBhZGRpbmdMZW5ndGg7XHJcbiAgICBwYXRjaGVzW3hdLnN0YXJ0MiArPSBwYWRkaW5nTGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHNvbWUgcGFkZGluZyBvbiBzdGFydCBvZiBmaXJzdCBkaWZmLlxyXG4gIHZhciBwYXRjaCA9IHBhdGNoZXNbMF07XHJcbiAgdmFyIGRpZmZzID0gcGF0Y2guZGlmZnM7XHJcbiAgaWYgKGRpZmZzLmxlbmd0aCA9PSAwIHx8IGRpZmZzWzBdWzBdICE9IERJRkZfRVFVQUwpIHtcclxuICAgIC8vIEFkZCBudWxsUGFkZGluZyBlcXVhbGl0eS5cclxuICAgIGRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSk7XHJcbiAgICBwYXRjaC5zdGFydDEgLT0gcGFkZGluZ0xlbmd0aDsgIC8vIFNob3VsZCBiZSAwLlxyXG4gICAgcGF0Y2guc3RhcnQyIC09IHBhZGRpbmdMZW5ndGg7ICAvLyBTaG91bGQgYmUgMC5cclxuICAgIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aDtcclxuICAgIHBhdGNoLmxlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aDtcclxuICB9IGVsc2UgaWYgKHBhZGRpbmdMZW5ndGggPiBkaWZmc1swXVsxXS5sZW5ndGgpIHtcclxuICAgIC8vIEdyb3cgZmlyc3QgZXF1YWxpdHkuXHJcbiAgICB2YXIgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbMF1bMV0ubGVuZ3RoO1xyXG4gICAgZGlmZnNbMF1bMV0gPSBudWxsUGFkZGluZy5zdWJzdHJpbmcoZGlmZnNbMF1bMV0ubGVuZ3RoKSArIGRpZmZzWzBdWzFdO1xyXG4gICAgcGF0Y2guc3RhcnQxIC09IGV4dHJhTGVuZ3RoO1xyXG4gICAgcGF0Y2guc3RhcnQyIC09IGV4dHJhTGVuZ3RoO1xyXG4gICAgcGF0Y2gubGVuZ3RoMSArPSBleHRyYUxlbmd0aDtcclxuICAgIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgc29tZSBwYWRkaW5nIG9uIGVuZCBvZiBsYXN0IGRpZmYuXHJcbiAgcGF0Y2ggPSBwYXRjaGVzW3BhdGNoZXMubGVuZ3RoIC0gMV07XHJcbiAgZGlmZnMgPSBwYXRjaC5kaWZmcztcclxuICBpZiAoZGlmZnMubGVuZ3RoID09IDAgfHwgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMF0gIT0gRElGRl9FUVVBTCkge1xyXG4gICAgLy8gQWRkIG51bGxQYWRkaW5nIGVxdWFsaXR5LlxyXG4gICAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKTtcclxuICAgIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aDtcclxuICAgIHBhdGNoLmxlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aDtcclxuICB9IGVsc2UgaWYgKHBhZGRpbmdMZW5ndGggPiBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGgpIHtcclxuICAgIC8vIEdyb3cgbGFzdCBlcXVhbGl0eS5cclxuICAgIHZhciBleHRyYUxlbmd0aCA9IHBhZGRpbmdMZW5ndGggLSBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGg7XHJcbiAgICBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSArPSBudWxsUGFkZGluZy5zdWJzdHJpbmcoMCwgZXh0cmFMZW5ndGgpO1xyXG4gICAgcGF0Y2gubGVuZ3RoMSArPSBleHRyYUxlbmd0aDtcclxuICAgIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbFBhZGRpbmc7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIExvb2sgdGhyb3VnaCB0aGUgcGF0Y2hlcyBhbmQgYnJlYWsgdXAgYW55IHdoaWNoIGFyZSBsb25nZXIgdGhhbiB0aGUgbWF4aW11bVxyXG4gKiBsaW1pdCBvZiB0aGUgbWF0Y2ggYWxnb3JpdGhtLlxyXG4gKiBJbnRlbmRlZCB0byBiZSBjYWxsZWQgb25seSBmcm9tIHdpdGhpbiBwYXRjaF9hcHBseS5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX3NwbGl0TWF4ID0gZnVuY3Rpb24ocGF0Y2hlcykge1xyXG4gIHZhciBwYXRjaF9zaXplID0gdGhpcy5NYXRjaF9NYXhCaXRzO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xyXG4gICAgaWYgKHBhdGNoZXNbeF0ubGVuZ3RoMSA8PSBwYXRjaF9zaXplKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIGJpZ3BhdGNoID0gcGF0Y2hlc1t4XTtcclxuICAgIC8vIFJlbW92ZSB0aGUgYmlnIG9sZCBwYXRjaC5cclxuICAgIHBhdGNoZXMuc3BsaWNlKHgtLSwgMSk7XHJcbiAgICB2YXIgc3RhcnQxID0gYmlncGF0Y2guc3RhcnQxO1xyXG4gICAgdmFyIHN0YXJ0MiA9IGJpZ3BhdGNoLnN0YXJ0MjtcclxuICAgIHZhciBwcmVjb250ZXh0ID0gJyc7XHJcbiAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgIC8vIENyZWF0ZSBvbmUgb2Ygc2V2ZXJhbCBzbWFsbGVyIHBhdGNoZXMuXHJcbiAgICAgIHZhciBwYXRjaCA9IG5ldyBkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaigpO1xyXG4gICAgICB2YXIgZW1wdHkgPSB0cnVlO1xyXG4gICAgICBwYXRjaC5zdGFydDEgPSBzdGFydDEgLSBwcmVjb250ZXh0Lmxlbmd0aDtcclxuICAgICAgcGF0Y2guc3RhcnQyID0gc3RhcnQyIC0gcHJlY29udGV4dC5sZW5ndGg7XHJcbiAgICAgIGlmIChwcmVjb250ZXh0ICE9PSAnJykge1xyXG4gICAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgyID0gcHJlY29udGV4dC5sZW5ndGg7XHJcbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgcHJlY29udGV4dF0pO1xyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlIChiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDAgJiZcclxuICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgPCBwYXRjaF9zaXplIC0gdGhpcy5QYXRjaF9NYXJnaW4pIHtcclxuICAgICAgICB2YXIgZGlmZl90eXBlID0gYmlncGF0Y2guZGlmZnNbMF1bMF07XHJcbiAgICAgICAgdmFyIGRpZmZfdGV4dCA9IGJpZ3BhdGNoLmRpZmZzWzBdWzFdO1xyXG4gICAgICAgIGlmIChkaWZmX3R5cGUgPT09IERJRkZfSU5TRVJUKSB7XHJcbiAgICAgICAgICAvLyBJbnNlcnRpb25zIGFyZSBoYXJtbGVzcy5cclxuICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgIHN0YXJ0MiArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChiaWdwYXRjaC5kaWZmcy5zaGlmdCgpKTtcclxuICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmX3R5cGUgPT09IERJRkZfREVMRVRFICYmIHBhdGNoLmRpZmZzLmxlbmd0aCA9PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICBwYXRjaC5kaWZmc1swXVswXSA9PSBESUZGX0VRVUFMICYmXHJcbiAgICAgICAgICAgICAgICAgICBkaWZmX3RleHQubGVuZ3RoID4gMiAqIHBhdGNoX3NpemUpIHtcclxuICAgICAgICAgIC8vIFRoaXMgaXMgYSBsYXJnZSBkZWxldGlvbi4gIExldCBpdCBwYXNzIGluIG9uZSBjaHVuay5cclxuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgIHN0YXJ0MSArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgICAgICAgZW1wdHkgPSBmYWxzZTtcclxuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW2RpZmZfdHlwZSwgZGlmZl90ZXh0XSk7XHJcbiAgICAgICAgICBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBEZWxldGlvbiBvciBlcXVhbGl0eS4gIE9ubHkgdGFrZSBhcyBtdWNoIGFzIHdlIGNhbiBzdG9tYWNoLlxyXG4gICAgICAgICAgZGlmZl90ZXh0ID0gZGlmZl90ZXh0LnN1YnN0cmluZygwLFxyXG4gICAgICAgICAgICAgIHBhdGNoX3NpemUgLSBwYXRjaC5sZW5ndGgxIC0gdGhpcy5QYXRjaF9NYXJnaW4pO1xyXG4gICAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgICAgICAgc3RhcnQxICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICBpZiAoZGlmZl90eXBlID09PSBESUZGX0VRVUFMKSB7XHJcbiAgICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgc3RhcnQyICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbZGlmZl90eXBlLCBkaWZmX3RleHRdKTtcclxuICAgICAgICAgIGlmIChkaWZmX3RleHQgPT0gYmlncGF0Y2guZGlmZnNbMF1bMV0pIHtcclxuICAgICAgICAgICAgYmlncGF0Y2guZGlmZnMuc2hpZnQoKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzWzBdWzFdID1cclxuICAgICAgICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzWzBdWzFdLnN1YnN0cmluZyhkaWZmX3RleHQubGVuZ3RoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gQ29tcHV0ZSB0aGUgaGVhZCBjb250ZXh0IGZvciB0aGUgbmV4dCBwYXRjaC5cclxuICAgICAgcHJlY29udGV4dCA9IHRoaXMuZGlmZl90ZXh0MihwYXRjaC5kaWZmcyk7XHJcbiAgICAgIHByZWNvbnRleHQgPVxyXG4gICAgICAgICAgcHJlY29udGV4dC5zdWJzdHJpbmcocHJlY29udGV4dC5sZW5ndGggLSB0aGlzLlBhdGNoX01hcmdpbik7XHJcbiAgICAgIC8vIEFwcGVuZCB0aGUgZW5kIGNvbnRleHQgZm9yIHRoaXMgcGF0Y2guXHJcbiAgICAgIHZhciBwb3N0Y29udGV4dCA9IHRoaXMuZGlmZl90ZXh0MShiaWdwYXRjaC5kaWZmcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoMCwgdGhpcy5QYXRjaF9NYXJnaW4pO1xyXG4gICAgICBpZiAocG9zdGNvbnRleHQgIT09ICcnKSB7XHJcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBwb3N0Y29udGV4dC5sZW5ndGg7XHJcbiAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBwb3N0Y29udGV4dC5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHBhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMCAmJlxyXG4gICAgICAgICAgICBwYXRjaC5kaWZmc1twYXRjaC5kaWZmcy5sZW5ndGggLSAxXVswXSA9PT0gRElGRl9FUVVBTCkge1xyXG4gICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gcG9zdGNvbnRleHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIHBvc3Rjb250ZXh0XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghZW1wdHkpIHtcclxuICAgICAgICBwYXRjaGVzLnNwbGljZSgrK3gsIDAsIHBhdGNoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogVGFrZSBhIGxpc3Qgb2YgcGF0Y2hlcyBhbmQgcmV0dXJuIGEgdGV4dHVhbCByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cclxuICogQHJldHVybiB7c3RyaW5nfSBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF90b1RleHQgPSBmdW5jdGlvbihwYXRjaGVzKSB7XHJcbiAgdmFyIHRleHQgPSBbXTtcclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcclxuICAgIHRleHRbeF0gPSBwYXRjaGVzW3hdO1xyXG4gIH1cclxuICByZXR1cm4gdGV4dC5qb2luKCcnKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUGFyc2UgYSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMgYW5kIHJldHVybiBhIGxpc3Qgb2YgUGF0Y2ggb2JqZWN0cy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRsaW5lIFRleHQgcmVwcmVzZW50YXRpb24gb2YgcGF0Y2hlcy5cclxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmo+fSBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxyXG4gKiBAdGhyb3dzIHshRXJyb3J9IElmIGludmFsaWQgaW5wdXQuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9mcm9tVGV4dCA9IGZ1bmN0aW9uKHRleHRsaW5lKSB7XHJcbiAgdmFyIHBhdGNoZXMgPSBbXTtcclxuICBpZiAoIXRleHRsaW5lKSB7XHJcbiAgICByZXR1cm4gcGF0Y2hlcztcclxuICB9XHJcbiAgdmFyIHRleHQgPSB0ZXh0bGluZS5zcGxpdCgnXFxuJyk7XHJcbiAgdmFyIHRleHRQb2ludGVyID0gMDtcclxuICB2YXIgcGF0Y2hIZWFkZXIgPSAvXkBAIC0oXFxkKyksPyhcXGQqKSBcXCsoXFxkKyksPyhcXGQqKSBAQCQvO1xyXG4gIHdoaWxlICh0ZXh0UG9pbnRlciA8IHRleHQubGVuZ3RoKSB7XHJcbiAgICB2YXIgbSA9IHRleHRbdGV4dFBvaW50ZXJdLm1hdGNoKHBhdGNoSGVhZGVyKTtcclxuICAgIGlmICghbSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0Y2ggc3RyaW5nOiAnICsgdGV4dFt0ZXh0UG9pbnRlcl0pO1xyXG4gICAgfVxyXG4gICAgdmFyIHBhdGNoID0gbmV3IGRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqKCk7XHJcbiAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xyXG4gICAgcGF0Y2guc3RhcnQxID0gcGFyc2VJbnQobVsxXSwgMTApO1xyXG4gICAgaWYgKG1bMl0gPT09ICcnKSB7XHJcbiAgICAgIHBhdGNoLnN0YXJ0MS0tO1xyXG4gICAgICBwYXRjaC5sZW5ndGgxID0gMTtcclxuICAgIH0gZWxzZSBpZiAobVsyXSA9PSAnMCcpIHtcclxuICAgICAgcGF0Y2gubGVuZ3RoMSA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwYXRjaC5zdGFydDEtLTtcclxuICAgICAgcGF0Y2gubGVuZ3RoMSA9IHBhcnNlSW50KG1bMl0sIDEwKTtcclxuICAgIH1cclxuXHJcbiAgICBwYXRjaC5zdGFydDIgPSBwYXJzZUludChtWzNdLCAxMCk7XHJcbiAgICBpZiAobVs0XSA9PT0gJycpIHtcclxuICAgICAgcGF0Y2guc3RhcnQyLS07XHJcbiAgICAgIHBhdGNoLmxlbmd0aDIgPSAxO1xyXG4gICAgfSBlbHNlIGlmIChtWzRdID09ICcwJykge1xyXG4gICAgICBwYXRjaC5sZW5ndGgyID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhdGNoLnN0YXJ0Mi0tO1xyXG4gICAgICBwYXRjaC5sZW5ndGgyID0gcGFyc2VJbnQobVs0XSwgMTApO1xyXG4gICAgfVxyXG4gICAgdGV4dFBvaW50ZXIrKztcclxuXHJcbiAgICB3aGlsZSAodGV4dFBvaW50ZXIgPCB0ZXh0Lmxlbmd0aCkge1xyXG4gICAgICB2YXIgc2lnbiA9IHRleHRbdGV4dFBvaW50ZXJdLmNoYXJBdCgwKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB2YXIgbGluZSA9IGRlY29kZVVSSSh0ZXh0W3RleHRQb2ludGVyXS5zdWJzdHJpbmcoMSkpO1xyXG4gICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgIC8vIE1hbGZvcm1lZCBVUkkgc2VxdWVuY2UuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGVzY2FwZSBpbiBwYXRjaF9mcm9tVGV4dDogJyArIGxpbmUpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzaWduID09ICctJykge1xyXG4gICAgICAgIC8vIERlbGV0aW9uLlxyXG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfREVMRVRFLCBsaW5lXSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PSAnKycpIHtcclxuICAgICAgICAvLyBJbnNlcnRpb24uXHJcbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9JTlNFUlQsIGxpbmVdKTtcclxuICAgICAgfSBlbHNlIGlmIChzaWduID09ICcgJykge1xyXG4gICAgICAgIC8vIE1pbm9yIGVxdWFsaXR5LlxyXG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIGxpbmVdKTtcclxuICAgICAgfSBlbHNlIGlmIChzaWduID09ICdAJykge1xyXG4gICAgICAgIC8vIFN0YXJ0IG9mIG5leHQgcGF0Y2guXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PT0gJycpIHtcclxuICAgICAgICAvLyBCbGFuayBsaW5lPyAgV2hhdGV2ZXIuXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gV1RGP1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXRjaCBtb2RlIFwiJyArIHNpZ24gKyAnXCIgaW46ICcgKyBsaW5lKTtcclxuICAgICAgfVxyXG4gICAgICB0ZXh0UG9pbnRlcisrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcGF0Y2hlcztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIG9uZSBwYXRjaCBvcGVyYXRpb24uXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmogPSBmdW5jdGlvbigpIHtcclxuICAvKiogQHR5cGUgeyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59ICovXHJcbiAgdGhpcy5kaWZmcyA9IFtdO1xyXG4gIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cclxuICB0aGlzLnN0YXJ0MSA9IG51bGw7XHJcbiAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xyXG4gIHRoaXMuc3RhcnQyID0gbnVsbDtcclxuICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICB0aGlzLmxlbmd0aDEgPSAwO1xyXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gIHRoaXMubGVuZ3RoMiA9IDA7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEVtbXVsYXRlIEdOVSBkaWZmJ3MgZm9ybWF0LlxyXG4gKiBIZWFkZXI6IEBAIC0zODIsOCArNDgxLDkgQEBcclxuICogSW5kaWNpZXMgYXJlIHByaW50ZWQgYXMgMS1iYXNlZCwgbm90IDAtYmFzZWQuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEdOVSBkaWZmIHN0cmluZy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBjb29yZHMxLCBjb29yZHMyO1xyXG4gIGlmICh0aGlzLmxlbmd0aDEgPT09IDApIHtcclxuICAgIGNvb3JkczEgPSB0aGlzLnN0YXJ0MSArICcsMCc7XHJcbiAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aDEgPT0gMSkge1xyXG4gICAgY29vcmRzMSA9IHRoaXMuc3RhcnQxICsgMTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29vcmRzMSA9ICh0aGlzLnN0YXJ0MSArIDEpICsgJywnICsgdGhpcy5sZW5ndGgxO1xyXG4gIH1cclxuICBpZiAodGhpcy5sZW5ndGgyID09PSAwKSB7XHJcbiAgICBjb29yZHMyID0gdGhpcy5zdGFydDIgKyAnLDAnO1xyXG4gIH0gZWxzZSBpZiAodGhpcy5sZW5ndGgyID09IDEpIHtcclxuICAgIGNvb3JkczIgPSB0aGlzLnN0YXJ0MiArIDE7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvb3JkczIgPSAodGhpcy5zdGFydDIgKyAxKSArICcsJyArIHRoaXMubGVuZ3RoMjtcclxuICB9XHJcbiAgdmFyIHRleHQgPSBbJ0BAIC0nICsgY29vcmRzMSArICcgKycgKyBjb29yZHMyICsgJyBAQFxcbiddO1xyXG4gIHZhciBvcDtcclxuICAvLyBFc2NhcGUgdGhlIGJvZHkgb2YgdGhlIHBhdGNoIHdpdGggJXh4IG5vdGF0aW9uLlxyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy5kaWZmcy5sZW5ndGg7IHgrKykge1xyXG4gICAgc3dpdGNoICh0aGlzLmRpZmZzW3hdWzBdKSB7XHJcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XHJcbiAgICAgICAgb3AgPSAnKyc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XHJcbiAgICAgICAgb3AgPSAnLSc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcclxuICAgICAgICBvcCA9ICcgJztcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHRleHRbeCArIDFdID0gb3AgKyBlbmNvZGVVUkkodGhpcy5kaWZmc1t4XVsxXSkgKyAnXFxuJztcclxuICB9XHJcbiAgcmV0dXJuIHRleHQuam9pbignJykucmVwbGFjZSgvJTIwL2csICcgJyk7XHJcbn07XHJcblxyXG5cclxuLy8gVGhlIGZvbGxvd2luZyBleHBvcnQgY29kZSB3YXMgYWRkZWQgYnkgQEZvcmJlc0xpbmRlc2F5XHJcbm1vZHVsZS5leHBvcnRzID0gZGlmZl9tYXRjaF9wYXRjaDtcclxubW9kdWxlLmV4cG9ydHNbJ2RpZmZfbWF0Y2hfcGF0Y2gnXSA9IGRpZmZfbWF0Y2hfcGF0Y2g7XHJcbm1vZHVsZS5leHBvcnRzWydESUZGX0RFTEVURSddID0gRElGRl9ERUxFVEU7XHJcbm1vZHVsZS5leHBvcnRzWydESUZGX0lOU0VSVCddID0gRElGRl9JTlNFUlQ7XHJcbm1vZHVsZS5leHBvcnRzWydESUZGX0VRVUFMJ10gPSBESUZGX0VRVUFMO1xyXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2RpZmYtbWF0Y2gtcGF0Y2gvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZGlmZi1tYXRjaC1wYXRjaFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCdiaWdpJylcblxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9wb2ludCcpXG5cbmZ1bmN0aW9uIEN1cnZlIChwLCBhLCBiLCBHeCwgR3ksIG4sIGgpIHtcbiAgdGhpcy5wID0gcFxuICB0aGlzLmEgPSBhXG4gIHRoaXMuYiA9IGJcbiAgdGhpcy5HID0gUG9pbnQuZnJvbUFmZmluZSh0aGlzLCBHeCwgR3kpXG4gIHRoaXMubiA9IG5cbiAgdGhpcy5oID0gaFxuXG4gIHRoaXMuaW5maW5pdHkgPSBuZXcgUG9pbnQodGhpcywgbnVsbCwgbnVsbCwgQmlnSW50ZWdlci5aRVJPKVxuXG4gIC8vIHJlc3VsdCBjYWNoaW5nXG4gIHRoaXMucE92ZXJGb3VyID0gcC5hZGQoQmlnSW50ZWdlci5PTkUpLnNoaWZ0UmlnaHQoMilcbn1cblxuQ3VydmUucHJvdG90eXBlLnBvaW50RnJvbVggPSBmdW5jdGlvbiAoaXNPZGQsIHgpIHtcbiAgdmFyIGFscGhhID0geC5wb3coMykuYWRkKHRoaXMuYS5tdWx0aXBseSh4KSkuYWRkKHRoaXMuYikubW9kKHRoaXMucClcbiAgdmFyIGJldGEgPSBhbHBoYS5tb2RQb3codGhpcy5wT3ZlckZvdXIsIHRoaXMucCkgLy8gWFhYOiBub3QgY29tcGF0aWJsZSB3aXRoIGFsbCBjdXJ2ZXNcblxuICB2YXIgeSA9IGJldGFcbiAgaWYgKGJldGEuaXNFdmVuKCkgXiAhaXNPZGQpIHtcbiAgICB5ID0gdGhpcy5wLnN1YnRyYWN0KHkpIC8vIC15ICUgcFxuICB9XG5cbiAgcmV0dXJuIFBvaW50LmZyb21BZmZpbmUodGhpcywgeCwgeSlcbn1cblxuQ3VydmUucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiAoUSkge1xuICBpZiAoUSA9PT0gdGhpcy5pbmZpbml0eSkgcmV0dXJuIHRydWVcblxuICByZXR1cm4gUS56LnNpZ251bSgpID09PSAwICYmIFEueS5zaWdudW0oKSAhPT0gMFxufVxuXG5DdXJ2ZS5wcm90b3R5cGUuaXNPbkN1cnZlID0gZnVuY3Rpb24gKFEpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eShRKSkgcmV0dXJuIHRydWVcblxuICB2YXIgeCA9IFEuYWZmaW5lWFxuICB2YXIgeSA9IFEuYWZmaW5lWVxuICB2YXIgYSA9IHRoaXMuYVxuICB2YXIgYiA9IHRoaXMuYlxuICB2YXIgcCA9IHRoaXMucFxuXG4gIC8vIENoZWNrIHRoYXQgeFEgYW5kIHlRIGFyZSBpbnRlZ2VycyBpbiB0aGUgaW50ZXJ2YWwgWzAsIHAgLSAxXVxuICBpZiAoeC5zaWdudW0oKSA8IDAgfHwgeC5jb21wYXJlVG8ocCkgPj0gMCkgcmV0dXJuIGZhbHNlXG4gIGlmICh5LnNpZ251bSgpIDwgMCB8fCB5LmNvbXBhcmVUbyhwKSA+PSAwKSByZXR1cm4gZmFsc2VcblxuICAvLyBhbmQgY2hlY2sgdGhhdCB5XjIgPSB4XjMgKyBheCArIGIgKG1vZCBwKVxuICB2YXIgbGhzID0geS5zcXVhcmUoKS5tb2QocClcbiAgdmFyIHJocyA9IHgucG93KDMpLmFkZChhLm11bHRpcGx5KHgpKS5hZGQoYikubW9kKHApXG4gIHJldHVybiBsaHMuZXF1YWxzKHJocylcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhbiBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqXG4gKiBTZWUgU0VDIDEsIHNlY3Rpb24gMy4yLjIuMTogRWxsaXB0aWMgQ3VydmUgUHVibGljIEtleSBWYWxpZGF0aW9uIFByaW1pdGl2ZVxuICovXG5DdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoUSkge1xuICAvLyBDaGVjayBRICE9IE9cbiAgYXNzZXJ0KCF0aGlzLmlzSW5maW5pdHkoUSksICdQb2ludCBpcyBhdCBpbmZpbml0eScpXG4gIGFzc2VydCh0aGlzLmlzT25DdXJ2ZShRKSwgJ1BvaW50IGlzIG5vdCBvbiB0aGUgY3VydmUnKVxuXG4gIC8vIENoZWNrIG5RID0gTyAod2hlcmUgUSBpcyBhIHNjYWxhciBtdWx0aXBsZSBvZiBHKVxuICB2YXIgblEgPSBRLm11bHRpcGx5KHRoaXMubilcbiAgYXNzZXJ0KHRoaXMuaXNJbmZpbml0eShuUSksICdQb2ludCBpcyBub3QgYSBzY2FsYXIgbXVsdGlwbGUgb2YgRycpXG5cbiAgcmV0dXJuIHRydWVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDdXJ2ZVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lY3VydmUvbGliL2N1cnZlLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWJcIikiLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwic2VjcDEyOHIxXCI6IHtcbiAgICBcInBcIjogXCJmZmZmZmZmZGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiLFxuICAgIFwiYVwiOiBcImZmZmZmZmZkZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjXCIsXG4gICAgXCJiXCI6IFwiZTg3NTc5YzExMDc5ZjQzZGQ4MjQ5OTNjMmNlZTVlZDNcIixcbiAgICBcIm5cIjogXCJmZmZmZmZmZTAwMDAwMDAwNzVhMzBkMWI5MDM4YTExNVwiLFxuICAgIFwiaFwiOiBcIjAxXCIsXG4gICAgXCJHeFwiOiBcIjE2MWZmNzUyOGI4OTliMmQwYzI4NjA3Y2E1MmM1Yjg2XCIsXG4gICAgXCJHeVwiOiBcImNmNWFjODM5NWJhZmViMTNjMDJkYTI5MmRkZWQ3YTgzXCJcbiAgfSxcbiAgXCJzZWNwMTYwazFcIjoge1xuICAgIFwicFwiOiBcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmFjNzNcIixcbiAgICBcImFcIjogXCIwMFwiLFxuICAgIFwiYlwiOiBcIjA3XCIsXG4gICAgXCJuXCI6IFwiMDEwMDAwMDAwMDAwMDAwMDAwMDAwMWI4ZmExNmRmYWI5YWNhMTZiNmIzXCIsXG4gICAgXCJoXCI6IFwiMDFcIixcbiAgICBcIkd4XCI6IFwiM2I0YzM4MmNlMzdhYTE5MmE0MDE5ZTc2MzAzNmY0ZjVkZDRkN2ViYlwiLFxuICAgIFwiR3lcIjogXCI5MzhjZjkzNTMxOGZkY2VkNmJjMjgyODY1MzE3MzNjM2YwM2M0ZmVlXCJcbiAgfSxcbiAgXCJzZWNwMTYwcjFcIjoge1xuICAgIFwicFwiOiBcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmN2ZmZmZmZmZcIixcbiAgICBcImFcIjogXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjdmZmZmZmZjXCIsXG4gICAgXCJiXCI6IFwiMWM5N2JlZmM1NGJkN2E4YjY1YWNmODlmODFkNGQ0YWRjNTY1ZmE0NVwiLFxuICAgIFwiblwiOiBcIjAxMDAwMDAwMDAwMDAwMDAwMDAwMDFmNGM4ZjkyN2FlZDNjYTc1MjI1N1wiLFxuICAgIFwiaFwiOiBcIjAxXCIsXG4gICAgXCJHeFwiOiBcIjRhOTZiNTY4OGVmNTczMjg0NjY0Njk4OTY4YzM4YmI5MTNjYmZjODJcIixcbiAgICBcIkd5XCI6IFwiMjNhNjI4NTUzMTY4OTQ3ZDU5ZGNjOTEyMDQyMzUxMzc3YWM1ZmIzMlwiXG4gIH0sXG4gIFwic2VjcDE5MmsxXCI6IHtcbiAgICBcInBcIjogXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmVlMzdcIixcbiAgICBcImFcIjogXCIwMFwiLFxuICAgIFwiYlwiOiBcIjAzXCIsXG4gICAgXCJuXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlMjZmMmZjMTcwZjY5NDY2YTc0ZGVmZDhkXCIsXG4gICAgXCJoXCI6IFwiMDFcIixcbiAgICBcIkd4XCI6IFwiZGI0ZmYxMGVjMDU3ZTlhZTI2YjA3ZDAyODBiN2Y0MzQxZGE1ZDFiMWVhZTA2YzdkXCIsXG4gICAgXCJHeVwiOiBcIjliMmYyZjZkOWM1NjI4YTc4NDQxNjNkMDE1YmU4NjM0NDA4MmFhODhkOTVlMmY5ZFwiXG4gIH0sXG4gIFwic2VjcDE5MnIxXCI6IHtcbiAgICBcInBcIjogXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmZmZmZmZmZmZmZmZcIixcbiAgICBcImFcIjogXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmZmZmZmZmZmZmZmNcIixcbiAgICBcImJcIjogXCI2NDIxMDUxOWU1OWM4MGU3MGZhN2U5YWI3MjI0MzA0OWZlYjhkZWVjYzE0NmI5YjFcIixcbiAgICBcIm5cIjogXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY5OWRlZjgzNjE0NmJjOWIxYjRkMjI4MzFcIixcbiAgICBcImhcIjogXCIwMVwiLFxuICAgIFwiR3hcIjogXCIxODhkYTgwZWIwMzA5MGY2N2NiZjIwZWI0M2ExODgwMGY0ZmYwYWZkODJmZjEwMTJcIixcbiAgICBcIkd5XCI6IFwiMDcxOTJiOTVmZmM4ZGE3ODYzMTAxMWVkNmIyNGNkZDU3M2Y5NzdhMTFlNzk0ODExXCJcbiAgfSxcbiAgXCJzZWNwMjU2azFcIjoge1xuICAgIFwicFwiOiBcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmZcIixcbiAgICBcImFcIjogXCIwMFwiLFxuICAgIFwiYlwiOiBcIjA3XCIsXG4gICAgXCJuXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiLFxuICAgIFwiaFwiOiBcIjAxXCIsXG4gICAgXCJHeFwiOiBcIjc5YmU2NjdlZjlkY2JiYWM1NWEwNjI5NWNlODcwYjA3MDI5YmZjZGIyZGNlMjhkOTU5ZjI4MTViMTZmODE3OThcIixcbiAgICBcIkd5XCI6IFwiNDgzYWRhNzcyNmEzYzQ2NTVkYTRmYmZjMGUxMTA4YThmZDE3YjQ0OGE2ODU1NDE5OWM0N2QwOGZmYjEwZDRiOFwiXG4gIH0sXG4gIFwic2VjcDI1NnIxXCI6IHtcbiAgICBcInBcIjogXCJmZmZmZmZmZjAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIsXG4gICAgXCJhXCI6IFwiZmZmZmZmZmYwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY1wiLFxuICAgIFwiYlwiOiBcIjVhYzYzNWQ4YWEzYTkzZTdiM2ViYmQ1NTc2OTg4NmJjNjUxZDA2YjBjYzUzYjBmNjNiY2UzYzNlMjdkMjYwNGJcIixcbiAgICBcIm5cIjogXCJmZmZmZmZmZjAwMDAwMDAwZmZmZmZmZmZmZmZmZmZmZmJjZTZmYWFkYTcxNzllODRmM2I5Y2FjMmZjNjMyNTUxXCIsXG4gICAgXCJoXCI6IFwiMDFcIixcbiAgICBcIkd4XCI6IFwiNmIxN2QxZjJlMTJjNDI0N2Y4YmNlNmU1NjNhNDQwZjI3NzAzN2Q4MTJkZWIzM2EwZjRhMTM5NDVkODk4YzI5NlwiLFxuICAgIFwiR3lcIjogXCI0ZmUzNDJlMmZlMWE3ZjliOGVlN2ViNGE3YzBmOWUxNjJiY2UzMzU3NmIzMTVlY2VjYmI2NDA2ODM3YmY1MWY1XCJcbiAgfVxufVxuIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9wb2ludCcpXG52YXIgQ3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJylcblxudmFyIGdldEN1cnZlQnlOYW1lID0gcmVxdWlyZSgnLi9uYW1lcycpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDdXJ2ZTogQ3VydmUsXG4gIFBvaW50OiBQb2ludCxcbiAgZ2V0Q3VydmVCeU5hbWU6IGdldEN1cnZlQnlOYW1lXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWIvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZWN1cnZlL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpXG5cbnZhciBjdXJ2ZXMgPSByZXF1aXJlKCcuL2N1cnZlcy5qc29uJylcbnZhciBDdXJ2ZSA9IHJlcXVpcmUoJy4vY3VydmUnKVxuXG5mdW5jdGlvbiBnZXRDdXJ2ZUJ5TmFtZSAobmFtZSkge1xuICB2YXIgY3VydmUgPSBjdXJ2ZXNbbmFtZV1cbiAgaWYgKCFjdXJ2ZSkgcmV0dXJuIG51bGxcblxuICB2YXIgcCA9IG5ldyBCaWdJbnRlZ2VyKGN1cnZlLnAsIDE2KVxuICB2YXIgYSA9IG5ldyBCaWdJbnRlZ2VyKGN1cnZlLmEsIDE2KVxuICB2YXIgYiA9IG5ldyBCaWdJbnRlZ2VyKGN1cnZlLmIsIDE2KVxuICB2YXIgbiA9IG5ldyBCaWdJbnRlZ2VyKGN1cnZlLm4sIDE2KVxuICB2YXIgaCA9IG5ldyBCaWdJbnRlZ2VyKGN1cnZlLmgsIDE2KVxuICB2YXIgR3ggPSBuZXcgQmlnSW50ZWdlcihjdXJ2ZS5HeCwgMTYpXG4gIHZhciBHeSA9IG5ldyBCaWdJbnRlZ2VyKGN1cnZlLkd5LCAxNilcblxuICByZXR1cm4gbmV3IEN1cnZlKHAsIGEsIGIsIEd4LCBHeSwgbiwgaClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRDdXJ2ZUJ5TmFtZVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lY3VydmUvbGliL25hbWVzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpXG5cbnZhciBUSFJFRSA9IEJpZ0ludGVnZXIudmFsdWVPZigzKVxuXG5mdW5jdGlvbiBQb2ludCAoY3VydmUsIHgsIHksIHopIHtcbiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKHosIHVuZGVmaW5lZCwgJ01pc3NpbmcgWiBjb29yZGluYXRlJylcblxuICB0aGlzLmN1cnZlID0gY3VydmVcbiAgdGhpcy54ID0geFxuICB0aGlzLnkgPSB5XG4gIHRoaXMueiA9IHpcbiAgdGhpcy5fekludiA9IG51bGxcblxuICB0aGlzLmNvbXByZXNzZWQgPSB0cnVlXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb2ludC5wcm90b3R5cGUsICd6SW52Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fekludiA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fekludiA9IHRoaXMuei5tb2RJbnZlcnNlKHRoaXMuY3VydmUucClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fekludlxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUG9pbnQucHJvdG90eXBlLCAnYWZmaW5lWCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMueC5tdWx0aXBseSh0aGlzLnpJbnYpLm1vZCh0aGlzLmN1cnZlLnApXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb2ludC5wcm90b3R5cGUsICdhZmZpbmVZJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy55Lm11bHRpcGx5KHRoaXMuekludikubW9kKHRoaXMuY3VydmUucClcbiAgfVxufSlcblxuUG9pbnQuZnJvbUFmZmluZSA9IGZ1bmN0aW9uIChjdXJ2ZSwgeCwgeSkge1xuICByZXR1cm4gbmV3IFBvaW50KGN1cnZlLCB4LCB5LCBCaWdJbnRlZ2VyLk9ORSlcbn1cblxuUG9pbnQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICBpZiAob3RoZXIgPT09IHRoaXMpIHJldHVybiB0cnVlXG4gIGlmICh0aGlzLmN1cnZlLmlzSW5maW5pdHkodGhpcykpIHJldHVybiB0aGlzLmN1cnZlLmlzSW5maW5pdHkob3RoZXIpXG4gIGlmICh0aGlzLmN1cnZlLmlzSW5maW5pdHkob3RoZXIpKSByZXR1cm4gdGhpcy5jdXJ2ZS5pc0luZmluaXR5KHRoaXMpXG5cbiAgLy8gdSA9IFkyICogWjEgLSBZMSAqIFoyXG4gIHZhciB1ID0gb3RoZXIueS5tdWx0aXBseSh0aGlzLnopLnN1YnRyYWN0KHRoaXMueS5tdWx0aXBseShvdGhlci56KSkubW9kKHRoaXMuY3VydmUucClcblxuICBpZiAodS5zaWdudW0oKSAhPT0gMCkgcmV0dXJuIGZhbHNlXG5cbiAgLy8gdiA9IFgyICogWjEgLSBYMSAqIFoyXG4gIHZhciB2ID0gb3RoZXIueC5tdWx0aXBseSh0aGlzLnopLnN1YnRyYWN0KHRoaXMueC5tdWx0aXBseShvdGhlci56KSkubW9kKHRoaXMuY3VydmUucClcblxuICByZXR1cm4gdi5zaWdudW0oKSA9PT0gMFxufVxuXG5Qb2ludC5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgeSA9IHRoaXMuY3VydmUucC5zdWJ0cmFjdCh0aGlzLnkpXG5cbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmN1cnZlLCB0aGlzLngsIHksIHRoaXMueilcbn1cblxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmICh0aGlzLmN1cnZlLmlzSW5maW5pdHkodGhpcykpIHJldHVybiBiXG4gIGlmICh0aGlzLmN1cnZlLmlzSW5maW5pdHkoYikpIHJldHVybiB0aGlzXG5cbiAgdmFyIHgxID0gdGhpcy54XG4gIHZhciB5MSA9IHRoaXMueVxuICB2YXIgeDIgPSBiLnhcbiAgdmFyIHkyID0gYi55XG5cbiAgLy8gdSA9IFkyICogWjEgLSBZMSAqIFoyXG4gIHZhciB1ID0geTIubXVsdGlwbHkodGhpcy56KS5zdWJ0cmFjdCh5MS5tdWx0aXBseShiLnopKS5tb2QodGhpcy5jdXJ2ZS5wKVxuICAvLyB2ID0gWDIgKiBaMSAtIFgxICogWjJcbiAgdmFyIHYgPSB4Mi5tdWx0aXBseSh0aGlzLnopLnN1YnRyYWN0KHgxLm11bHRpcGx5KGIueikpLm1vZCh0aGlzLmN1cnZlLnApXG5cbiAgaWYgKHYuc2lnbnVtKCkgPT09IDApIHtcbiAgICBpZiAodS5zaWdudW0oKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMudHdpY2UoKSAvLyB0aGlzID09IGIsIHNvIGRvdWJsZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmN1cnZlLmluZmluaXR5IC8vIHRoaXMgPSAtYiwgc28gaW5maW5pdHlcbiAgfVxuXG4gIHZhciB2MiA9IHYuc3F1YXJlKClcbiAgdmFyIHYzID0gdjIubXVsdGlwbHkodilcbiAgdmFyIHgxdjIgPSB4MS5tdWx0aXBseSh2MilcbiAgdmFyIHp1MiA9IHUuc3F1YXJlKCkubXVsdGlwbHkodGhpcy56KVxuXG4gIC8vIHgzID0gdiAqICh6MiAqICh6MSAqIHVeMiAtIDIgKiB4MSAqIHZeMikgLSB2XjMpXG4gIHZhciB4MyA9IHp1Mi5zdWJ0cmFjdCh4MXYyLnNoaWZ0TGVmdCgxKSkubXVsdGlwbHkoYi56KS5zdWJ0cmFjdCh2MykubXVsdGlwbHkodikubW9kKHRoaXMuY3VydmUucClcbiAgLy8geTMgPSB6MiAqICgzICogeDEgKiB1ICogdl4yIC0geTEgKiB2XjMgLSB6MSAqIHVeMykgKyB1ICogdl4zXG4gIHZhciB5MyA9IHgxdjIubXVsdGlwbHkoVEhSRUUpLm11bHRpcGx5KHUpLnN1YnRyYWN0KHkxLm11bHRpcGx5KHYzKSkuc3VidHJhY3QoenUyLm11bHRpcGx5KHUpKS5tdWx0aXBseShiLnopLmFkZCh1Lm11bHRpcGx5KHYzKSkubW9kKHRoaXMuY3VydmUucClcbiAgLy8gejMgPSB2XjMgKiB6MSAqIHoyXG4gIHZhciB6MyA9IHYzLm11bHRpcGx5KHRoaXMueikubXVsdGlwbHkoYi56KS5tb2QodGhpcy5jdXJ2ZS5wKVxuXG4gIHJldHVybiBuZXcgUG9pbnQodGhpcy5jdXJ2ZSwgeDMsIHkzLCB6Mylcbn1cblxuUG9pbnQucHJvdG90eXBlLnR3aWNlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jdXJ2ZS5pc0luZmluaXR5KHRoaXMpKSByZXR1cm4gdGhpc1xuICBpZiAodGhpcy55LnNpZ251bSgpID09PSAwKSByZXR1cm4gdGhpcy5jdXJ2ZS5pbmZpbml0eVxuXG4gIHZhciB4MSA9IHRoaXMueFxuICB2YXIgeTEgPSB0aGlzLnlcblxuICB2YXIgeTF6MSA9IHkxLm11bHRpcGx5KHRoaXMueilcbiAgdmFyIHkxc3F6MSA9IHkxejEubXVsdGlwbHkoeTEpLm1vZCh0aGlzLmN1cnZlLnApXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hXG5cbiAgLy8gdyA9IDMgKiB4MV4yICsgYSAqIHoxXjJcbiAgdmFyIHcgPSB4MS5zcXVhcmUoKS5tdWx0aXBseShUSFJFRSlcblxuICBpZiAoYS5zaWdudW0oKSAhPT0gMCkge1xuICAgIHcgPSB3LmFkZCh0aGlzLnouc3F1YXJlKCkubXVsdGlwbHkoYSkpXG4gIH1cblxuICB3ID0gdy5tb2QodGhpcy5jdXJ2ZS5wKVxuICAvLyB4MyA9IDIgKiB5MSAqIHoxICogKHdeMiAtIDggKiB4MSAqIHkxXjIgKiB6MSlcbiAgdmFyIHgzID0gdy5zcXVhcmUoKS5zdWJ0cmFjdCh4MS5zaGlmdExlZnQoMykubXVsdGlwbHkoeTFzcXoxKSkuc2hpZnRMZWZ0KDEpLm11bHRpcGx5KHkxejEpLm1vZCh0aGlzLmN1cnZlLnApXG4gIC8vIHkzID0gNCAqIHkxXjIgKiB6MSAqICgzICogdyAqIHgxIC0gMiAqIHkxXjIgKiB6MSkgLSB3XjNcbiAgdmFyIHkzID0gdy5tdWx0aXBseShUSFJFRSkubXVsdGlwbHkoeDEpLnN1YnRyYWN0KHkxc3F6MS5zaGlmdExlZnQoMSkpLnNoaWZ0TGVmdCgyKS5tdWx0aXBseSh5MXNxejEpLnN1YnRyYWN0KHcucG93KDMpKS5tb2QodGhpcy5jdXJ2ZS5wKVxuICAvLyB6MyA9IDggKiAoeTEgKiB6MSleM1xuICB2YXIgejMgPSB5MXoxLnBvdygzKS5zaGlmdExlZnQoMykubW9kKHRoaXMuY3VydmUucClcblxuICByZXR1cm4gbmV3IFBvaW50KHRoaXMuY3VydmUsIHgzLCB5MywgejMpXG59XG5cbi8vIFNpbXBsZSBOQUYgKE5vbi1BZGphY2VudCBGb3JtKSBtdWx0aXBsaWNhdGlvbiBhbGdvcml0aG1cbi8vIFRPRE86IG1vZHVsYXJpemUgdGhlIG11bHRpcGxpY2F0aW9uIGFsZ29yaXRobVxuUG9pbnQucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKGspIHtcbiAgaWYgKHRoaXMuY3VydmUuaXNJbmZpbml0eSh0aGlzKSkgcmV0dXJuIHRoaXNcbiAgaWYgKGsuc2lnbnVtKCkgPT09IDApIHJldHVybiB0aGlzLmN1cnZlLmluZmluaXR5XG5cbiAgdmFyIGUgPSBrXG4gIHZhciBoID0gZS5tdWx0aXBseShUSFJFRSlcblxuICB2YXIgbmVnID0gdGhpcy5uZWdhdGUoKVxuICB2YXIgUiA9IHRoaXNcblxuICBmb3IgKHZhciBpID0gaC5iaXRMZW5ndGgoKSAtIDI7IGkgPiAwOyAtLWkpIHtcbiAgICB2YXIgaEJpdCA9IGgudGVzdEJpdChpKVxuICAgIHZhciBlQml0ID0gZS50ZXN0Qml0KGkpXG5cbiAgICBSID0gUi50d2ljZSgpXG5cbiAgICBpZiAoaEJpdCAhPT0gZUJpdCkge1xuICAgICAgUiA9IFIuYWRkKGhCaXQgPyB0aGlzIDogbmVnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSXG59XG5cbi8vIENvbXB1dGUgdGhpcypqICsgeCprIChzaW11bHRhbmVvdXMgbXVsdGlwbGljYXRpb24pXG5Qb2ludC5wcm90b3R5cGUubXVsdGlwbHlUd28gPSBmdW5jdGlvbiAoaiwgeCwgaykge1xuICB2YXIgaSA9IE1hdGgubWF4KGouYml0TGVuZ3RoKCksIGsuYml0TGVuZ3RoKCkpIC0gMVxuICB2YXIgUiA9IHRoaXMuY3VydmUuaW5maW5pdHlcbiAgdmFyIGJvdGggPSB0aGlzLmFkZCh4KVxuXG4gIHdoaWxlIChpID49IDApIHtcbiAgICB2YXIgakJpdCA9IGoudGVzdEJpdChpKVxuICAgIHZhciBrQml0ID0gay50ZXN0Qml0KGkpXG5cbiAgICBSID0gUi50d2ljZSgpXG5cbiAgICBpZiAoakJpdCkge1xuICAgICAgaWYgKGtCaXQpIHtcbiAgICAgICAgUiA9IFIuYWRkKGJvdGgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSID0gUi5hZGQodGhpcylcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtCaXQpIHtcbiAgICAgIFIgPSBSLmFkZCh4KVxuICAgIH1cbiAgICAtLWlcbiAgfVxuXG4gIHJldHVybiBSXG59XG5cblBvaW50LnByb3RvdHlwZS5nZXRFbmNvZGVkID0gZnVuY3Rpb24gKGNvbXByZXNzZWQpIHtcbiAgaWYgKGNvbXByZXNzZWQgPT0gbnVsbCkgY29tcHJlc3NlZCA9IHRoaXMuY29tcHJlc3NlZFxuICBpZiAodGhpcy5jdXJ2ZS5pc0luZmluaXR5KHRoaXMpKSByZXR1cm4gbmV3IEJ1ZmZlcignMDAnLCAnaGV4JykgLy8gSW5maW5pdHkgcG9pbnQgZW5jb2RlZCBpcyBzaW1wbHkgJzAwJ1xuXG4gIHZhciB4ID0gdGhpcy5hZmZpbmVYXG4gIHZhciB5ID0gdGhpcy5hZmZpbmVZXG5cbiAgdmFyIGJ1ZmZlclxuXG4gIC8vIERldGVybWluZSBzaXplIG9mIHEgaW4gYnl0ZXNcbiAgdmFyIGJ5dGVMZW5ndGggPSBNYXRoLmZsb29yKCh0aGlzLmN1cnZlLnAuYml0TGVuZ3RoKCkgKyA3KSAvIDgpXG5cbiAgLy8gMHgwMi8weDAzIHwgWFxuICBpZiAoY29tcHJlc3NlZCkge1xuICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoMSArIGJ5dGVMZW5ndGgpXG4gICAgYnVmZmVyLndyaXRlVUludDgoeS5pc0V2ZW4oKSA/IDB4MDIgOiAweDAzLCAwKVxuXG4gIC8vIDB4MDQgfCBYIHwgWVxuICB9IGVsc2Uge1xuICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoMSArIGJ5dGVMZW5ndGggKyBieXRlTGVuZ3RoKVxuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4MDQsIDApXG5cbiAgICB5LnRvQnVmZmVyKGJ5dGVMZW5ndGgpLmNvcHkoYnVmZmVyLCAxICsgYnl0ZUxlbmd0aClcbiAgfVxuXG4gIHgudG9CdWZmZXIoYnl0ZUxlbmd0aCkuY29weShidWZmZXIsIDEpXG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5Qb2ludC5kZWNvZGVGcm9tID0gZnVuY3Rpb24gKGN1cnZlLCBidWZmZXIpIHtcbiAgdmFyIHR5cGUgPSBidWZmZXIucmVhZFVJbnQ4KDApXG4gIHZhciBjb21wcmVzc2VkID0gKHR5cGUgIT09IDQpXG5cbiAgdmFyIGJ5dGVMZW5ndGggPSBNYXRoLmZsb29yKChjdXJ2ZS5wLmJpdExlbmd0aCgpICsgNykgLyA4KVxuICB2YXIgeCA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihidWZmZXIuc2xpY2UoMSwgMSArIGJ5dGVMZW5ndGgpKVxuXG4gIHZhciBRXG4gIGlmIChjb21wcmVzc2VkKSB7XG4gICAgYXNzZXJ0LmVxdWFsKGJ1ZmZlci5sZW5ndGgsIGJ5dGVMZW5ndGggKyAxLCAnSW52YWxpZCBzZXF1ZW5jZSBsZW5ndGgnKVxuICAgIGFzc2VydCh0eXBlID09PSAweDAyIHx8IHR5cGUgPT09IDB4MDMsICdJbnZhbGlkIHNlcXVlbmNlIHRhZycpXG5cbiAgICB2YXIgaXNPZGQgPSAodHlwZSA9PT0gMHgwMylcbiAgICBRID0gY3VydmUucG9pbnRGcm9tWChpc09kZCwgeClcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQuZXF1YWwoYnVmZmVyLmxlbmd0aCwgMSArIGJ5dGVMZW5ndGggKyBieXRlTGVuZ3RoLCAnSW52YWxpZCBzZXF1ZW5jZSBsZW5ndGgnKVxuXG4gICAgdmFyIHkgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoYnVmZmVyLnNsaWNlKDEgKyBieXRlTGVuZ3RoKSlcbiAgICBRID0gUG9pbnQuZnJvbUFmZmluZShjdXJ2ZSwgeCwgeSlcbiAgfVxuXG4gIFEuY29tcHJlc3NlZCA9IGNvbXByZXNzZWRcbiAgcmV0dXJuIFFcbn1cblxuUG9pbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jdXJ2ZS5pc0luZmluaXR5KHRoaXMpKSByZXR1cm4gJyhJTkZJTklUWSknXG5cbiAgcmV0dXJuICcoJyArIHRoaXMuYWZmaW5lWC50b1N0cmluZygpICsgJywnICsgdGhpcy5hZmZpbmVZLnRvU3RyaW5nKCkgKyAnKSdcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludFxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lY3VydmUvbGliL3BvaW50LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXZlbnRzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBUcmFuc2FjdGlvbkJ1aWxkZXIgPSByZXF1aXJlKFwiLi9zcmMvVHJhbnNhY3Rpb25CdWlsZGVyXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBUcmFuc2FjdGlvbkJ1aWxkZXI6IFRyYW5zYWN0aW9uQnVpbGRlcixcblxuICAgIENoYWluVHlwZXM6IHJlcXVpcmUoXCIuL3NyYy9DaGFpblR5cGVzXCIpLFxuICAgIE9iamVjdElkOiByZXF1aXJlKFwiLi9zcmMvT2JqZWN0SWRcIiksXG4gICAgTnVtYmVyVXRpbHM6IHJlcXVpcmUoXCIuL3NyYy9OdW1iZXJVdGlsc1wiKSxcbiAgICBUcmFuc2FjdGlvbkhlbHBlcjogcmVxdWlyZShcIi4vc3JjL1RyYW5zYWN0aW9uSGVscGVyXCIpLFxuICAgIENoYWluVmFsaWRhdGlvbjogcmVxdWlyZShcIi4vc3JjL0NoYWluVmFsaWRhdGlvblwiKSxcbiAgICBMb2dpbjogcmVxdWlyZShcIi4vc3JjL0FjY291bnRMb2dpblwiKVxufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvY2hhaW4vaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9jaGFpblwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoXCIuLi8uLi9lY2Mvc3JjL1ByaXZhdGVLZXlcIik7XG52YXIga2V5ID0gcmVxdWlyZShcIi4uLy4uL2VjYy9zcmMvS2V5VXRpbHNcIik7XG5cbnZhciBLZXlDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBLZXlDYWNoZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEtleUNhY2hlKTtcblxuICAgICAgICB0aGlzLl9rZXlDYWNoZVByaXYgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2tleUNhY2hlUHViID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9teUtleXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEtleUNhY2hlLCBbe1xuICAgICAgICBrZXk6IFwic2V0UHJpdktleVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJpdktleShrZXksIHByaXZLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuX2tleUNhY2hlUHJpdi5zZXQoa2V5LCBwcml2S2V5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImhhc1ByaXZLZXlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhc1ByaXZLZXkoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5Q2FjaGVQcml2LmhhcyhrZXkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0UHJpdktleVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJpdktleShrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlDYWNoZVByaXYuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJzZXRQdWJLZXlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFB1YktleShrZXksIHB1YktleSkge1xuICAgICAgICAgICAgdGhpcy5fa2V5Q2FjaGVQdWIuc2V0KGtleSwgcHViS2V5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImhhc1B1YktleVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUHViS2V5KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleUNhY2hlUHViLmhhcyhrZXkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0UHViS2V5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQdWJLZXkoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5Q2FjaGVQdWIuZ2V0KGtleSk7O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwic2V0TXlLZXlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE15S2V5KGtleSwgcHJpdktleSkge1xuICAgICAgICAgICAgdGhpcy5fbXlLZXlzLnNldChrZXksIHByaXZLZXkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0TXlLZXlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE15S2V5KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX215S2V5cy5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBLZXlDYWNoZTtcbn0oKTtcblxudmFyIEFjY291bnRMb2dpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBY2NvdW50TG9naW4oKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBY2NvdW50TG9naW4pO1xuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5rZXlDYWNoZSA9IG5ldyBLZXlDYWNoZSgpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhBY2NvdW50TG9naW4sIFt7XG4gICAgICAgIGtleTogXCJyZXNldFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0geyBsb2dnZWRJbjogZmFsc2UsIHJvbGVzOiBbXCJhY3RpdmVcIiwgXCJvd25lclwiLCBcInBvc3RpbmdcIiwgXCJtZW1vXCJdIH07XG5cbiAgICAgICAgICAgIHRoaXMuc3VicyA9IHt9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYWRkU3Vic2NyaXB0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTdWJzY3JpcHRpb24oY2IpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic1tjYl0gPSBjYjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNldFJvbGVzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSb2xlcyhyb2xlcykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5yb2xlcyA9IHJvbGVzO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0Um9sZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJvbGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucm9sZXM7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZW5lcmF0ZUtleXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlS2V5cyhhY2NvdW50TmFtZSwgcGFzc3dvcmQsIHJvbGVzLCBwcmVmaXgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICghYWNjb3VudE5hbWUgfHwgIXBhc3N3b3JkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWNjb3VudCBuYW1lIG9yIHBhc3N3b3JkIHJlcXVpcmVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhc3N3b3JkLmxlbmd0aCA8IDEyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFzc3dvcmQgbXVzdCBoYXZlIGF0IGxlYXN0IDEyIGNoYXJhY3RlcnNcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwcml2S2V5cyA9IHt9O1xuICAgICAgICAgICAgdmFyIHB1YktleXMgPSB7fTtcblxuICAgICAgICAgICAgKHJvbGVzIHx8IHRoaXMuc3RhdGUucm9sZXMpLmZvckVhY2goZnVuY3Rpb24gKHJvbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VlZCA9IGFjY291bnROYW1lICsgcm9sZSArIHBhc3N3b3JkO1xuICAgICAgICAgICAgICAgIHZhciBwa2V5ID0gX3RoaXMua2V5Q2FjaGUuaGFzUHJpdktleShyb2xlKSA/IF90aGlzLmtleUNhY2hlLmdldFByaXZLZXkocm9sZSkgOiBQcml2YXRlS2V5LmZyb21TZWVkKGtleS5ub3JtYWxpemVfYnJhaW5LZXkoc2VlZCkpO1xuICAgICAgICAgICAgICAgIF90aGlzLmtleUNhY2hlLnNldFByaXZLZXkocm9sZSwgcGtleSk7XG5cbiAgICAgICAgICAgICAgICBwcml2S2V5c1tyb2xlXSA9IHBrZXk7XG4gICAgICAgICAgICAgICAgcHViS2V5c1tyb2xlXSA9IF90aGlzLmtleUNhY2hlLmdldFB1YktleShyb2xlKSA/IF90aGlzLmtleUNhY2hlLmdldFB1YktleShyb2xlKSA6IHBrZXkudG9QdWJsaWNLZXkoKS50b1N0cmluZyhwcmVmaXgpO1xuXG4gICAgICAgICAgICAgICAgX3RoaXMua2V5Q2FjaGUuc2V0UHViS2V5KHJvbGUsIHB1YktleXNbcm9sZV0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHByaXZLZXlzOiBwcml2S2V5cywgcHViS2V5czogcHViS2V5cyB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZnJvbVByaXZLZXlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Qcml2S2V5KGFjY291bnROYW1lLCBwcml2YXRlS2V5LCByb2xlcywgcHJlZml4KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKCFwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJpdktleXMgPSB7fTtcbiAgICAgICAgICAgIHZhciBwdWJLZXlzID0ge307XG5cbiAgICAgICAgICAgIChyb2xlcyB8fCB0aGlzLnN0YXRlLnJvbGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChyb2xlKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGtleSA9IF90aGlzMi5rZXlDYWNoZS5oYXNQcml2S2V5KHJvbGUpID8gX3RoaXMyLmtleUNhY2hlLmdldFByaXZLZXkocm9sZSkgOiBQcml2YXRlS2V5LmZyb21XaWYocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgX3RoaXMyLmtleUNhY2hlLnNldFByaXZLZXkocm9sZSwgcGtleSk7XG5cbiAgICAgICAgICAgICAgICBwcml2S2V5c1tyb2xlXSA9IHBrZXk7XG4gICAgICAgICAgICAgICAgcHViS2V5c1tyb2xlXSA9IF90aGlzMi5rZXlDYWNoZS5nZXRQdWJLZXkocm9sZSkgPyBfdGhpczIua2V5Q2FjaGUuZ2V0UHViS2V5KHJvbGUpIDogcGtleS50b1B1YmxpY0tleSgpLnRvU3RyaW5nKHByZWZpeCk7XG5cbiAgICAgICAgICAgICAgICBfdGhpczIua2V5Q2FjaGUuc2V0UHViS2V5KHJvbGUsIHB1YktleXNbcm9sZV0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHByaXZLZXlzOiBwcml2S2V5cywgcHViS2V5czogcHViS2V5cyB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0UHViS2V5c1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHViS2V5cygpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5yb2xlcy5tYXAoZnVuY3Rpb24gKHJvbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLmtleUNhY2hlLmdldFB1YktleShyb2xlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiY2hlY2tLZXlzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0tleXMoX3JlZikge1xuICAgICAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBhY2NvdW50TmFtZSA9IF9yZWYuYWNjb3VudE5hbWU7XG4gICAgICAgICAgICB2YXIgcGFzc3dvcmQgPSBfcmVmLnBhc3N3b3JkO1xuICAgICAgICAgICAgdmFyIGF1dGhzID0gX3JlZi5hdXRocztcbiAgICAgICAgICAgIHZhciBfcmVmJHByaXZhdGVLZXkgPSBfcmVmLnByaXZhdGVLZXk7XG4gICAgICAgICAgICB2YXIgcHJpdmF0ZUtleSA9IF9yZWYkcHJpdmF0ZUtleSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IF9yZWYkcHJpdmF0ZUtleTtcblxuICAgICAgICAgICAgaWYgKCFhY2NvdW50TmFtZSB8fCAhcGFzc3dvcmQgJiYgIXByaXZhdGVLZXkgfHwgIWF1dGhzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hlY2tLZXlzOiBNaXNzaW5nIGlucHV0c1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoYXNLZXkgPSBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3Aocm9sZSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChwYXNzd29yZCkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzID0gX3RoaXM0LmdlbmVyYXRlS2V5cyhhY2NvdW50TmFtZSwgcGFzc3dvcmQsIFtyb2xlXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMgPSBfdGhpczQuZnJvbVByaXZLZXkoYWNjb3VudE5hbWUsIHByaXZhdGVLZXksIFtyb2xlXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGtleXMgJiYgT2JqZWN0LmtleXMoa2V5cykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2tleXMgPSBrZXlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByaXZLZXlzID0gX2tleXMucHJpdktleXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHViS2V5cyA9IF9rZXlzLnB1YktleXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhzW3JvbGVdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gPT09IHB1YktleXNbcm9sZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXM0LmtleUNhY2hlLnNldE15S2V5KHJvbGUsIHsgcHJpdjogcHJpdktleXNbcm9sZV0sIHB1YjogcHViS2V5c1tyb2xlXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciByb2xlIGluIGF1dGhzKSB7XG4gICAgICAgICAgICAgICAgX2xvb3Aocm9sZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoaGFzS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gYWNjb3VudE5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RhdGUubG9nZ2VkSW4gPSBoYXNLZXk7XG5cbiAgICAgICAgICAgIHJldHVybiBoYXNLZXk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJzaWduVHJhbnNhY3Rpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ25UcmFuc2FjdGlvbih0cikge1xuICAgICAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBzaWduZXJQdWJrZXlzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgICAgICAgIHZhciByZXF1aXJlZFB1YmtleXMgPSBhcmd1bWVudHNbMl07XG5cblxuICAgICAgICAgICAgdmFyIG15S2V5cyA9IHt9O1xuICAgICAgICAgICAgdmFyIGhhc0tleSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnJvbGVzLmZvckVhY2goZnVuY3Rpb24gKHJvbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXlLZXkgPSBfdGhpczUua2V5Q2FjaGUuZ2V0TXlLZXkocm9sZSk7XG4gICAgICAgICAgICAgICAgaWYgKG15S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWduZXJQdWJrZXlzW215S2V5LnB1Yl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0tleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVyUHVia2V5c1tteUtleS5wdWJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkUHVia2V5cyAmJiByZXF1aXJlZFB1YmtleXMuaW5kZXhPZihteUtleS5wdWIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkX3NpZ25lcihteUtleS5wcml2LCBteUtleS5wdWIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFyZXF1aXJlZFB1YmtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZF9zaWduZXIobXlLZXkucHJpdiwgbXlLZXkucHViKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWhhc0tleSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJZb3UgZG8gbm90IGhhdmUgYW55IHByaXZhdGUga2V5cyB0byBzaWduIHRoaXMgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGRvIG5vdCBoYXZlIGFueSBwcml2YXRlIGtleXMgdG8gc2lnbiB0aGlzIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFjY291bnRMb2dpbjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBY2NvdW50TG9naW47XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L2NoYWluL3NyYy9BY2NvdW50TG9naW4uanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9jaGFpbi9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF90aGlzO1xuXG52YXIgZWNjX2NvbmZpZyA9IHtcbiAgICBhZGRyZXNzX3ByZWZpeDogXCJHTFNcIlxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBfdGhpcyA9IHtcbiAgICBjb3JlX2Fzc2V0OiBcIkdPTE9TXCIsXG4gICAgdmVzdF9hc3NldDogXCJHRVNUU1wiLFxuICAgIGRvbGxhcl9hc3NldDogXCJHQkdcIixcbiAgICBhZGRyZXNzX3ByZWZpeDogXCJHTFNcIixcbiAgICBleHBpcmVfaW5fc2VjczogMTUsXG4gICAgZXhwaXJlX2luX3NlY3NfcHJvcG9zYWw6IDI0ICogNjAgKiA2MCxcbiAgICBuZXR3b3Jrczoge1xuICAgICAgICBTdGVlbToge1xuICAgICAgICAgICAgY29yZV9hc3NldDogXCJHT0xPU1wiLFxuICAgICAgICAgICAgYWRkcmVzc19wcmVmaXg6IFwiR0xTXCIsXG4gICAgICAgICAgICBjaGFpbl9pZDogXCI3ODJhMzAzOWI0NzhjODM5ZTRjYjBjOTQxZmY0ZWFlYjdkZjQwYmRkNjhiZDQ0MWFmZDQ0NGI5ZGE3NjNkZTEyXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqIFNldCBhIGZldyBwcm9wZXJ0aWVzIGZvciBrbm93biBjaGFpbiBJRHMuICovXG4gICAgc2V0Q2hhaW5JZDogZnVuY3Rpb24gc2V0Q2hhaW5JZChjaGFpbl9pZCkge1xuXG4gICAgICAgIHZhciBpLCBsZW4sIG5ldHdvcmssIG5ldHdvcmtfbmFtZSwgcmVmO1xuICAgICAgICByZWYgPSBPYmplY3Qua2V5cyhfdGhpcy5uZXR3b3Jrcyk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgIG5ldHdvcmtfbmFtZSA9IHJlZltpXTtcbiAgICAgICAgICAgIG5ldHdvcmsgPSBfdGhpcy5uZXR3b3Jrc1tuZXR3b3JrX25hbWVdO1xuXG4gICAgICAgICAgICBpZiAobmV0d29yay5jaGFpbl9pZCA9PT0gY2hhaW5faWQpIHtcblxuICAgICAgICAgICAgICAgIF90aGlzLm5ldHdvcmtfbmFtZSA9IG5ldHdvcmtfbmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrLmFkZHJlc3NfcHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZHJlc3NfcHJlZml4ID0gbmV0d29yay5hZGRyZXNzX3ByZWZpeDtcbiAgICAgICAgICAgICAgICAgICAgZWNjX2NvbmZpZy5hZGRyZXNzX3ByZWZpeCA9IG5ldHdvcmsuYWRkcmVzc19wcmVmaXg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJJTkZPICAgIENvbmZpZ3VyZWQgZm9yXCIsIG5ldHdvcmtfbmFtZSwgXCI6XCIsIG5ldHdvcmsuY29yZV9hc3NldCwgXCJcXG5cIik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrX25hbWU6IG5ldHdvcmtfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29yazogbmV0d29ya1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIV90aGlzLm5ldHdvcmtfbmFtZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIGNoYWluIGlkICh0aGlzIG1heSBiZSBhIHRlc3RuZXQpXCIsIGNoYWluX2lkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIF90aGlzLmNvcmVfYXNzZXQgPSBcIkdPTE9TXCI7XG4gICAgICAgIF90aGlzLmFkZHJlc3NfcHJlZml4ID0gXCJHTFNcIjtcbiAgICAgICAgZWNjX2NvbmZpZy5hZGRyZXNzX3ByZWZpeCA9IFwiR0xTXCI7XG4gICAgICAgIF90aGlzLmV4cGlyZV9pbl9zZWNzID0gMTU7XG4gICAgICAgIF90aGlzLmV4cGlyZV9pbl9zZWNzX3Byb3Bvc2FsID0gMjQgKiA2MCAqIDYwO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ2hhaW4gY29uZmlnIHJlc2V0XCIpO1xuICAgIH0sXG5cbiAgICBzZXRQcmVmaXg6IGZ1bmN0aW9uIHNldFByZWZpeCgpIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJHTFNcIjtcblxuICAgICAgICBfdGhpcy5hZGRyZXNzX3ByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgZWNjX2NvbmZpZy5hZGRyZXNzX3ByZWZpeCA9IHByZWZpeDtcbiAgICB9XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9jaGFpbi9zcmMvQ2hhaW5Db25maWcuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9jaGFpbi9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIENoYWluVHlwZXMgPSB7fTtcblxuQ2hhaW5UeXBlcy5vcGVyYXRpb25zID0ge1xuICAgIHZvdGU6IDAsXG4gICAgY29tbWVudDogMSxcbiAgICB0cmFuc2ZlcjogMixcbiAgICB0cmFuc2Zlcl90b192ZXN0aW5nOiAzLFxuICAgIHdpdGhkcmF3X3Zlc3Rpbmc6IDQsXG4gICAgbGltaXRfb3JkZXJfY3JlYXRlOiA1LFxuICAgIGxpbWl0X29yZGVyX2NhbmNlbDogNixcbiAgICBmZWVkX3B1Ymxpc2g6IDcsXG4gICAgY29udmVydDogOCxcbiAgICBhY2NvdW50X2NyZWF0ZTogOSxcbiAgICBhY2NvdW50X3VwZGF0ZTogMTAsXG4gICAgd2l0bmVzc191cGRhdGU6IDExLFxuICAgIGFjY291bnRfd2l0bmVzc192b3RlOiAxMixcbiAgICBhY2NvdW50X3dpdG5lc3NfcHJveHk6IDEzLFxuICAgIHBvdzogMTQsXG4gICAgY3VzdG9tOiAxNSxcbiAgICByZXBvcnRfb3Zlcl9wcm9kdWN0aW9uOiAxNixcbiAgICBkZWxldGVfY29tbWVudDogMTcsXG4gICAgY3VzdG9tX2pzb246IDE4LFxuICAgIGNvbW1lbnRfb3B0aW9uczogMTksXG4gICAgc2V0X3dpdGhkcmF3X3Zlc3Rpbmdfcm91dGU6IDIwLFxuICAgIGZpbGxfY29udmVydF9yZXF1ZXN0OiAyMSxcbiAgICBhdXRob3JfcmV3YXJkOiAyMixcbiAgICBjdXJhdGlvbl9yZXdhcmQ6IDIzLFxuICAgIGxpcXVpZGl0eV9yZXdhcmQ6IDI0LFxuICAgIGludGVyZXN0OiAyNSxcbiAgICBmaWxsX3Zlc3Rpbmdfd2l0aGRyYXc6IDI2LFxuICAgIGZpbGxfb3JkZXI6IDI3LFxuICAgIGNvbW1lbnRfcGF5b3V0OiAyOCxcbiAgICBlc2Nyb3dfdHJhbnNmZXI6IDI5LFxuICAgIGVzY3Jvd19hcHByb3ZlOiAzMCxcbiAgICBlc2Nyb3dfZGlzcHV0ZTogMzEsXG4gICAgZXNjcm93X3JlbGVhc2U6IDMyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYWluVHlwZXM7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L2NoYWluL3NyYy9DaGFpblR5cGVzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvY2hhaW4vc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAgICBBY2NvdW50IG5hbWVzIG1heSBjb250YWluIG9uZSBvciBtb3JlIG5hbWVzIHNlcGFyYXRlZCBieSBhIGRvdC5cbiAgICBFYWNoIG5hbWUgbmVlZHMgdG8gc3RhcnQgd2l0aCBhIGxldHRlciBhbmQgbWF5IGNvbnRhaW5cbiAgICBudW1iZXJzLCBvciB3ZWxsIHBsYWNlZCBkYXNoZXMuXG4gICAgQHNlZSBpc192YWxpZF9uYW1lIGdyYXBoZW5lL2xpYnJhcmllcy9jaGFpbi9wcm90b2NvbC9hY2NvdW50LmNwcFxuKi9cbnZhciBpZF9yZWdleCA9IC9cXGJcXGQrXFwuXFxkK1xcLihcXGQrKVxcYi87XG5cbnZhciBjaGFpblZhbGlkYXRpb24gPSB7XG4gICAgaXNfYWNjb3VudF9uYW1lOiBmdW5jdGlvbiBpc19hY2NvdW50X25hbWUodmFsdWUpIHtcbiAgICAgICAgdmFyIGFsbG93X3Rvb19zaG9ydCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgICAgdmFyIGksIGxhYmVsLCBsZW4sIGxlbmd0aCwgcmVmO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgICAgIGlmICghYWxsb3dfdG9vX3Nob3J0ICYmIGxlbmd0aCA8IDMgfHwgbGVuZ3RoID4gNjMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZiA9IHZhbHVlLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgIGxhYmVsID0gcmVmW2ldO1xuXG4gICAgICAgICAgICBpZiAoISgvXlthLXpdW2EtejAtOS1dKiQvLnRlc3QobGFiZWwpICYmICEvLS0vLnRlc3QobGFiZWwpICYmIC9bYS16MC05XSQvLnRlc3QobGFiZWwpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgaXNfb2JqZWN0X2lkOiBmdW5jdGlvbiBpc19vYmplY3RfaWQob2JqX2lkKSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyAhPSB0eXBlb2Ygb2JqX2lkKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIG1hdGNoID0gaWRfcmVnZXguZXhlYyhvYmpfaWQpO1xuICAgICAgICByZXR1cm4gbWF0Y2ggIT09IG51bGwgJiYgb2JqX2lkLnNwbGl0KFwiLlwiKS5sZW5ndGggPT09IDM7XG4gICAgfSxcblxuICAgIGlzX2VtcHR5OiBmdW5jdGlvbiBpc19lbXB0eSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZS5sZW5ndGggPT09IDA7XG4gICAgfSxcblxuICAgIGlzX2FjY291bnRfbmFtZV9lcnJvcjogZnVuY3Rpb24gaXNfYWNjb3VudF9uYW1lX2Vycm9yKHZhbHVlLCBhbGxvd190b29fc2hvcnQpIHtcbiAgICAgICAgdmFyIGksIGxhYmVsLCBsZW4sIGxlbmd0aCwgcmVmLCBzdWZmaXg7XG4gICAgICAgIGlmIChhbGxvd190b29fc2hvcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYWxsb3dfdG9vX3Nob3J0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3VmZml4ID0gXCJBY2NvdW50IG5hbWUgc2hvdWxkIFwiO1xuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcIm5vdCBiZSBlbXB0eS5cIjtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmICghYWxsb3dfdG9vX3Nob3J0ICYmIGxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcImJlIGxvbmdlci5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID4gNjMpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcImJlIHNob3J0ZXIuXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9cXC4vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICBzdWZmaXggPSBcIkVhY2ggYWNjb3VudCBzZWdtZW50IHNob3VsZCBcIjtcbiAgICAgICAgfVxuICAgICAgICByZWYgPSB2YWx1ZS5zcGxpdCgnLicpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGxhYmVsID0gcmVmW2ldO1xuICAgICAgICAgICAgaWYgKCEvXlt+YS16XS8udGVzdChsYWJlbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJzdGFydCB3aXRoIGEgbGV0dGVyLlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEvXlt+YS16MC05LV0qJC8udGVzdChsYWJlbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJoYXZlIG9ubHkgbGV0dGVycywgZGlnaXRzLCBvciBkYXNoZXMuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoLy0tLy50ZXN0KGxhYmVsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcImhhdmUgb25seSBvbmUgZGFzaCBpbiBhIHJvdy5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghL1thLXowLTldJC8udGVzdChsYWJlbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJlbmQgd2l0aCBhIGxldHRlciBvciBkaWdpdC5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGxhYmVsLmxlbmd0aCA+PSAzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcImJlIGxvbmdlclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBpc19jaGVhcF9uYW1lOiBmdW5jdGlvbiBpc19jaGVhcF9uYW1lKGFjY291bnRfbmFtZSkge1xuICAgICAgICByZXR1cm4gKC9bMC05LV0vLnRlc3QoYWNjb3VudF9uYW1lKSB8fCAhL1thZWlvdXldLy50ZXN0KGFjY291bnRfbmFtZSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgaXNfZW1wdHlfdXNlcl9pbnB1dDogZnVuY3Rpb24gaXNfZW1wdHlfdXNlcl9pbnB1dCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodmFsdWUgKyBcIlwiKS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgcmVxdWlyZWQ6IGZ1bmN0aW9uIHJlcXVpcmVkKHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmFsdWUgcmVxdWlyZWQgZm9yIFwiICsgZmllbGRfbmFtZSArIFwiOiBcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKiBAc2VlIGlzX3ZhbGlkX3N5bWJvbCBncmFwaGVuZS9saWJyYXJpZXMvY2hhaW4vcHJvdG9jb2wvYXNzZXRfb3BzLmNwcCAqL1xuICAgIGlzX3ZhbGlkX3N5bWJvbF9lcnJvcjogZnVuY3Rpb24gaXNfdmFsaWRfc3ltYm9sX2Vycm9yKHZhbHVlKSB7XG4gICAgICAgIHZhciBzdWZmaXggPSBcIkFzc2V0IG5hbWUgc2hvdWxkIFwiO1xuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcIm5vdCBiZSBlbXB0eS5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuc3BsaXQoJy4nKS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJoYXZlIG9ubHkgb25lIGRvdC5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiYmUgbG9uZ2VyLlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxNikge1xuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiYmUgc2hvcnRlci5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIS9eW0EtWl0vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJzdGFydCB3aXRoIGEgbGV0dGVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEvW0EtWl0kLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiZW5kIHdpdGggYSBsZXR0ZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoL15bQS1aMC05XFwuXSQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJjb250YWluIG9ubHkgbGV0dGVycyBudW1iZXJzIGFuZCBwZXJoYXBzIGEgZG90LlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2hhaW5WYWxpZGF0aW9uO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9jaGFpbi9zcmMvQ2hhaW5WYWxpZGF0aW9uLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvY2hhaW4vc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcblxuLyoqXG4gICAgQ29udmVydCAxMi4zNCB3aXRoIGEgcHJlY2lzaW9uIG9mIDMgaW50byAxMjM0MFxuICAgIFxuICAgIEBhcmcge251bWJlcnxzdHJpbmd9IG51bWJlciAtIFVzZSBzdHJpbmdzIGZvciBsYXJnZSBudW1iZXJzLiAgVGhpcyBtYXkgY29udGFpbiBvbmUgZGVjaW1hbCBidXQgbm8gc2lnblxuICAgIEBhcmcge251bWJlcn0gcHJlY2lzaW9uIC0gbnVtYmVyIG9mIGltcGxpZWQgZGVjaW1hbCBwbGFjZXMgKHVzdWFsbHkgY2F1c2VzIHJpZ2h0IHplcm8gcGFkZGluZylcbiAgICBAcmV0dXJuIHtzdHJpbmd9IC1cbiovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB0b0ltcGxpZWREZWNpbWFsOiBmdW5jdGlvbiB0b0ltcGxpZWREZWNpbWFsKG51bWJlciwgcHJlY2lzaW9uKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBudW1iZXIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGFzc2VydChudW1iZXIgPD0gOTAwNzE5OTI1NDc0MDk5MSwgXCJvdmVyZmxvd1wiKTtcbiAgICAgICAgICAgIG51bWJlciA9IFwiXCIgKyBudW1iZXI7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtYmVyLnRvU3RyaW5nKSBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKTtcblxuICAgICAgICBhc3NlcnQodHlwZW9mIG51bWJlciA9PT0gXCJzdHJpbmdcIiwgXCJudW1iZXIgc2hvdWxkIGJlIGFuIGFjdHVhbCBudW1iZXIgb3Igc3RyaW5nOiBcIiArICh0eXBlb2YgbnVtYmVyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YobnVtYmVyKSkpO1xuICAgICAgICBudW1iZXIgPSBudW1iZXIudHJpbSgpO1xuICAgICAgICBhc3NlcnQoL15bMC05XSpcXC4/WzAtOV0qJC8udGVzdChudW1iZXIpLCBcIkludmFsaWQgZGVjaW1hbCBudW1iZXIgXCIgKyBudW1iZXIpO1xuXG4gICAgICAgIHZhciBfbnVtYmVyJHNwbGl0ID0gbnVtYmVyLnNwbGl0KFwiLlwiKTtcblxuICAgICAgICB2YXIgX251bWJlciRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfbnVtYmVyJHNwbGl0LCAyKTtcblxuICAgICAgICB2YXIgX251bWJlciRzcGxpdDIkID0gX251bWJlciRzcGxpdDJbMF07XG4gICAgICAgIHZhciB3aG9sZSA9IF9udW1iZXIkc3BsaXQyJCA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IF9udW1iZXIkc3BsaXQyJDtcbiAgICAgICAgdmFyIF9udW1iZXIkc3BsaXQyJDIgPSBfbnVtYmVyJHNwbGl0MlsxXTtcbiAgICAgICAgdmFyIGRlY2ltYWwgPSBfbnVtYmVyJHNwbGl0MiQyID09PSB1bmRlZmluZWQgPyBcIlwiIDogX251bWJlciRzcGxpdDIkMjtcblxuXG4gICAgICAgIHZhciBwYWRkaW5nID0gcHJlY2lzaW9uIC0gZGVjaW1hbC5sZW5ndGg7XG4gICAgICAgIGFzc2VydChwYWRkaW5nID49IDAsIFwiVG9vIG1hbnkgZGVjaW1hbCBkaWdpdHMgaW4gXCIgKyBudW1iZXIgKyBcIiB0byBjcmVhdGUgYW4gaW1wbGllZCBkZWNpbWFsIG9mIFwiICsgcHJlY2lzaW9uKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZGRpbmc7IGkrKykge1xuICAgICAgICAgICAgZGVjaW1hbCArPSBcIjBcIjtcbiAgICAgICAgfXdoaWxlICh3aG9sZS5jaGFyQXQoMCkgPT09IFwiMFwiKSB7XG4gICAgICAgICAgICB3aG9sZSA9IHdob2xlLnN1YnN0cmluZygxKTtcbiAgICAgICAgfXJldHVybiB3aG9sZSArIGRlY2ltYWw7XG4gICAgfVxufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvY2hhaW4vc3JjL051bWJlclV0aWxzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvY2hhaW4vc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdieXRlYnVmZmVyJyk7XG5cbnZhciBMb25nID0gX3JlcXVpcmUuTG9uZztcblxuXG52YXIgdiA9IHJlcXVpcmUoJy4uLy4uL3NlcmlhbGl6ZXIvc3JjL1NlcmlhbGl6ZXJWYWxpZGF0aW9uJyk7XG5cbnZhciBEQl9NQVhfSU5TVEFOQ0VfSUQgPSBMb25nLmZyb21OdW1iZXIoTWF0aC5wb3coMiwgNDgpIC0gMSk7XG5cbnZhciBPYmplY3RJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYmplY3RJZChzcGFjZSwgdHlwZSwgaW5zdGFuY2UpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9iamVjdElkKTtcblxuICAgICAgICB0aGlzLnNwYWNlID0gc3BhY2U7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgdmFyIGluc3RhbmNlX3N0cmluZyA9IHRoaXMuaW5zdGFuY2UudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIF9PYmplY3RJZCA9IHRoaXMuc3BhY2UgKyAnLicgKyB0aGlzLnR5cGUgKyAnLicgKyBpbnN0YW5jZV9zdHJpbmc7XG4gICAgICAgIGlmICghdi5pc19kaWdpdHMoaW5zdGFuY2Vfc3RyaW5nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3ICgnSW52YWxpZCBvYmplY3QgaWQgJyArIF9PYmplY3RJZCkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhPYmplY3RJZCwgW3tcbiAgICAgICAga2V5OiAndG9Mb25nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvTG9uZygpIHtcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21OdW1iZXIodGhpcy5zcGFjZSkuc2hpZnRMZWZ0KDU2KS5vcihMb25nLmZyb21OdW1iZXIodGhpcy50eXBlKS5zaGlmdExlZnQoNDgpLm9yKHRoaXMuaW5zdGFuY2UpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYXBwZW5kQnl0ZUJ1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLndyaXRlVWludDY0KHRoaXMudG9Mb25nKCkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwYWNlICsgJy4nICsgdGhpcy50eXBlICsgJy4nICsgdGhpcy5pbnN0YW5jZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2Zyb21TdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnNwYWNlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUudHlwZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmluc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB2LnJlcXVpcmVfbWF0Y2goL14oWzAtOV0rKVxcLihbMC05XSspXFwuKFswLTldKykkLywgdi5yZXF1aXJlZCh2YWx1ZSwgXCJPYmplY3RJZFwiKSwgXCJPYmplY3RJZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQocGFyc2VJbnQocGFyYW1zWzFdKSwgcGFyc2VJbnQocGFyYW1zWzJdKSwgTG9uZy5mcm9tU3RyaW5nKHBhcmFtc1szXSkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tTG9uZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tTG9uZyhsb25nKSB7XG4gICAgICAgICAgICB2YXIgc3BhY2UgPSBsb25nLnNoaWZ0UmlnaHQoNTYpLnRvSW50KCk7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGxvbmcuc2hpZnRSaWdodCg0OCkudG9JbnQoKSAmIDB4MDBmZjtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGxvbmcuYW5kKERCX01BWF9JTlNUQU5DRV9JRCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9iamVjdElkKHNwYWNlLCB0eXBlLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21CeXRlQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RJZC5mcm9tTG9uZyhiLnJlYWRVaW50NjQoKSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gT2JqZWN0SWQ7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0SWQ7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L2NoYWluL3NyYy9PYmplY3RJZC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L2NoYWluL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vLi4vZWNjXCIpO1xuXG52YXIgU2lnbmF0dXJlID0gX3JlcXVpcmUuU2lnbmF0dXJlO1xudmFyIFB1YmxpY0tleSA9IF9yZXF1aXJlLlB1YmxpY0tleTtcbnZhciBoYXNoID0gX3JlcXVpcmUuaGFzaDtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuLi8uLi9zZXJpYWxpemVyXCIpO1xuXG52YXIgb3BzID0gX3JlcXVpcmUyLm9wcztcblxudmFyIENoYWluQ29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NoYWluL3NyYy9DaGFpbkNvbmZpZ1wiKTtcblxudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoJ3N0ZWVtLXJwYycpO1xuXG52YXIgQ2xpZW50ID0gX3JlcXVpcmUzLkNsaWVudDtcblxudmFyIEFwaSA9IENsaWVudC5nZXQoKTtcblxudmFyIF9yZXF1aXJlNCA9IHJlcXVpcmUoJ2J5dGVidWZmZXInKTtcblxudmFyIExvbmcgPSBfcmVxdWlyZTQuTG9uZztcblxuXG52YXIgQ2hhaW5UeXBlcyA9IHJlcXVpcmUoJy4vQ2hhaW5UeXBlcycpO1xuXG52YXIgaGVhZF9ibG9ja190aW1lX3N0cmluZztcblxudmFyIFRyYW5zYWN0aW9uQnVpbGRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmFuc2FjdGlvbkJ1aWxkZXIoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2FjdGlvbkJ1aWxkZXIpO1xuXG4gICAgICAgIHRoaXMucmVmX2Jsb2NrX251bSA9IDA7XG4gICAgICAgIHRoaXMucmVmX2Jsb2NrX3ByZWZpeCA9IDA7XG4gICAgICAgIHRoaXMuZXhwaXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnNpZ25hdHVyZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zaWduZXJfcHJpdmF0ZV9rZXlzID0gW107XG5cbiAgICAgICAgLy8gc2VtaS1wcml2YXRlIG1ldGhvZCBiaW5kaW5nc1xuICAgICAgICB0aGlzLl9icm9hZGNhc3QgPSBfYnJvYWRjYXN0LmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgIEBhcmcge3N0cmluZ30gbmFtZSAtIGxpa2UgXCJ0cmFuc2ZlclwiXG4gICAgICAgIEBhcmcge29iamVjdH0gb3BlcmF0aW9uIC0gSlNPTiBtYXRjaGNoaW5nIHRoZSBvcGVyYXRpb24ncyBmb3JtYXRcbiAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoVHJhbnNhY3Rpb25CdWlsZGVyLCBbe1xuICAgICAgICBrZXk6IFwiYWRkX3R5cGVfb3BlcmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRfdHlwZV9vcGVyYXRpb24obmFtZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFkZF9vcGVyYXRpb24odGhpcy5nZXRfdHlwZV9vcGVyYXRpb24obmFtZSwgb3BlcmF0aW9uKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICAgIFRoaXMgZG9lcyBpdCBhbGw6IHNldCBmZWVzLCBmaW5hbGl6ZSwgc2lnbiwgYW5kIGJyb2FkY2FzdCAoaWYgd2FudGVkKS5cbiAgICAgICAgICAgICBAYXJnIHtDb25maWRlbnRpYWxXYWxsZXR9IGN3YWxsZXQgLSBtdXN0IGJlIHVubG9ja2VkLCB1c2VkIHRvIGdhdGhlciBzaWduaW5nIGtleXNcbiAgICAgICAgICAgICBAYXJnIHthcnJheTxzdHJpbmc+fSBbc2lnbmVyX3B1YmtleXMgPSBudWxsXSAtIE9wdGlvbmFsIFtcIkdQSEFiYzlEZWYwLi4uXCIsIC4uLl0uICBUaGVzZSBhcmUgYWRkaXRpb25hbCBzaWduaW5nIGtleXMuICBTb21lIGJhbGFuY2UgY2xhaW1zIHJlcXVpcmUgcHJvcHJpdGFyeSBhZGRyZXNzIGZvcm1hdHMsIHRoZSB3aXRuZXNzIG5vZGUgY2FuJ3QgdGVsbCB1cyB3aGljaCBvbmVzIGFyZSBuZWVkZWQgc28gdGhleSBtdXN0IGJlIHBhc3NlZCBpbi4gIElmIHRoZSB3aXRuZXNzIG5vZGUgY2FuIGZpZ3VyZSBvdXQgYSBzaWduaW5nIGtleSAobW9zdGx5IGFsbCBvdGhlciB0cmFuc2FjdGlvbnMpLCBpdCBzaG91bGQgbm90IGJlIHBhc3NlZCBpbiBoZXJlLlxuICAgICAgICAgICAgIEBhcmcge2Jvb2xlYW59IFticm9hZGNhc3QgPSBmYWxzZV1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInByb2Nlc3NfdHJhbnNhY3Rpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NfdHJhbnNhY3Rpb24oYWNjb3VudExvZ2luKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgc2lnbmVyX3B1YmtleXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICAgICAgICB2YXIgYnJvYWRjYXN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuXG4gICAgICAgICAgICAvLyBsZXQgd2FsbGV0X29iamVjdCA9IGN3YWxsZXQud2FsbGV0LndhbGxldF9vYmplY3RcbiAgICAgICAgICAgIC8vIGlmKEFwaS5jaGFpbl9pZCAhPT0gd2FsbGV0X29iamVjdC5nZXQoXCJjaGFpbl9pZFwiKSlcbiAgICAgICAgICAgIC8vICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJNaXNtYXRjaGVkIGNoYWluX2lkOyBleHBlY3RpbmcgXCIgK1xuICAgICAgICAgICAgLy8gICAgICAgICB3YWxsZXRfb2JqZWN0LmdldChcImNoYWluX2lkXCIpICsgXCIsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgLy8gICAgICAgICBBcGkuY2hhaW5faWQpXG5cbiAgICAgICAgICAgIHZhciBzaWduZXJfcHVia2V5c19hZGRlZCA9IHt9O1xuICAgICAgICAgICAgLy8gaWYoc2lnbmVyX3B1YmtleXMpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgLy8gQmFsYW5jZSBjbGFpbXMgYXJlIGJ5IGFkZHJlc3MsIG9ubHkgdGhlIHByaXZhdGVcbiAgICAgICAgICAgIC8vICAgICAvLyBrZXkgaG9sZGVyIGNhbiBrbm93IGFib3V0IHRoZXNlIGFkZGl0aW9uYWxcbiAgICAgICAgICAgIC8vICAgICAvLyBwb3RlbnRpYWwga2V5cy5cbiAgICAgICAgICAgIC8vICAgICB2YXIgcHVia2V5cyA9IGFjY291bnRMb2dpbi5nZXRQdWJLZXlzKClcbiAgICAgICAgICAgIC8vICAgICBpZiggISBwdWJrZXlzLmxlbmd0aClcbiAgICAgICAgICAgIC8vICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBzaWduaW5nIGtleVwiKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICBmb3IobGV0IHB1YmtleV9zdHJpbmcgb2YgcHVia2V5cykge1xuICAgICAgICAgICAgLy8gICAgICAgICB2YXIgcHJpdmF0ZV9rZXkgPSBjd2FsbGV0LmdldFByaXZhdGVLZXkocHVia2V5X3N0cmluZylcbiAgICAgICAgICAgIC8vICAgICAgICAgdGhpcy5hZGRfc2lnbmVyKHByaXZhdGVfa2V5LCBwdWJrZXlfc3RyaW5nKVxuICAgICAgICAgICAgLy8gICAgICAgICBzaWduZXJfcHVia2V5c19hZGRlZFtwdWJrZXlfc3RyaW5nXSA9IHRydWVcbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIC8vIHJldHVybiB0aGlzLmdldF9wb3RlbnRpYWxfc2lnbmF0dXJlcygpLnRoZW4oIChwdWJrZXlzKT0+IHtcbiAgICAgICAgICAgIHZhciBteV9wdWJrZXlzID0gYWNjb3VudExvZ2luLmdldFB1YktleXMoKTtcblxuICAgICAgICAgICAgLy97Ly9UZXN0aW5nIG9ubHksIGRvbid0IHNlbmQgQWxsIHB1YmxpYyBrZXlzIVxuICAgICAgICAgICAgLy8gICAgdmFyIHB1YmtleXNfYWxsID0gUHJpdmF0ZUtleVN0b3JlLmdldFB1YmtleXMoKSAvLyBBbGwgcHVibGljIGtleXNcbiAgICAgICAgICAgIC8vICAgIHRoaXMuZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXMocHVia2V5c19hbGwpLnRoZW4oIHJlcXVpcmVkX3B1YmtleV9zdHJpbmdzID0+XG4gICAgICAgICAgICAvLyAgICAgICAgY29uc29sZS5sb2coJ2dldF9yZXF1aXJlZF9zaWduYXR1cmVzIGFsbFxcdCcscmVxdWlyZWRfcHVia2V5X3N0cmluZ3Muc29ydCgpLCBwdWJrZXlzX2FsbCkpXG4gICAgICAgICAgICAvLyAgICB0aGlzLmdldF9yZXF1aXJlZF9zaWduYXR1cmVzKG15X3B1YmtleXMpLnRoZW4oIHJlcXVpcmVkX3B1YmtleV9zdHJpbmdzID0+XG4gICAgICAgICAgICAvLyAgICAgICAgY29uc29sZS5sb2coJ2dldF9yZXF1aXJlZF9zaWduYXR1cmVzIG5vcm1hbFxcdCcscmVxdWlyZWRfcHVia2V5X3N0cmluZ3Muc29ydCgpLCBwdWJrZXlzKSlcbiAgICAgICAgICAgIC8vfVxuXG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldF9yZXF1aXJlZF9zaWduYXR1cmVzKG15X3B1YmtleXMpLnRoZW4oZnVuY3Rpb24gKHJlcXVpcmVkX3B1YmtleXMpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInJlcXVpcmVkX3B1YmtleXNcIiwgcmVxdWlyZWRfcHVia2V5cyk7XG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IG15X3B1YmtleXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHVia2V5X3N0cmluZyA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInB1YmtleV9zdHJpbmdcIiwgcHVia2V5X3N0cmluZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWduZXJfcHVia2V5c19hZGRlZFtwdWJrZXlfc3RyaW5nXSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRMb2dpbi5zaWduVHJhbnNhY3Rpb24oX3RoaXMsIHNpZ25lcl9wdWJrZXlzX2FkZGVkLCByZXF1aXJlZF9wdWJrZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhciBwcml2YXRlX2tleSA9IGN3YWxsZXQuZ2V0UHJpdmF0ZUtleShwdWJrZXlfc3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYoICEgcHJpdmF0ZV9rZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXMgd2lsbCBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgLy8gcmV0dXJuZWQga2V5cyBmcm9tIG15X3B1YmtleXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHNpZ25pbmcga2V5IGZvciBcIiArIHB1YmtleV9zdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLmFkZF9zaWduZXIocHJpdmF0ZV9rZXksIHB1YmtleV9zdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInNpZ25lcl9wdWJrZXlzX2FkZGVkXCIsIHNpZ25lcl9wdWJrZXlzX2FkZGVkKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChicm9hZGNhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmJyb2FkY2FzdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBUeXBpY2FsbHkgdGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBqdXN0IHByaW9yIHRvIHNpZ25pbmcuICBPbmNlIGZpbmFsaXplZCB0aGlzIHRyYW5zYWN0aW9uIGNhbiBub3QgYmUgY2hhbmdlZC4gKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImZpbmFsaXplXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5hbGl6ZSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlRyeSB0byBmaW5hbGl6ZVwiLCBcImV4cGlyYXRpb246XCIsIHRoaXMuZXhwaXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzMi50cl9idWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbGl6ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShBcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9keW5hbWljX2dsb2JhbF9wcm9wZXJ0aWVzXCIsIFtdKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRfYmxvY2tfdGltZV9zdHJpbmcgPSByLnRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczIuZXhwaXJhdGlvbiA9PT0gMCkgX3RoaXMyLmV4cGlyYXRpb24gPSBiYXNlX2V4cGlyYXRpb25fc2VjKCkgKyBDaGFpbkNvbmZpZy5leHBpcmVfaW5fc2VjcztcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJuZXcgZXhwaXJhdGlvbjpcIiwgdGhpcy5leHBpcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMyLnJlZl9ibG9ja19udW0gPSByLmhlYWRfYmxvY2tfbnVtYmVyICYgMHhGRkZGO1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIucmVmX2Jsb2NrX3ByZWZpeCA9IG5ldyBCdWZmZXIoci5oZWFkX2Jsb2NrX2lkLCAnaGV4JykucmVhZFVJbnQzMkxFKDQpO1xuICAgICAgICAgICAgICAgICAgICAvL0RFQlVHIGNvbnNvbGUubG9nKFwicmVmX2Jsb2NrXCIsQHJlZl9ibG9ja19udW0sQHJlZl9ibG9ja19wcmVmaXgscilcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlcmFibGUgPSBfdGhpczIub3BlcmF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG9wOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMV1bXCJmaW5hbGl6ZVwiXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wWzFdLmZpbmFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMyLnRyX2J1ZmZlciA9IG9wcy50cmFuc2FjdGlvbi50b0J1ZmZlcihfdGhpczIpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJnZXRfZHluYW1pY19nbG9iYWxfcHJvcGVydGllcyBlcnI6XCIsIGVycik7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7c3RyaW5nfSBoZXggdHJhbnNhY3Rpb24gSUQgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImlkXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpZCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50cl9idWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgZmluYWxpemVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhc2guc2hhMjU2KHRoaXMudHJfYnVmZmVyKS50b1N0cmluZygnaGV4Jykuc3Vic3RyaW5nKDAsIDQwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgVHlwaWNhbGx5IG9uZSB3aWxsIHVzZSB7QGxpbmsgdGhpcy5hZGRfdHlwZV9vcGVyYXRpb259IGluc3RlYWQuXG4gICAgICAgICAgICBAYXJnIHthcnJheX0gb3BlcmF0aW9uIC0gW29wZXJhdGlvbl9pZCwgb3BlcmF0aW9uXVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYWRkX29wZXJhdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkX29wZXJhdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyX2J1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgZmluYWxpemVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KG9wZXJhdGlvbiwgXCJvcGVyYXRpb25cIik7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3BlcmF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGluZyBhcnJheSBbb3BlcmF0aW9uX2lkLCBvcGVyYXRpb25dXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldF90eXBlX29wZXJhdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0X3R5cGVfb3BlcmF0aW9uKG5hbWUsIG9wZXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJfYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbGl6ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQobmFtZSwgXCJuYW1lXCIpO1xuICAgICAgICAgICAgYXNzZXJ0KG9wZXJhdGlvbiwgXCJvcGVyYXRpb25cIik7XG4gICAgICAgICAgICB2YXIgX3R5cGUgPSBvcHNbbmFtZV07XG4gICAgICAgICAgICBhc3NlcnQoX3R5cGUsIFwiVW5rbm93biBvcGVyYXRpb24gXCIgKyBuYW1lKTtcbiAgICAgICAgICAgIHZhciBvcGVyYXRpb25faWQgPSBDaGFpblR5cGVzLm9wZXJhdGlvbnNbX3R5cGUub3BlcmF0aW9uX25hbWVdO1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbl9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBvcGVyYXRpb246IFwiICsgX3R5cGUub3BlcmF0aW9uX25hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcGVyYXRpb24uZmVlKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLmZlZSA9IHsgYW1vdW50OiAwLCBhc3NldF9pZDogMCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdwcm9wb3NhbF9jcmVhdGUnKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLmV4cGlyYXRpb25fdGltZSB8fCAob3BlcmF0aW9uLmV4cGlyYXRpb25fdGltZSA9IGJhc2VfZXhwaXJhdGlvbl9zZWMoKSArIENoYWluQ29uZmlnLmV4cGlyZV9pbl9zZWNzX3Byb3Bvc2FsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcGVyYXRpb25faW5zdGFuY2UgPSBfdHlwZS5mcm9tT2JqZWN0KG9wZXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gW29wZXJhdGlvbl9pZCwgb3BlcmF0aW9uX2luc3RhbmNlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBvcHRpb25hbDogdGhlcmUgaXMgYSBkZWFmdWx0IGV4cGlyYXRpb24gKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNldF9leHBpcmVfc2Vjb25kc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0X2V4cGlyZV9zZWNvbmRzKHNlYykge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJfYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbGl6ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBpcmF0aW9uID0gYmFzZV9leHBpcmF0aW9uX3NlYygpICsgc2VjO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogV3JhcHMgdGhpcyB0cmFuc2FjdGlvbiBpbiBhIHByb3Bvc2FsX2NyZWF0ZSB0cmFuc2FjdGlvbiAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwicHJvcG9zZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvcG9zZShwcm9wb3NhbF9jcmVhdGVfb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJfYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbGl6ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMub3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGQgb3BlcmF0aW9uIGZpcnN0XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhc3NlcnQocHJvcG9zYWxfY3JlYXRlX29wdGlvbnMsIFwicHJvcG9zYWxfY3JlYXRlX29wdGlvbnNcIik7XG4gICAgICAgICAgICBhc3NlcnQocHJvcG9zYWxfY3JlYXRlX29wdGlvbnMuZmVlX3BheWluZ19hY2NvdW50LCBcInByb3Bvc2FsX2NyZWF0ZV9vcHRpb25zLmZlZV9wYXlpbmdfYWNjb3VudFwiKTtcblxuICAgICAgICAgICAgdmFyIHByb3Bvc2VkX29wcyA9IHRoaXMub3BlcmF0aW9ucy5tYXAoZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb3A6IG9wIH07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25zID0gW107XG4gICAgICAgICAgICB0aGlzLnNpZ25hdHVyZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2lnbmVyX3ByaXZhdGVfa2V5cyA9IFtdO1xuICAgICAgICAgICAgcHJvcG9zYWxfY3JlYXRlX29wdGlvbnMucHJvcG9zZWRfb3BzID0gcHJvcG9zZWRfb3BzO1xuICAgICAgICAgICAgdGhpcy5hZGRfdHlwZV9vcGVyYXRpb24oXCJwcm9wb3NhbF9jcmVhdGVcIiwgcHJvcG9zYWxfY3JlYXRlX29wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJoYXNfcHJvcG9zZWRfb3BlcmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNfcHJvcG9zZWRfb3BlcmF0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhc1Byb3Bvc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3BlcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChcInByb3Bvc2VkX29wc1wiIGluIHRoaXMub3BlcmF0aW9uc1tpXVsxXSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNQcm9wb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhhc1Byb3Bvc2VkO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0X3BvdGVudGlhbF9zaWduYXR1cmVzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRfcG90ZW50aWFsX3NpZ25hdHVyZXMoKSB7XG4gICAgICAgICAgICB2YXIgdHJfb2JqZWN0ID0gb3BzLnNpZ25lZF90cmFuc2FjdGlvbi50b09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBBcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9wb3RlbnRpYWxfc2lnbmF0dXJlc1wiLCBbdHJfb2JqZWN0XSkudGhlbihmdW5jdGlvbiAocHVia2V5cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHB1YmtleXM6IHB1YmtleXMgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldF9yZXF1aXJlZF9zaWduYXR1cmVzKGF2YWlsYWJsZV9rZXlzKSB7XG5cbiAgICAgICAgICAgIGlmICghYXZhaWxhYmxlX2tleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHJfb2JqZWN0ID0gb3BzLnNpZ25lZF90cmFuc2FjdGlvbi50b09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcuLi4gdHJfb2JqZWN0Jyx0cl9vYmplY3QpXG4gICAgICAgICAgICAvL0RFQlVHIGNvbnNvbGUubG9nKCcuLi4gdHJfb2JqZWN0Jyx0cl9vYmplY3QpXG4gICAgICAgICAgICByZXR1cm4gQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfcmVxdWlyZWRfc2lnbmF0dXJlc1wiLCBbdHJfb2JqZWN0LCBhdmFpbGFibGVfa2V5c10pLnRoZW4oZnVuY3Rpb24gKHJlcXVpcmVkX3B1YmxpY19rZXlzKSB7XG4gICAgICAgICAgICAgICAgLy8gREVCVUcgY29uc29sZS5sb2coJy4uLiBnZXRfcmVxdWlyZWRfc2lnbmF0dXJlcycscmVxdWlyZWRfcHVibGljX2tleXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmVkX3B1YmxpY19rZXlzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhZGRfc2lnbmVyXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRfc2lnbmVyKHByaXZhdGVfa2V5KSB7XG4gICAgICAgICAgICB2YXIgcHVibGljX2tleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogcHJpdmF0ZV9rZXkudG9QdWJsaWNLZXkoKTtcblxuXG4gICAgICAgICAgICBhc3NlcnQocHJpdmF0ZV9rZXkuZCwgXCJyZXF1aXJlZCBQcml2YXRlS2V5IG9iamVjdFwiKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBzaWduZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXB1YmxpY19rZXkuUSkge1xuICAgICAgICAgICAgICAgIHB1YmxpY19rZXkgPSBQdWJsaWNLZXkuZnJvbVB1YmxpY0tleVN0cmluZyhwdWJsaWNfa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICAgICAgdmFyIHNwSGV4ID0gcHJpdmF0ZV9rZXkudG9IZXgoKTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB0aGlzLnNpZ25lcl9wcml2YXRlX2tleXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcFswXS50b0hleCgpID09PSBzcEhleCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNpZ25lcl9wcml2YXRlX2tleXMucHVzaChbcHJpdmF0ZV9rZXksIHB1YmxpY19rZXldKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNpZ25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5faWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IENoYWluQ29uZmlnLm5ldHdvcmtzLlN0ZWVtLmNoYWluX2lkO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMudHJfYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGZpbmFsaXplZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgc2lnbmVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuc2lnbmVyX3ByaXZhdGVfa2V5cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgMCA8IGVuZCA/IGkgPCBlbmQgOiBpID4gZW5kOyAwIDwgZW5kID8gaSsrIDogaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9zaWduZXJfcHJpdmF0ZV9rZXlzJCA9IF9zbGljZWRUb0FycmF5KHRoaXMuc2lnbmVyX3ByaXZhdGVfa2V5c1tpXSwgMik7XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJpdmF0ZV9rZXkgPSBfc2lnbmVyX3ByaXZhdGVfa2V5cyRbMF07XG4gICAgICAgICAgICAgICAgdmFyIHB1YmxpY19rZXkgPSBfc2lnbmVyX3ByaXZhdGVfa2V5cyRbMV07XG5cbiAgICAgICAgICAgICAgICB2YXIgc2lnID0gU2lnbmF0dXJlLnNpZ25CdWZmZXIoQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihjaGFpbl9pZCwgJ2hleCcpLCB0aGlzLnRyX2J1ZmZlcl0pLCBwcml2YXRlX2tleSwgcHVibGljX2tleSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWduYXR1cmVzLnB1c2goc2lnLnRvQnVmZmVyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zaWduZXJfcHJpdmF0ZV9rZXlzID0gW107XG4gICAgICAgICAgICB0aGlzLnNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHMuc2lnbmVkX3RyYW5zYWN0aW9uLnRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwidG9PYmplY3RcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG9wcy5zaWduZWRfdHJhbnNhY3Rpb24udG9PYmplY3QodGhpcyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJicm9hZGNhc3RcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJyb2FkY2FzdCh3YXNfYnJvYWRjYXN0X2NhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKHRoaXMudHJfYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jyb2FkY2FzdCh3YXNfYnJvYWRjYXN0X2NhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fYnJvYWRjYXN0KHdhc19icm9hZGNhc3RfY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uQnVpbGRlcjtcbn0oKTtcblxudmFyIGJhc2VfZXhwaXJhdGlvbl9zZWMgPSBmdW5jdGlvbiBiYXNlX2V4cGlyYXRpb25fc2VjKCkge1xuICAgIHZhciBoZWFkX2Jsb2NrX3NlYyA9IE1hdGguY2VpbChnZXRIZWFkQmxvY2tEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgdmFyIG5vd19zZWMgPSBNYXRoLmNlaWwoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgIC8vIFRoZSBoZWFkIGJsb2NrIHRpbWUgc2hvdWxkIGJlIHVwZGF0ZWQgZXZlcnkgMyBzZWNvbmRzLiAgSWYgaXQgaXNuJ3RcbiAgICAvLyB0aGVuIGhlbHAgdGhlIHRyYW5zYWN0aW9uIHRvIGV4cGlyZSAodXNlIGhlYWRfYmxvY2tfc2VjKVxuICAgIGlmIChub3dfc2VjIC0gaGVhZF9ibG9ja19zZWMgPiAzMCkge1xuICAgICAgICByZXR1cm4gaGVhZF9ibG9ja19zZWM7XG4gICAgfVxuICAgIC8vIElmIHRoZSB1c2VyJ3MgY2xvY2sgaXMgdmVyeSBmYXIgYmVoaW5kLCB1c2UgdGhlIGhlYWQgYmxvY2sgdGltZS5cbiAgICByZXR1cm4gTWF0aC5tYXgobm93X3NlYywgaGVhZF9ibG9ja19zZWMpO1xufTtcblxuZnVuY3Rpb24gX2Jyb2FkY2FzdCh3YXNfYnJvYWRjYXN0X2NhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAoIV90aGlzNC5zaWduZWQpIHtcbiAgICAgICAgICAgIF90aGlzNC5zaWduKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfdGhpczQudHJfYnVmZmVyKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwibm90IGZpbmFsaXplZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfdGhpczQuc2lnbmF0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJub3Qgc2lnbmVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV90aGlzNC5vcGVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIm5vIG9wZXJhdGlvbnNcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoXCJuZXR3b3JrX2Jyb2FkY2FzdF9hcGlcIiBpbiBBcGkpKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQXBpIGRvZXMgbm90IGluY2x1ZGUgbmV0d29ya19icm9hZGNhc3RfYXBpXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJfb2JqZWN0ID0gb3BzLnNpZ25lZF90cmFuc2FjdGlvbi50b09iamVjdChfdGhpczQpO1xuXG4gICAgICAgIHJldHVybiBBcGkubmV0d29ya19icm9hZGNhc3RfYXBpKCkuZXhlYyhcImJyb2FkY2FzdF90cmFuc2FjdGlvbl93aXRoX2NhbGxiYWNrXCIsIFt7IHJlamVjdDogcmVqZWN0LCByZXNvbHZlOiByZXNvbHZlIH0sIHRyX29iamVjdF0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy4uLiBicm9hZGNhc3Qgc3VjY2Vzcywgd2FpdGluZyBmb3IgY2FsbGJhY2snKVxuICAgICAgICAgICAgaWYgKHdhc19icm9hZGNhc3RfY2FsbGJhY2spIHdhc19icm9hZGNhc3RfY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyBtYXkgYmUgcmVkdW5kYW50IGZvciBuZXR3b3JrIGVycm9ycywgb3RoZXIgZXJyb3JzIGNvdWxkIG9jY3VyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IobWVzc2FnZSArIFwiXFxuXCIgKyAnZ3JhcGhlbmUtY3J5cHRvICcgKyAnIGRpZ2VzdCAnICsgaGFzaC5zaGEyNTYoX3RoaXM0LnRyX2J1ZmZlcikudG9TdHJpbmcoJ2hleCcpICsgJyB0cmFuc2FjdGlvbiAnICsgX3RoaXM0LnRyX2J1ZmZlci50b1N0cmluZygnaGV4JykgKyAnICcgKyBKU09OLnN0cmluZ2lmeSh0cl9vYmplY3QpKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRIZWFkQmxvY2tEYXRlKCkge1xuICAgIHJldHVybiB0aW1lU3RyaW5nVG9EYXRlKGhlYWRfYmxvY2tfdGltZV9zdHJpbmcpO1xufVxuXG5mdW5jdGlvbiB0aW1lU3RyaW5nVG9EYXRlKHRpbWVfc3RyaW5nKSB7XG4gICAgaWYgKCF0aW1lX3N0cmluZykgcmV0dXJuIG5ldyBEYXRlKFwiMTk3MC0wMS0wMVQwMDowMDowMC4wMDBaXCIpO1xuICAgIGlmICghL1okLy50ZXN0KHRpbWVfc3RyaW5nKSkgLy9kb2VzIG5vdCBlbmQgaW4gWlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvbm9tZXgvZ3JhcGhlbmUvaXNzdWVzLzM2OFxuICAgICAgICB0aW1lX3N0cmluZyA9IHRpbWVfc3RyaW5nICsgXCJaXCI7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRpbWVfc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2FjdGlvbkJ1aWxkZXI7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L2NoYWluL3NyYy9UcmFuc2FjdGlvbkJ1aWxkZXIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9jaGFpbi9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBoZWxwZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGhlbHBlciA9IHt9O1xuXG52YXIgc2VjdXJlUmFuZG9tID0gcmVxdWlyZSgnc2VjdXJlLXJhbmRvbScpO1xuXG4vL1Byb21pc2UgPSByZXF1aXJlICcuLi9jb21tb24vUHJvbWlzZSdcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnYnl0ZWJ1ZmZlcicpO1xuXG52YXIgTG9uZyA9IF9yZXF1aXJlLkxvbmc7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi4vLi4vZWNjXCIpO1xuXG52YXIgU2lnbmF0dXJlID0gX3JlcXVpcmUyLlNpZ25hdHVyZTtcblxudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoXCIuLi8uLi9zZXJpYWxpemVyXCIpO1xuXG52YXIgb3BzID0gX3JlcXVpcmUzLm9wcztcblxuXG5oZWxwZXIudW5pcXVlX25vbmNlX2VudHJvcHkgPSBudWxsO1xuaGVscGVyLnVuaXF1ZV9ub25jZV91aW50NjQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVudHJvcHkgPSBoZWxwZXIudW5pcXVlX25vbmNlX2VudHJvcHkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgaWYgKGhlbHBlci51bmlxdWVfbm9uY2VfZW50cm9weSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnLi4uIHNlY3VyZVJhbmRvbS5yYW5kb21VaW50OEFycmF5KDEpWzBdJyxzZWN1cmVSYW5kb20ucmFuZG9tVWludDhBcnJheSgxKVswXSlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChzZWN1cmVSYW5kb20ucmFuZG9tVWludDhBcnJheSgxKVswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKytoZWxwZXIudW5pcXVlX25vbmNlX2VudHJvcHkgJSAyNTY7XG4gICAgICAgIH1cbiAgICB9KCk7XG4gICAgdmFyIGxvbmcgPSBMb25nLmZyb21OdW1iZXIoRGF0ZS5ub3coKSk7XG4gICAgLy9jb25zb2xlLmxvZygndW5pcXVlX25vbmNlX3VpbnQ2NCBkYXRlXFx0JyxCeXRlQnVmZmVyLmFsbG9jYXRlKDgpLndyaXRlVWludDY0KGxvbmcpLnRvSGV4KDApKVxuICAgIC8vY29uc29sZS5sb2coJ3VuaXF1ZV9ub25jZV91aW50NjQgZW50cm9weVxcdCcsQnl0ZUJ1ZmZlci5hbGxvY2F0ZSg4KS53cml0ZVVpbnQ2NChMb25nLmZyb21OdW1iZXIoZW50cm9weSkpLnRvSGV4KDApKVxuICAgIGxvbmcgPSBsb25nLnNoaWZ0TGVmdCg4KS5vcihMb25nLmZyb21OdW1iZXIoZW50cm9weSkpO1xuICAgIC8vY29uc29sZS5sb2coJ3VuaXF1ZV9ub25jZV91aW50NjQgc2hpZnQ4XFx0JyxCeXRlQnVmZmVyLmFsbG9jYXRlKDgpLndyaXRlVWludDY0KGxvbmcpLnRvSGV4KDApKVxuICAgIHJldHVybiBsb25nLnRvU3RyaW5nKCk7XG59O1xuXG4vKiBUb2RvLCBzZXQgZmVlcyAqL1xuaGVscGVyLnRvX2pzb24gPSBmdW5jdGlvbiAodHIpIHtcbiAgICB2YXIgYnJvYWRjYXN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAodHIsIGJyb2FkY2FzdCkge1xuICAgICAgICB2YXIgdHJfb2JqZWN0ID0gb3BzLnNpZ25lZF90cmFuc2FjdGlvbi50b09iamVjdCh0cik7XG4gICAgICAgIGlmIChicm9hZGNhc3QpIHtcbiAgICAgICAgICAgIHZhciBuZXQgPSBBcGlzLmluc3RhbmNlKCkubmV0d29ya19hcGkoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCcuLi4gdHJfb2JqZWN0JywgSlNPTi5zdHJpbmdpZnkodHJfb2JqZWN0KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV0LmV4ZWMoXCJicm9hZGNhc3RfdHJhbnNhY3Rpb25cIiwgW3RyX29iamVjdF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRyX29iamVjdDtcbiAgICAgICAgfVxuICAgIH0odHIsIGJyb2FkY2FzdCk7XG59O1xuXG5oZWxwZXIuc2lnbmVkX3RyX2pzb24gPSBmdW5jdGlvbiAodHIsIHByaXZhdGVfa2V5cykge1xuICAgIHZhciB0cl9idWZmZXIgPSBvcHMudHJhbnNhY3Rpb24udG9CdWZmZXIodHIpO1xuICAgIHRyID0gb3BzLnRyYW5zYWN0aW9uLnRvT2JqZWN0KHRyKTtcbiAgICB0ci5zaWduYXR1cmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyAwIDwgcHJpdmF0ZV9rZXlzLmxlbmd0aCA/IGkgPCBwcml2YXRlX2tleXMubGVuZ3RoIDogaSA+IHByaXZhdGVfa2V5cy5sZW5ndGg7IDAgPCBwcml2YXRlX2tleXMubGVuZ3RoID8gaSsrIDogaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJpdmF0ZV9rZXkgPSBwcml2YXRlX2tleXNbaV07XG4gICAgICAgICAgICByZXN1bHQucHVzaChTaWduYXR1cmUuc2lnbkJ1ZmZlcih0cl9idWZmZXIsIHByaXZhdGVfa2V5KS50b0hleCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0oKTtcbiAgICByZXR1cm4gdHI7XG59O1xuXG5oZWxwZXIuZXhwaXJlX2luX21pbiA9IGZ1bmN0aW9uIChtaW4pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkgKyBtaW4gKiA2MDtcbn07XG5cbmhlbHBlci5zZWNvbmRzX2Zyb21fbm93ID0gZnVuY3Rpb24gKHRpbWVvdXRfc2VjKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApICsgdGltZW91dF9zZWM7XG59O1xuXG4vKipcbiAgICBQcmludCB0byB0aGUgY29uc29sZSBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW55IG9iamVjdCBpblxuICAgIEBncmFwaGVuZS9zZXJpYWxpemVyIHsgdHlwZXMgfVxuKi9cbmhlbHBlci50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChzZXJpYWxpemVyX29wZXJhdGlvbl90eXBlX25hbWUpIHtcbiAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHsgdXNlX2RlZmF1bHQ6IHRydWUsIGFubm90YXRlOiB0cnVlIH07XG5cbiAgICB2YXIgc28gPSB0eXBlW3NlcmlhbGl6ZXJfb3BlcmF0aW9uX3R5cGVfbmFtZV07XG4gICAgaWYgKCFzbykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gc2VyaWFsaXplcl9vcGVyYXRpb25fdHlwZSAnICsgc2VyaWFsaXplcl9vcGVyYXRpb25fdHlwZV9uYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvLnRvT2JqZWN0KHVuZGVmaW5lZCwgZGVidWcpO1xufTtcblxuaGVscGVyLm5ld19vcGVyYXRpb24gPSBmdW5jdGlvbiAoc2VyaWFsaXplcl9vcGVyYXRpb25fdHlwZV9uYW1lKSB7XG4gICAgdmFyIHNvID0gdHlwZVtzZXJpYWxpemVyX29wZXJhdGlvbl90eXBlX25hbWVdO1xuICAgIGlmICghc28pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHNlcmlhbGl6ZXJfb3BlcmF0aW9uX3R5cGUgJyArIHNlcmlhbGl6ZXJfb3BlcmF0aW9uX3R5cGVfbmFtZSk7XG4gICAgfVxuICAgIHZhciBvYmplY3QgPSBzby50b09iamVjdCh1bmRlZmluZWQsIHsgdXNlX2RlZmF1bHQ6IHRydWUsIGFubm90YXRlOiB0cnVlIH0pO1xuICAgIHJldHVybiBzby5mcm9tT2JqZWN0KG9iamVjdCk7XG59O1xuXG5oZWxwZXIuaW5zdGFuY2UgPSBmdW5jdGlvbiAoT2JqZWN0SWQpIHtcbiAgICByZXR1cm4gT2JqZWN0SWQuc3Vic3RyaW5nKFwiMC4wLlwiLmxlbmd0aCk7XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9jaGFpbi9zcmMvVHJhbnNhY3Rpb25IZWxwZXIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9jaGFpbi9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQWRkcmVzczogcmVxdWlyZShcIi4vc3JjL2FkZHJlc3NcIiksXG4gICAgQWVzOiByZXF1aXJlKFwiLi9zcmMvYWVzXCIpLFxuICAgIFByaXZhdGVLZXk6IHJlcXVpcmUoXCIuL3NyYy9Qcml2YXRlS2V5XCIpLFxuICAgIFB1YmxpY0tleTogcmVxdWlyZShcIi4vc3JjL1B1YmxpY0tleVwiKSxcbiAgICBTaWduYXR1cmU6IHJlcXVpcmUoXCIuL3NyYy9zaWduYXR1cmVcIiksXG4gICAgYnJhaW5LZXk6IHJlcXVpcmUoXCIuL3NyYy9CcmFpbktleVwiKSxcbiAgICBoYXNoOiByZXF1aXJlKFwiLi9zcmMvaGFzaFwiKSxcbiAgICBrZXk6IHJlcXVpcmUoXCIuL3NyYy9LZXlVdGlsc1wiKVxufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvZWNjL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvZWNjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShicmFpbktleSkge1xuICAgIGlmICh0eXBlb2YgYnJhaW5LZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0cmluZyByZXF1aXJlZCBmb3IgYnJhaW5LZXlcIik7XG4gICAgfVxuICAgIGJyYWluS2V5ID0gYnJhaW5LZXkudHJpbSgpO1xuICAgIHJldHVybiBicmFpbktleS5zcGxpdCgvW1xcdFxcblxcdlxcZlxcciBdKy8pLmpvaW4oJyAnKTtcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L2VjYy9zcmMvQnJhaW5LZXkuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9lY2Mvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBrZXk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vUHJpdmF0ZUtleScpO1xudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vUHVibGljS2V5Jyk7XG52YXIgQWRkcmVzcyA9IHJlcXVpcmUoJy4vYWRkcmVzcycpO1xudmFyIEFlcyA9IHJlcXVpcmUoJy4vYWVzJyk7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnLi9oYXNoJyk7XG4vLyB2YXIgZGljdGlvbmFyeSA9IHJlcXVpcmUoJy4vZGljdGlvbmFyeV9lbicpO1xudmFyIHNlY3VyZVJhbmRvbSA9IHJlcXVpcmUoJ3NlY3VyZS1yYW5kb20nKTtcbnZhciBDaGFpbkNvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jaGFpbi9zcmMvQ2hhaW5Db25maWdcIik7XG5cbi8vIGhhc2ggZm9yIC4yNSBzZWNvbmRcbnZhciBIQVNIX1BPV0VSX01JTExTID0gMjUwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleSA9IHtcblxuICAgIC8qKiBVc2VzIDEgc2Vjb25kIG9mIGhhc2hpbmcgcG93ZXIgdG8gY3JlYXRlIGEga2V5L3Bhc3N3b3JkIGNoZWNrc3VtLiAgQW5cbiAgICBpbXBsZW1lbnRhdGlvbiBjYW4gcmUtY2FsbCB0aGlzIG1ldGhvZCB3aXRoIHRoZSBzYW1lIHBhc3N3b3JkIHRvIHJlLW1hdGNoXG4gICAgdGhlIHN0cmVuZ3RoIG9mIHRoZSBDUFUgKGVpdGhlciBhZnRlciBtb3ZpbmcgZnJvbSBhIGRlc2t0b3AgdG8gYSBtb2JpbGUsXG4gICAgbW9iaWxlIHRvIGRlc2t0b3AsIG9yIE4geWVhcnMgZnJvbSBub3cgd2hlbiBDUFVzIGFyZSBwcmVzdW1hYmx5IHN0cm9uZ2VyKS5cbiAgICAgQSBzYWx0IGlzIHVzZWQgZm9yIGFsbCB0aGUgbm9ybWFsIHJlYXNvbnMuLi5cbiAgICAgQHJldHVybiBvYmplY3Qge1xuICAgICAgICBhZXNfcHJpdmF0ZTogQWVzLFxuICAgICAgICBjaGVja3N1bTogXCJ7aGFzaF9pdGVyYXRpb25fY291bnR9LHtzYWx0fSx7Y2hlY2tzdW19XCJcbiAgICB9XG4gICAgKi9cbiAgICBhZXNfY2hlY2tzdW06IGZ1bmN0aW9uIGFlc19jaGVja3N1bShwYXNzd29yZCkge1xuICAgICAgICBpZiAoISh0eXBlb2YgcGFzc3dvcmQgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgXCJwYXNzd29yZCBzdHJpbmcgcmVxdWlyZWRcIigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzYWx0ID0gc2VjdXJlUmFuZG9tLnJhbmRvbUJ1ZmZlcig0KS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgICAgdmFyIHNlY3JldCA9IHNhbHQgKyBwYXNzd29yZDtcbiAgICAgICAgLy8gaGFzaCBmb3IgLjEgc2Vjb25kXG4gICAgICAgIHZhciBzdGFydF90ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydF90IDwgSEFTSF9QT1dFUl9NSUxMUykge1xuICAgICAgICAgICAgc2VjcmV0ID0gaGFzaC5zaGEyNTYoc2VjcmV0KTtcbiAgICAgICAgICAgIGl0ZXJhdGlvbnMgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGVja3N1bSA9IGhhc2guc2hhMjU2KHNlY3JldCk7XG4gICAgICAgIHZhciBjaGVja3N1bV9zdHJpbmcgPSBbaXRlcmF0aW9ucywgc2FsdC50b1N0cmluZygnaGV4JyksIGNoZWNrc3VtLnNsaWNlKDAsIDQpLnRvU3RyaW5nKCdoZXgnKV0uam9pbignLCcpO1xuXG4gICAgICAgIHJldHVybiB7IGFlc19wcml2YXRlOiBBZXMuZnJvbVNlZWQoc2VjcmV0KSxcbiAgICAgICAgICAgIGNoZWNrc3VtOiBjaGVja3N1bV9zdHJpbmdcbiAgICAgICAgfTtcbiAgICB9LFxuXG5cbiAgICAvKiogUHJvdmlkZSBhIG1hdGNoaW5nIHBhc3N3b3JkIGFuZCBrZXlfY2hlY2tzdW0uICBBIFwid3JvbmcgcGFzc3dvcmRcIlxuICAgIGVycm9yIGlzIHRocm93biBpZiB0aGUgcGFzc3dvcmQgZG9lcyBub3QgbWF0Y2guICBJZiB0aGlzIG1ldGhvZCB0YWtlc1xuICAgIG11Y2ggbW9yZSBvciBsZXNzIHRoYW4gMSBzZWNvbmQgdG8gcmV0dXJuLCBvbmUgc2hvdWxkIGNvbnNpZGVyIHVwZGF0aW5nXG4gICAgYWxsIGVuY3lycHRlZCBmaWVsZHMgdXNpbmcgYSBuZXcga2V5LmtleV9jaGVja3N1bS5cbiAgICAqL1xuICAgIGFlc19wcml2YXRlOiBmdW5jdGlvbiBhZXNfcHJpdmF0ZShwYXNzd29yZCwga2V5X2NoZWNrc3VtKSB7XG4gICAgICAgIHZhciBfa2V5X2NoZWNrc3VtJHNwbGl0ID0ga2V5X2NoZWNrc3VtLnNwbGl0KCcsJyk7XG5cbiAgICAgICAgdmFyIF9rZXlfY2hlY2tzdW0kc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX2tleV9jaGVja3N1bSRzcGxpdCwgMyk7XG5cbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBfa2V5X2NoZWNrc3VtJHNwbGl0MlswXTtcbiAgICAgICAgdmFyIHNhbHQgPSBfa2V5X2NoZWNrc3VtJHNwbGl0MlsxXTtcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gX2tleV9jaGVja3N1bSRzcGxpdDJbMl07XG5cbiAgICAgICAgdmFyIHNlY3JldCA9IHNhbHQgKyBwYXNzd29yZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IDAgPCBpdGVyYXRpb25zID8gaSA8IGl0ZXJhdGlvbnMgOiBpID4gaXRlcmF0aW9uczsgMCA8IGl0ZXJhdGlvbnMgPyBpKysgOiBpKyspIHtcbiAgICAgICAgICAgIHNlY3JldCA9IGhhc2guc2hhMjU2KHNlY3JldCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld19jaGVja3N1bSA9IGhhc2guc2hhMjU2KHNlY3JldCk7XG4gICAgICAgIGlmICghKG5ld19jaGVja3N1bS5zbGljZSgwLCA0KS50b1N0cmluZygnaGV4JykgPT09IGNoZWNrc3VtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid3JvbmcgcGFzc3dvcmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFlcy5mcm9tU2VlZChzZWNyZXQpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAgICBBIHdlZWsgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgY2FuIHJ1biBvdXQgb2YgZW50cm9weS4gIFRoaXMgc2hvdWxkIGVuc3VyZSBldmVuIHRoZSB3b3JzdCByYW5kb20gbnVtYmVyIGltcGxlbWVudGF0aW9uIHdpbGwgYmUgcmVhc29uYWJseSBzYWZlLlxuICAgICAgICAgQHBhcmFtMSBzdHJpbmcgZW50cm9weSBvZiBhdCBsZWFzdCAzMiBieXRlc1xuICAgICovXG4gICAgcmFuZG9tMzJCeXRlQnVmZmVyOiBmdW5jdGlvbiByYW5kb20zMkJ5dGVCdWZmZXIoKSB7XG4gICAgICAgIHZhciBlbnRyb3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLmJyb3dzZXJFbnRyb3B5KCk7XG5cblxuICAgICAgICBpZiAoISh0eXBlb2YgZW50cm9weSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgcmVxdWlyZWQgZm9yIGVudHJvcHlcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cm9weS5sZW5ndGggPCAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0aW5nIGF0IGxlYXN0IDMyIGJ5dGVzIG9mIGVudHJvcHlcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRfdCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydF90IDwgSEFTSF9QT1dFUl9NSUxMUykge1xuICAgICAgICAgICAgZW50cm9weSA9IGhhc2guc2hhMjU2KGVudHJvcHkpO1xuICAgICAgICB9dmFyIGhhc2hfYXJyYXkgPSBbXTtcbiAgICAgICAgaGFzaF9hcnJheS5wdXNoKGVudHJvcHkpO1xuXG4gICAgICAgIC8vIEhhc2hpbmcgZm9yIDEgc2Vjb25kIG1heSBoZWxwcyB0aGUgY29tcHV0ZXIgaXMgbm90IGxvdyBvbiBlbnRyb3B5ICh0aGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIGJhY2stdG8tYmFjaykuXG4gICAgICAgIGhhc2hfYXJyYXkucHVzaChzZWN1cmVSYW5kb20ucmFuZG9tQnVmZmVyKDMyKSk7XG5cbiAgICAgICAgcmV0dXJuIGhhc2guc2hhMjU2KEJ1ZmZlci5jb25jYXQoaGFzaF9hcnJheSkpO1xuICAgIH0sXG5cblxuICAgIHN1Z2dlc3RfYnJhaW5fa2V5OiBmdW5jdGlvbiBzdWdnZXN0X2JyYWluX2tleSgpIHtcbiAgICAgICAgdmFyIGRpY3Rpb25hcnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwiLFwiO1xuICAgICAgICB2YXIgZW50cm9weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5icm93c2VyRW50cm9weSgpO1xuXG5cbiAgICAgICAgdmFyIHJhbmRvbUJ1ZmZlciA9IHRoaXMucmFuZG9tMzJCeXRlQnVmZmVyKGVudHJvcHkpO1xuXG4gICAgICAgIHZhciB3b3JkX2NvdW50ID0gMTY7XG4gICAgICAgIHZhciBkaWN0aW9uYXJ5X2xpbmVzID0gZGljdGlvbmFyeS5zcGxpdCgnLCcpO1xuXG4gICAgICAgIGlmICghKGRpY3Rpb25hcnlfbGluZXMubGVuZ3RoID09PSA0OTc0NCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nICcgKyA0OTc0NCArICcgYnV0IGdvdCAnICsgZGljdGlvbmFyeV9saW5lcy5sZW5ndGggKyAnIGRpY3Rpb25hcnkgd29yZHMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBicmFpbmtleSA9IFtdO1xuICAgICAgICB2YXIgZW5kID0gd29yZF9jb3VudCAqIDI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkgKz0gMikge1xuXG4gICAgICAgICAgICAvLyByYW5kb21CdWZmZXIgaGFzIDI1NiBiaXRzIC8gMTYgYml0cyBwZXIgd29yZCA9PSAxNiB3b3Jkc1xuICAgICAgICAgICAgdmFyIG51bSA9IChyYW5kb21CdWZmZXJbaV0gPDwgOCkgKyByYW5kb21CdWZmZXJbaSArIDFdO1xuXG4gICAgICAgICAgICAvLyBjb252ZXJ0IGludG8gYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIChpbmNsdXNpdmUpXG4gICAgICAgICAgICB2YXIgcm5kTXVsdGlwbGllciA9IG51bSAvIE1hdGgucG93KDIsIDE2KTtcbiAgICAgICAgICAgIHZhciB3b3JkSW5kZXggPSBNYXRoLnJvdW5kKGRpY3Rpb25hcnlfbGluZXMubGVuZ3RoICogcm5kTXVsdGlwbGllcik7XG5cbiAgICAgICAgICAgIGJyYWlua2V5LnB1c2goZGljdGlvbmFyeV9saW5lc1t3b3JkSW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVfYnJhaW5LZXkoYnJhaW5rZXkuam9pbignICcpKTtcbiAgICB9LFxuXG4gICAgZ2V0X3JhbmRvbV9rZXk6IGZ1bmN0aW9uIGdldF9yYW5kb21fa2V5KGVudHJvcHkpIHtcbiAgICAgICAgcmV0dXJuIFByaXZhdGVLZXkuZnJvbUJ1ZmZlcih0aGlzLnJhbmRvbTMyQnl0ZUJ1ZmZlcihlbnRyb3B5KSk7XG4gICAgfSxcbiAgICBnZXRfYnJhaW5Qcml2YXRlS2V5OiBmdW5jdGlvbiBnZXRfYnJhaW5Qcml2YXRlS2V5KGJyYWluS2V5KSB7XG4gICAgICAgIHZhciBzZXF1ZW5jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICAgICAgICBpZiAoc2VxdWVuY2UgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlcXVlbmNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyYWluS2V5ID0ga2V5Lm5vcm1hbGl6ZV9icmFpbktleShicmFpbktleSk7XG4gICAgICAgIHJldHVybiBQcml2YXRlS2V5LmZyb21CdWZmZXIoaGFzaC5zaGEyNTYoaGFzaC5zaGE1MTIoYnJhaW5LZXkgKyBcIiBcIiArIHNlcXVlbmNlKSkpO1xuICAgIH0sXG5cblxuICAgIC8vIFR1cm4gaW52aXNpYmxlIHNwYWNlIGxpa2UgY2hhcmFjdGVycyBpbnRvIGEgc2luZ2xlIHNwYWNlXG4gICAgbm9ybWFsaXplX2JyYWluS2V5OiBmdW5jdGlvbiBub3JtYWxpemVfYnJhaW5LZXkoYnJhaW5LZXkpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIGJyYWluS2V5ID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0cmluZyByZXF1aXJlZCBmb3IgYnJhaW5LZXlcIik7XG4gICAgICAgIH1cblxuICAgICAgICBicmFpbktleSA9IGJyYWluS2V5LnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIGJyYWluS2V5LnNwbGl0KC9bXFx0XFxuXFx2XFxmXFxyIF0rLykuam9pbignICcpO1xuICAgIH0sXG4gICAgYnJvd3NlckVudHJvcHk6IGZ1bmN0aW9uIGJyb3dzZXJFbnRyb3B5KCkge1xuXG4gICAgICAgIHZhciBlbnRyb3B5U3RyID0gXCJcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVudHJvcHlTdHIgPSBuZXcgRGF0ZSgpLnRvU3RyaW5nKCkgKyBcIiBcIiArIHdpbmRvdy5zY3JlZW4uaGVpZ2h0ICsgXCIgXCIgKyB3aW5kb3cuc2NyZWVuLndpZHRoICsgXCIgXCIgKyB3aW5kb3cuc2NyZWVuLmNvbG9yRGVwdGggKyBcIiBcIiArIFwiIFwiICsgd2luZG93LnNjcmVlbi5hdmFpbEhlaWdodCArIFwiIFwiICsgd2luZG93LnNjcmVlbi5hdmFpbFdpZHRoICsgXCIgXCIgKyB3aW5kb3cuc2NyZWVuLnBpeGVsRGVwdGggKyBuYXZpZ2F0b3IubGFuZ3VhZ2UgKyBcIiBcIiArIHdpbmRvdy5sb2NhdGlvbiArIFwiIFwiICsgd2luZG93Lmhpc3RvcnkubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbWltZVR5cGU7IGkgPCBuYXZpZ2F0b3IubWltZVR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWltZVR5cGUgPSBuYXZpZ2F0b3IubWltZVR5cGVzW2ldO1xuICAgICAgICAgICAgICAgIGVudHJvcHlTdHIgKz0gbWltZVR5cGUuZGVzY3JpcHRpb24gKyBcIiBcIiArIG1pbWVUeXBlLnR5cGUgKyBcIiBcIiArIG1pbWVUeXBlLnN1ZmZpeGVzICsgXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIklORk9cXHRicm93c2VyRW50cm9weSBnYXRoZXJlZFwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vbm9kZWpzOlJlZmVyZW5jZUVycm9yOiB3aW5kb3cgaXMgbm90IGRlZmluZWRcbiAgICAgICAgICAgIGVudHJvcHlTdHIgPSBoYXNoLnNoYTI1NihuZXcgRGF0ZSgpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGIgPSBuZXcgQnVmZmVyKGVudHJvcHlTdHIpO1xuICAgICAgICBlbnRyb3B5U3RyICs9IGIudG9TdHJpbmcoJ2JpbmFyeScpICsgXCIgXCIgKyBuZXcgRGF0ZSgpLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBlbnRyb3B5U3RyO1xuICAgIH0sXG5cblxuICAgIC8vIEByZXR1cm4gYXJyYXkgb2YgNSBsZWdhY3kgYWRkcmVzc2VzIGZvciBhIHB1YmtleSBzdHJpbmcgcGFyYW1ldGVyLlxuICAgIGFkZHJlc3NlczogZnVuY3Rpb24gYWRkcmVzc2VzKHB1YmtleSkge1xuICAgICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IENoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4O1xuXG4gICAgICAgIHZhciBwdWJsaWNfa2V5ID0gUHVibGljS2V5LmZyb21QdWJsaWNLZXlTdHJpbmcocHVia2V5LCBhZGRyZXNzX3ByZWZpeCk7XG4gICAgICAgIC8vIFMgTCBPIFdcbiAgICAgICAgdmFyIGFkZHJlc3Nfc3RyaW5nID0gW0FkZHJlc3MuZnJvbVB1YmxpYyhwdWJsaWNfa2V5LCBmYWxzZSwgMCkudG9TdHJpbmcoYWRkcmVzc19wcmVmaXgpLCAvLyBidGNfdW5jb21wcmVzc2VkXG4gICAgICAgIEFkZHJlc3MuZnJvbVB1YmxpYyhwdWJsaWNfa2V5LCB0cnVlLCAwKS50b1N0cmluZyhhZGRyZXNzX3ByZWZpeCksIC8vIGJ0Y19jb21wcmVzc2VkXG4gICAgICAgIEFkZHJlc3MuZnJvbVB1YmxpYyhwdWJsaWNfa2V5LCBmYWxzZSwgNTYpLnRvU3RyaW5nKGFkZHJlc3NfcHJlZml4KSwgLy8gcHRzX3VuY29tcHJlc3NlZFxuICAgICAgICBBZGRyZXNzLmZyb21QdWJsaWMocHVibGljX2tleSwgdHJ1ZSwgNTYpLnRvU3RyaW5nKGFkZHJlc3NfcHJlZml4KSwgLy8gcHRzX2NvbXByZXNzZWRcbiAgICAgICAgcHVibGljX2tleS50b0FkZHJlc3NTdHJpbmcoYWRkcmVzc19wcmVmaXgpIC8vIGJ0c19zaG9ydCwgbW9zdCByZWNlbnQgZm9ybWF0XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBhZGRyZXNzX3N0cmluZztcbiAgICB9XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9lY2Mvc3JjL0tleVV0aWxzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvZWNjL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGVjdXJ2ZSA9IHJlcXVpcmUoJ2VjdXJ2ZScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdlY3VydmUnKTtcblxudmFyIFBvaW50ID0gX3JlcXVpcmUuUG9pbnQ7XG52YXIgZ2V0Q3VydmVCeU5hbWUgPSBfcmVxdWlyZS5nZXRDdXJ2ZUJ5TmFtZTtcblxudmFyIHNlY3AyNTZrMSA9IGdldEN1cnZlQnlOYW1lKCdzZWNwMjU2azEnKTtcbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgnYnM1OCcpO1xuXG52YXIgZW5jb2RlID0gX3JlcXVpcmUyLmVuY29kZTtcbnZhciBkZWNvZGUgPSBfcmVxdWlyZTIuZGVjb2RlO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgaGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpO1xudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vUHVibGljS2V5Jyk7XG52YXIgZGVlcEVxdWFsID0gcmVxdWlyZShcImRlZXAtZXF1YWxcIik7XG5cbnZhciBHID0gc2VjcDI1NmsxLkc7XG52YXIgbiA9IHNlY3AyNTZrMS5uO1xuXG52YXIgUHJpdmF0ZUtleSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAgICBAcHJpdmF0ZSBzZWUgc3RhdGljIGZ1bmN0aW9uc1xuICAgICAgICBAcGFyYW0ge0JpZ0ludGVnZXJ9XG4gICAgKi9cbiAgICBmdW5jdGlvbiBQcml2YXRlS2V5KGQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByaXZhdGVLZXkpO1xuXG4gICAgICAgIHRoaXMuZCA9IGQ7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFByaXZhdGVLZXksIFt7XG4gICAgICAgIGtleTogJ3RvV2lmJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvV2lmKCkge1xuICAgICAgICAgICAgdmFyIHByaXZhdGVfa2V5ID0gdGhpcy50b0J1ZmZlcigpO1xuICAgICAgICAgICAgLy8gY2hlY2tzdW0gaW5jbHVkZXMgdGhlIHZlcnNpb25cbiAgICAgICAgICAgIHByaXZhdGVfa2V5ID0gQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihbMHg4MF0pLCBwcml2YXRlX2tleV0pO1xuICAgICAgICAgICAgdmFyIGNoZWNrc3VtID0gaGFzaC5zaGEyNTYocHJpdmF0ZV9rZXkpO1xuICAgICAgICAgICAgY2hlY2tzdW0gPSBoYXNoLnNoYTI1NihjaGVja3N1bSk7XG4gICAgICAgICAgICBjaGVja3N1bSA9IGNoZWNrc3VtLnNsaWNlKDAsIDQpO1xuICAgICAgICAgICAgdmFyIHByaXZhdGVfd2lmID0gQnVmZmVyLmNvbmNhdChbcHJpdmF0ZV9rZXksIGNoZWNrc3VtXSk7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlKHByaXZhdGVfd2lmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgQHJldHVybiB7UG9pbnR9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvUHVibGljS2V5UG9pbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9QdWJsaWNLZXlQb2ludCgpIHtcbiAgICAgICAgICAgIHZhciBRO1xuICAgICAgICAgICAgcmV0dXJuIFEgPSBzZWNwMjU2azEuRy5tdWx0aXBseSh0aGlzLmQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1B1YmxpY0tleScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1B1YmxpY0tleSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnB1YmxpY19rZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNfa2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVibGljX2tleSA9IFB1YmxpY0tleS5mcm9tUG9pbnQodGhpcy50b1B1YmxpY0tleVBvaW50KCkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0J1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmQudG9CdWZmZXIoMzIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEVDSUVTICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldF9zaGFyZWRfc2VjcmV0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldF9zaGFyZWRfc2VjcmV0KHB1YmxpY19rZXkpIHtcbiAgICAgICAgICAgIHZhciBsZWdhY3kgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICAgICAgICBwdWJsaWNfa2V5ID0gdG9QdWJsaWMocHVibGljX2tleSk7XG4gICAgICAgICAgICB2YXIgS0IgPSBwdWJsaWNfa2V5LnRvVW5jb21wcmVzc2VkKCkudG9CdWZmZXIoKTtcbiAgICAgICAgICAgIHZhciBLQlAgPSBQb2ludC5mcm9tQWZmaW5lKHNlY3AyNTZrMSwgQmlnSW50ZWdlci5mcm9tQnVmZmVyKEtCLnNsaWNlKDEsIDMzKSksIC8vIHhcbiAgICAgICAgICAgIEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihLQi5zbGljZSgzMywgNjUpKSAvLyB5XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLnRvQnVmZmVyKCk7XG4gICAgICAgICAgICB2YXIgUCA9IEtCUC5tdWx0aXBseShCaWdJbnRlZ2VyLmZyb21CdWZmZXIocikpO1xuICAgICAgICAgICAgdmFyIFMgPSBQLmFmZmluZVgudG9CdWZmZXIoeyBzaXplOiAzMiB9KTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICB0aGUgaW5wdXQgdG8gc2hhNTEyIG11c3QgYmUgZXhhY3RseSAzMi1ieXRlcywgdG8gbWF0Y2ggdGhlIGMrKyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgb2YgZ2V0X3NoYXJlZF9zZWNyZXQuICBSaWdodCBub3cgUyB3aWxsIGJlIHNob3J0ZXIgaWYgdGhlIG1vc3Qgc2lnbmlmaWNhbnRcbiAgICAgICAgICAgIGJ5dGUocykgaXMgemVyby4gIFBhZCBpdCBiYWNrIHRvIHRoZSBmdWxsIDMyLWJ5dGVzXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCFsZWdhY3kgJiYgUy5sZW5ndGggPCAzMikge1xuICAgICAgICAgICAgICAgIHBhZCA9IG5ldyBCdWZmZXIoMzIgLSBTLmxlbmd0aCkuZmlsbCgwKTtcbiAgICAgICAgICAgICAgICBTID0gQnVmZmVyLmNvbmNhdChbcGFkLCBTXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNIQTUxMiB1c2VkIGluIEVDSUVTXG4gICAgICAgICAgICByZXR1cm4gaGFzaC5zaGE1MTIoUyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAvKiogRUNJRVMgKGRvZXMgbm90IGFsd2F5cyBtYXRjaCB0aGUgUG9pbnQuZnJvbUFmZmluZSB2ZXJzaW9uIGFib3ZlKSAqL1xuICAgICAgICAvLyBnZXRfc2hhcmVkX3NlY3JldChwdWJsaWNfa2V5KXtcbiAgICAgICAgLy8gICAgIHB1YmxpY19rZXkgPSB0b1B1YmxpYyhwdWJsaWNfa2V5KVxuICAgICAgICAvLyAgICAgdmFyIFAgPSBwdWJsaWNfa2V5LlEubXVsdGlwbHkoIHRoaXMuZCApO1xuICAgICAgICAvLyAgICAgdmFyIFMgPSBQLmFmZmluZVgudG9CdWZmZXIoe3NpemU6IDMyfSk7XG4gICAgICAgIC8vICAgICAvLyBFQ0lFUywgYWRkcyBhbiBleHRyYSBzaGE1MTJcbiAgICAgICAgLy8gICAgIHJldHVybiBoYXNoLnNoYTUxMihTKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8qKiBAdGhyb3dzIHtFcnJvcn0gLSBvdmVyZmxvdyBvZiB0aGUga2V5IGNvdWxkIG5vdCBiZSBkZXJpdmVkICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoaWxkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoaWxkKG9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gQnVmZmVyLmNvbmNhdChbdGhpcy50b1B1YmxpY0tleSgpLnRvQnVmZmVyKCksIG9mZnNldF0pO1xuICAgICAgICAgICAgb2Zmc2V0ID0gaGFzaC5zaGEyNTYob2Zmc2V0KTtcbiAgICAgICAgICAgIHZhciBjID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKG9mZnNldCk7XG5cbiAgICAgICAgICAgIGlmIChjLmNvbXBhcmVUbyhuKSA+PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBvZmZzZXQgd2VudCBvdXQgb2YgYm91bmRzLCB0cnkgYWdhaW5cIik7XG5cbiAgICAgICAgICAgIHZhciBkZXJpdmVkID0gdGhpcy5kLmFkZChjKTsgLy8ubW9kKG4pXG5cbiAgICAgICAgICAgIGlmIChkZXJpdmVkLnNpZ251bSgpID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBvZmZzZXQgZGVyaXZlZCB0byBhbiBpbnZhbGlkIGtleSwgdHJ5IGFnYWluXCIpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByaXZhdGVLZXkoZGVyaXZlZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiA8aGVscGVyX2Z1bmN0aW9ucz4gKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9CeXRlQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQnl0ZUJ1ZmZlcigpIHtcbiAgICAgICAgICAgIHZhciBiID0gbmV3IEJ5dGVCdWZmZXIoQnl0ZUJ1ZmZlci5ERUZBVUxUX0NBUEFDSVRZLCBCeXRlQnVmZmVyLkxJVFRMRV9FTkRJQU4pO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRCeXRlQnVmZmVyKGIpO1xuICAgICAgICAgICAgcmV0dXJuIGIuY29weSgwLCBiLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvSGV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiA8L2hlbHBlcl9mdW5jdGlvbnM+ICovXG5cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiAnZnJvbUJ1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQnVmZmVyKGJ1Zikge1xuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGluZyBwYXJhbXRlciB0byBiZSBhIEJ1ZmZlciB0eXBlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDMyICE9PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dBUk46IEV4cGVjdGluZyAzMiBieXRlcywgaW5zdGVhZCBnb3QgJyArIGJ1Zi5sZW5ndGggKyAnLCBzdGFjayB0cmFjZTonLCBuZXcgRXJyb3IoKS5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVtcHR5IGJ1ZmZlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJpdmF0ZUtleShCaWdJbnRlZ2VyLmZyb21CdWZmZXIoYnVmKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQGFyZyB7c3RyaW5nfSBzZWVkIC0gYW55IGxlbmd0aCBzdHJpbmcuICBUaGlzIGlzIHByaXZhdGUsIHRoZSBzYW1lIHNlZWQgcHJvZHVjZXMgdGhlIHNhbWUgcHJpdmF0ZSBrZXkgZXZlcnkgdGltZS4gICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21TZWVkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TZWVkKHNlZWQpIHtcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlX3ByaXZhdGVfa2V5XG4gICAgICAgICAgICBpZiAoISh0eXBlb2Ygc2VlZCA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWVkIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcml2YXRlS2V5LmZyb21CdWZmZXIoaGFzaC5zaGEyNTYoc2VlZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4ge3N0cmluZ30gV2FsbGV0IEltcG9ydCBGb3JtYXQgKHN0aWxsIGEgc2VjcmV0LCBOb3QgZW5jcnlwdGVkKSAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tV2lmJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21XaWYoX3ByaXZhdGVfd2lmKSB7XG4gICAgICAgICAgICB2YXIgcHJpdmF0ZV93aWYgPSBuZXcgQnVmZmVyKGRlY29kZShfcHJpdmF0ZV93aWYpKTtcbiAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gcHJpdmF0ZV93aWYucmVhZFVJbnQ4KDApO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKDB4ODAsIHZlcnNpb24sICdFeHBlY3RlZCB2ZXJzaW9uICcgKyAweDgwICsgJywgaW5zdGVhZCBnb3QgJyArIHZlcnNpb24pO1xuICAgICAgICAgICAgLy8gY2hlY2tzdW0gaW5jbHVkZXMgdGhlIHZlcnNpb25cbiAgICAgICAgICAgIHZhciBwcml2YXRlX2tleSA9IHByaXZhdGVfd2lmLnNsaWNlKDAsIC00KTtcbiAgICAgICAgICAgIHZhciBjaGVja3N1bSA9IHByaXZhdGVfd2lmLnNsaWNlKC00KTtcbiAgICAgICAgICAgIHZhciBuZXdfY2hlY2tzdW0gPSBoYXNoLnNoYTI1Nihwcml2YXRlX2tleSk7XG4gICAgICAgICAgICBuZXdfY2hlY2tzdW0gPSBoYXNoLnNoYTI1NihuZXdfY2hlY2tzdW0pO1xuICAgICAgICAgICAgbmV3X2NoZWNrc3VtID0gbmV3X2NoZWNrc3VtLnNsaWNlKDAsIDQpO1xuICAgICAgICAgICAgdmFyIGlzRXF1YWwgPSBkZWVwRXF1YWwoY2hlY2tzdW0sIG5ld19jaGVja3N1bSk7IC8vLCAnSW52YWxpZCBjaGVja3N1bSdcbiAgICAgICAgICAgIGlmICghaXNFcXVhbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoZWNrc3VtIGRpZCBub3QgbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcml2YXRlX2tleSA9IHByaXZhdGVfa2V5LnNsaWNlKDEpO1xuICAgICAgICAgICAgcmV0dXJuIFByaXZhdGVLZXkuZnJvbUJ1ZmZlcihwcml2YXRlX2tleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21IZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcml2YXRlS2V5LmZyb21CdWZmZXIobmV3IEJ1ZmZlcihoZXgsICdoZXgnKSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUHJpdmF0ZUtleTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcml2YXRlS2V5O1xuXG52YXIgdG9QdWJsaWMgPSBmdW5jdGlvbiB0b1B1YmxpYyhkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgPT0gbnVsbCA/IGRhdGEgOiBkYXRhLlEgPyBkYXRhIDogUHVibGljS2V5LmZyb21TdHJpbmdPclRocm93KGRhdGEpO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvZWNjL3NyYy9Qcml2YXRlS2V5LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvZWNjL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCdiaWdpJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2VjdXJ2ZScpO1xuXG52YXIgUG9pbnQgPSBfcmVxdWlyZS5Qb2ludDtcbnZhciBnZXRDdXJ2ZUJ5TmFtZSA9IF9yZXF1aXJlLmdldEN1cnZlQnlOYW1lO1xuXG52YXIgc2VjcDI1NmsxID0gZ2V0Q3VydmVCeU5hbWUoJ3NlY3AyNTZrMScpO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgnYnM1OCcpO1xuXG52YXIgZW5jb2RlID0gX3JlcXVpcmUyLmVuY29kZTtcbnZhciBkZWNvZGUgPSBfcmVxdWlyZTIuZGVjb2RlO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpO1xudmFyIENoYWluQ29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NoYWluL3NyYy9DaGFpbkNvbmZpZ1wiKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBkZWVwRXF1YWwgPSByZXF1aXJlKFwiZGVlcC1lcXVhbFwiKTtcblxudmFyIEcgPSBzZWNwMjU2azEuRztcbnZhciBuID0gc2VjcDI1NmsxLm47XG5cbnZhciBQdWJsaWNLZXkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKiogQHBhcmFtIHtQb2ludH0gcHVibGljIGtleSAqL1xuICAgIGZ1bmN0aW9uIFB1YmxpY0tleShRKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQdWJsaWNLZXkpO1xuXG4gICAgICAgIHRoaXMuUSA9IFE7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFB1YmxpY0tleSwgW3tcbiAgICAgICAga2V5OiAndG9CdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9CdWZmZXIoKSB7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3NlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5RID8gdGhpcy5RLmNvbXByZXNzZWQgOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5RID09PSBudWxsKSByZXR1cm4gbmV3IEJ1ZmZlcignMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywgJ2hleCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuUS5nZXRFbmNvZGVkKGNvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1VuY29tcHJlc3NlZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1VuY29tcHJlc3NlZCgpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSB0aGlzLlEuZ2V0RW5jb2RlZChmYWxzZSk7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBQb2ludC5kZWNvZGVGcm9tKHNlY3AyNTZrMSwgYnVmKTtcbiAgICAgICAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbVBvaW50KHBvaW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBidHM6OmJsb2NrY2hhaW46OmFkZHJlc3MgKHVuaXF1ZSBidXQgbm90IGEgZnVsbCBwdWJsaWMga2V5KSAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0Jsb2NrY2hhaW5BZGRyZXNzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQmxvY2tjaGFpbkFkZHJlc3MoKSB7XG4gICAgICAgICAgICB2YXIgcHViX2J1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICAgICAgICAgIHZhciBwdWJfc2hhID0gaGFzaC5zaGE1MTIocHViX2J1Zik7XG4gICAgICAgICAgICByZXR1cm4gaGFzaC5yaXBlbWQxNjAocHViX3NoYSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQWxpYXMgZm9yIHtAbGluayB0b1B1YmxpY0tleVN0cmluZ30gKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9TdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IENoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1B1YmxpY0tleVN0cmluZyhhZGRyZXNzX3ByZWZpeCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICAgIEZ1bGwgcHVibGljIGtleVxuICAgICAgICAgICAge3JldHVybn0gc3RyaW5nXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvUHVibGljS2V5U3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvUHVibGljS2V5U3RyaW5nKCkge1xuICAgICAgICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBDaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeDtcblxuICAgICAgICAgICAgdmFyIHB1Yl9idWYgPSB0aGlzLnRvQnVmZmVyKCk7XG4gICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBoYXNoLnJpcGVtZDE2MChwdWJfYnVmKTtcbiAgICAgICAgICAgIHZhciBhZGR5ID0gQnVmZmVyLmNvbmNhdChbcHViX2J1ZiwgY2hlY2tzdW0uc2xpY2UoMCwgNCldKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzX3ByZWZpeCArIGVuY29kZShhZGR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfSBwdWJsaWNfa2V5IC0gbGlrZSBHUEhYeXouLi5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gYWRkcmVzc19wcmVmaXggLSBsaWtlIEdQSFxuICAgICAgICAgICAgQHJldHVybiBQdWJsaWNLZXkgb3IgYG51bGxgIChpZiB0aGUgcHVibGljX2tleSBzdHJpbmcgaXMgaW52YWxpZClcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9BZGRyZXNzU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQWRkcmVzc1N0cmluZygpIHtcbiAgICAgICAgICAgIHZhciBhZGRyZXNzX3ByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogQ2hhaW5Db25maWcuYWRkcmVzc19wcmVmaXg7XG5cbiAgICAgICAgICAgIHZhciBwdWJfYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICAgICAgICAgICAgdmFyIHB1Yl9zaGEgPSBoYXNoLnNoYTUxMihwdWJfYnVmKTtcbiAgICAgICAgICAgIHZhciBhZGR5ID0gaGFzaC5yaXBlbWQxNjAocHViX3NoYSk7XG4gICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBoYXNoLnJpcGVtZDE2MChhZGR5KTtcbiAgICAgICAgICAgIGFkZHkgPSBCdWZmZXIuY29uY2F0KFthZGR5LCBjaGVja3N1bS5zbGljZSgwLCA0KV0pO1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3NfcHJlZml4ICsgZW5jb2RlKGFkZHkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1B0c0FkZHknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9QdHNBZGR5KCkge1xuICAgICAgICAgICAgdmFyIHB1Yl9idWYgPSB0aGlzLnRvQnVmZmVyKCk7XG4gICAgICAgICAgICB2YXIgcHViX3NoYSA9IGhhc2guc2hhMjU2KHB1Yl9idWYpO1xuICAgICAgICAgICAgdmFyIGFkZHkgPSBoYXNoLnJpcGVtZDE2MChwdWJfc2hhKTtcbiAgICAgICAgICAgIGFkZHkgPSBCdWZmZXIuY29uY2F0KFtuZXcgQnVmZmVyKFsweDM4XSksIGFkZHldKTsgLy92ZXJzaW9uIDU2KGRlY2ltYWwpXG5cbiAgICAgICAgICAgIHZhciBjaGVja3N1bSA9IGhhc2guc2hhMjU2KGFkZHkpO1xuICAgICAgICAgICAgY2hlY2tzdW0gPSBoYXNoLnNoYTI1NihjaGVja3N1bSk7XG5cbiAgICAgICAgICAgIGFkZHkgPSBCdWZmZXIuY29uY2F0KFthZGR5LCBjaGVja3N1bS5zbGljZSgwLCA0KV0pO1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZShhZGR5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hpbGQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hpbGQob2Zmc2V0KSB7XG5cbiAgICAgICAgICAgIGFzc2VydChCdWZmZXIuaXNCdWZmZXIob2Zmc2V0KSwgXCJCdWZmZXIgcmVxdWlyZWQ6IG9mZnNldFwiKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChvZmZzZXQubGVuZ3RoLCAzMiwgXCJvZmZzZXQgbGVuZ3RoXCIpO1xuXG4gICAgICAgICAgICBvZmZzZXQgPSBCdWZmZXIuY29uY2F0KFt0aGlzLnRvQnVmZmVyKCksIG9mZnNldF0pO1xuICAgICAgICAgICAgb2Zmc2V0ID0gaGFzaC5zaGEyNTYob2Zmc2V0KTtcblxuICAgICAgICAgICAgdmFyIGMgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIob2Zmc2V0KTtcblxuICAgICAgICAgICAgaWYgKGMuY29tcGFyZVRvKG4pID49IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG9mZnNldCB3ZW50IG91dCBvZiBib3VuZHMsIHRyeSBhZ2FpblwiKTtcblxuICAgICAgICAgICAgdmFyIGNHID0gRy5tdWx0aXBseShjKTtcbiAgICAgICAgICAgIHZhciBRcHJpbWUgPSB0aGlzLlEuYWRkKGNHKTtcblxuICAgICAgICAgICAgaWYgKHNlY3AyNTZrMS5pc0luZmluaXR5KFFwcmltZSkpIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG9mZnNldCBkZXJpdmVkIHRvIGFuIGludmFsaWQga2V5LCB0cnkgYWdhaW5cIik7XG5cbiAgICAgICAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbVBvaW50KFFwcmltZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiA8SEVYPiAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0J5dGVCdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9CeXRlQnVmZmVyKCkge1xuICAgICAgICAgICAgdmFyIGIgPSBuZXcgQnl0ZUJ1ZmZlcihCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFksIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTik7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEJ5dGVCdWZmZXIoYik7XG4gICAgICAgICAgICByZXR1cm4gYi5jb3B5KDAsIGIub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9IZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9IZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAgICBrZXk6ICdmcm9tQmluYXJ5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21CaW5hcnkoYmluKSB7XG4gICAgICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21CdWZmZXIobmV3IEJ1ZmZlcihiaW4sICdiaW5hcnknKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21CdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChidWZmZXIudG9TdHJpbmcoJ2hleCcpID09PSAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJykgcmV0dXJuIG5ldyBQdWJsaWNLZXkobnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFB1YmxpY0tleShQb2ludC5kZWNvZGVGcm9tKHNlY3AyNTZrMSwgYnVmZmVyKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21Qb2ludCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUG9pbnQocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KHBvaW50KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbVB1YmxpY0tleVN0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUHVibGljS2V5U3RyaW5nKHB1YmxpY19rZXkpIHtcbiAgICAgICAgICAgIHZhciBhZGRyZXNzX3ByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogQ2hhaW5Db25maWcuYWRkcmVzc19wcmVmaXg7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tU3RyaW5nT3JUaHJvdyhwdWJsaWNfa2V5LCBhZGRyZXNzX3ByZWZpeCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gcHVibGljX2tleSAtIGxpa2UgR1BIWHl6Li4uXG4gICAgICAgICAgICBAYXJnIHtzdHJpbmd9IGFkZHJlc3NfcHJlZml4IC0gbGlrZSBHUEhcbiAgICAgICAgICAgIEB0aHJvd3Mge0Vycm9yfSBpZiBwdWJsaWMga2V5IGlzIGludmFsaWRcbiAgICAgICAgICAgIEByZXR1cm4gUHVibGljS2V5XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21TdHJpbmdPclRocm93JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TdHJpbmdPclRocm93KHB1YmxpY19rZXkpIHtcbiAgICAgICAgICAgIHZhciBhZGRyZXNzX3ByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogQ2hhaW5Db25maWcuYWRkcmVzc19wcmVmaXg7XG5cbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBwdWJsaWNfa2V5LnNsaWNlKDAsIGFkZHJlc3NfcHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoYWRkcmVzc19wcmVmaXgsIHByZWZpeCwgJ0V4cGVjdGluZyBrZXkgdG8gYmVnaW4gd2l0aCAnICsgYWRkcmVzc19wcmVmaXggKyAnLCBpbnN0ZWFkIGdvdCAnICsgcHJlZml4KTtcbiAgICAgICAgICAgIHB1YmxpY19rZXkgPSBwdWJsaWNfa2V5LnNsaWNlKGFkZHJlc3NfcHJlZml4Lmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHB1YmxpY19rZXkgPSBuZXcgQnVmZmVyKGRlY29kZShwdWJsaWNfa2V5KSwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgdmFyIGNoZWNrc3VtID0gcHVibGljX2tleS5zbGljZSgtNCk7XG4gICAgICAgICAgICBwdWJsaWNfa2V5ID0gcHVibGljX2tleS5zbGljZSgwLCAtNCk7XG4gICAgICAgICAgICB2YXIgbmV3X2NoZWNrc3VtID0gaGFzaC5yaXBlbWQxNjAocHVibGljX2tleSk7XG4gICAgICAgICAgICBuZXdfY2hlY2tzdW0gPSBuZXdfY2hlY2tzdW0uc2xpY2UoMCwgNCk7XG4gICAgICAgICAgICB2YXIgaXNFcXVhbCA9IGRlZXBFcXVhbChjaGVja3N1bSwgbmV3X2NoZWNrc3VtKTsgLy8sICdJbnZhbGlkIGNoZWNrc3VtJ1xuICAgICAgICAgICAgaWYgKCFpc0VxdWFsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hlY2tzdW0gZGlkIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbUJ1ZmZlcihwdWJsaWNfa2V5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbUhleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tQnVmZmVyKG5ldyBCdWZmZXIoaGV4LCAnaGV4JykpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tUHVibGljS2V5U3RyaW5nSGV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21QdWJsaWNLZXlTdHJpbmdIZXgoaGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21QdWJsaWNLZXlTdHJpbmcobmV3IEJ1ZmZlcihoZXgsICdoZXgnKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiA8L0hFWD4gKi9cblxuICAgIH1dKTtcblxuICAgIHJldHVybiBQdWJsaWNLZXk7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHVibGljS2V5O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9lY2Mvc3JjL1B1YmxpY0tleS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L2VjYy9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBDaGFpbkNvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jaGFpbi9zcmMvQ2hhaW5Db25maWdcIik7XG52YXIgaGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdiczU4Jyk7XG5cbnZhciBlbmNvZGUgPSBfcmVxdWlyZS5lbmNvZGU7XG52YXIgZGVjb2RlID0gX3JlcXVpcmUuZGVjb2RlO1xuXG52YXIgZGVlcEVxdWFsID0gcmVxdWlyZShcImRlZXAtZXF1YWxcIik7XG5cbi8qKiBBZGRyZXNzZXMgYXJlIHNob3J0ZW5lZCBub24tcmV2ZXJzYWJsZSBoYXNoZXMgb2YgYSBwdWJsaWMga2V5LiAgVGhlIGZ1bGwgUHVibGljS2V5IGlzIHByZWZlcnJlZC5cbiAgICBAZGVwcmVjYXRlZFxuKi9cblxudmFyIEFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWRkcmVzcyhhZGR5KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBZGRyZXNzKTtcblxuICAgICAgICB0aGlzLmFkZHkgPSBhZGR5O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhBZGRyZXNzLCBbe1xuICAgICAgICBrZXk6ICd0b0J1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZHk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBDaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeDtcblxuICAgICAgICAgICAgdmFyIGNoZWNrc3VtID0gaGFzaC5yaXBlbWQxNjAodGhpcy5hZGR5KTtcbiAgICAgICAgICAgIHZhciBhZGR5ID0gQnVmZmVyLmNvbmNhdChbdGhpcy5hZGR5LCBjaGVja3N1bS5zbGljZSgwLCA0KV0pO1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3NfcHJlZml4ICsgZW5jb2RlKGFkZHkpO1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2Zyb21CdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgICAgIHZhciBfaGFzaCA9IGhhc2guc2hhNTEyKGJ1ZmZlcik7XG4gICAgICAgICAgICB2YXIgYWRkeSA9IGhhc2gucmlwZW1kMTYwKF9oYXNoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWRkcmVzcyhhZGR5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbVN0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBDaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeDtcblxuICAgICAgICAgICAgdmFyIHByZWZpeCA9IHN0cmluZy5zbGljZSgwLCBhZGRyZXNzX3ByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFkZHJlc3NfcHJlZml4LCBwcmVmaXgsICdFeHBlY3Rpbmcga2V5IHRvIGJlZ2luIHdpdGggJyArIGFkZHJlc3NfcHJlZml4ICsgJywgaW5zdGVhZCBnb3QgJyArIHByZWZpeCk7XG4gICAgICAgICAgICB2YXIgYWRkeSA9IHN0cmluZy5zbGljZShhZGRyZXNzX3ByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgYWRkeSA9IG5ldyBCdWZmZXIoZGVjb2RlKGFkZHkpLCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBhZGR5LnNsaWNlKC00KTtcbiAgICAgICAgICAgIGFkZHkgPSBhZGR5LnNsaWNlKDAsIC00KTtcbiAgICAgICAgICAgIHZhciBuZXdfY2hlY2tzdW0gPSBoYXNoLnJpcGVtZDE2MChhZGR5KTtcbiAgICAgICAgICAgIG5ld19jaGVja3N1bSA9IG5ld19jaGVja3N1bS5zbGljZSgwLCA0KTtcbiAgICAgICAgICAgIHZhciBpc0VxdWFsID0gZGVlcEVxdWFsKGNoZWNrc3VtLCBuZXdfY2hlY2tzdW0pOyAvLywgJ0ludmFsaWQgY2hlY2tzdW0nXG4gICAgICAgICAgICBpZiAoIWlzRXF1YWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGVja3N1bSBkaWQgbm90IG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKGFkZHkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tUHVibGljJyxcblxuXG4gICAgICAgIC8qKiBAcmV0dXJuIEFkZHJlc3MgLSBDb21wcmVzc2VkIFBUUyBmb3JtYXQgKGJ5IGRlZmF1bHQpICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUHVibGljKHB1YmxpY19rZXkpIHtcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2VkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgICAgICAgdmFyIHZlcnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDU2O1xuXG4gICAgICAgICAgICB2YXIgc2hhMiA9IGhhc2guc2hhMjU2KHB1YmxpY19rZXkudG9CdWZmZXIoY29tcHJlc3NlZCkpO1xuICAgICAgICAgICAgdmFyIHJlcCA9IGhhc2gucmlwZW1kMTYwKHNoYTIpO1xuICAgICAgICAgICAgdmFyIHZlcnNpb25CdWZmZXIgPSBuZXcgQnVmZmVyKDEpO1xuICAgICAgICAgICAgdmVyc2lvbkJ1ZmZlci53cml0ZVVJbnQ4KDB4RkYgJiB2ZXJzaW9uLCAwKTtcbiAgICAgICAgICAgIHZhciBhZGRyID0gQnVmZmVyLmNvbmNhdChbdmVyc2lvbkJ1ZmZlciwgcmVwXSk7XG4gICAgICAgICAgICB2YXIgY2hlY2sgPSBoYXNoLnNoYTI1NihhZGRyKTtcbiAgICAgICAgICAgIGNoZWNrID0gaGFzaC5zaGEyNTYoY2hlY2spO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2FkZHIsIGNoZWNrLnNsaWNlKDAsIDQpXSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoaGFzaC5yaXBlbWQxNjAoYnVmZmVyKSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQWRkcmVzcztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZGRyZXNzO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9lY2Mvc3JjL2FkZHJlc3MuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9lY2Mvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzXG52YXIgQUVTID0gcmVxdWlyZShcImNyeXB0by1qcy9hZXNcIik7XG52YXIgZW5jSGV4ID0gcmVxdWlyZShcImNyeXB0by1qcy9lbmMtaGV4XCIpO1xudmFyIGVuY0Jhc2U2NCA9IHJlcXVpcmUoXCJjcnlwdG8tanMvZW5jLWJhc2U2NFwiKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiYnl0ZWJ1ZmZlclwiKTtcblxudmFyIExvbmcgPSBfcmVxdWlyZS5Mb25nO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpO1xuXG4vKiogUHJvdmlkZXMgc3ltZXRyaWMgZW5jcnlwdCBhbmQgZGVjcnlwdCB2aWEgQUVTLiAqL1xuXG52YXIgQWVzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gQWVzKGl2LCBrZXkpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFlcyk7XG5cbiAgICAgICAgdGhpcy5pdiA9IGl2LCB0aGlzLmtleSA9IGtleTtcbiAgICB9XG5cbiAgICAvKiogVGhpcyBpcyBhbiBleGNlbGxlbnQgd2F5IHRvIGVuc3VyZSB0aGF0IGFsbCByZWZlcmVuY2VzIHRvIEFlcyBjYW4gbm90IG9wZXJhdGUgYW55bW9yZSAoZXhhbXBsZTogYSB3YWxsZXQgYmVjb21lcyBsb2NrZWQpLiAgQW4gYXBwbGljYXRpb24gc2hvdWxkIGVuc3VyZSB0aGVyZSBpcyBvbmx5IG9uZSBBZXMgb2JqZWN0IGluc3RhbmNlIGZvciBhIGdpdmVuIHNlY3JldCBgc2VlZGAuICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhBZXMsIFt7XG4gICAgICAgIGtleTogXCJjbGVhclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdiA9IHRoaXMua2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBhcmcge3N0cmluZ30gc2VlZCAtIHNlY3JldCBzZWVkIG1heSBiZSB1c2VkIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC4gKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9kZWNyeXB0X3dvcmRfYXJyYXlcIixcblxuXG4gICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlY3J5cHRfd29yZF9hcnJheShjaXBoZXIpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzLyNDdXN0b21fS2V5X2FuZF9JVlxuICAgICAgICAgICAgLy8gc2VlIHdhbGxldF9yZWNvcmRzLmNwcCBtYXN0ZXJfa2V5OjpkZWNyeXB0X2tleVxuICAgICAgICAgICAgcmV0dXJuIEFFUy5kZWNyeXB0KHsgY2lwaGVydGV4dDogY2lwaGVyLCBzYWx0OiBudWxsIH0sIHRoaXMua2V5LCB7IGl2OiB0aGlzLml2IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBwcml2YXRlICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfZW5jcnlwdF93b3JkX2FycmF5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZW5jcnlwdF93b3JkX2FycmF5KHBsYWludGV4dCkge1xuICAgICAgICAgICAgLy9odHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy9pc3N1ZXMvZGV0YWlsP2lkPTg1XG4gICAgICAgICAgICB2YXIgY2lwaGVyID0gQUVTLmVuY3J5cHQocGxhaW50ZXh0LCB0aGlzLmtleSwgeyBpdjogdGhpcy5pdiB9KTtcbiAgICAgICAgICAgIHJldHVybiBlbmNCYXNlNjQucGFyc2UoY2lwaGVyLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVzZSBhIGNoZWNrc3VtLCB0aGUgcmV0dXJuZWQgZGF0YSBtdXN0IGJlIHZhbGlkYXRlZCBzb21lIG90aGVyIHdheS5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gY2lwaGVydGV4dFxuICAgICAgICAgICAgQHJldHVybiB7QnVmZmVyfSBiaW5hcnlcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlY3J5cHRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaXBoZXJ0ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dCA9IG5ldyBCdWZmZXIoY2lwaGVydGV4dCwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2lwaGVydGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJidWZmZXIgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoY2lwaGVydGV4dCwgXCJNaXNzaW5nIGNpcGhlciB0ZXh0XCIpO1xuICAgICAgICAgICAgLy8gaGV4IGlzIHRoZSBvbmx5IGNvbW1vbiBmb3JtYXRcbiAgICAgICAgICAgIHZhciBoZXggPSB0aGlzLmRlY3J5cHRIZXgoY2lwaGVydGV4dC50b1N0cmluZygnaGV4JykpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoaGV4LCAnaGV4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogVGhpcyBtZXRob2QgZG9lcyBub3QgdXNlIGEgY2hlY2tzdW0sIHRoZSByZXR1cm5lZCBkYXRhIG11c3QgYmUgdmFsaWRhdGVkIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfSBwbGFpbnRleHRcbiAgICAgICAgICAgIEByZXR1cm4ge0J1ZmZlcn0gYmluYXJ5XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJlbmNyeXB0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbGFpbnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBwbGFpbnRleHQgPSBuZXcgQnVmZmVyKHBsYWludGV4dCwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGxhaW50ZXh0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJ1ZmZlciByZXF1aXJlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vYXNzZXJ0IHBsYWludGV4dCwgXCJNaXNzaW5nIHBsYWluIHRleHRcIlxuICAgICAgICAgICAgLy8gaGV4IGlzIHRoZSBvbmx5IGNvbW1vbiBmb3JtYXRcbiAgICAgICAgICAgIHZhciBoZXggPSB0aGlzLmVuY3J5cHRIZXgocGxhaW50ZXh0LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihoZXgsICdoZXgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB1c2UgYSBjaGVja3N1bSwgdGhlIHJldHVybmVkIGRhdGEgbXVzdCBiZSB2YWxpZGF0ZWQgc29tZSBvdGhlciB3YXkuXG4gICAgICAgICAgICBAYXJnIHtzdHJpbmd8QnVmZmVyfSBwbGFpbnRleHRcbiAgICAgICAgICAgIEByZXR1cm4ge3N0cmluZ30gaGV4XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJlbmNyeXB0VG9IZXhcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuY3J5cHRUb0hleChwbGFpbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGxhaW50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcGxhaW50ZXh0ID0gbmV3IEJ1ZmZlcihwbGFpbnRleHQsICdiaW5hcnknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHBsYWludGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJidWZmZXIgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2Fzc2VydCBwbGFpbnRleHQsIFwiTWlzc2luZyBwbGFpbiB0ZXh0XCJcbiAgICAgICAgICAgIC8vIGhleCBpcyB0aGUgb25seSBjb21tb24gZm9ybWF0XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0SGV4KHBsYWludGV4dC50b1N0cmluZygnaGV4JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVzZSBhIGNoZWNrc3VtLCB0aGUgcmV0dXJuZWQgZGF0YSBtdXN0IGJlIHZhbGlkYXRlZCBzb21lIG90aGVyIHdheS5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gY2lwaGVyIC0gaGV4XG4gICAgICAgICAgICBAcmV0dXJuIHtzdHJpbmd9IGJpbmFyeSAoY291bGQgZWFzaWx5IGJlIHJlYWRhYmxlIHRleHQpXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJkZWNyeXB0SGV4XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyeXB0SGV4KGNpcGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0KGNpcGhlciwgXCJNaXNzaW5nIGNpcGhlciB0ZXh0XCIpO1xuICAgICAgICAgICAgLy8gQ29udmVydCBkYXRhIGludG8gd29yZCBhcnJheXMgKHVzZWQgYnkgQ3J5cHRvKVxuICAgICAgICAgICAgdmFyIGNpcGhlcl9hcnJheSA9IGVuY0hleC5wYXJzZShjaXBoZXIpO1xuICAgICAgICAgICAgdmFyIHBsYWlud29yZHMgPSB0aGlzLl9kZWNyeXB0X3dvcmRfYXJyYXkoY2lwaGVyX2FycmF5KTtcbiAgICAgICAgICAgIHJldHVybiBlbmNIZXguc3RyaW5naWZ5KHBsYWlud29yZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVzZSBhIGNoZWNrc3VtLCB0aGUgcmV0dXJuZWQgZGF0YSBtdXN0IGJlIHZhbGlkYXRlZCBzb21lIG90aGVyIHdheS5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gY2lwaGVyIC0gaGV4XG4gICAgICAgICAgICBAcmV0dXJuIHtCdWZmZXJ9IGVuY29kZWQgYXMgc3BlY2lmaWVkIGJ5IHRoZSBwYXJhbWV0ZXJcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlY3J5cHRIZXhUb0J1ZmZlclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVjcnlwdEhleFRvQnVmZmVyKGNpcGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0KGNpcGhlciwgXCJNaXNzaW5nIGNpcGhlciB0ZXh0XCIpO1xuICAgICAgICAgICAgLy8gQ29udmVydCBkYXRhIGludG8gd29yZCBhcnJheXMgKHVzZWQgYnkgQ3J5cHRvKVxuICAgICAgICAgICAgdmFyIGNpcGhlcl9hcnJheSA9IGVuY0hleC5wYXJzZShjaXBoZXIpO1xuICAgICAgICAgICAgdmFyIHBsYWlud29yZHMgPSB0aGlzLl9kZWNyeXB0X3dvcmRfYXJyYXkoY2lwaGVyX2FycmF5KTtcbiAgICAgICAgICAgIHZhciBwbGFpbmhleCA9IGVuY0hleC5zdHJpbmdpZnkocGxhaW53b3Jkcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihwbGFpbmhleCwgJ2hleCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVzZSBhIGNoZWNrc3VtLCB0aGUgcmV0dXJuZWQgZGF0YSBtdXN0IGJlIHZhbGlkYXRlZCBzb21lIG90aGVyIHdheS5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gY2lwaGVyIC0gaGV4XG4gICAgICAgICAgICBAYXJnIHtzdHJpbmd9IFtlbmNvZGluZyA9ICdiaW5hcnknXSAtIGEgdmFsaWQgQnVmZmVyIGVuY29kaW5nXG4gICAgICAgICAgICBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWQgYXMgc3BlY2lmaWVkIGJ5IHRoZSBwYXJhbWV0ZXJcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlY3J5cHRIZXhUb1RleHRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlY3J5cHRIZXhUb1RleHQoY2lwaGVyKSB7XG4gICAgICAgICAgICB2YXIgZW5jb2RpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdiaW5hcnknO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0SGV4VG9CdWZmZXIoY2lwaGVyKS50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogVGhpcyBtZXRob2QgZG9lcyBub3QgdXNlIGEgY2hlY2tzdW0sIHRoZSByZXR1cm5lZCBkYXRhIG11c3QgYmUgdmFsaWRhdGVkIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfSBwbGFpbmhleCAtIGhleCBmb3JtYXRcbiAgICAgICAgICAgIEByZXR1cm4ge1N0cmluZ30gaGV4XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJlbmNyeXB0SGV4XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNyeXB0SGV4KHBsYWluaGV4KSB7XG4gICAgICAgICAgICB2YXIgcGxhaW5fYXJyYXkgPSBlbmNIZXgucGFyc2UocGxhaW5oZXgpO1xuICAgICAgICAgICAgdmFyIGNpcGhlcl9hcnJheSA9IHRoaXMuX2VuY3J5cHRfd29yZF9hcnJheShwbGFpbl9hcnJheSk7XG4gICAgICAgICAgICByZXR1cm4gZW5jSGV4LnN0cmluZ2lmeShjaXBoZXJfYXJyYXkpO1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogXCJmcm9tU2VlZFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVNlZWQoc2VlZCkge1xuICAgICAgICAgICAgaWYgKHNlZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNlZWQgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2hhc2ggPSBoYXNoLnNoYTUxMihzZWVkKTtcbiAgICAgICAgICAgIF9oYXNoID0gX2hhc2gudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgLy8gREVCVUcgY29uc29sZS5sb2coJy4uLiBmcm9tU2VlZCBfaGFzaCcsX2hhc2gpXG4gICAgICAgICAgICByZXR1cm4gQWVzLmZyb21TaGE1MTIoX2hhc2gpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZnJvbVNoYTUxMlwiLFxuXG5cbiAgICAgICAgLyoqIEBhcmcge3N0cmluZ30gaGFzaCAtIEEgMTI4IGJ5dGUgaGV4IHN0cmluZywgdHlwaWNhbGx5IG9uZSB3b3VsZCBjYWxsIHtAbGluayBmcm9tU2VlZH0gaW5zdGVhZC4gKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TaGE1MTIoaGFzaCkge1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGhhc2gubGVuZ3RoLCAxMjgsIFwiQSBTaGE1MTIgaW4gSEVYIHNob3VsZCBiZSAxMjggY2hhcmFjdGVycyBsb25nLCBpbnN0ZWFkIGdvdCBcIiArIGhhc2gubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBpdiA9IGVuY0hleC5wYXJzZShoYXNoLnN1YnN0cmluZyg2NCwgOTYpKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBlbmNIZXgucGFyc2UoaGFzaC5zdWJzdHJpbmcoMCwgNjQpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWVzKGl2LCBrZXkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZnJvbUJ1ZmZlclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWYpIHtcbiAgICAgICAgICAgIGFzc2VydChCdWZmZXIuaXNCdWZmZXIoYnVmKSwgXCJFeHBlY3RpbmcgQnVmZmVyXCIpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGJ1Zi5sZW5ndGgsIDY0LCBcIkEgU2hhNTEyIEJ1ZmZlciBzaG91bGQgYmUgNjQgY2hhcmFjdGVycyBsb25nLCBpbnN0ZWFkIGdvdCBcIiArIGJ1Zi5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIEFlcy5mcm9tU2hhNTEyKGJ1Zi50b1N0cmluZyhcImhleFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBAdGhyb3dzIHtFcnJvcn0gLSBcIkludmFsaWQgS2V5LCAuLi5cIlxuICAgICAgICAgICAgQGFyZyB7UHJpdmF0ZUtleX0gcHJpdmF0ZV9rZXkgLSByZXF1aXJlZCBhbmQgdXNlZCBmb3IgZGVjcnlwdGlvblxuICAgICAgICAgICAgQGFyZyB7UHVibGljS2V5fSBwdWJsaWNfa2V5IC0gcmVxdWlyZWQgYW5kIHVzZWQgdG8gY2FsY3VhbHRlIHRoZSBzaGFyZWQgc2VjcmV0XG4gICAgICAgICAgICBAYXJnIHtzdHJpbmd9IFtub25jZSA9IFwiXCJdIG9wdGlvbmFsIGJ1dCBzaG91bGQgYWx3YXlzIGJlIHByb3ZpZGVkIGFuZCBiZSB1bmlxdWUgd2hlbiByZS11c2luZyB0aGUgc2FtZSBwcml2YXRlL3B1YmxpYyBrZXlzIG1vcmUgdGhhbiBvbmNlLiAgVGhpcyBub25jZSBpcyBub3QgYSBzZWNyZXQuXG4gICAgICAgICAgICBAYXJnIHtzdHJpbmd8QnVmZmVyfSBtZXNzYWdlIC0gRW5jcnlwdGVkIG1lc3NhZ2UgY29udGFpbmluZyBhIGNoZWNrc3VtXG4gICAgICAgICAgICBAcmV0dXJuIHtCdWZmZXJ9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJkZWNyeXB0X3dpdGhfY2hlY2tzdW1cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlY3J5cHRfd2l0aF9jaGVja3N1bShwcml2YXRlX2tleSwgcHVibGljX2tleSwgbm9uY2UsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBsZWdhY3kgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG5cbiAgICAgICAgICAgIC8vIFdhcm5pbmc6IERvIG5vdCBwdXQgYG5vbmNlID0gXCJcImAgaW4gdGhlIGFyZ3VtZW50cywgaW4gZXM2IHRoaXMgd2lsbCBub3QgY29udmVydCBcIm51bGxcIiBpbnRvIGFuIGVtdHB5IHN0cmluZ1xuICAgICAgICAgICAgaWYgKG5vbmNlID09IG51bGwpIC8vIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgbm9uY2UgPSBcIlwiO1xuXG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgQnVmZmVyKG1lc3NhZ2UsICdoZXgnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIFMgPSBwcml2YXRlX2tleS5nZXRfc2hhcmVkX3NlY3JldChwdWJsaWNfa2V5LCBsZWdhY3kpO1xuICAgICAgICAgICAgLy8gRCBFIEIgVSBHXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZGVjcnlwdF93aXRoX2NoZWNrc3VtJywge1xuICAgICAgICAgICAgLy8gICAgIHByaXZfdG9fcHViOiBwcml2YXRlX2tleS50b1B1YmxpY0tleSgpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAvLyAgICAgcHViOiBwdWJsaWNfa2V5LnRvUHVibGljS2V5U3RyaW5nKCksXG4gICAgICAgICAgICAvLyAgICAgbm9uY2U6IG5vbmNlLFxuICAgICAgICAgICAgLy8gICAgIG1lc3NhZ2U6IG1lc3NhZ2UubGVuZ3RoLFxuICAgICAgICAgICAgLy8gICAgIFM6IFMudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgICAgICAvLyB9KVxuXG4gICAgICAgICAgICB2YXIgYWVzID0gQWVzLmZyb21TZWVkKEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgLy8gQSBudWxsIG9yIGVtcHR5IHN0cmluZyBub25jZSB3aWxsIG5vdCBlZmZlY3QgdGhlIGhhc2hcbiAgICAgICAgICAgIG5ldyBCdWZmZXIoXCJcIiArIG5vbmNlKSwgbmV3IEJ1ZmZlcihTLnRvU3RyaW5nKCdoZXgnKSldKSk7XG5cbiAgICAgICAgICAgIHZhciBwbGFuZWJ1ZmZlciA9IGFlcy5kZWNyeXB0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKCEocGxhbmVidWZmZXIubGVuZ3RoID49IDQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXksIGNvdWxkIG5vdCBkZWNyeXB0IG1lc3NhZ2UoMSlcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERFQlVHIGNvbnNvbGUubG9nKCcuLi4gcGxhbmVidWZmZXInLHBsYW5lYnVmZmVyKVxuICAgICAgICAgICAgdmFyIGNoZWNrc3VtID0gcGxhbmVidWZmZXIuc2xpY2UoMCwgNCk7XG4gICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gcGxhbmVidWZmZXIuc2xpY2UoNCk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcuLi4gY2hlY2tzdW0nLGNoZWNrc3VtLnRvU3RyaW5nKCdoZXgnKSlcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcuLi4gcGxhaW50ZXh0JyxwbGFpbnRleHQudG9TdHJpbmcoKSlcblxuICAgICAgICAgICAgdmFyIG5ld19jaGVja3N1bSA9IGhhc2guc2hhMjU2KHBsYWludGV4dCk7XG4gICAgICAgICAgICBuZXdfY2hlY2tzdW0gPSBuZXdfY2hlY2tzdW0uc2xpY2UoMCwgNCk7XG4gICAgICAgICAgICBuZXdfY2hlY2tzdW0gPSBuZXdfY2hlY2tzdW0udG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgICAgICAgICBpZiAoIShjaGVja3N1bS50b1N0cmluZygnaGV4JykgPT09IG5ld19jaGVja3N1bSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleSwgY291bGQgbm90IGRlY3J5cHQgbWVzc2FnZSgyKVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImVuY3J5cHRfd2l0aF9jaGVja3N1bVwiLFxuXG5cbiAgICAgICAgLyoqIElkZW50aWNhbCB0byB7QGxpbmsgZGVjcnlwdF93aXRoX2NoZWNrc3VtfSBidXQgdXNlZCB0byBlbmNyeXB0LiAgU2hvdWxkIG5vdCB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgICAgIEByZXR1cm4ge0J1ZmZlcn0gbWVzc2FnZSAtIEVuY3J5cHRlZCBtZXNzYWdlIHdoaWNoIGluY2x1ZGVzIGEgY2hlY2tzdW1cbiAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuY3J5cHRfd2l0aF9jaGVja3N1bShwcml2YXRlX2tleSwgcHVibGljX2tleSwgbm9uY2UsIG1lc3NhZ2UpIHtcblxuICAgICAgICAgICAgLy8gV2FybmluZzogRG8gbm90IHB1dCBgbm9uY2UgPSBcIlwiYCBpbiB0aGUgYXJndW1lbnRzLCBpbiBlczYgdGhpcyB3aWxsIG5vdCBjb252ZXJ0IFwibnVsbFwiIGludG8gYW4gZW10cHkgc3RyaW5nXG5cbiAgICAgICAgICAgIGlmIChub25jZSA9PSBudWxsKSAvLyBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIG5vbmNlID0gXCJcIjtcblxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gbmV3IEJ1ZmZlcihtZXNzYWdlLCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBTID0gcHJpdmF0ZV9rZXkuZ2V0X3NoYXJlZF9zZWNyZXQocHVibGljX2tleSk7XG5cbiAgICAgICAgICAgIC8vIEQgRSBCIFUgR1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2VuY3J5cHRfd2l0aF9jaGVja3N1bScsIHtcbiAgICAgICAgICAgIC8vICAgICBwcml2X3RvX3B1YjogcHJpdmF0ZV9rZXkudG9QdWJsaWNLZXkoKS50b1N0cmluZygpXG4gICAgICAgICAgICAvLyAgICAgcHViOiBwdWJsaWNfa2V5LnRvUHVibGljS2V5U3RyaW5nKClcbiAgICAgICAgICAgIC8vICAgICBub25jZTogbm9uY2VcbiAgICAgICAgICAgIC8vICAgICBtZXNzYWdlOiBtZXNzYWdlLmxlbmd0aFxuICAgICAgICAgICAgLy8gICAgIFM6IFMudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgICAgICAvLyB9KVxuXG4gICAgICAgICAgICB2YXIgYWVzID0gQWVzLmZyb21TZWVkKEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgLy8gQSBudWxsIG9yIGVtcHR5IHN0cmluZyBub25jZSB3aWxsIG5vdCBlZmZlY3QgdGhlIGhhc2hcbiAgICAgICAgICAgIG5ldyBCdWZmZXIoXCJcIiArIG5vbmNlKSwgbmV3IEJ1ZmZlcihTLnRvU3RyaW5nKCdoZXgnKSldKSk7XG4gICAgICAgICAgICAvLyBERUJVRyBjb25zb2xlLmxvZygnLi4uIFMnLFMudG9TdHJpbmcoJ2hleCcpKVxuICAgICAgICAgICAgdmFyIGNoZWNrc3VtID0gaGFzaC5zaGEyNTYobWVzc2FnZSkuc2xpY2UoMCwgNCk7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IEJ1ZmZlci5jb25jYXQoW2NoZWNrc3VtLCBtZXNzYWdlXSk7XG4gICAgICAgICAgICAvLyBERUJVRyBjb25zb2xlLmxvZygnLi4uIHBheWxvYWQnLHBheWxvYWQudG9TdHJpbmcoKSlcbiAgICAgICAgICAgIHJldHVybiBhZXMuZW5jcnlwdChwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBZXM7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWVzO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9lY2Mvc3JjL2Flcy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L2VjYy9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTsgLy8gZnJvbSBnaXRodWIuY29tL2JpdGNvaW5qcy9iaXRjb2luanMtbGliIGZyb20gZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvZWNkc2FcbnZhciBjcnlwdG8gPSByZXF1aXJlKCcuL2hhc2gnKTtcbnZhciBlbmZvcmNlVHlwZSA9IHJlcXVpcmUoJy4vZW5mb3JjZV90eXBlcycpO1xuXG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKTtcbnZhciBFQ1NpZ25hdHVyZSA9IHJlcXVpcmUoJy4vZWNzaWduYXR1cmUnKTtcblxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5Nzkjc2VjdGlvbi0zLjJcbmZ1bmN0aW9uIGRldGVybWluaXN0aWNHZW5lcmF0ZUsoY3VydmUsIGhhc2gsIGQsIGNoZWNrU2lnLCBub25jZSkge1xuXG4gIGVuZm9yY2VUeXBlKCdCdWZmZXInLCBoYXNoKTtcbiAgZW5mb3JjZVR5cGUoQmlnSW50ZWdlciwgZCk7XG5cbiAgaWYgKG5vbmNlKSB7XG4gICAgaGFzaCA9IGNyeXB0by5zaGEyNTYoQnVmZmVyLmNvbmNhdChbaGFzaCwgbmV3IEJ1ZmZlcihub25jZSldKSk7XG4gIH1cblxuICAvLyBzYW5pdHkgY2hlY2tcbiAgYXNzZXJ0LmVxdWFsKGhhc2gubGVuZ3RoLCAzMiwgJ0hhc2ggbXVzdCBiZSAyNTYgYml0Jyk7XG5cbiAgdmFyIHggPSBkLnRvQnVmZmVyKDMyKTtcbiAgdmFyIGsgPSBuZXcgQnVmZmVyKDMyKTtcbiAgdmFyIHYgPSBuZXcgQnVmZmVyKDMyKTtcblxuICAvLyBTdGVwIEJcbiAgdi5maWxsKDEpO1xuXG4gIC8vIFN0ZXAgQ1xuICBrLmZpbGwoMCk7XG5cbiAgLy8gU3RlcCBEXG4gIGsgPSBjcnlwdG8uSG1hY1NIQTI1NihCdWZmZXIuY29uY2F0KFt2LCBuZXcgQnVmZmVyKFswXSksIHgsIGhhc2hdKSwgayk7XG5cbiAgLy8gU3RlcCBFXG4gIHYgPSBjcnlwdG8uSG1hY1NIQTI1Nih2LCBrKTtcblxuICAvLyBTdGVwIEZcbiAgayA9IGNyeXB0by5IbWFjU0hBMjU2KEJ1ZmZlci5jb25jYXQoW3YsIG5ldyBCdWZmZXIoWzFdKSwgeCwgaGFzaF0pLCBrKTtcblxuICAvLyBTdGVwIEdcbiAgdiA9IGNyeXB0by5IbWFjU0hBMjU2KHYsIGspO1xuXG4gIC8vIFN0ZXAgSDEvSDJhLCBpZ25vcmVkIGFzIHRsZW4gPT09IHFsZW4gKDI1NiBiaXQpXG4gIC8vIFN0ZXAgSDJiXG4gIHYgPSBjcnlwdG8uSG1hY1NIQTI1Nih2LCBrKTtcblxuICB2YXIgVCA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcih2KTtcblxuICAvLyBTdGVwIEgzLCByZXBlYXQgdW50aWwgVCBpcyB3aXRoaW4gdGhlIGludGVydmFsIFsxLCBuIC0gMV1cbiAgd2hpbGUgKFQuc2lnbnVtKCkgPD0gMCB8fCBULmNvbXBhcmVUbyhjdXJ2ZS5uKSA+PSAwIHx8ICFjaGVja1NpZyhUKSkge1xuICAgIGsgPSBjcnlwdG8uSG1hY1NIQTI1NihCdWZmZXIuY29uY2F0KFt2LCBuZXcgQnVmZmVyKFswXSldKSwgayk7XG4gICAgdiA9IGNyeXB0by5IbWFjU0hBMjU2KHYsIGspO1xuXG4gICAgLy8gU3RlcCBIMS9IMmEsIGFnYWluLCBpZ25vcmVkIGFzIHRsZW4gPT09IHFsZW4gKDI1NiBiaXQpXG4gICAgLy8gU3RlcCBIMmIgYWdhaW5cbiAgICB2ID0gY3J5cHRvLkhtYWNTSEEyNTYodiwgayk7XG5cbiAgICBUID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKHYpO1xuICB9XG5cbiAgcmV0dXJuIFQ7XG59XG5cbmZ1bmN0aW9uIHNpZ24oY3VydmUsIGhhc2gsIGQsIG5vbmNlKSB7XG5cbiAgdmFyIGUgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoaGFzaCk7XG4gIHZhciBuID0gY3VydmUubjtcbiAgdmFyIEcgPSBjdXJ2ZS5HO1xuXG4gIHZhciByLCBzO1xuICB2YXIgayA9IGRldGVybWluaXN0aWNHZW5lcmF0ZUsoY3VydmUsIGhhc2gsIGQsIGZ1bmN0aW9uIChrKSB7XG4gICAgLy8gZmluZCBjYW5vbmljYWxseSB2YWxpZCBzaWduYXR1cmVcbiAgICB2YXIgUSA9IEcubXVsdGlwbHkoayk7XG5cbiAgICBpZiAoY3VydmUuaXNJbmZpbml0eShRKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgciA9IFEuYWZmaW5lWC5tb2Qobik7XG4gICAgaWYgKHIuc2lnbnVtKCkgPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgIHMgPSBrLm1vZEludmVyc2UobikubXVsdGlwbHkoZS5hZGQoZC5tdWx0aXBseShyKSkpLm1vZChuKTtcbiAgICBpZiAocy5zaWdudW0oKSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIG5vbmNlKTtcblxuICB2YXIgTl9PVkVSX1RXTyA9IG4uc2hpZnRSaWdodCgxKTtcblxuICAvLyBlbmZvcmNlIGxvdyBTIHZhbHVlcywgc2VlIGJpcDYyOiAnbG93IHMgdmFsdWVzIGluIHNpZ25hdHVyZXMnXG4gIGlmIChzLmNvbXBhcmVUbyhOX09WRVJfVFdPKSA+IDApIHtcbiAgICBzID0gbi5zdWJ0cmFjdChzKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgRUNTaWduYXR1cmUociwgcyk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVJhdyhjdXJ2ZSwgZSwgc2lnbmF0dXJlLCBRKSB7XG4gIHZhciBuID0gY3VydmUubjtcbiAgdmFyIEcgPSBjdXJ2ZS5HO1xuXG4gIHZhciByID0gc2lnbmF0dXJlLnI7XG4gIHZhciBzID0gc2lnbmF0dXJlLnM7XG5cbiAgLy8gMS40LjEgRW5mb3JjZSByIGFuZCBzIGFyZSBib3RoIGludGVnZXJzIGluIHRoZSBpbnRlcnZhbCBbMSwgbiDiiJIgMV1cbiAgaWYgKHIuc2lnbnVtKCkgPD0gMCB8fCByLmNvbXBhcmVUbyhuKSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmIChzLnNpZ251bSgpIDw9IDAgfHwgcy5jb21wYXJlVG8obikgPj0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIGMgPSBzXi0xIG1vZCBuXG4gIHZhciBjID0gcy5tb2RJbnZlcnNlKG4pO1xuXG4gIC8vIDEuNC40IENvbXB1dGUgdTEgPSBlc17iiJIxIG1vZCBuXG4gIC8vICAgICAgICAgICAgICAgdTIgPSByc17iiJIxIG1vZCBuXG4gIHZhciB1MSA9IGUubXVsdGlwbHkoYykubW9kKG4pO1xuICB2YXIgdTIgPSByLm11bHRpcGx5KGMpLm1vZChuKTtcblxuICAvLyAxLjQuNSBDb21wdXRlIFIgPSAoeFIsIHlSKSA9IHUxRyArIHUyUVxuICB2YXIgUiA9IEcubXVsdGlwbHlUd28odTEsIFEsIHUyKTtcblxuICAvLyAxLjQuNSAoY29udC4pIEVuZm9yY2UgUiBpcyBub3QgYXQgaW5maW5pdHlcbiAgaWYgKGN1cnZlLmlzSW5maW5pdHkoUikpIHJldHVybiBmYWxzZTtcblxuICAvLyAxLjQuNiBDb252ZXJ0IHRoZSBmaWVsZCBlbGVtZW50IFIueCB0byBhbiBpbnRlZ2VyXG4gIHZhciB4UiA9IFIuYWZmaW5lWDtcblxuICAvLyAxLjQuNyBTZXQgdiA9IHhSIG1vZCBuXG4gIHZhciB2ID0geFIubW9kKG4pO1xuXG4gIC8vIDEuNC44IElmIHYgPSByLCBvdXRwdXQgXCJ2YWxpZFwiLCBhbmQgaWYgdiAhPSByLCBvdXRwdXQgXCJpbnZhbGlkXCJcbiAgcmV0dXJuIHYuZXF1YWxzKHIpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnkoY3VydmUsIGhhc2gsIHNpZ25hdHVyZSwgUSkge1xuICAvLyAxLjQuMiBIID0gSGFzaChNKSwgYWxyZWFkeSBkb25lIGJ5IHRoZSB1c2VyXG4gIC8vIDEuNC4zIGUgPSBIXG4gIHZhciBlID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGhhc2gpO1xuICByZXR1cm4gdmVyaWZ5UmF3KGN1cnZlLCBlLCBzaWduYXR1cmUsIFEpO1xufVxuXG4vKipcbiAgKiBSZWNvdmVyIGEgcHVibGljIGtleSBmcm9tIGEgc2lnbmF0dXJlLlxuICAqXG4gICogU2VlIFNFQyAxOiBFbGxpcHRpYyBDdXJ2ZSBDcnlwdG9ncmFwaHksIHNlY3Rpb24gNC4xLjYsIFwiUHVibGljXG4gICogS2V5IFJlY292ZXJ5IE9wZXJhdGlvblwiLlxuICAqXG4gICogaHR0cDovL3d3dy5zZWNnLm9yZy9kb3dubG9hZC9haWQtNzgwL3NlYzEtdjIucGRmXG4gICovXG5mdW5jdGlvbiByZWNvdmVyUHViS2V5KGN1cnZlLCBlLCBzaWduYXR1cmUsIGkpIHtcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKGkgJiAzLCBpLCAnUmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzJyk7XG5cbiAgdmFyIG4gPSBjdXJ2ZS5uO1xuICB2YXIgRyA9IGN1cnZlLkc7XG5cbiAgdmFyIHIgPSBzaWduYXR1cmUucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUucztcblxuICBhc3NlcnQoci5zaWdudW0oKSA+IDAgJiYgci5jb21wYXJlVG8obikgPCAwLCAnSW52YWxpZCByIHZhbHVlJyk7XG4gIGFzc2VydChzLnNpZ251bSgpID4gMCAmJiBzLmNvbXBhcmVUbyhuKSA8IDAsICdJbnZhbGlkIHMgdmFsdWUnKTtcblxuICAvLyBBIHNldCBMU0Igc2lnbmlmaWVzIHRoYXQgdGhlIHktY29vcmRpbmF0ZSBpcyBvZGRcbiAgdmFyIGlzWU9kZCA9IGkgJiAxO1xuXG4gIC8vIFRoZSBtb3JlIHNpZ25pZmljYW50IGJpdCBzcGVjaWZpZXMgd2hldGhlciB3ZSBzaG91bGQgdXNlIHRoZVxuICAvLyBmaXJzdCBvciBzZWNvbmQgY2FuZGlkYXRlIGtleS5cbiAgdmFyIGlzU2Vjb25kS2V5ID0gaSA+PiAxO1xuXG4gIC8vIDEuMSBMZXQgeCA9IHIgKyBqblxuICB2YXIgeCA9IGlzU2Vjb25kS2V5ID8gci5hZGQobikgOiByO1xuICB2YXIgUiA9IGN1cnZlLnBvaW50RnJvbVgoaXNZT2RkLCB4KTtcblxuICAvLyAxLjQgQ2hlY2sgdGhhdCBuUiBpcyBhdCBpbmZpbml0eVxuICB2YXIgblIgPSBSLm11bHRpcGx5KG4pO1xuICBhc3NlcnQoY3VydmUuaXNJbmZpbml0eShuUiksICduUiBpcyBub3QgYSB2YWxpZCBjdXJ2ZSBwb2ludCcpO1xuXG4gIC8vIENvbXB1dGUgLWUgZnJvbSBlXG4gIHZhciBlTmVnID0gZS5uZWdhdGUoKS5tb2Qobik7XG5cbiAgLy8gMS42LjEgQ29tcHV0ZSBRID0gcl4tMSAoc1IgLSAgZUcpXG4gIC8vICAgICAgICAgICAgICAgUSA9IHJeLTEgKHNSICsgLWVHKVxuICB2YXIgckludiA9IHIubW9kSW52ZXJzZShuKTtcblxuICB2YXIgUSA9IFIubXVsdGlwbHlUd28ocywgRywgZU5lZykubXVsdGlwbHkockludik7XG4gIGN1cnZlLnZhbGlkYXRlKFEpO1xuXG4gIHJldHVybiBRO1xufVxuXG4vKipcbiAgKiBDYWxjdWxhdGUgcHVia2V5IGV4dHJhY3Rpb24gcGFyYW1ldGVyLlxuICAqXG4gICogV2hlbiBleHRyYWN0aW5nIGEgcHVia2V5IGZyb20gYSBzaWduYXR1cmUsIHdlIGhhdmUgdG9cbiAgKiBkaXN0aW5ndWlzaCBmb3VyIGRpZmZlcmVudCBjYXNlcy4gUmF0aGVyIHRoYW4gcHV0dGluZyB0aGlzXG4gICogYnVyZGVuIG9uIHRoZSB2ZXJpZmllciwgQml0Y29pbiBpbmNsdWRlcyBhIDItYml0IHZhbHVlIHdpdGggdGhlXG4gICogc2lnbmF0dXJlLlxuICAqXG4gICogVGhpcyBmdW5jdGlvbiBzaW1wbHkgdHJpZXMgYWxsIGZvdXIgY2FzZXMgYW5kIHJldHVybnMgdGhlIHZhbHVlXG4gICogdGhhdCByZXN1bHRlZCBpbiBhIHN1Y2Nlc3NmdWwgcHVia2V5IHJlY292ZXJ5LlxuICAqL1xuZnVuY3Rpb24gY2FsY1B1YktleVJlY292ZXJ5UGFyYW0oY3VydmUsIGUsIHNpZ25hdHVyZSwgUSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBRcHJpbWUgPSByZWNvdmVyUHViS2V5KGN1cnZlLCBlLCBzaWduYXR1cmUsIGkpO1xuXG4gICAgLy8gMS42LjIgVmVyaWZ5IFFcbiAgICBpZiAoUXByaW1lLmVxdWFscyhRKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCB2YWxpZCByZWNvdmVyeSBmYWN0b3InKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNhbGNQdWJLZXlSZWNvdmVyeVBhcmFtOiBjYWxjUHViS2V5UmVjb3ZlcnlQYXJhbSxcbiAgZGV0ZXJtaW5pc3RpY0dlbmVyYXRlSzogZGV0ZXJtaW5pc3RpY0dlbmVyYXRlSyxcbiAgcmVjb3ZlclB1YktleTogcmVjb3ZlclB1YktleSxcbiAgc2lnbjogc2lnbixcbiAgdmVyaWZ5OiB2ZXJpZnksXG4gIHZlcmlmeVJhdzogdmVyaWZ5UmF3XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9lY2Mvc3JjL2VjZHNhLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvZWNjL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOyAvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luanMvYml0Y29pbmpzLWxpYlxudmFyIGVuZm9yY2VUeXBlID0gcmVxdWlyZSgnLi9lbmZvcmNlX3R5cGVzJyk7XG5cbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpO1xuXG5mdW5jdGlvbiBFQ1NpZ25hdHVyZShyLCBzKSB7XG4gIGVuZm9yY2VUeXBlKEJpZ0ludGVnZXIsIHIpO1xuICBlbmZvcmNlVHlwZShCaWdJbnRlZ2VyLCBzKTtcblxuICB0aGlzLnIgPSByO1xuICB0aGlzLnMgPSBzO1xufVxuXG4vLyBJbXBvcnQgb3BlcmF0aW9uc1xuRUNTaWduYXR1cmUucGFyc2VDb21wYWN0ID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICBhc3NlcnQuZXF1YWwoYnVmZmVyLmxlbmd0aCwgNjUsICdJbnZhbGlkIHNpZ25hdHVyZSBsZW5ndGgnKTtcbiAgdmFyIGkgPSBidWZmZXIucmVhZFVJbnQ4KDApIC0gMjc7XG5cbiAgLy8gQXQgbW9zdCAzIGJpdHNcbiAgYXNzZXJ0LmVxdWFsKGksIGkgJiA3LCAnSW52YWxpZCBzaWduYXR1cmUgcGFyYW1ldGVyJyk7XG4gIHZhciBjb21wcmVzc2VkID0gISEoaSAmIDQpO1xuXG4gIC8vIFJlY292ZXJ5IHBhcmFtIG9ubHlcbiAgaSA9IGkgJiAzO1xuXG4gIHZhciByID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1ZmZlci5zbGljZSgxLCAzMykpO1xuICB2YXIgcyA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihidWZmZXIuc2xpY2UoMzMpKTtcblxuICByZXR1cm4ge1xuICAgIGNvbXByZXNzZWQ6IGNvbXByZXNzZWQsXG4gICAgaTogaSxcbiAgICBzaWduYXR1cmU6IG5ldyBFQ1NpZ25hdHVyZShyLCBzKVxuICB9O1xufTtcblxuRUNTaWduYXR1cmUuZnJvbURFUiA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgYXNzZXJ0LmVxdWFsKGJ1ZmZlci5yZWFkVUludDgoMCksIDB4MzAsICdOb3QgYSBERVIgc2VxdWVuY2UnKTtcbiAgYXNzZXJ0LmVxdWFsKGJ1ZmZlci5yZWFkVUludDgoMSksIGJ1ZmZlci5sZW5ndGggLSAyLCAnSW52YWxpZCBzZXF1ZW5jZSBsZW5ndGgnKTtcbiAgYXNzZXJ0LmVxdWFsKGJ1ZmZlci5yZWFkVUludDgoMiksIDB4MDIsICdFeHBlY3RlZCBhIERFUiBpbnRlZ2VyJyk7XG5cbiAgdmFyIHJMZW4gPSBidWZmZXIucmVhZFVJbnQ4KDMpO1xuICBhc3NlcnQockxlbiA+IDAsICdSIGxlbmd0aCBpcyB6ZXJvJyk7XG5cbiAgdmFyIG9mZnNldCA9IDQgKyByTGVuO1xuICBhc3NlcnQuZXF1YWwoYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpLCAweDAyLCAnRXhwZWN0ZWQgYSBERVIgaW50ZWdlciAoMiknKTtcblxuICB2YXIgc0xlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0ICsgMSk7XG4gIGFzc2VydChzTGVuID4gMCwgJ1MgbGVuZ3RoIGlzIHplcm8nKTtcblxuICB2YXIgckIgPSBidWZmZXIuc2xpY2UoNCwgb2Zmc2V0KTtcbiAgdmFyIHNCID0gYnVmZmVyLnNsaWNlKG9mZnNldCArIDIpO1xuICBvZmZzZXQgKz0gMiArIHNMZW47XG5cbiAgaWYgKHJMZW4gPiAxICYmIHJCLnJlYWRVSW50OCgwKSA9PT0gMHgwMCkge1xuICAgIGFzc2VydChyQi5yZWFkVUludDgoMSkgJiAweDgwLCAnUiB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWQnKTtcbiAgfVxuXG4gIGlmIChzTGVuID4gMSAmJiBzQi5yZWFkVUludDgoMCkgPT09IDB4MDApIHtcbiAgICBhc3NlcnQoc0IucmVhZFVJbnQ4KDEpICYgMHg4MCwgJ1MgdmFsdWUgZXhjZXNzaXZlbHkgcGFkZGVkJyk7XG4gIH1cblxuICBhc3NlcnQuZXF1YWwob2Zmc2V0LCBidWZmZXIubGVuZ3RoLCAnSW52YWxpZCBERVIgZW5jb2RpbmcnKTtcbiAgdmFyIHIgPSBCaWdJbnRlZ2VyLmZyb21ERVJJbnRlZ2VyKHJCKTtcbiAgdmFyIHMgPSBCaWdJbnRlZ2VyLmZyb21ERVJJbnRlZ2VyKHNCKTtcblxuICBhc3NlcnQoci5zaWdudW0oKSA+PSAwLCAnUiB2YWx1ZSBpcyBuZWdhdGl2ZScpO1xuICBhc3NlcnQocy5zaWdudW0oKSA+PSAwLCAnUyB2YWx1ZSBpcyBuZWdhdGl2ZScpO1xuXG4gIHJldHVybiBuZXcgRUNTaWduYXR1cmUociwgcyk7XG59O1xuXG4vLyBGSVhNRTogMHgwMCwgMHgwNCwgMHg4MCBhcmUgU0lHSEFTSF8qIGJvdW5kYXJ5IGNvbnN0YW50cywgaW1wb3J0aW5nIFRyYW5zYWN0aW9uIGNhdXNlcyBhIGNpcmN1bGFyIGRlcGVuZGVuY3lcbkVDU2lnbmF0dXJlLnBhcnNlU2NyaXB0U2lnbmF0dXJlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICB2YXIgaGFzaFR5cGUgPSBidWZmZXIucmVhZFVJbnQ4KGJ1ZmZlci5sZW5ndGggLSAxKTtcbiAgdmFyIGhhc2hUeXBlTW9kID0gaGFzaFR5cGUgJiB+MHg4MDtcblxuICBhc3NlcnQoaGFzaFR5cGVNb2QgPiAweDAwICYmIGhhc2hUeXBlTW9kIDwgMHgwNCwgJ0ludmFsaWQgaGFzaFR5cGUnKTtcblxuICByZXR1cm4ge1xuICAgIHNpZ25hdHVyZTogRUNTaWduYXR1cmUuZnJvbURFUihidWZmZXIuc2xpY2UoMCwgLTEpKSxcbiAgICBoYXNoVHlwZTogaGFzaFR5cGVcbiAgfTtcbn07XG5cbi8vIEV4cG9ydCBvcGVyYXRpb25zXG5FQ1NpZ25hdHVyZS5wcm90b3R5cGUudG9Db21wYWN0ID0gZnVuY3Rpb24gKGksIGNvbXByZXNzZWQpIHtcbiAgaWYgKGNvbXByZXNzZWQpIGkgKz0gNDtcbiAgaSArPSAyNztcblxuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcig2NSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQ4KGksIDApO1xuXG4gIHRoaXMuci50b0J1ZmZlcigzMikuY29weShidWZmZXIsIDEpO1xuICB0aGlzLnMudG9CdWZmZXIoMzIpLmNvcHkoYnVmZmVyLCAzMyk7XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbkVDU2lnbmF0dXJlLnByb3RvdHlwZS50b0RFUiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJCYSA9IHRoaXMuci50b0RFUkludGVnZXIoKTtcbiAgdmFyIHNCYSA9IHRoaXMucy50b0RFUkludGVnZXIoKTtcblxuICB2YXIgc2VxdWVuY2UgPSBbXTtcblxuICAvLyBJTlRFR0VSXG4gIHNlcXVlbmNlLnB1c2goMHgwMiwgckJhLmxlbmd0aCk7XG4gIHNlcXVlbmNlID0gc2VxdWVuY2UuY29uY2F0KHJCYSk7XG5cbiAgLy8gSU5URUdFUlxuICBzZXF1ZW5jZS5wdXNoKDB4MDIsIHNCYS5sZW5ndGgpO1xuICBzZXF1ZW5jZSA9IHNlcXVlbmNlLmNvbmNhdChzQmEpO1xuXG4gIC8vIFNFUVVFTkNFXG4gIHNlcXVlbmNlLnVuc2hpZnQoMHgzMCwgc2VxdWVuY2UubGVuZ3RoKTtcblxuICByZXR1cm4gbmV3IEJ1ZmZlcihzZXF1ZW5jZSk7XG59O1xuXG5FQ1NpZ25hdHVyZS5wcm90b3R5cGUudG9TY3JpcHRTaWduYXR1cmUgPSBmdW5jdGlvbiAoaGFzaFR5cGUpIHtcbiAgdmFyIGhhc2hUeXBlQnVmZmVyID0gbmV3IEJ1ZmZlcigxKTtcbiAgaGFzaFR5cGVCdWZmZXIud3JpdGVVSW50OChoYXNoVHlwZSwgMCk7XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3RoaXMudG9ERVIoKSwgaGFzaFR5cGVCdWZmZXJdKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRUNTaWduYXR1cmU7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L2VjYy9zcmMvZWNzaWduYXR1cmUuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9lY2Mvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuZm9yY2UodHlwZSwgdmFsdWUpIHtcbiAgLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXRjb2luanMtbGliXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykgcmV0dXJuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ0J1ZmZlcic6XG4gICAgICB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSByZXR1cm47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdTdHJpbmcnOlxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgcmV0dXJuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGlmIChnZXROYW1lKHZhbHVlLmNvbnN0cnVjdG9yKSA9PT0gZ2V0TmFtZSh0eXBlKSkgcmV0dXJuO1xuICAgICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgJyArIChnZXROYW1lKHR5cGUpIHx8IHR5cGUpICsgJywgZ290ICcgKyB2YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiBnZXROYW1lKGZuKSB7XG4gIC8vIFdoeSBub3QgZm4ubmFtZTogaHR0cHM6Ly9rYW5nYXguZ2l0aHViLmlvL2NvbXBhdC10YWJsZS9lczYvI2Z1bmN0aW9uX25hbWVfcHJvcGVydHlcbiAgdmFyIG1hdGNoID0gZm4udG9TdHJpbmcoKS5tYXRjaCgvZnVuY3Rpb24gKC4qPylcXCgvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBudWxsO1xufVxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9lY2Mvc3JjL2VuZm9yY2VfdHlwZXMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9lY2Mvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZShcImNyZWF0ZS1oYXNoXCIpO1xudmFyIGNyZWF0ZUhtYWMgPSByZXF1aXJlKFwiY3JlYXRlLWhtYWNcIik7XG5cbi8qKiBAYXJnIHtzdHJpbmd8QnVmZmVyfSBkYXRhXG4gICAgQGFyZyB7c3RyaW5nfSBbZGlnZXN0ID0gbnVsbF0gLSAnaGV4JywgJ2JpbmFyeScgb3IgJ2Jhc2U2NCdcbiAgICBAcmV0dXJuIHtzdHJpbmd8QnVmZmVyfSAtIEJ1ZmZlciB3aGVuIGRpZ2VzdCBpcyBudWxsLCBvciBzdHJpbmdcbiovXG5mdW5jdGlvbiBzaGExKGRhdGEsIGVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoZGF0YSkuZGlnZXN0KGVuY29kaW5nKTtcbn1cblxuLyoqIEBhcmcge3N0cmluZ3xCdWZmZXJ9IGRhdGFcbiAgICBAYXJnIHtzdHJpbmd9IFtkaWdlc3QgPSBudWxsXSAtICdoZXgnLCAnYmluYXJ5JyBvciAnYmFzZTY0J1xuICAgIEByZXR1cm4ge3N0cmluZ3xCdWZmZXJ9IC0gQnVmZmVyIHdoZW4gZGlnZXN0IGlzIG51bGwsIG9yIHN0cmluZ1xuKi9cbmZ1bmN0aW9uIHNoYTI1NihkYXRhLCBlbmNvZGluZykge1xuICAgIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoZGF0YSkuZGlnZXN0KGVuY29kaW5nKTtcbn1cblxuLyoqIEBhcmcge3N0cmluZ3xCdWZmZXJ9IGRhdGFcbiAgICBAYXJnIHtzdHJpbmd9IFtkaWdlc3QgPSBudWxsXSAtICdoZXgnLCAnYmluYXJ5JyBvciAnYmFzZTY0J1xuICAgIEByZXR1cm4ge3N0cmluZ3xCdWZmZXJ9IC0gQnVmZmVyIHdoZW4gZGlnZXN0IGlzIG51bGwsIG9yIHN0cmluZ1xuKi9cbmZ1bmN0aW9uIHNoYTUxMihkYXRhLCBlbmNvZGluZykge1xuICAgIHJldHVybiBjcmVhdGVIYXNoKCdzaGE1MTInKS51cGRhdGUoZGF0YSkuZGlnZXN0KGVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gSG1hY1NIQTI1NihidWZmZXIsIHNlY3JldCkge1xuICAgIHJldHVybiBjcmVhdGVIbWFjKCdzaGEyNTYnLCBzZWNyZXQpLnVwZGF0ZShidWZmZXIpLmRpZ2VzdCgpO1xufVxuXG5mdW5jdGlvbiByaXBlbWQxNjAoZGF0YSkge1xuICAgIHJldHVybiBjcmVhdGVIYXNoKCdybWQxNjAnKS51cGRhdGUoZGF0YSkuZGlnZXN0KCk7XG59XG5cbi8vIGZ1bmN0aW9uIGhhc2gxNjAoYnVmZmVyKSB7XG4vLyAgIHJldHVybiByaXBlbWQxNjAoc2hhMjU2KGJ1ZmZlcikpXG4vLyB9XG4vL1xuLy8gZnVuY3Rpb24gaGFzaDI1NihidWZmZXIpIHtcbi8vICAgcmV0dXJuIHNoYTI1NihzaGEyNTYoYnVmZmVyKSlcbi8vIH1cblxuLy9cbi8vIGZ1bmN0aW9uIEhtYWNTSEE1MTIoYnVmZmVyLCBzZWNyZXQpIHtcbi8vICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIbWFjKCdzaGE1MTInLCBzZWNyZXQpLnVwZGF0ZShidWZmZXIpLmRpZ2VzdCgpXG4vLyB9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHNoYTE6IHNoYTEsXG4gICAgc2hhMjU2OiBzaGEyNTYsXG4gICAgc2hhNTEyOiBzaGE1MTIsXG4gICAgSG1hY1NIQTI1NjogSG1hY1NIQTI1NixcbiAgICByaXBlbWQxNjA6IHJpcGVtZDE2MFxuICAgIC8vIGhhc2gxNjA6IGhhc2gxNjAsXG4gICAgLy8gaGFzaDI1NjogaGFzaDI1NixcbiAgICAvLyBIbWFjU0hBNTEyOiBIbWFjU0hBNTEyXG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9lY2Mvc3JjL2hhc2guanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9lY2Mvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgZWNkc2EgPSByZXF1aXJlKCcuL2VjZHNhJyk7XG52YXIgaGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdlY3VydmUnKTtcblxudmFyIGdldEN1cnZlQnlOYW1lID0gX3JlcXVpcmUuZ2V0Q3VydmVCeU5hbWU7XG5cbnZhciBzZWNwMjU2azEgPSBnZXRDdXJ2ZUJ5TmFtZSgnc2VjcDI1NmsxJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKTtcbnZhciBQdWJsaWNLZXkgPSByZXF1aXJlKCcuL1B1YmxpY0tleScpO1xuXG52YXIgU2lnbmF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpZ25hdHVyZShyMSwgczEsIGkxKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaWduYXR1cmUpO1xuXG4gICAgICAgIHRoaXMuciA9IHIxO1xuICAgICAgICB0aGlzLnMgPSBzMTtcbiAgICAgICAgdGhpcy5pID0gaTE7XG4gICAgICAgIGFzc2VydC5lcXVhbCh0aGlzLnIgIT0gbnVsbCwgdHJ1ZSwgJ01pc3NpbmcgcGFyYW1ldGVyJyk7XG4gICAgICAgIGFzc2VydC5lcXVhbCh0aGlzLnMgIT0gbnVsbCwgdHJ1ZSwgJ01pc3NpbmcgcGFyYW1ldGVyJyk7XG4gICAgICAgIGFzc2VydC5lcXVhbCh0aGlzLmkgIT0gbnVsbCwgdHJ1ZSwgJ01pc3NpbmcgcGFyYW1ldGVyJyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFNpZ25hdHVyZSwgW3tcbiAgICAgICAga2V5OiAndG9CdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9CdWZmZXIoKSB7XG4gICAgICAgICAgICB2YXIgYnVmO1xuICAgICAgICAgICAgYnVmID0gbmV3IEJ1ZmZlcig2NSk7XG4gICAgICAgICAgICBidWYud3JpdGVVSW50OCh0aGlzLmksIDApO1xuICAgICAgICAgICAgdGhpcy5yLnRvQnVmZmVyKDMyKS5jb3B5KGJ1ZiwgMSk7XG4gICAgICAgICAgICB0aGlzLnMudG9CdWZmZXIoMzIpLmNvcHkoYnVmLCAzMyk7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZWNvdmVyUHVibGljS2V5RnJvbUJ1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5RnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY292ZXJQdWJsaWNLZXkoaGFzaC5zaGEyNTYoYnVmZmVyKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlY292ZXJQdWJsaWNLZXknLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBAcmV0dXJuIHtQdWJsaWNLZXl9XG4gICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KHNoYTI1Nl9idWZmZXIpIHtcbiAgICAgICAgICAgIHZhciBRID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGUgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgaSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGUgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoc2hhMjU2X2J1ZmZlcik7XG4gICAgICAgICAgICBpID0gdGhpcy5pO1xuICAgICAgICAgICAgaSAtPSAyNztcbiAgICAgICAgICAgIGkgPSBpICYgMztcbiAgICAgICAgICAgIFEgPSBlY2RzYS5yZWNvdmVyUHViS2V5KHNlY3AyNTZrMSwgZSwgdGhpcywgaSk7XG4gICAgICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21Qb2ludChRKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndmVyaWZ5QnVmZmVyJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgQHBhcmFtIHtCdWZmZXJ9IHVuLWhhc2hlZFxuICAgICAgICAgICAgQHBhcmFtIHsuL1B1YmxpY0tleX1cbiAgICAgICAgICAgIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnlCdWZmZXIoYnVmLCBwdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICB2YXIgX2hhc2ggPSBoYXNoLnNoYTI1NihidWYpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5SGFzaChfaGFzaCwgcHVibGljX2tleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3ZlcmlmeUhhc2gnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmVyaWZ5SGFzaChoYXNoLCBwdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaGFzaC5sZW5ndGgsIDMyLCBcIkEgU0hBIDI1NiBzaG91bGQgYmUgMzIgYnl0ZXMgbG9uZywgaW5zdGVhZCBnb3QgXCIgKyBoYXNoLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gZWNkc2EudmVyaWZ5KHNlY3AyNTZrMSwgaGFzaCwge1xuICAgICAgICAgICAgICAgIHI6IHRoaXMucixcbiAgICAgICAgICAgICAgICBzOiB0aGlzLnNcbiAgICAgICAgICAgIH0sIHB1YmxpY19rZXkuUSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQnl0ZUJ1ZmZlcicsXG5cblxuICAgICAgICAvKiA8SEVYPiAqL1xuXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J5dGVCdWZmZXIoKSB7XG4gICAgICAgICAgICB2YXIgYjtcbiAgICAgICAgICAgIGIgPSBuZXcgQnl0ZUJ1ZmZlcihCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFksIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTik7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEJ5dGVCdWZmZXIoYik7XG4gICAgICAgICAgICByZXR1cm4gYi5jb3B5KDAsIGIub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9IZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9IZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0J1ZmZlcigpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd2ZXJpZnlIZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmVyaWZ5SGV4KGhleCwgcHVibGljX2tleSkge1xuICAgICAgICAgICAgdmFyIGJ1ZjtcbiAgICAgICAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIoaGV4LCAnaGV4Jyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlCdWZmZXIoYnVmLCBwdWJsaWNfa2V5KTtcbiAgICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAgICBrZXk6ICdmcm9tQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmKSB7XG4gICAgICAgICAgICB2YXIgaSwgciwgcztcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChidWYubGVuZ3RoLCA2NSwgJ0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICAgICAgICAgICAgaSA9IGJ1Zi5yZWFkVUludDgoMCk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaSAtIDI3LCBpIC0gMjcgJiA3LCAnSW52YWxpZCBzaWduYXR1cmUgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICByID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1Zi5zbGljZSgxLCAzMykpO1xuICAgICAgICAgICAgcyA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihidWYuc2xpY2UoMzMpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMsIGkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzaWduQnVmZmVyJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICAgICAgICAgICAgQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlX2tleVxuICAgICAgICAgICAgQHJldHVybiB7U2lnbmF0dXJlfVxuICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbkJ1ZmZlcihidWYsIHByaXZhdGVfa2V5KSB7XG4gICAgICAgICAgICB2YXIgX2hhc2ggPSBoYXNoLnNoYTI1NihidWYpO1xuICAgICAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5zaWduQnVmZmVyU2hhMjU2KF9oYXNoLCBwcml2YXRlX2tleSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogU2lnbiBhIGJ1ZmZlciBvZiBleGFjdGFsbHkgMzIgYnl0ZXMgaW4gc2l6ZSAoc2hhMjU2KHRleHQpKVxuICAgICAgICAgICAgQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIDMyIGJ5dGVzIGJpbmFyeVxuICAgICAgICAgICAgQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlX2tleVxuICAgICAgICAgICAgQHJldHVybiB7U2lnbmF0dXJlfVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzaWduQnVmZmVyU2hhMjU2JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ25CdWZmZXJTaGEyNTYoYnVmX3NoYTI1NiwgcHJpdmF0ZV9rZXkpIHtcbiAgICAgICAgICAgIGlmIChidWZfc2hhMjU2Lmxlbmd0aCAhPT0gMzIgfHwgIUJ1ZmZlci5pc0J1ZmZlcihidWZfc2hhMjU2KSkgdGhyb3cgbmV3IEVycm9yKFwiYnVmX3NoYTI1NjogMzIgYnl0ZSBidWZmZXIgcmVxdXJlZFwiKTtcbiAgICAgICAgICAgIHZhciBkZXIsIGUsIGVjc2lnbmF0dXJlLCBpLCBsZW5SLCBsZW5TLCBub25jZTtcbiAgICAgICAgICAgIGkgPSBudWxsO1xuICAgICAgICAgICAgbm9uY2UgPSAwO1xuICAgICAgICAgICAgZSA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihidWZfc2hhMjU2KTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgZWNzaWduYXR1cmUgPSBlY2RzYS5zaWduKHNlY3AyNTZrMSwgYnVmX3NoYTI1NiwgcHJpdmF0ZV9rZXkuZCwgbm9uY2UrKyk7XG4gICAgICAgICAgICAgICAgZGVyID0gZWNzaWduYXR1cmUudG9ERVIoKTtcbiAgICAgICAgICAgICAgICBsZW5SID0gZGVyWzNdO1xuICAgICAgICAgICAgICAgIGxlblMgPSBkZXJbNSArIGxlblJdO1xuICAgICAgICAgICAgICAgIGlmIChsZW5SID09PSAzMiAmJiBsZW5TID09PSAzMikge1xuICAgICAgICAgICAgICAgICAgICBpID0gZWNkc2EuY2FsY1B1YktleVJlY292ZXJ5UGFyYW0oc2VjcDI1NmsxLCBlLCBlY3NpZ25hdHVyZSwgcHJpdmF0ZV9rZXkudG9QdWJsaWNLZXkoKS5RKTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSA0OyAvLyBjb21wcmVzc2VkXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjc7IC8vIGNvbXBhY3QgIC8vICAyNCBvciAyNyA6KCBmb3JjaW5nIG9kZC15IDJuZCBrZXkgY2FuZGlkYXRlKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vbmNlICUgMTAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXQVJOOiBcIiArIG5vbmNlICsgXCIgYXR0ZW1wdHMgdG8gZmluZCBjYW5vbmljYWwgc2lnbmF0dXJlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKGVjc2lnbmF0dXJlLnIsIGVjc2lnbmF0dXJlLnMsIGkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzaWduJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ24oc3RyaW5nLCBwcml2YXRlX2tleSkge1xuICAgICAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5zaWduQnVmZmVyKG5ldyBCdWZmZXIoc3RyaW5nKSwgcHJpdmF0ZV9rZXkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tSGV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmZyb21CdWZmZXIobmV3IEJ1ZmZlcihoZXgsIFwiaGV4XCIpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2lnbkhleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaWduSGV4KGhleCwgcHJpdmF0ZV9rZXkpIHtcbiAgICAgICAgICAgIHZhciBidWY7XG4gICAgICAgICAgICBidWYgPSBuZXcgQnVmZmVyKGhleCwgJ2hleCcpO1xuICAgICAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5zaWduQnVmZmVyKGJ1ZiwgcHJpdmF0ZV9rZXkpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNpZ25hdHVyZTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaWduYXR1cmU7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L2VjYy9zcmMvc2lnbmF0dXJlLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3QvZWNjL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24ocmVxdWlyZShcIi4vY2hhaW5cIiksIHJlcXVpcmUoXCIuL2VjY1wiKSwgcmVxdWlyZShcIi4vc2VyaWFsaXplclwiKSk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3RcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgLy8gUHJpbWFyeSBjbGFzcyBmb3IgY3JlYXRpbmcgb3BlcmF0aW9uc1xuICAgIFNlcmlhbGl6ZXI6IHJlcXVpcmUoJy4vc3JjL3NlcmlhbGl6ZXInKSxcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbnMgZm9yIGNyZWF0aW5nIG9wZXJhdGlvbnNcbiAgICBmcDogcmVxdWlyZSgnLi9zcmMvRmFzdFBhcnNlcicpLFxuXG4gICAgLy8gTG93IGxldmVsIHR5cGVzXG4gICAgdHlwZXM6IHJlcXVpcmUoJy4vc3JjL3R5cGVzJyksXG5cbiAgICAvLyBIaWdoZXIgbGV2ZWwgb3BlcmF0aW9ucyAobWFkZSBvdXQgb2YgZ2VuZXJpYyB0eXBlcylcbiAgICBvcHM6IHJlcXVpcmUoJy4vc3JjL29wZXJhdGlvbnMnKSxcblxuICAgIC8vIFV0aWxpdHkgdGhhdCBnZW5lcmF0ZXMgSlNPTiBleGFtcGxlc1xuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3NyYy90ZW1wbGF0ZScpLFxuXG4gICAgLy8gU2VyaWFsaXplciB2YWxpZGF0aW9uXG4gICAgU2VyaWFsaXplclZhbGlkYXRpb246IHJlcXVpcmUoJy4vc3JjL1NlcmlhbGl6ZXJWYWxpZGF0aW9uJylcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9zZXJpYWxpemVyXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUHVibGljS2V5ID0gcmVxdWlyZShcIi4uLy4uL2VjYy9zcmMvUHVibGljS2V5XCIpO1xuXG52YXIgRmFzdFBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGYXN0UGFyc2VyKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmFzdFBhcnNlcik7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEZhc3RQYXJzZXIsIG51bGwsIFt7XG4gICAgICAgIGtleTogJ2ZpeGVkX2RhdGEnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZml4ZWRfZGF0YShiLCBsZW4sIGJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gYnVmZmVyLnNsaWNlKDAsIGxlbikudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgICAgICAgICAgIGIuYXBwZW5kKGRhdGEsICdiaW5hcnknKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobGVuLS0gPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBiLndyaXRlVWludDgoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYl9jb3B5ID0gYi5jb3B5KGIub2Zmc2V0LCBiLm9mZnNldCArIGxlbik7XG4gICAgICAgICAgICAgICAgYi5za2lwKGxlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYl9jb3B5LnRvQmluYXJ5KCksICdiaW5hcnknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncHVibGljX2tleScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdWJsaWNfa2V5KGIsIF9wdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3B1YmxpY19rZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gX3B1YmxpY19rZXkudG9CdWZmZXIoKTtcbiAgICAgICAgICAgICAgICBiLmFwcGVuZChidWZmZXIudG9TdHJpbmcoJ2JpbmFyeScpLCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBGYXN0UGFyc2VyLmZpeGVkX2RhdGEoYiwgMzMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbUJ1ZmZlcihidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyaXBlbWQxNjAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmlwZW1kMTYwKGIsIF9yaXBlbWQpIHtcbiAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfcmlwZW1kKSB7XG4gICAgICAgICAgICAgICAgRmFzdFBhcnNlci5maXhlZF9kYXRhKGIsIDIwLCBfcmlwZW1kKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBGYXN0UGFyc2VyLmZpeGVkX2RhdGEoYiwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0aW1lX3BvaW50X3NlYycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lX3BvaW50X3NlYyhiLCBlcG9jaCkge1xuICAgICAgICAgICAgaWYgKGVwb2NoKSB7XG4gICAgICAgICAgICAgICAgZXBvY2ggPSBNYXRoLmNlaWwoZXBvY2ggLyAxMDAwKTtcbiAgICAgICAgICAgICAgICBiLndyaXRlSW50MzIoZXBvY2gpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXBvY2ggPSBiLnJlYWRJbnQzMigpOyAvLyBmYzo6dGltZV9wb2ludF9zZWNcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZXBvY2ggKiAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBGYXN0UGFyc2VyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhc3RQYXJzZXI7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL0Zhc3RQYXJzZXIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9zZXJpYWxpemVyL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdieXRlYnVmZmVyJyk7XG5cbnZhciBMb25nID0gX3JlcXVpcmUuTG9uZztcblxudmFyIENoYWluVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9jaGFpbi9zcmMvQ2hhaW5UeXBlcycpO1xuXG52YXIgTUFYX1NBRkVfSU5UID0gOTAwNzE5OTI1NDc0MDk5MTtcbnZhciBNSU5fU0FGRV9JTlQgPSAtOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gICAgTW9zdCB2YWxpZGF0aW9ucyBhcmUgc2tpcHBlZCBhbmQgdGhlIHZhbHVlIHJldHVybmVkIHVuY2hhbmdlZCB3aGVuIGFuIGVtcHR5IHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkIGlzIGVuY291bnRlcmVkIChleGNlcHQgXCJyZXF1aXJlZFwiKS5cblxuICAgIFZhbGlkYXRpb25zIHN1cHBvcnQgYSBzdHJpbmcgZm9ybWF0IGZvciBkZWFsaW5nIHdpdGggbGFyZ2UgbnVtYmVycy5cbiovXG52YXIgX215ID0ge1xuXG4gICAgaXNfZW1wdHk6IGZ1bmN0aW9uIGlzX2VtcHR5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICByZXF1aXJlZDogZnVuY3Rpb24gcmVxdWlyZWQodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIHJlcXVpcmVkICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlcXVpcmVfbG9uZzogZnVuY3Rpb24gcmVxdWlyZV9sb25nKHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuXG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvbmcgdmFsdWUgcmVxdWlyZWQgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc3RyaW5nOiBmdW5jdGlvbiBzdHJpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgcmVxdWlyZWQ6ICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgbnVtYmVyOiBmdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgcmVxdWlyZWQ6ICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgd2hvbGVfbnVtYmVyOiBmdW5jdGlvbiB3aG9sZV9udW1iZXIodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9cXC4vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dob2xlIG51bWJlciByZXF1aXJlZCAnICsgZmllbGRfbmFtZSArICcgJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICB1bnNpZ25lZDogZnVuY3Rpb24gdW5zaWduZWQodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC8tLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNpZ25lZCByZXF1aXJlZCAnICsgZmllbGRfbmFtZSArICcgJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuXG4gICAgaXNfZGlnaXRzOiBmdW5jdGlvbiBpc19kaWdpdHModmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1lcmljXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoL15bMC05XSskLy50ZXN0KHZhbHVlKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICB0b19udW1iZXI6IGZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJcIjtcblxuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vX292ZXJmbG93NTModmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICB2YXIgaW50X3ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4gaW50X3ZhbHVlO1xuICAgIH0sXG5cbiAgICB0b19sb25nOiBmdW5jdGlvbiB0b19sb25nKHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChMb25nLmlzTG9uZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubm9fb3ZlcmZsb3c2NCh2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gXCJcIiArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgIH0sXG4gICAgdG9fc3RyaW5nOiBmdW5jdGlvbiB0b19zdHJpbmcodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMubm9fb3ZlcmZsb3c1Myh2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChMb25nLmlzTG9uZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93ICd1bnN1cHBvcnRlZCB0eXBlICcgKyBmaWVsZF9uYW1lICsgJzogKCcgKyAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpICsgJykgJyArIHZhbHVlO1xuICAgIH0sXG4gICAgcmVxdWlyZV90ZXN0OiBmdW5jdGlvbiByZXF1aXJlX3Rlc3QocmVnZXgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBcIlwiO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5tYXRjaGVkICcgKyByZWdleCArICcgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cblxuICAgIHJlcXVpcmVfbWF0Y2g6IGZ1bmN0aW9uIHJlcXVpcmVfbWF0Y2gocmVnZXgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBcIlwiO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VubWF0Y2hlZCAnICsgcmVnZXggKyAnICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9LFxuXG4gICAgcmVxdWlyZV9vYmplY3RfaWQ6IGZ1bmN0aW9uIHJlcXVpcmVfb2JqZWN0X2lkKHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlX21hdGNoKC9eKFswLTldKylcXC4oWzAtOV0rKVxcLihbMC05XSspJC8sIHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICB9LFxuXG4gICAgLy8gRG9lcyBub3Qgc3VwcG9ydCBvdmVyIDUzIGJpdHNcbiAgICByZXF1aXJlX3JhbmdlOiBmdW5jdGlvbiByZXF1aXJlX3JhbmdlKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJcIjtcblxuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnVtYmVyID0gdGhpcy50b19udW1iZXIodmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgPCBtaW4gfHwgdmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0IG9mIHJhbmdlICcgKyB2YWx1ZSArICcgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cblxuICAgIHJlcXVpcmVfb2JqZWN0X3R5cGU6IGZ1bmN0aW9uIHJlcXVpcmVfb2JqZWN0X3R5cGUoKSB7XG4gICAgICAgIHZhciByZXNlcnZlZF9zcGFjZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG4gICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBcIlwiO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvYmplY3RfdHlwZSA9IENoYWluVHlwZXMub2JqZWN0X3R5cGVbdHlwZV07XG4gICAgICAgIGlmICghb2JqZWN0X3R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBvYmplY3QgdHlwZSAnICsgdHlwZSArICcgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cChyZXNlcnZlZF9zcGFjZXMgKyAnLicgKyBvYmplY3RfdHlwZSArICcuWzAtOV0rJCcpO1xuICAgICAgICBpZiAoIXJlLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGluZyAnICsgdHlwZSArICcgaW4gZm9ybWF0ICcgKyAocmVzZXJ2ZWRfc3BhY2VzICsgJy4nICsgb2JqZWN0X3R5cGUgKyAnLlswLTldKyAnKSArICgnaW5zdGVhZCBvZiAnICsgdmFsdWUgKyAnICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldF9pbnN0YW5jZTogZnVuY3Rpb24gZ2V0X2luc3RhbmNlKHJlc2VydmVfc3BhY2VzLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVpcmVfb2JqZWN0X3R5cGUocmVzZXJ2ZV9zcGFjZXMsIHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9fbnVtYmVyKHZhbHVlLnNwbGl0KCcuJylbMl0pO1xuICAgIH0sXG5cbiAgICByZXF1aXJlX3JlbGF0aXZlX3R5cGU6IGZ1bmN0aW9uIHJlcXVpcmVfcmVsYXRpdmVfdHlwZSh0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICB0aGlzLnJlcXVpcmVfb2JqZWN0X3R5cGUoMCwgdHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldF9yZWxhdGl2ZV9pbnN0YW5jZTogZnVuY3Rpb24gZ2V0X3JlbGF0aXZlX2luc3RhbmNlKHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWlyZV9vYmplY3RfdHlwZSgwLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvX251bWJlcih2YWx1ZS5zcGxpdCgnLicpWzJdKTtcbiAgICB9LFxuXG4gICAgcmVxdWlyZV9wcm90b2NvbF90eXBlOiBmdW5jdGlvbiByZXF1aXJlX3Byb3RvY29sX3R5cGUodHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpIHtcbiAgICAgICAgdGhpcy5yZXF1aXJlX29iamVjdF90eXBlKDEsIHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXRfcHJvdG9jb2xfaW5zdGFuY2U6IGZ1bmN0aW9uIGdldF9wcm90b2NvbF9pbnN0YW5jZSh0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVpcmVfb2JqZWN0X3R5cGUoMSwgdHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy50b19udW1iZXIodmFsdWUuc3BsaXQoJy4nKVsyXSk7XG4gICAgfSxcblxuICAgIGdldF9wcm90b2NvbF90eXBlOiBmdW5jdGlvbiBnZXRfcHJvdG9jb2xfdHlwZSh2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVpcmVfb2JqZWN0X2lkKHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHZhbHVlLnNwbGl0KCcuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvX251bWJlcih2YWx1ZXNbMV0pO1xuICAgIH0sXG5cbiAgICBnZXRfcHJvdG9jb2xfdHlwZV9uYW1lOiBmdW5jdGlvbiBnZXRfcHJvdG9jb2xfdHlwZV9uYW1lKHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlX2lkID0gdGhpcy5nZXRfcHJvdG9jb2xfdHlwZSh2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhDaGFpblR5cGVzLm9iamVjdF90eXBlKVt0eXBlX2lkXTtcbiAgICB9LFxuXG5cbiAgICByZXF1aXJlX2ltcGxlbWVudGF0aW9uX3R5cGU6IGZ1bmN0aW9uIHJlcXVpcmVfaW1wbGVtZW50YXRpb25fdHlwZSh0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICB0aGlzLnJlcXVpcmVfb2JqZWN0X3R5cGUoMiwgdHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldF9pbXBsZW1lbnRhdGlvbl9pbnN0YW5jZTogZnVuY3Rpb24gZ2V0X2ltcGxlbWVudGF0aW9uX2luc3RhbmNlKHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWlyZV9vYmplY3RfdHlwZSgyLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvX251bWJlcih2YWx1ZS5zcGxpdCgnLicpWzJdKTtcbiAgICB9LFxuXG4gICAgLy8gc2lnbmVkIC8gdW5zaWduZWQgZGVjaW1hbFxuICAgIG5vX292ZXJmbG93NTM6IGZ1bmN0aW9uIG5vX292ZXJmbG93NTModmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gTUFYX1NBRkVfSU5UIHx8IHZhbHVlIDwgTUlOX1NBRkVfSU5UKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdmVyZmxvdyAnICsgZmllbGRfbmFtZSArICcgJyArIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgaW50ID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gTUFYX1NBRkVfSU5UIHx8IHZhbHVlIDwgTUlOX1NBRkVfSU5UKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdmVyZmxvdyAnICsgZmllbGRfbmFtZSArICcgJyArIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTG9uZy5pc0xvbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAvLyB0eXBlb2YgdmFsdWUudG9JbnQoKSBpcyAnbnVtYmVyJ1xuICAgICAgICAgICAgdGhpcy5ub19vdmVyZmxvdzUzKHZhbHVlLnRvSW50KCksIGZpZWxkX25hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93ICd1bnN1cHBvcnRlZCB0eXBlICcgKyBmaWVsZF9uYW1lICsgJzogKCcgKyAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpICsgJykgJyArIHZhbHVlO1xuICAgIH0sXG5cblxuICAgIC8vIHNpZ25lZCAvIHVuc2lnbmVkIHdob2xlIG51bWJlcnMgb25seVxuICAgIG5vX292ZXJmbG93NjQ6IGZ1bmN0aW9uIG5vX292ZXJmbG93NjQodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vTG9uZy5qcy9pc3N1ZXMvMjBcbiAgICAgICAgaWYgKExvbmcuaXNMb25nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmlnSW50ZWdlciNpc0JpZ0ludGVnZXIgaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9iaWdpL2lzc3Vlcy8yMFxuICAgICAgICBpZiAodmFsdWUudCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5ub19vdmVyZmxvdzY0KHZhbHVlLnRvU3RyaW5nKCksIGZpZWxkX25hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGxlYWRpbmcgemVyb3MsIHdpbGwgY2F1c2UgYSBmYWxzZSBwb3NpdGl2ZVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eMCsvLCAnJyk7XG4gICAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb3NcbiAgICAgICAgICAgIHdoaWxlICgvMCQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoL1xcLiQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIGRvdFxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIjBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsb25nX3N0cmluZyA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChsb25nX3N0cmluZyAhPT0gdmFsdWUudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdmVyZmxvdyAnICsgZmllbGRfbmFtZSArICcgJyArIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBNQVhfU0FGRV9JTlQgfHwgdmFsdWUgPCBNSU5fU0FGRV9JTlQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ292ZXJmbG93ICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgJ3Vuc3VwcG9ydGVkIHR5cGUgJyArIGZpZWxkX25hbWUgKyAnOiAoJyArICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgKyAnKSAnICsgdmFsdWU7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBfbXk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL1NlcmlhbGl6ZXJWYWxpZGF0aW9uLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqIEV4Y2VwdGlvbiBuZXN0aW5nLiAgKi9cbnZhciBFcnJvcldpdGhDYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFcnJvcldpdGhDYXVzZShtZXNzYWdlLCBjYXVzZSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXJyb3JXaXRoQ2F1c2UpO1xuXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIGlmICh0eXBlb2YgY2F1c2UgIT09IFwidW5kZWZpbmVkXCIgJiYgY2F1c2UgIT09IG51bGwgPyBjYXVzZS5tZXNzYWdlIDogdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcImNhdXNlXFx0XCIgKyBjYXVzZS5tZXNzYWdlICsgXCJcXHRcIiArIHRoaXMubWVzc2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFjayA9IFwiXCI7IC8vKG5ldyBFcnJvcikuc3RhY2tcbiAgICAgICAgaWYgKHR5cGVvZiBjYXVzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYXVzZSAhPT0gbnVsbCA/IGNhdXNlLnN0YWNrIDogdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGFjayA9IFwiY2F1c2VkIGJ5XFxuXFx0XCIgKyBjYXVzZS5zdGFjayArIFwiXFx0XCIgKyBzdGFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLm1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2s7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEVycm9yV2l0aENhdXNlLCBudWxsLCBbe1xuICAgICAgICBrZXk6IFwidGhyb3dcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90aHJvdyhtZXNzYWdlLCBjYXVzZSkge1xuICAgICAgICAgICAgdmFyIG1zZyA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhdXNlICE9PSBcInVuZGVmaW5lZFwiICYmIGNhdXNlICE9PSBudWxsID8gY2F1c2UubWVzc2FnZSA6IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1zZyArPSBcIlxcdCBjYXVzZTogXCIgKyBjYXVzZS5tZXNzYWdlICsgXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhdXNlICE9PSBcInVuZGVmaW5lZFwiICYmIGNhdXNlICE9PSBudWxsID8gY2F1c2Uuc3RhY2sgOiB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtc2cgKz0gXCJcXG4gc3RhY2s6IFwiICsgY2F1c2Uuc3RhY2sgKyBcIiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEVycm9yV2l0aENhdXNlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVycm9yV2l0aENhdXNlO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9lcnJvcl93aXRoX2NhdXNlLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG4vKipcbiAgICBDb252ZXJ0IDEyLjM0IHdpdGggYSBwcmVjaXNpb24gb2YgMyBpbnRvIDEyMzQwXG5cbiAgICBAYXJnIHtudW1iZXJ8c3RyaW5nfSBudW1iZXIgLSBVc2Ugc3RyaW5ncyBmb3IgbGFyZ2UgbnVtYmVycy4gIFRoaXMgbWF5IGNvbnRhaW4gb25lIGRlY2ltYWwgYnV0IG5vIHNpZ25cbiAgICBAYXJnIHtudW1iZXJ9IHByZWNpc2lvbiAtIG51bWJlciBvZiBpbXBsaWVkIGRlY2ltYWwgcGxhY2VzICh1c3VhbGx5IGNhdXNlcyByaWdodCB6ZXJvIHBhZGRpbmcpXG4gICAgQHJldHVybiB7c3RyaW5nfSAtXG4qL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdG9JbXBsaWVkRGVjaW1hbDogZnVuY3Rpb24gdG9JbXBsaWVkRGVjaW1hbChudW1iZXIsIHByZWNpc2lvbikge1xuXG4gICAgICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBhc3NlcnQobnVtYmVyIDw9IDkwMDcxOTkyNTQ3NDA5OTEsIFwib3ZlcmZsb3dcIik7XG4gICAgICAgICAgICBudW1iZXIgPSBcIlwiICsgbnVtYmVyO1xuICAgICAgICB9IGVsc2UgaWYgKG51bWJlci50b1N0cmluZykgbnVtYmVyID0gbnVtYmVyLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBudW1iZXIgPT09IFwic3RyaW5nXCIsIFwibnVtYmVyIHNob3VsZCBiZSBhbiBhY3R1YWwgbnVtYmVyIG9yIHN0cmluZzogXCIgKyAodHlwZW9mIG51bWJlciA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG51bWJlcikpKTtcbiAgICAgICAgbnVtYmVyID0gbnVtYmVyLnRyaW0oKTtcbiAgICAgICAgYXNzZXJ0KC9eWzAtOV0qXFwuP1swLTldKiQvLnRlc3QobnVtYmVyKSwgXCJJbnZhbGlkIGRlY2ltYWwgbnVtYmVyIFwiICsgbnVtYmVyKTtcblxuICAgICAgICB2YXIgX251bWJlciRzcGxpdCA9IG51bWJlci5zcGxpdChcIi5cIik7XG5cbiAgICAgICAgdmFyIF9udW1iZXIkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX251bWJlciRzcGxpdCwgMik7XG5cbiAgICAgICAgdmFyIF9udW1iZXIkc3BsaXQyJCA9IF9udW1iZXIkc3BsaXQyWzBdO1xuICAgICAgICB2YXIgd2hvbGUgPSBfbnVtYmVyJHNwbGl0MiQgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBfbnVtYmVyJHNwbGl0MiQ7XG4gICAgICAgIHZhciBfbnVtYmVyJHNwbGl0MiQyID0gX251bWJlciRzcGxpdDJbMV07XG4gICAgICAgIHZhciBkZWNpbWFsID0gX251bWJlciRzcGxpdDIkMiA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IF9udW1iZXIkc3BsaXQyJDI7XG5cblxuICAgICAgICB2YXIgcGFkZGluZyA9IHByZWNpc2lvbiAtIGRlY2ltYWwubGVuZ3RoO1xuICAgICAgICBhc3NlcnQocGFkZGluZyA+PSAwLCBcIlRvbyBtYW55IGRlY2ltYWwgZGlnaXRzIGluIFwiICsgbnVtYmVyICsgXCIgdG8gY3JlYXRlIGFuIGltcGxpZWQgZGVjaW1hbCBvZiBcIiArIHByZWNpc2lvbik7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRkaW5nOyBpKyspIHtcbiAgICAgICAgICAgIGRlY2ltYWwgKz0gXCIwXCI7XG4gICAgICAgIH13aGlsZSAod2hvbGUuY2hhckF0KDApID09PSBcIjBcIikge1xuICAgICAgICAgICAgd2hvbGUgPSB3aG9sZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1yZXR1cm4gd2hvbGUgKyBkZWNpbWFsO1xuICAgIH0sXG5cbiAgICBmcm9tSW1wbGllZERlY2ltYWw6IGZ1bmN0aW9uIGZyb21JbXBsaWVkRGVjaW1hbChudW1iZXIsIHByZWNpc2lvbikge1xuICAgICAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgYXNzZXJ0KG51bWJlciA8PSA5MDA3MTk5MjU0NzQwOTkxLCBcIm92ZXJmbG93XCIpO1xuICAgICAgICAgICAgbnVtYmVyID0gXCJcIiArIG51bWJlcjtcbiAgICAgICAgfSBlbHNlIGlmIChudW1iZXIudG9TdHJpbmcpIG51bWJlciA9IG51bWJlci50b1N0cmluZygpO1xuXG4gICAgICAgIHdoaWxlIChudW1iZXIubGVuZ3RoIDwgcHJlY2lzaW9uICsgMSkge1xuICAgICAgICAgICAgLy8gMC4xMjNcbiAgICAgICAgICAgIG51bWJlciA9IFwiMFwiICsgbnVtYmVyO1xuICAgICAgICB9IC8vIDQ0MDAwID0+IDQ0LjAwMFxuICAgICAgICB2YXIgZGVjX3N0cmluZyA9IG51bWJlci5zdWJzdHJpbmcobnVtYmVyLmxlbmd0aCAtIHByZWNpc2lvbik7XG4gICAgICAgIHJldHVybiBudW1iZXIuc3Vic3RyaW5nKDAsIG51bWJlci5sZW5ndGggLSBwcmVjaXNpb24pICsgKGRlY19zdHJpbmcgPyBcIi5cIiArIGRlY19zdHJpbmcgOiBcIlwiKTtcbiAgICB9XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9udW1iZXJVdGlscy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xudmFyIFNlcmlhbGl6ZXJJbXBsID0gcmVxdWlyZShcIi4vc2VyaWFsaXplclwiKTtcblxudmFyIGludDE2ID0gdHlwZXMuaW50MTY7XG52YXIgdWludDE2ID0gdHlwZXMudWludDE2O1xudmFyIHVpbnQzMiA9IHR5cGVzLnVpbnQzMjtcbnZhciBpbnQ2NCA9IHR5cGVzLmludDY0O1xudmFyIHVpbnQ2NCA9IHR5cGVzLnVpbnQ2NDtcbnZhciBzdHJpbmcgPSB0eXBlcy5zdHJpbmc7XG52YXIgYnl0ZXMgPSB0eXBlcy5ieXRlcztcbnZhciBib29sID0gdHlwZXMuYm9vbDtcbnZhciBhcnJheSA9IHR5cGVzLmFycmF5O1xudmFyIGZpeGVkX2FycmF5ID0gdHlwZXMuZml4ZWRfYXJyYXk7XG52YXIgb2JqZWN0X2lkX3R5cGUgPSB0eXBlcy5vYmplY3RfaWRfdHlwZTtcbnZhciB2b3RlX2lkID0gdHlwZXMudm90ZV9pZDtcbnZhciBmdXR1cmVfZXh0ZW5zaW9ucyA9IHR5cGVzLmZ1dHVyZV9leHRlbnNpb25zO1xudmFyIHN0YXRpY192YXJpYW50ID0gdHlwZXMuc3RhdGljX3ZhcmlhbnQ7XG52YXIgbWFwID0gdHlwZXMubWFwO1xudmFyIHNldCA9IHR5cGVzLnNldDtcbnZhciBwdWJsaWNfa2V5ID0gdHlwZXMucHVibGljX2tleTtcbnZhciBhZGRyZXNzID0gdHlwZXMuYWRkcmVzcztcbnZhciB0aW1lX3BvaW50X3NlYyA9IHR5cGVzLnRpbWVfcG9pbnRfc2VjO1xudmFyIG9wdGlvbmFsID0gdHlwZXMub3B0aW9uYWw7XG52YXIgYXNzZXQgPSB0eXBlcy5hc3NldDtcblxuXG5mdXR1cmVfZXh0ZW5zaW9ucyA9IHR5cGVzLnZvaWQ7XG5cbi8qXG5XaGVuIHVwZGF0aW5nIGdlbmVyYXRlZCBjb2RlXG5SZXBsYWNlOiAgb3BlcmF0aW9uID0gc3RhdGljX3ZhcmlhbnQgW1xud2l0aDogICAgIG9wZXJhdGlvbi5zdF9vcGVyYXRpb25zID0gW1xuXG5hdCB0aGUgZW5kIG9mIHRoaXMgZmlsZS5cblxuVGhlbiwgZGVsZXRlIHRoaXMgcGFydDpcbnB1YmxpY19rZXkgPSBuZXcgU2VyaWFsaXplcihcbiAgICBcInB1YmxpY19rZXlcIlxuICAgIGtleV9kYXRhOiBieXRlcyAzM1xuKVxuXG4qL1xuLy8gUGxhY2UtaG9sZGVyLCB0aGVpciBhcmUgZGVwZW5kZW5jaWVzIG9uIFwib3BlcmF0aW9uXCIgLi4gVGhlIGZpbmFsIGxpc3Qgb2Zcbi8vIG9wZXJhdGlvbnMgaXMgbm90IGF2aWFsYmxlIHVudGlsIHRoZSB2ZXJ5IGVuZCBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4vLyBTZWU6IG9wZXJhdGlvbi5zdF9vcGVyYXRpb25zID0gLi4uXG52YXIgb3BlcmF0aW9uID0gc3RhdGljX3ZhcmlhbnQoKTtcbm1vZHVsZS5leHBvcnRzW1wib3BlcmF0aW9uXCJdID0gb3BlcmF0aW9uO1xuXG4vLyBGb3IgbW9kdWxlLmV4cG9ydHNcbnZhciBTZXJpYWxpemVyID0gZnVuY3Rpb24gU2VyaWFsaXplcihvcGVyYXRpb25fbmFtZSwgc2VyaWxpemF0aW9uX3R5cGVzX29iamVjdCkge1xuICAgIHZhciBzID0gbmV3IFNlcmlhbGl6ZXJJbXBsKG9wZXJhdGlvbl9uYW1lLCBzZXJpbGl6YXRpb25fdHlwZXNfb2JqZWN0KTtcbiAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHNbb3BlcmF0aW9uX25hbWVdID0gcztcbn07XG5cbi8vIEN1c3RvbS10eXBlcyBmb2xsb3cgR2VuZXJhdGVkIGNvZGU6XG5cbi8vICMjICBHZW5lcmF0ZWQgY29kZSBmb2xsb3dzXG4vLyAjIG5wbSBpIC1nIGRlY2FmZmVpbmF0ZVxuLy8gIyBwcm9ncmFtcy9qc19vcGVyYXRpb25fc2VyaWFsaXplciA+IG9wcy5jb2ZmZWUgJiYgZGVjYWZmZWluYXRlIG9wcy5jb2ZmZWVcbi8vICMgb3BlbiBvcHMudHh0LCBjb3B5IHRvIENoYWluL0NoYWluVHlwZXMgYW5kIG9wZXJhdGlvbnMuanNcbi8vICMjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBzaWduZWRfdHJhbnNhY3Rpb24gPSBuZXcgU2VyaWFsaXplcihcInNpZ25lZF90cmFuc2FjdGlvblwiLCB7XG4gICAgcmVmX2Jsb2NrX251bTogdWludDE2LFxuICAgIHJlZl9ibG9ja19wcmVmaXg6IHVpbnQzMixcbiAgICBleHBpcmF0aW9uOiB0aW1lX3BvaW50X3NlYyxcbiAgICBvcGVyYXRpb25zOiBhcnJheShvcGVyYXRpb24pLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucyksXG4gICAgc2lnbmF0dXJlczogYXJyYXkoYnl0ZXMoNjUpKVxufSk7XG5cbnZhciBzaWduZWRfYmxvY2sgPSBuZXcgU2VyaWFsaXplcihcInNpZ25lZF9ibG9ja1wiLCB7XG4gICAgcHJldmlvdXM6IGJ5dGVzKDIwKSxcbiAgICB0aW1lc3RhbXA6IHRpbWVfcG9pbnRfc2VjLFxuICAgIHdpdG5lc3M6IHN0cmluZyxcbiAgICB0cmFuc2FjdGlvbl9tZXJrbGVfcm9vdDogYnl0ZXMoMjApLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucyksXG4gICAgd2l0bmVzc19zaWduYXR1cmU6IGJ5dGVzKDY1KSxcbiAgICB0cmFuc2FjdGlvbnM6IGFycmF5KHNpZ25lZF90cmFuc2FjdGlvbilcbn0pO1xuXG52YXIgYmxvY2tfaGVhZGVyID0gbmV3IFNlcmlhbGl6ZXIoXCJibG9ja19oZWFkZXJcIiwge1xuICAgIHByZXZpb3VzOiBieXRlcygyMCksXG4gICAgdGltZXN0YW1wOiB0aW1lX3BvaW50X3NlYyxcbiAgICB3aXRuZXNzOiBzdHJpbmcsXG4gICAgdHJhbnNhY3Rpb25fbWVya2xlX3Jvb3Q6IGJ5dGVzKDIwKSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpXG59KTtcblxudmFyIHNpZ25lZF9ibG9ja19oZWFkZXIgPSBuZXcgU2VyaWFsaXplcihcInNpZ25lZF9ibG9ja19oZWFkZXJcIiwge1xuICAgIHByZXZpb3VzOiBieXRlcygyMCksXG4gICAgdGltZXN0YW1wOiB0aW1lX3BvaW50X3NlYyxcbiAgICB3aXRuZXNzOiBzdHJpbmcsXG4gICAgdHJhbnNhY3Rpb25fbWVya2xlX3Jvb3Q6IGJ5dGVzKDIwKSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpLFxuICAgIHdpdG5lc3Nfc2lnbmF0dXJlOiBieXRlcyg2NSlcbn0pO1xuXG52YXIgdm90ZSA9IG5ldyBTZXJpYWxpemVyKFwidm90ZVwiLCB7XG4gICAgdm90ZXI6IHN0cmluZyxcbiAgICBhdXRob3I6IHN0cmluZyxcbiAgICBwZXJtbGluazogc3RyaW5nLFxuICAgIHdlaWdodDogdWludDE2XG59KTtcblxudmFyIGNvbW1lbnQgPSBuZXcgU2VyaWFsaXplcihcImNvbW1lbnRcIiwge1xuICAgIHBhcmVudF9hdXRob3I6IHN0cmluZyxcbiAgICBwYXJlbnRfcGVybWxpbms6IHN0cmluZyxcbiAgICBhdXRob3I6IHN0cmluZyxcbiAgICBwZXJtbGluazogc3RyaW5nLFxuICAgIHRpdGxlOiBzdHJpbmcsXG4gICAgYm9keTogc3RyaW5nLFxuICAgIGpzb25fbWV0YWRhdGE6IHN0cmluZ1xufSk7XG5cbi8vIGxldCBhc3NldCA9IG5ldyBTZXJpYWxpemVyKFxuLy8gICAgIFwiYXNzZXRcIix7XG4vLyAgICAgYW1vdW50OiBpbnQ2NCxcbi8vICAgICBzeW1ib2w6IHN0cmluZ1xuLy8gfVxuLy8gKTtcblxudmFyIHRyYW5zZmVyID0gbmV3IFNlcmlhbGl6ZXIoXCJ0cmFuc2ZlclwiLCB7XG4gICAgZnJvbTogc3RyaW5nLFxuICAgIHRvOiBzdHJpbmcsXG4gICAgYW1vdW50OiBhc3NldCxcbiAgICBtZW1vOiBzdHJpbmdcbn0pO1xuXG52YXIgdHJhbnNmZXJfdG9fdmVzdGluZyA9IG5ldyBTZXJpYWxpemVyKFwidHJhbnNmZXJfdG9fdmVzdGluZ1wiLCB7XG4gICAgZnJvbTogc3RyaW5nLFxuICAgIHRvOiBzdHJpbmcsXG4gICAgYW1vdW50OiBhc3NldFxufSk7XG5cbnZhciB3aXRoZHJhd192ZXN0aW5nID0gbmV3IFNlcmlhbGl6ZXIoXCJ3aXRoZHJhd192ZXN0aW5nXCIsIHtcbiAgICBhY2NvdW50OiBzdHJpbmcsXG4gICAgdmVzdGluZ19zaGFyZXM6IGFzc2V0XG59KTtcblxudmFyIGxpbWl0X29yZGVyX2NyZWF0ZSA9IG5ldyBTZXJpYWxpemVyKFwibGltaXRfb3JkZXJfY3JlYXRlXCIsIHtcbiAgICBvd25lcjogc3RyaW5nLFxuICAgIG9yZGVyaWQ6IHVpbnQzMixcbiAgICBhbW91bnRfdG9fc2VsbDogYXNzZXQsXG4gICAgbWluX3RvX3JlY2VpdmU6IGFzc2V0LFxuICAgIGZpbGxfb3Jfa2lsbDogYm9vbCxcbiAgICBleHBpcmF0aW9uOiB0aW1lX3BvaW50X3NlY1xufSk7XG5cbnZhciBsaW1pdF9vcmRlcl9jYW5jZWwgPSBuZXcgU2VyaWFsaXplcihcImxpbWl0X29yZGVyX2NhbmNlbFwiLCB7XG4gICAgb3duZXI6IHN0cmluZyxcbiAgICBvcmRlcmlkOiB1aW50MzJcbn0pO1xuXG52YXIgcHJpY2UgPSBuZXcgU2VyaWFsaXplcihcInByaWNlXCIsIHtcbiAgICBiYXNlOiBhc3NldCxcbiAgICBxdW90ZTogYXNzZXRcbn0pO1xuXG52YXIgZmVlZF9wdWJsaXNoID0gbmV3IFNlcmlhbGl6ZXIoXCJmZWVkX3B1Ymxpc2hcIiwge1xuICAgIHB1Ymxpc2hlcjogc3RyaW5nLFxuICAgIGV4Y2hhbmdlX3JhdGU6IHByaWNlXG59KTtcblxudmFyIGNvbnZlcnQgPSBuZXcgU2VyaWFsaXplcihcImNvbnZlcnRcIiwge1xuICAgIG93bmVyOiBzdHJpbmcsXG4gICAgcmVxdWVzdGlkOiB1aW50MzIsXG4gICAgYW1vdW50OiBhc3NldFxufSk7XG5cbnZhciBhdXRob3JpdHkgPSBuZXcgU2VyaWFsaXplcihcImF1dGhvcml0eVwiLCB7XG4gICAgd2VpZ2h0X3RocmVzaG9sZDogdWludDMyLFxuICAgIGFjY291bnRfYXV0aHM6IG1hcChzdHJpbmcsIHVpbnQxNiksXG4gICAga2V5X2F1dGhzOiBtYXAocHVibGljX2tleSwgdWludDE2KVxufSk7XG5cbnZhciBhY2NvdW50X2NyZWF0ZSA9IG5ldyBTZXJpYWxpemVyKFwiYWNjb3VudF9jcmVhdGVcIiwge1xuICAgIGZlZTogYXNzZXQsXG4gICAgY3JlYXRvcjogc3RyaW5nLFxuICAgIG5ld19hY2NvdW50X25hbWU6IHN0cmluZyxcbiAgICBvd25lcjogYXV0aG9yaXR5LFxuICAgIGFjdGl2ZTogYXV0aG9yaXR5LFxuICAgIHBvc3Rpbmc6IGF1dGhvcml0eSxcbiAgICBtZW1vX2tleTogcHVibGljX2tleSxcbiAgICBqc29uX21ldGFkYXRhOiBzdHJpbmdcbn0pO1xuXG52YXIgYWNjb3VudF91cGRhdGUgPSBuZXcgU2VyaWFsaXplcihcImFjY291bnRfdXBkYXRlXCIsIHtcbiAgICBhY2NvdW50OiBzdHJpbmcsXG4gICAgb3duZXI6IG9wdGlvbmFsKGF1dGhvcml0eSksXG4gICAgYWN0aXZlOiBvcHRpb25hbChhdXRob3JpdHkpLFxuICAgIHBvc3Rpbmc6IG9wdGlvbmFsKGF1dGhvcml0eSksXG4gICAgbWVtb19rZXk6IHB1YmxpY19rZXksXG4gICAganNvbl9tZXRhZGF0YTogc3RyaW5nXG59KTtcblxudmFyIGNoYWluX3Byb3BlcnRpZXMgPSBuZXcgU2VyaWFsaXplcihcImNoYWluX3Byb3BlcnRpZXNcIiwge1xuICAgIGFjY291bnRfY3JlYXRpb25fZmVlOiBhc3NldCxcbiAgICBtYXhpbXVtX2Jsb2NrX3NpemU6IHVpbnQzMixcbiAgICBzYmRfaW50ZXJlc3RfcmF0ZTogdWludDE2XG59KTtcblxudmFyIHdpdG5lc3NfdXBkYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJ3aXRuZXNzX3VwZGF0ZVwiLCB7XG4gICAgb3duZXI6IHN0cmluZyxcbiAgICB1cmw6IHN0cmluZyxcbiAgICBibG9ja19zaWduaW5nX2tleTogcHVibGljX2tleSxcbiAgICBwcm9wczogY2hhaW5fcHJvcGVydGllcyxcbiAgICBmZWU6IGFzc2V0XG59KTtcblxudmFyIGFjY291bnRfd2l0bmVzc192b3RlID0gbmV3IFNlcmlhbGl6ZXIoXCJhY2NvdW50X3dpdG5lc3Nfdm90ZVwiLCB7XG4gICAgYWNjb3VudDogc3RyaW5nLFxuICAgIHdpdG5lc3M6IHN0cmluZyxcbiAgICBhcHByb3ZlOiBib29sXG59KTtcblxudmFyIGFjY291bnRfd2l0bmVzc19wcm94eSA9IG5ldyBTZXJpYWxpemVyKFwiYWNjb3VudF93aXRuZXNzX3Byb3h5XCIsIHtcbiAgICBhY2NvdW50OiBzdHJpbmcsXG4gICAgcHJveHk6IHN0cmluZ1xufSk7XG5cbnZhciBwb3cgPSBuZXcgU2VyaWFsaXplcihcInBvd1wiLCB7XG4gICAgd29ya2VyOiBwdWJsaWNfa2V5LFxuICAgIGlucHV0OiBieXRlcygzMiksXG4gICAgc2lnbmF0dXJlOiBieXRlcyg2NSksXG4gICAgd29yazogYnl0ZXMoMzIpXG59KTtcblxudmFyIGN1c3RvbSA9IG5ldyBTZXJpYWxpemVyKFwiY3VzdG9tXCIsIHtcbiAgICByZXF1aXJlZF9hdXRoczogc2V0KHN0cmluZyksXG4gICAgaWQ6IHVpbnQxNixcbiAgICBkYXRhOiBieXRlcygpXG59KTtcblxudmFyIHJlcG9ydF9vdmVyX3Byb2R1Y3Rpb24gPSBuZXcgU2VyaWFsaXplcihcInJlcG9ydF9vdmVyX3Byb2R1Y3Rpb25cIiwge1xuICAgIHJlcG9ydGVyOiBzdHJpbmcsXG4gICAgZmlyc3RfYmxvY2s6IHNpZ25lZF9ibG9ja19oZWFkZXIsXG4gICAgc2Vjb25kX2Jsb2NrOiBzaWduZWRfYmxvY2tfaGVhZGVyXG59KTtcblxudmFyIGRlbGV0ZV9jb21tZW50ID0gbmV3IFNlcmlhbGl6ZXIoXCJkZWxldGVfY29tbWVudFwiLCB7XG4gICAgYXV0aG9yOiBzdHJpbmcsXG4gICAgcGVybWxpbms6IHN0cmluZ1xufSk7XG5cbnZhciBjdXN0b21fanNvbiA9IG5ldyBTZXJpYWxpemVyKFwiY3VzdG9tX2pzb25cIiwge1xuICAgIHJlcXVpcmVkX2F1dGhzOiBzZXQoc3RyaW5nKSxcbiAgICByZXF1aXJlZF9wb3N0aW5nX2F1dGhzOiBzZXQoc3RyaW5nKSxcbiAgICBpZDogc3RyaW5nLFxuICAgIGpzb246IHN0cmluZ1xufSk7XG5cbnZhciBjb21tZW50X29wdGlvbnMgPSBuZXcgU2VyaWFsaXplcihcImNvbW1lbnRfb3B0aW9uc1wiLCB7XG4gICAgYXV0aG9yOiBzdHJpbmcsXG4gICAgcGVybWxpbms6IHN0cmluZyxcbiAgICBtYXhfYWNjZXB0ZWRfcGF5b3V0OiBhc3NldCxcbiAgICBwZXJjZW50X3N0ZWVtX2RvbGxhcnM6IHVpbnQxNixcbiAgICBhbGxvd192b3RlczogYm9vbCxcbiAgICBhbGxvd19jdXJhdGlvbl9yZXdhcmRzOiBib29sLFxuICAgIGV4dGVuc2lvbnM6IHNldChzdGF0aWNfdmFyaWFudChbZnV0dXJlX2V4dGVuc2lvbnNdKSlcbn0pO1xuXG52YXIgc2V0X3dpdGhkcmF3X3Zlc3Rpbmdfcm91dGUgPSBuZXcgU2VyaWFsaXplcihcInNldF93aXRoZHJhd192ZXN0aW5nX3JvdXRlXCIsIHtcbiAgICBmcm9tX2FjY291bnQ6IHN0cmluZyxcbiAgICB0b19hY2NvdW50OiBzdHJpbmcsXG4gICAgcGVyY2VudDogdWludDE2LFxuICAgIGF1dG9fdmVzdDogYm9vbFxufSk7XG5cbnZhciBmaWxsX2NvbnZlcnRfcmVxdWVzdCA9IG5ldyBTZXJpYWxpemVyKFwiZmlsbF9jb252ZXJ0X3JlcXVlc3RcIiwge1xuICAgIG93bmVyOiBzdHJpbmcsXG4gICAgcmVxdWVzdGlkOiB1aW50MzIsXG4gICAgYW1vdW50X2luOiBhc3NldCxcbiAgICBhbW91bnRfb3V0OiBhc3NldFxufSk7XG5cbnZhciBjb21tZW50X3Jld2FyZCA9IG5ldyBTZXJpYWxpemVyKFwiY29tbWVudF9yZXdhcmRcIiwge1xuICAgIGF1dGhvcjogc3RyaW5nLFxuICAgIHBlcm1saW5rOiBzdHJpbmcsXG4gICAgc2JkX3BheW91dDogYXNzZXQsXG4gICAgdmVzdGluZ19wYXlvdXQ6IGFzc2V0XG59KTtcblxudmFyIGN1cmF0ZV9yZXdhcmQgPSBuZXcgU2VyaWFsaXplcihcImN1cmF0ZV9yZXdhcmRcIiwge1xuICAgIGN1cmF0b3I6IHN0cmluZyxcbiAgICByZXdhcmQ6IGFzc2V0LFxuICAgIGNvbW1lbnRfYXV0aG9yOiBzdHJpbmcsXG4gICAgY29tbWVudF9wZXJtbGluazogc3RyaW5nXG59KTtcblxudmFyIGxpcXVpZGl0eV9yZXdhcmQgPSBuZXcgU2VyaWFsaXplcihcImxpcXVpZGl0eV9yZXdhcmRcIiwge1xuICAgIG93bmVyOiBzdHJpbmcsXG4gICAgcGF5b3V0OiBhc3NldFxufSk7XG5cbnZhciBpbnRlcmVzdCA9IG5ldyBTZXJpYWxpemVyKFwiaW50ZXJlc3RcIiwge1xuICAgIG93bmVyOiBzdHJpbmcsXG4gICAgaW50ZXJlc3Q6IGFzc2V0XG59KTtcblxudmFyIGZpbGxfdmVzdGluZ193aXRoZHJhdyA9IG5ldyBTZXJpYWxpemVyKFwiZmlsbF92ZXN0aW5nX3dpdGhkcmF3XCIsIHtcbiAgICBmcm9tX2FjY291bnQ6IHN0cmluZyxcbiAgICB0b19hY2NvdW50OiBzdHJpbmcsXG4gICAgd2l0aGRyYXduOiBhc3NldCxcbiAgICBkZXBvc2l0ZWQ6IGFzc2V0XG59KTtcblxudmFyIGZpbGxfb3JkZXIgPSBuZXcgU2VyaWFsaXplcihcImZpbGxfb3JkZXJcIiwge1xuICAgIGN1cnJlbnRfb3duZXI6IHN0cmluZyxcbiAgICBjdXJyZW50X29yZGVyaWQ6IHVpbnQzMixcbiAgICBjdXJyZW50X3BheXM6IGFzc2V0LFxuICAgIG9wZW5fb3duZXI6IHN0cmluZyxcbiAgICBvcGVuX29yZGVyaWQ6IHVpbnQzMixcbiAgICBvcGVuX3BheXM6IGFzc2V0XG59KTtcblxudmFyIGNvbW1lbnRfcGF5b3V0ID0gbmV3IFNlcmlhbGl6ZXIoXCJjb21tZW50X3BheW91dFwiLCB7XG4gICAgYXV0aG9yOiBzdHJpbmcsXG4gICAgcGVybWxpbms6IHN0cmluZyxcbiAgICBwYXlvdXQ6IGFzc2V0XG59KTtcblxudmFyIGVzY3Jvd190cmFuc2ZlciA9IG5ldyBTZXJpYWxpemVyKFwiZXNjcm93X3RyYW5zZmVyXCIsIHtcbiAgICBmcm9tOiBzdHJpbmcsXG4gICAgdG86IHN0cmluZyxcbiAgICBhZ2VudDogc3RyaW5nLFxuICAgIGVzY3Jvd19pZDogdWludDMyLFxuICAgIHNiZF9hbW91bnQ6IGFzc2V0LFxuICAgIHN0ZWVtX2Ftb3VudDogYXNzZXQsXG4gICAgZmVlOiBhc3NldCxcbiAgICByYXRpZmljYXRpb25fZGVhZGxpbmU6IHRpbWVfcG9pbnRfc2VjLFxuICAgIGVzY3Jvd19leHBpcmF0aW9uOiB0aW1lX3BvaW50X3NlYyxcbiAgICBqc29uX21ldGFkYXRhOiBzdHJpbmdcbn0pO1xuXG52YXIgZXNjcm93X2FwcHJvdmUgPSBuZXcgU2VyaWFsaXplcihcImVzY3Jvd19hcHByb3ZlXCIsIHtcbiAgICBmcm9tOiBzdHJpbmcsXG4gICAgdG86IHN0cmluZyxcbiAgICBhZ2VudDogc3RyaW5nLFxuICAgIHdobzogc3RyaW5nLFxuICAgIGVzY3Jvd19pZDogdWludDMyLFxuICAgIGFwcHJvdmU6IGJvb2xcbn0pO1xuXG52YXIgZXNjcm93X2Rpc3B1dGUgPSBuZXcgU2VyaWFsaXplcihcImVzY3Jvd19kaXNwdXRlXCIsIHtcbiAgICBmcm9tOiBzdHJpbmcsXG4gICAgdG86IHN0cmluZyxcbiAgICBhZ2VudDogc3RyaW5nLFxuICAgIHdobzogc3RyaW5nLFxuICAgIGVzY3Jvd19pZDogdWludDMyXG59KTtcblxudmFyIGVzY3Jvd19yZWxlYXNlID0gbmV3IFNlcmlhbGl6ZXIoXCJlc2Nyb3dfcmVsZWFzZVwiLCB7XG4gICAgZnJvbTogc3RyaW5nLFxuICAgIHRvOiBzdHJpbmcsXG4gICAgYWdlbnQ6IHN0cmluZyxcbiAgICB3aG86IHN0cmluZyxcbiAgICByZWNlaXZlcjogc3RyaW5nLFxuICAgIGVzY3Jvd19pZDogdWludDMyLFxuICAgIHNiZF9hbW91bnQ6IGFzc2V0LFxuICAgIHN0ZWVtX2Ftb3VudDogYXNzZXRcbn0pO1xuXG5vcGVyYXRpb24uc3Rfb3BlcmF0aW9ucyA9IFt2b3RlLCBjb21tZW50LCB0cmFuc2ZlciwgdHJhbnNmZXJfdG9fdmVzdGluZywgd2l0aGRyYXdfdmVzdGluZywgbGltaXRfb3JkZXJfY3JlYXRlLCBsaW1pdF9vcmRlcl9jYW5jZWwsIGZlZWRfcHVibGlzaCwgY29udmVydCwgYWNjb3VudF9jcmVhdGUsIGFjY291bnRfdXBkYXRlLCB3aXRuZXNzX3VwZGF0ZSwgYWNjb3VudF93aXRuZXNzX3ZvdGUsIGFjY291bnRfd2l0bmVzc19wcm94eSwgcG93LCBjdXN0b20sIHJlcG9ydF9vdmVyX3Byb2R1Y3Rpb24sIGRlbGV0ZV9jb21tZW50LCBjdXN0b21fanNvbiwgY29tbWVudF9vcHRpb25zLCBzZXRfd2l0aGRyYXdfdmVzdGluZ19yb3V0ZSwgZmlsbF9jb252ZXJ0X3JlcXVlc3QsIGNvbW1lbnRfcmV3YXJkLCBjdXJhdGVfcmV3YXJkLCBsaXF1aWRpdHlfcmV3YXJkLCBpbnRlcmVzdCwgZmlsbF92ZXN0aW5nX3dpdGhkcmF3LCBmaWxsX29yZGVyLCBjb21tZW50X3BheW91dCwgZXNjcm93X3RyYW5zZmVyLCBlc2Nyb3dfYXBwcm92ZSwgZXNjcm93X2Rpc3B1dGUsIGVzY3Jvd19yZWxlYXNlXTtcblxudmFyIHRyYW5zYWN0aW9uID0gbmV3IFNlcmlhbGl6ZXIoXCJ0cmFuc2FjdGlvblwiLCB7XG4gICAgcmVmX2Jsb2NrX251bTogdWludDE2LFxuICAgIHJlZl9ibG9ja19wcmVmaXg6IHVpbnQzMixcbiAgICBleHBpcmF0aW9uOiB0aW1lX3BvaW50X3NlYyxcbiAgICBvcGVyYXRpb25zOiBhcnJheShvcGVyYXRpb24pLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucylcbn0pO1xuXG4vLyMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8jICBHZW5lcmF0ZWQgY29kZSBlbmRcbi8vIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL29wZXJhdGlvbnMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9zZXJpYWxpemVyL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ5dGVCdWZmZXIgPSByZXF1aXJlKCdieXRlYnVmZmVyJyk7XG52YXIgRUMgPSByZXF1aXJlKCcuL2Vycm9yX3dpdGhfY2F1c2UnKTtcblxudmFyIEhFWF9EVU1QID0gcHJvY2Vzcy5lbnYubnBtX2NvbmZpZ19fZ3JhcGhlbmVfc2VyaWFsaXplcl9oZXhfZHVtcDtcblxudmFyIFNlcmlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VyaWFsaXplcihvcGVyYXRpb25fbmFtZSwgdHlwZXMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlcmlhbGl6ZXIpO1xuXG4gICAgICAgIHRoaXMub3BlcmF0aW9uX25hbWUgPSBvcGVyYXRpb25fbmFtZTtcbiAgICAgICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgICAgICBpZiAodGhpcy50eXBlcykgdGhpcy5rZXlzID0gT2JqZWN0LmtleXModGhpcy50eXBlcyk7XG5cbiAgICAgICAgU2VyaWFsaXplci5wcmludERlYnVnID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU2VyaWFsaXplciwgW3tcbiAgICAgICAga2V5OiAnZnJvbUJ5dGVCdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZXJhYmxlID0gdGhpcy5rZXlzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBmaWVsZDsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlc1tmaWVsZF07XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSEVYX0RVTVApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5vcGVyYXRpb25fbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHR5cGUub3BlcmF0aW9uX25hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvMSA9IGIub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLmZyb21CeXRlQnVmZmVyKGIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbzIgPSBiLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5vZmZzZXQgPSBvMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9iLnJlc2V0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gYi5jb3B5KG8xLCBvMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkICsgJ1xcdCcsIF9iLnRvSGV4KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtmaWVsZF0gPSB0eXBlLmZyb21CeXRlQnVmZmVyKGIpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoU2VyaWFsaXplci5wcmludERlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVhZGluZyAnICsgdGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkICsgJyBpbiBkYXRhOicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIucHJpbnREZWJ1ZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgRUMudGhyb3codGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkLCBlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FwcGVuZEJ5dGVCdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXMua2V5cztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZmllbGQ7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZXNbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICB0eXBlLmFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0W2ZpZWxkXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBFQy50aHJvdyh0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQgKyBcIiA9IFwiICsgSlNPTi5zdHJpbmdpZnkob2JqZWN0W2ZpZWxkXSksIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNpcmN1bGFyIHJlZlxuICAgICAgICAgICAgICAgICAgICBFQy50aHJvdyh0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQgKyBcIiA9IFwiICsgb2JqZWN0W2ZpZWxkXSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbU9iamVjdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tT2JqZWN0KHNlcmlhbGl6ZWRfb2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLmtleXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGZpZWxkOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGVzW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VyaWFsaXplZF9vYmplY3RbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICAvL0RFQlVHIHZhbHVlID0gdmFsdWUucmVzb2x2ZSBpZiB2YWx1ZS5yZXNvbHZlXG4gICAgICAgICAgICAgICAgICAgIC8vREVCVUcgY29uc29sZS5sb2coJy4uLiB2YWx1ZScsZmllbGQsdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSB0eXBlLmZyb21PYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZmllbGRdID0gb2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgRUMudGhyb3codGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkLCBlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICAgIEBhcmcge2Jvb2xlYW59IFtkZWJ1Zy51c2VfZGVmYXVsdCA9IGZhbHNlXSAtIG1vcmUgdGVtcGxhdGUgZnJpZW5kbHlcbiAgICAgICAgICAgIEBhcmcge2Jvb2xlYW59IFtkZWJ1Zy5hbm5vdGF0ZSA9IGZhbHNlXSAtIGFkZCB1c2VyLWZyaWVuZGx5IGluZm9ybWF0aW9uXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvT2JqZWN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRfb2JqZWN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogeyB1c2VfZGVmYXVsdDogZmFsc2UsIGFubm90YXRlOiBmYWxzZSB9O1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudHlwZXMpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLmtleXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGZpZWxkOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGVzW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IHR5cGUudG9PYmplY3QodHlwZW9mIHNlcmlhbGl6ZWRfb2JqZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIHNlcmlhbGl6ZWRfb2JqZWN0ICE9PSBudWxsID8gc2VyaWFsaXplZF9vYmplY3RbZmllbGRdIDogdW5kZWZpbmVkLCBkZWJ1Zyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZF0gPSBvYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChIRVhfRFVNUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBuZXcgQnl0ZUJ1ZmZlcihCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFksIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLmFwcGVuZEJ5dGVCdWZmZXIoYiwgdHlwZW9mIHNlcmlhbGl6ZWRfb2JqZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIHNlcmlhbGl6ZWRfb2JqZWN0ICE9PSBudWxsID8gc2VyaWFsaXplZF9vYmplY3RbZmllbGRdIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBiLmNvcHkoMCwgYi5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcih0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQsIGIudG9IZXgoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIEVDLnRocm93KHRoaXMub3BlcmF0aW9uX25hbWUgKyAnLicgKyBmaWVsZCwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFNvcnQgYnkgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSBvcGVyYXRpb24gKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29tcGFyZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcblxuICAgICAgICAgICAgdmFyIGZpcnN0X2tleSA9IHRoaXMua2V5c1swXTtcbiAgICAgICAgICAgIHZhciBmaXJzdF90eXBlID0gdGhpcy50eXBlc1tmaXJzdF9rZXldO1xuXG4gICAgICAgICAgICB2YXIgdmFsQSA9IGFbZmlyc3Rfa2V5XTtcbiAgICAgICAgICAgIHZhciB2YWxCID0gYltmaXJzdF9rZXldO1xuXG4gICAgICAgICAgICBpZiAoZmlyc3RfdHlwZS5jb21wYXJlKSByZXR1cm4gZmlyc3RfdHlwZS5jb21wYXJlKHZhbEEsIHZhbEIpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbEEgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHZhbEIgPT09IFwibnVtYmVyXCIpIHJldHVybiB2YWxBIC0gdmFsQjtcblxuICAgICAgICAgICAgdmFyIGVuY29kaW5nID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWxBKSAmJiBCdWZmZXIuaXNCdWZmZXIodmFsQikpIHtcbiAgICAgICAgICAgICAgICAvLyBBIGJpbmFyeSBzdHJpbmcgY29tcGFyZSBkb2VzIG5vdCB3b3JrLiAgSWYgbG9jYWxlQ29tcGFyZSBpcyB3ZWxsIHN1cHBvcnRlZCB0aGF0IGNvdWxkIHJlcGxhY2UgSEVYLiAgUGVyZm9ybWFuYW5jZSBpcyB2ZXJ5IGdvb2Qgc28gY29tcGFyaW5nIEhFWCB3b3Jrcy5cbiAgICAgICAgICAgICAgICBlbmNvZGluZyA9IFwiaGV4XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdHJBID0gdmFsQS50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgICAgICAgICB2YXIgc3RyQiA9IHZhbEIudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHN0ckEgPiBzdHJCID8gMSA6IHN0ckEgPCBzdHJCID8gLTEgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gPGhlbHBlcl9mdW5jdGlvbnM+XG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21IZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIHZhciBiID0gQnl0ZUJ1ZmZlci5mcm9tSGV4KGhleCwgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21CeXRlQnVmZmVyKGIpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IEJ5dGVCdWZmZXIuZnJvbUJpbmFyeShidWZmZXIudG9TdHJpbmcoXCJiaW5hcnlcIiksIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQnl0ZUJ1ZmZlcihiKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9IZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9IZXgob2JqZWN0KSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gdGhpcy50b0J1ZmZlcihvYmplY3QpLnRvU3RyaW5nKFwiaGV4XCIpXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMudG9CeXRlQnVmZmVyKG9iamVjdCk7XG4gICAgICAgICAgICByZXR1cm4gYi50b0hleCgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0J5dGVCdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9CeXRlQnVmZmVyKG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGIgPSBuZXcgQnl0ZUJ1ZmZlcihCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFksIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTik7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KTtcbiAgICAgICAgICAgIHJldHVybiBiLmNvcHkoMCwgYi5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0J1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J1ZmZlcihvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHRoaXMudG9CeXRlQnVmZmVyKG9iamVjdCkudG9CaW5hcnkoKSwgJ2JpbmFyeScpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNlcmlhbGl6ZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VyaWFsaXplcjtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvc2VyaWFsaXplci5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKiBDb25zb2xlIHByaW50IGFueSB0cmFuc2FjdGlvbiBvYmplY3Qgd2l0aCB6ZXJvIGRlZmF1bHQgdmFsdWVzLiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZW1wbGF0ZShvcCkge1xuXG4gICAgdmFyIG9iamVjdCA9IG9wLnRvT2JqZWN0KHZvaWQgMCwgeyB1c2VfZGVmYXVsdDogdHJ1ZSwgYW5ub3RhdGU6IHRydWUgfSk7XG5cbiAgICAvLyB2aXN1YWwgKHdpdGggZGVzY3JpcHRpb25zKVxuICAgIGNvbnNvbGUuZXJyb3IoSlNPTi5zdHJpbmdpZnkob2JqZWN0LCBudWxsLCA0KSk7XG5cbiAgICAvLyB1c2FibGUgaW4gYSBjb3B5LXBhc3RlXG5cbiAgICBvYmplY3QgPSBvcC50b09iamVjdCh2b2lkIDAsIHsgdXNlX2RlZmF1bHQ6IHRydWUsIGFubm90YXRlOiBmYWxzZSB9KTtcblxuICAgIC8vIGNvcHktcGFzdGUgb25lLWxpbmVlclxuICAgIGNvbnNvbGUuZXJyb3IoSlNPTi5zdHJpbmdpZnkob2JqZWN0KSk7XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy90ZW1wbGF0ZS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxuLy8gTG93LWxldmVsIHR5cGVzIHRoYXQgbWFrZSB1cCBvcGVyYXRpb25zXG5cbnZhciB2ID0gcmVxdWlyZSgnLi9TZXJpYWxpemVyVmFsaWRhdGlvbicpO1xudmFyIGZwID0gcmVxdWlyZSgnLi9GYXN0UGFyc2VyJyk7XG5cbnZhciBDaGFpblR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2NoYWluL3NyYy9DaGFpblR5cGVzXCIpO1xudmFyIE9iamVjdElkID0gcmVxdWlyZShcIi4uLy4uL2NoYWluL3NyYy9PYmplY3RJZFwiKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uLy4uL2VjY1wiKTtcblxudmFyIFB1YmxpY0tleSA9IF9yZXF1aXJlLlB1YmxpY0tleTtcbnZhciBBZGRyZXNzID0gX3JlcXVpcmUuQWRkcmVzcztcblxudmFyIENoYWluQ29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NoYWluL3NyYy9DaGFpbkNvbmZpZ1wiKTtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuL251bWJlclV0aWxzXCIpO1xuXG52YXIgZnJvbUltcGxpZWREZWNpbWFsID0gX3JlcXVpcmUyLmZyb21JbXBsaWVkRGVjaW1hbDtcblxudmFyIFR5cGVzID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVzO1xuXG52YXIgSEVYX0RVTVAgPSBwcm9jZXNzLmVudi5ucG1fY29uZmlnX19ncmFwaGVuZV9zZXJpYWxpemVyX2hleF9kdW1wO1xuXG5UeXBlcy5hc3NldCA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICB2YXIgYW1vdW50ID0gYi5yZWFkSW50NjQoKTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IGIucmVhZFVpbnQ4KCk7XG4gICAgICAgIHZhciBiX2NvcHkgPSBiLmNvcHkoYi5vZmZzZXQsIGIub2Zmc2V0ICsgNyk7XG4gICAgICAgIHZhciBzeW1ib2wgPSBuZXcgQnVmZmVyKGJfY29weS50b0JpbmFyeSgpLCBcImJpbmFyeVwiKS50b1N0cmluZygpLnJlcGxhY2UoL1xceDAwL2csIFwiXCIpO1xuICAgICAgICBiLnNraXAoNyk7XG4gICAgICAgIC8vIFwiMS4wMDAgU1RFRU1cIiBhbHdheXMgd3JpdHRlbiB3aXRoIGZ1bGwgcHJlY2lzaW9uXG4gICAgICAgIHZhciBhbW91bnRfc3RyaW5nID0gZnJvbUltcGxpZWREZWNpbWFsKGFtb3VudCwgcHJlY2lzaW9uKTtcbiAgICAgICAgcmV0dXJuIGFtb3VudF9zdHJpbmcgKyBcIiBcIiArIHN5bWJvbDtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdC50cmltKCk7XG4gICAgICAgIGlmICghL15bMC05XStcXC4/WzAtOV0qIFtBLVphLXowLTldKyQvLnRlc3Qob2JqZWN0KSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0aW5nIGFtb3VudCBsaWtlICc5OS4wMDAgU1lNQk9MJywgaW5zdGVhZCBnb3QgJ1wiICsgb2JqZWN0ICsgXCInXCIpO1xuXG4gICAgICAgIHZhciBfb2JqZWN0JHNwbGl0ID0gb2JqZWN0LnNwbGl0KFwiIFwiKTtcblxuICAgICAgICB2YXIgX29iamVjdCRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfb2JqZWN0JHNwbGl0LCAyKTtcblxuICAgICAgICB2YXIgYW1vdW50ID0gX29iamVjdCRzcGxpdDJbMF07XG4gICAgICAgIHZhciBzeW1ib2wgPSBfb2JqZWN0JHNwbGl0MlsxXTtcblxuICAgICAgICBpZiAoc3ltYm9sLmxlbmd0aCA+IDYpIHRocm93IG5ldyBFcnJvcihcIlN5bWJvbHMgYXJlIG5vdCBsb25nZXIgdGhhbiA2IGNoYXJhY3RlcnMgXCIgKyBzeW1ib2wgKyBcIi1cIiArIHN5bWJvbC5sZW5ndGgpO1xuXG4gICAgICAgIGIud3JpdGVJbnQ2NCh2LnRvX2xvbmcoYW1vdW50LnJlcGxhY2UoXCIuXCIsIFwiXCIpKSk7XG4gICAgICAgIHZhciBkb3QgPSBhbW91bnQuaW5kZXhPZihcIi5cIik7IC8vIDAuMDAwXG4gICAgICAgIHZhciBwcmVjaXNpb24gPSBkb3QgPT09IC0xID8gMCA6IGFtb3VudC5sZW5ndGggLSBkb3QgLSAxO1xuICAgICAgICBiLndyaXRlVWludDgocHJlY2lzaW9uKTtcbiAgICAgICAgYi5hcHBlbmQoc3ltYm9sLnRvVXBwZXJDYXNlKCksICdiaW5hcnknKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA3IC0gc3ltYm9sLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBiLndyaXRlVWludDgoMCk7XG4gICAgICAgIH1yZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiMC4wMDAgU1RFRU1cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbn07XG5cblR5cGVzLnVpbnQ4ID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBiLnJlYWRVaW50OCgpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkYsIG9iamVjdCwgJ3VpbnQ4ICcgKyBvYmplY3QpO1xuICAgICAgICBiLndyaXRlVWludDgob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkYsIG9iamVjdCwgJ3VpbnQ4ICcgKyBvYmplY3QpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkYsIG9iamVjdCwgJ3VpbnQ4ICcgKyBvYmplY3QpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqZWN0KTtcbiAgICB9XG59O1xuXG5UeXBlcy5pbnQxNiA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkSW50MTYoKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZSgwLCAweEZGRkYsIG9iamVjdCwgJ2ludDE2ICcgKyBvYmplY3QpO1xuICAgICAgICBiLndyaXRlSW50MTYob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkZGRiwgb2JqZWN0LCAnaW50MTYgJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRkZGLCBvYmplY3QsICdpbnQxNiAnICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iamVjdCk7XG4gICAgfVxufTtcblxuVHlwZXMudWludDE2ID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBiLnJlYWRVaW50MTYoKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZSgtMHhGRkZGLCAweEZGRkYsIG9iamVjdCwgJ3VpbnQxNiAnICsgb2JqZWN0KTtcbiAgICAgICAgYi53cml0ZVVpbnQxNihvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoLTB4RkZGRiwgMHhGRkZGLCBvYmplY3QsICd1aW50MTYgJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoLTB4RkZGRiwgMHhGRkZGLCBvYmplY3QsICd1aW50MTYgJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBwYXJzZUludChvYmplY3QpO1xuICAgIH1cbn07XG5cblR5cGVzLnVpbnQzMiA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkVWludDMyKCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRkZGRkZGRiwgb2JqZWN0LCAndWludDMyICcgKyBvYmplY3QpO1xuICAgICAgICBiLndyaXRlVWludDMyKG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZSgwLCAweEZGRkZGRkZGLCBvYmplY3QsICd1aW50MzIgJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRkZGRkZGRiwgb2JqZWN0LCAndWludDMyICcgKyBvYmplY3QpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqZWN0KTtcbiAgICB9XG59O1xuXG52YXIgTUlOX1NJR05FRF8zMiA9IC0xICogTWF0aC5wb3coMiwgMzEpO1xudmFyIE1BWF9TSUdORURfMzIgPSBNYXRoLnBvdygyLCAzMSkgLSAxO1xuXG5UeXBlcy52YXJpbnQzMiA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkVmFyaW50MzIoKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZShNSU5fU0lHTkVEXzMyLCBNQVhfU0lHTkVEXzMyLCBvYmplY3QsICd1aW50MzIgJyArIG9iamVjdCk7XG4gICAgICAgIGIud3JpdGVWYXJpbnQzMihvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoTUlOX1NJR05FRF8zMiwgTUFYX1NJR05FRF8zMiwgb2JqZWN0LCAndWludDMyICcgKyBvYmplY3QpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKE1JTl9TSUdORURfMzIsIE1BWF9TSUdORURfMzIsIG9iamVjdCwgJ3VpbnQzMiAnICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iamVjdCk7XG4gICAgfVxufTtcblxuVHlwZXMuaW50NjQgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVhZEludDY0KCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIGIud3JpdGVJbnQ2NCh2LnRvX2xvbmcob2JqZWN0KSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIHYudG9fbG9uZyhvYmplY3QpO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiMFwiO1xuICAgICAgICB9XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIHYudG9fbG9uZyhvYmplY3QpLnRvU3RyaW5nKCk7XG4gICAgfVxufTtcblxuVHlwZXMudWludDY0ID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBiLnJlYWRVaW50NjQoKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIGIud3JpdGVVaW50NjQodi50b19sb25nKHYudW5zaWduZWQob2JqZWN0KSkpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICByZXR1cm4gdi50b19sb25nKHYudW5zaWduZWQob2JqZWN0KSk7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYudG9fbG9uZyhvYmplY3QpLnRvU3RyaW5nKCk7XG4gICAgfVxufTtcblxuVHlwZXMuc3RyaW5nID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHZhciBiX2NvcHk7XG4gICAgICAgIHZhciBsZW4gPSBiLnJlYWRWYXJpbnQzMigpO1xuICAgICAgICBiX2NvcHkgPSBiLmNvcHkoYi5vZmZzZXQsIGIub2Zmc2V0ICsgbGVuKSwgYi5za2lwKGxlbik7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGJfY29weS50b0JpbmFyeSgpLCAnYmluYXJ5Jyk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIGIud3JpdGVWYXJpbnQzMihvYmplY3QubGVuZ3RoKTtcbiAgICAgICAgYi5hcHBlbmQob2JqZWN0LnRvU3RyaW5nKCdiaW5hcnknKSwgJ2JpbmFyeScpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKG9iamVjdCk7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0LnRvU3RyaW5nKCk7XG4gICAgfVxufTtcblxuVHlwZXMuYnl0ZXMgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJfY29weTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gYi5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgICAgICAgICBiX2NvcHkgPSBiLmNvcHkoYi5vZmZzZXQsIGIub2Zmc2V0ICsgbGVuKSwgYi5za2lwKGxlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYl9jb3B5LnRvQmluYXJ5KCksICdiaW5hcnknKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYl9jb3B5ID0gYi5jb3B5KGIub2Zmc2V0LCBiLm9mZnNldCArIHNpemUpLCBiLnNraXAoc2l6ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYl9jb3B5LnRvQmluYXJ5KCksICdiaW5hcnknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiKSBvYmplY3QgPSBuZXcgQnVmZmVyKG9iamVjdCwgXCJoZXhcIik7XG5cbiAgICAgICAgICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBiLndyaXRlVmFyaW50MzIob2JqZWN0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLmFwcGVuZChvYmplY3QudG9TdHJpbmcoJ2JpbmFyeScpLCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iamVjdCkpIHJldHVybiBvYmplY3Q7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKG9iamVjdCwgJ2hleCcpO1xuICAgICAgICB9LFxuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgemVyb3MgPSBmdW5jdGlvbiB6ZXJvcyhudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheShudW0pLmpvaW4oXCIwMFwiKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvcyhzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblR5cGVzLmJvb2wgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVhZFVpbnQ4KCkgPT09IDE7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAvLyBzdXBwb3J0cyBib29sZWFuIG9yIGludGVnZXJcbiAgICAgICAgYi53cml0ZVVpbnQ4KEpTT04ucGFyc2Uob2JqZWN0KSA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uob2JqZWN0KSA/IHRydWUgOiBmYWxzZTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShvYmplY3QpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbn07XG5cblR5cGVzLnZvaWQgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiKHZvaWQpIHVuZGVmaW5lZCB0eXBlXCIpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiKHZvaWQpIHVuZGVmaW5lZCB0eXBlXCIpO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiKHZvaWQpIHVuZGVmaW5lZCB0eXBlXCIpO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIodm9pZCkgdW5kZWZpbmVkIHR5cGVcIik7XG4gICAgfVxufTtcblxuVHlwZXMuYXJyYXkgPSBmdW5jdGlvbiAoc3Rfb3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gYi5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgICAgIGlmIChIRVhfRFVNUCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidmFyaW50MzIgc2l6ZSA9IFwiICsgc2l6ZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IDAgPCBzaXplID8gaSA8IHNpemUgOiBpID4gc2l6ZTsgMCA8IHNpemUgPyBpKysgOiBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdF9vcGVyYXRpb24uZnJvbUJ5dGVCdWZmZXIoYikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvcnRPcGVyYXRpb24ocmVzdWx0LCBzdF9vcGVyYXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgb2JqZWN0ID0gc29ydE9wZXJhdGlvbihvYmplY3QsIHN0X29wZXJhdGlvbik7XG4gICAgICAgICAgICBiLndyaXRlVmFyaW50MzIob2JqZWN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgICAgICAgICAgc3Rfb3BlcmF0aW9uLmFwcGVuZEJ5dGVCdWZmZXIoYiwgbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICBvYmplY3QgPSBzb3J0T3BlcmF0aW9uKG9iamVjdCwgc3Rfb3BlcmF0aW9uKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdF9vcGVyYXRpb24uZnJvbU9iamVjdChvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3N0X29wZXJhdGlvbi50b09iamVjdChvYmplY3QsIGRlYnVnKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICBvYmplY3QgPSBzb3J0T3BlcmF0aW9uKG9iamVjdCwgc3Rfb3BlcmF0aW9uKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvID0gb2JqZWN0W2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0X29wZXJhdGlvbi50b09iamVjdChvLCBkZWJ1ZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5UeXBlcy50aW1lX3BvaW50X3NlYyA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkVWludDMyKCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gXCJudW1iZXJcIikgb2JqZWN0ID0gVHlwZXMudGltZV9wb2ludF9zZWMuZnJvbU9iamVjdChvYmplY3QpO1xuXG4gICAgICAgIGIud3JpdGVVaW50MzIob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcIm51bWJlclwiKSByZXR1cm4gb2JqZWN0O1xuXG4gICAgICAgIGlmIChvYmplY3QuZ2V0VGltZSkgcmV0dXJuIE1hdGguZmxvb3Iob2JqZWN0LmdldFRpbWUoKSAvIDEwMDApO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBcInN0cmluZ1wiKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGUgdHlwZTogXCIgKyBvYmplY3QpO1xuXG4gICAgICAgIC8vIGlmKHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIgJiYgIS9aJC8udGVzdChvYmplY3QpKVxuICAgICAgICAvLyAgICAgb2JqZWN0ID0gb2JqZWN0ICsgXCJaXCJcblxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihuZXcgRGF0ZShvYmplY3QpLmdldFRpbWUoKSAvIDEwMDApO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG5ldyBEYXRlKDApLnRvSVNPU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcblxuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIpIHJldHVybiBvYmplY3Q7XG5cbiAgICAgICAgaWYgKG9iamVjdC5nZXRUaW1lKSByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcblxuICAgICAgICB2YXIgaW50ID0gcGFyc2VJbnQob2JqZWN0KTtcbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkZGRkZGRkYsIGludCwgJ3VpbnQzMiAnICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGludCAqIDEwMDApLnRvSVNPU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcbiAgICB9XG59O1xuXG5UeXBlcy5zZXQgPSBmdW5jdGlvbiAoc3Rfb3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgZHVwX21hcCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBhcnJheVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgIGlmIChyZWYgPSB0eXBlb2YgbyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobyksIFsnc3RyaW5nJywgJ251bWJlciddLmluZGV4T2YocmVmKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkdXBfbWFwW29dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImR1cGxpY2F0ZSAoc2V0KVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkdXBfbWFwW29dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc29ydE9wZXJhdGlvbihhcnJheSwgc3Rfb3BlcmF0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gYi5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgICAgIGlmIChIRVhfRFVNUCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidmFyaW50MzIgc2l6ZSA9IFwiICsgc2l6ZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgMCA8IHNpemUgPyBpIDwgc2l6ZSA6IGkgPiBzaXplOyAwIDwgc2l6ZSA/IGkrKyA6IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdF9vcGVyYXRpb24uZnJvbUJ5dGVCdWZmZXIoYikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLndyaXRlVmFyaW50MzIob2JqZWN0Lmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLnZhbGlkYXRlKG9iamVjdCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbyA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICAgIHN0X29wZXJhdGlvbi5hcHBlbmRCeXRlQnVmZmVyKGIsIG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Rfb3BlcmF0aW9uLmZyb21PYmplY3QobykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzdF9vcGVyYXRpb24udG9PYmplY3Qob2JqZWN0LCBkZWJ1ZyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KG8sIGRlYnVnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8vIGdsb2JhbF9wYXJhbWV0ZXJzX3VwZGF0ZV9vcGVyYXRpb24gY3VycmVudF9mZWVzXG5UeXBlcy5maXhlZF9hcnJheSA9IGZ1bmN0aW9uIChjb3VudCwgc3Rfb3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHZhciBpLCBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gY291bnQ7IGogPCByZWY7IGkgPSBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc3Rfb3BlcmF0aW9uLmZyb21CeXRlQnVmZmVyKGIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3J0T3BlcmF0aW9uKHJlc3VsdHMsIHN0X29wZXJhdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgaSwgaiwgcmVmO1xuICAgICAgICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IHNvcnRPcGVyYXRpb24ob2JqZWN0LCBzdF9vcGVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNvdW50OyBqIDwgcmVmOyBpID0gaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgc3Rfb3BlcmF0aW9uLmFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBpLCBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICBpZiAoY291bnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gY291bnQ7IGogPCByZWY7IGkgPSBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc3Rfb3BlcmF0aW9uLmZyb21PYmplY3Qob2JqZWN0W2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCwgZGVidWcpIHtcbiAgICAgICAgICAgIHZhciBpLCBqLCBrLCByZWYsIHJlZjEsIHJlc3VsdHMsIHJlc3VsdHMxO1xuICAgICAgICAgICAgaWYgKGRlYnVnID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBjb3VudDsgaiA8IHJlZjsgaSA9IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KHZvaWQgMCwgZGVidWcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzMSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZjEgPSBjb3VudDsgayA8IHJlZjE7IGkgPSBrICs9IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzMS5wdXNoKHN0X29wZXJhdGlvbi50b09iamVjdChvYmplY3RbaV0sIGRlYnVnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0czE7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLyogU3VwcG9ydHMgaW5zdGFuY2UgbnVtYmVycyAoMTEpIG9yIG9iamVjdCB0eXBlcyAoMS4yLjExKS4gIE9iamVjdCB0eXBlXG5WYWxpZGF0aW9uIGlzIGVuZm9yY2VkIHdoZW4gYW4gb2JqZWN0IHR5cGUgaXMgdXNlZC4gKi9cbnZhciBpZF90eXBlID0gZnVuY3Rpb24gaWRfdHlwZShyZXNlcnZlZF9zcGFjZXMsIG9iamVjdF90eXBlKSB7XG4gICAgdi5yZXF1aXJlZChyZXNlcnZlZF9zcGFjZXMsIFwicmVzZXJ2ZWRfc3BhY2VzXCIpO1xuICAgIHYucmVxdWlyZWQob2JqZWN0X3R5cGUsIFwib2JqZWN0X3R5cGVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLnJlYWRWYXJpbnQzMigpO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBvYmplY3QucmVzb2x2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgMS4yLm4gaW50byBqdXN0IG5cbiAgICAgICAgICAgIGlmICgvXlswLTldK1xcLlswLTldK1xcLlswLTldKyQvLnRlc3Qob2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IHYuZ2V0X2luc3RhbmNlKHJlc2VydmVkX3NwYWNlcywgb2JqZWN0X3R5cGUsIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLndyaXRlVmFyaW50MzIodi50b19udW1iZXIob2JqZWN0KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnJlc29sdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5yZXNvbHZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHYuaXNfZGlnaXRzKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi50b19udW1iZXIob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2LmdldF9pbnN0YW5jZShyZXNlcnZlZF9zcGFjZXMsIG9iamVjdF90eXBlLCBvYmplY3QpO1xuICAgICAgICB9LFxuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICB2YXIgb2JqZWN0X3R5cGVfaWQgPSBDaGFpblR5cGVzLm9iamVjdF90eXBlW29iamVjdF90eXBlXTtcbiAgICAgICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNlcnZlZF9zcGFjZXMgKyAnLicgKyBvYmplY3RfdHlwZV9pZCArICcuMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnJlc29sdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5yZXNvbHZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC9eWzAtOV0rXFwuWzAtOV0rXFwuWzAtOV0rJC8udGVzdChvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gdi5nZXRfaW5zdGFuY2UocmVzZXJ2ZWRfc3BhY2VzLCBvYmplY3RfdHlwZSwgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc2VydmVkX3NwYWNlcyArICcuJyArIG9iamVjdF90eXBlX2lkICsgJy4nICsgb2JqZWN0O1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblR5cGVzLm9iamVjdF9pZF90eXBlID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3RJZC5mcm9tQnl0ZUJ1ZmZlcihiKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5yZXNvbHZlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IE9iamVjdElkLmZyb21TdHJpbmcob2JqZWN0KTtcbiAgICAgICAgb2JqZWN0LmFwcGVuZEJ5dGVCdWZmZXIoYik7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5yZXNvbHZlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3RJZC5mcm9tU3RyaW5nKG9iamVjdCk7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwLjAuMFwiO1xuICAgICAgICB9XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5yZXNvbHZlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IE9iamVjdElkLmZyb21TdHJpbmcob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG9iamVjdC50b1N0cmluZygpO1xuICAgIH1cbn07XG5cblR5cGVzLnZvdGVfaWQgPSB7IFRZUEU6IDB4MDAwMDAwRkYsXG4gICAgSUQ6IDB4RkZGRkZGMDAsXG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYi5yZWFkVWludDMyKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB2YWx1ZSAmIHRoaXMuVFlQRSxcbiAgICAgICAgICAgIGlkOiB2YWx1ZSAmIHRoaXMuSURcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gXCJzdHJpbmdcIikgb2JqZWN0ID0gVHlwZXMudm90ZV9pZC5mcm9tT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0LmlkIDw8IDggfCBvYmplY3QudHlwZTtcbiAgICAgICAgYi53cml0ZVVpbnQzMih2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0LCBcIih0eXBlIHZvdGVfaWQpXCIpO1xuICAgICAgICBpZiAoKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iamVjdCkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdC50eXBlLCBcInR5cGVcIik7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdC5pZCwgXCJpZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgdi5yZXF1aXJlX3Rlc3QoL15bMC05XSs6WzAtOV0rJC8sIG9iamVjdCwgJ3ZvdGVfaWQgZm9ybWF0ICcgKyBvYmplY3QpO1xuXG4gICAgICAgIHZhciBfb2JqZWN0JHNwbGl0MyA9IG9iamVjdC5zcGxpdCgnOicpO1xuXG4gICAgICAgIHZhciBfb2JqZWN0JHNwbGl0NCA9IF9zbGljZWRUb0FycmF5KF9vYmplY3Qkc3BsaXQzLCAyKTtcblxuICAgICAgICB2YXIgdHlwZSA9IF9vYmplY3Qkc3BsaXQ0WzBdO1xuICAgICAgICB2YXIgaWQgPSBfb2JqZWN0JHNwbGl0NFsxXTtcblxuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhmZiwgdHlwZSwgJ3ZvdGUgdHlwZSAnICsgb2JqZWN0KTtcbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4ZmZmZmZmLCBpZCwgJ3ZvdGUgaWQgJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGlkOiBpZCB9O1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiMDowXCI7XG4gICAgICAgIH1cbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJzdHJpbmdcIikgb2JqZWN0ID0gVHlwZXMudm90ZV9pZC5mcm9tT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdC50eXBlICsgXCI6XCIgKyBvYmplY3QuaWQ7XG4gICAgfSxcbiAgICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYSkpICE9PSBcIm9iamVjdFwiKSBhID0gVHlwZXMudm90ZV9pZC5mcm9tT2JqZWN0KGEpO1xuICAgICAgICBpZiAoKHR5cGVvZiBiID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihiKSkgIT09IFwib2JqZWN0XCIpIGIgPSBUeXBlcy52b3RlX2lkLmZyb21PYmplY3QoYik7XG4gICAgICAgIHJldHVybiBwYXJzZUludChhLmlkKSAtIHBhcnNlSW50KGIuaWQpO1xuICAgIH1cbn07XG5cblR5cGVzLm9wdGlvbmFsID0gZnVuY3Rpb24gKHN0X29wZXJhdGlvbikge1xuICAgIHYucmVxdWlyZWQoc3Rfb3BlcmF0aW9uLCBcInN0X29wZXJhdGlvblwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICAgICAgaWYgKCEoYi5yZWFkVWludDgoKSA9PT0gMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0X29wZXJhdGlvbi5mcm9tQnl0ZUJ1ZmZlcihiKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBiLndyaXRlVWludDgoMSk7XG4gICAgICAgICAgICAgICAgc3Rfb3BlcmF0aW9uLmFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYi53cml0ZVVpbnQ4KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdF9vcGVyYXRpb24uZnJvbU9iamVjdChvYmplY3QpO1xuICAgICAgICB9LFxuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICAvLyB0b09iamVjdCBpcyBvbmx5IG51bGwgc2F2ZSBpZiB1c2VfZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgICAgICB2YXIgcmVzdWx0X29iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0X29wZXJhdGlvbi50b09iamVjdChvYmplY3QsIGRlYnVnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zy5hbm5vdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIHJlc3VsdF9vYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHJlc3VsdF9vYmplY3QpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRfb2JqZWN0Ll9fb3B0aW9uYWwgPSBcInBhcmVudCBpcyBvcHRpb25hbFwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdF9vYmplY3QgPSB7IF9fb3B0aW9uYWw6IHJlc3VsdF9vYmplY3QgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0X29iamVjdDtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5UeXBlcy5zdGF0aWNfdmFyaWFudCA9IGZ1bmN0aW9uIChfc3Rfb3BlcmF0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5vc29ydDogdHJ1ZSxcbiAgICAgICAgc3Rfb3BlcmF0aW9uczogX3N0X29wZXJhdGlvbnMsXG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICB2YXIgdHlwZV9pZCA9IGIucmVhZFZhcmludDMyKCk7XG4gICAgICAgICAgICB2YXIgc3Rfb3BlcmF0aW9uID0gdGhpcy5zdF9vcGVyYXRpb25zW3R5cGVfaWRdO1xuICAgICAgICAgICAgaWYgKEhFWF9EVU1QKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignc3RhdGljX3ZhcmlhbnQgaWQgMHgnICsgdHlwZV9pZC50b1N0cmluZygxNikgKyAnICgnICsgdHlwZV9pZCArICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2LnJlcXVpcmVkKHN0X29wZXJhdGlvbiwgJ29wZXJhdGlvbiAnICsgdHlwZV9pZCk7XG4gICAgICAgICAgICByZXR1cm4gW3R5cGVfaWQsIHN0X29wZXJhdGlvbi5mcm9tQnl0ZUJ1ZmZlcihiKV07XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICB2YXIgdHlwZV9pZCA9IG9iamVjdFswXTtcbiAgICAgICAgICAgIHZhciBzdF9vcGVyYXRpb24gPSB0aGlzLnN0X29wZXJhdGlvbnNbdHlwZV9pZF07XG4gICAgICAgICAgICB2LnJlcXVpcmVkKHN0X29wZXJhdGlvbiwgJ29wZXJhdGlvbiAnICsgdHlwZV9pZCk7XG4gICAgICAgICAgICBiLndyaXRlVmFyaW50MzIodHlwZV9pZCk7XG4gICAgICAgICAgICBzdF9vcGVyYXRpb24uYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3RbMV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgdmFyIHR5cGVfaWQgPSBvYmplY3RbMF07XG4gICAgICAgICAgICB2YXIgc3Rfb3BlcmF0aW9uID0gdGhpcy5zdF9vcGVyYXRpb25zW3R5cGVfaWRdO1xuICAgICAgICAgICAgdi5yZXF1aXJlZChzdF9vcGVyYXRpb24sICdvcGVyYXRpb24gJyArIHR5cGVfaWQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0eXBlX2lkLCBzdF9vcGVyYXRpb24uZnJvbU9iamVjdChvYmplY3RbMV0pXTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFswLCB0aGlzLnN0X29wZXJhdGlvbnNbMF0udG9PYmplY3QodW5kZWZpbmVkLCBkZWJ1ZyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgdmFyIHR5cGVfaWQgPSBvYmplY3RbMF07XG4gICAgICAgICAgICB2YXIgc3Rfb3BlcmF0aW9uID0gdGhpcy5zdF9vcGVyYXRpb25zW3R5cGVfaWRdO1xuICAgICAgICAgICAgdi5yZXF1aXJlZChzdF9vcGVyYXRpb24sICdvcGVyYXRpb24gJyArIHR5cGVfaWQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0eXBlX2lkLCBzdF9vcGVyYXRpb24udG9PYmplY3Qob2JqZWN0WzFdLCBkZWJ1ZyldO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblR5cGVzLm1hcCA9IGZ1bmN0aW9uIChrZXlfc3Rfb3BlcmF0aW9uLCB2YWx1ZV9zdF9vcGVyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoYXJyYXkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RpbmcgYXJyYXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZHVwX21hcCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBhcnJheVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgIGlmICghKG8ubGVuZ3RoID09PSAyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RpbmcgdHdvIGVsZW1lbnRzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVmID0gX3R5cGVvZihvWzBdKSwgWydudW1iZXInLCAnc3RyaW5nJ10uaW5kZXhPZihyZWYpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR1cF9tYXBbb1swXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZHVwbGljYXRlIChtYXApXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGR1cF9tYXBbb1swXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3J0T3BlcmF0aW9uKGFycmF5LCBrZXlfc3Rfb3BlcmF0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBiLnJlYWRWYXJpbnQzMigpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IDAgPCBlbmQgPyBpIDwgZW5kIDogaSA+IGVuZDsgMCA8IGVuZCA/IGkrKyA6IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtrZXlfc3Rfb3BlcmF0aW9uLmZyb21CeXRlQnVmZmVyKGIpLCB2YWx1ZV9zdF9vcGVyYXRpb24uZnJvbUJ5dGVCdWZmZXIoYildKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKHJlc3VsdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlKG9iamVjdCk7XG4gICAgICAgICAgICBiLndyaXRlVmFyaW50MzIob2JqZWN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgICAgICAgICAga2V5X3N0X29wZXJhdGlvbi5hcHBlbmRCeXRlQnVmZmVyKGIsIG9bMF0pO1xuICAgICAgICAgICAgICAgIHZhbHVlX3N0X29wZXJhdGlvbi5hcHBlbmRCeXRlQnVmZmVyKGIsIG9bMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvID0gb2JqZWN0W2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtrZXlfc3Rfb3BlcmF0aW9uLmZyb21PYmplY3Qob1swXSksIHZhbHVlX3N0X29wZXJhdGlvbi5mcm9tT2JqZWN0KG9bMV0pXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZShyZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1trZXlfc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KHVuZGVmaW5lZCwgZGVidWcpLCB2YWx1ZV9zdF9vcGVyYXRpb24udG9PYmplY3QodW5kZWZpbmVkLCBkZWJ1ZyldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIG9iamVjdCA9IHRoaXMudmFsaWRhdGUob2JqZWN0KTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChba2V5X3N0X29wZXJhdGlvbi50b09iamVjdChvWzBdLCBkZWJ1ZyksIHZhbHVlX3N0X29wZXJhdGlvbi50b09iamVjdChvWzFdLCBkZWJ1ZyldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuVHlwZXMucHVibGljX2tleSA9IHtcbiAgICB0b1B1YmxpYzogZnVuY3Rpb24gdG9QdWJsaWMob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QucmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmplY3QgPSBvYmplY3QucmVzb2x2ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBvYmplY3QuUSA/IG9iamVjdCA6IFB1YmxpY0tleS5mcm9tU3RyaW5nT3JUaHJvdyhvYmplY3QpO1xuICAgIH0sXG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGZwLnB1YmxpY19rZXkoYik7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIGZwLnB1YmxpY19rZXkoYiwgVHlwZXMucHVibGljX2tleS50b1B1YmxpYyhvYmplY3QpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0LlEpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFR5cGVzLnB1YmxpY19rZXkudG9QdWJsaWMob2JqZWN0KTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBDaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeCArIFwiODU5Z3hmblh5VXJpTWdVZVRoaDFmV3Yzb3FjcExGeUhhM1RmRllDNFBLMkhxaFRvVk1cIjtcbiAgICAgICAgfVxuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcbiAgICB9LFxuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgICByZXR1cm4gc3RyQ21wKGEudG9TdHJpbmcoKSwgYi50b1N0cmluZygpKTtcbiAgICB9XG59O1xuXG5UeXBlcy5hZGRyZXNzID0ge1xuICAgIF90b19hZGRyZXNzOiBmdW5jdGlvbiBfdG9fYWRkcmVzcyhvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0LmFkZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFkZHJlc3MuZnJvbVN0cmluZyhvYmplY3QpO1xuICAgIH0sXG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKGZwLnJpcGVtZDE2MChiKSk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICBmcC5yaXBlbWQxNjAoYiwgVHlwZXMuYWRkcmVzcy5fdG9fYWRkcmVzcyhvYmplY3QpLnRvQnVmZmVyKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICByZXR1cm4gVHlwZXMuYWRkcmVzcy5fdG9fYWRkcmVzcyhvYmplY3QpO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIENoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4ICsgXCI2NjRLbUh4U3VReURzZndvNFdFSnZXcHpnMVFLZGc2N1NcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHlwZXMuYWRkcmVzcy5fdG9fYWRkcmVzcyhvYmplY3QpLnRvU3RyaW5nKCk7XG4gICAgfSxcbiAgICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHN0ckNtcChhLnRvU3RyaW5nKCksIGIudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcblxudmFyIHN0ckNtcCA9IGZ1bmN0aW9uIHN0ckNtcChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xufTtcbnZhciBmaXJzdEVsID0gZnVuY3Rpb24gZmlyc3RFbChlbCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGVsKSA/IGVsWzBdIDogZWw7XG59O1xudmFyIHNvcnRPcGVyYXRpb24gPSBmdW5jdGlvbiBzb3J0T3BlcmF0aW9uKGFycmF5LCBzdF9vcGVyYXRpb24pIHtcbiAgICByZXR1cm4gc3Rfb3BlcmF0aW9uLm5vc29ydCA/IGFycmF5IDogc3Rfb3BlcmF0aW9uLmNvbXBhcmUgPyBhcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBzdF9vcGVyYXRpb24uY29tcGFyZShmaXJzdEVsKGEpLCBmaXJzdEVsKGIpKTtcbiAgICB9KSA6IC8vIGN1c3RvbSBjb21wYXJlIG9wZXJhdGlvblxuICAgIGFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmaXJzdEVsKGEpID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBmaXJzdEVsKGIpID09PSBcIm51bWJlclwiID8gZmlyc3RFbChhKSAtIGZpcnN0RWwoYikgOlxuICAgICAgICAvLyBBIGJpbmFyeSBzdHJpbmcgY29tcGFyZSBkb2VzIG5vdCB3b3JrLiBQZXJmb3JtYW5hbmNlIGlzIHZlcnkgZ29vZCBzbyBIRVggaXMgdXNlZC4uICBsb2NhbGVDb21wYXJlIGlzIGFub3RoZXIgb3B0aW9uLlxuICAgICAgICBCdWZmZXIuaXNCdWZmZXIoZmlyc3RFbChhKSkgJiYgQnVmZmVyLmlzQnVmZmVyKGZpcnN0RWwoYikpID8gc3RyQ21wKGZpcnN0RWwoYSkudG9TdHJpbmcoXCJoZXhcIiksIGZpcnN0RWwoYikudG9TdHJpbmcoXCJoZXhcIikpIDogc3RyQ21wKGZpcnN0RWwoYSkudG9TdHJpbmcoKSwgZmlyc3RFbChiKS50b1N0cmluZygpKTtcbiAgICB9KTtcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL3R5cGVzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuL2xpYi9rZXlzLmpzJyk7XG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2xpYi9pc19hcmd1bWVudHMuanMnKTtcblxudmFyIGRlZXBFcXVhbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCB8fCB0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcHRzLnN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAoeCkge1xuICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnIHx8IHR5cGVvZiB4Lmxlbmd0aCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB4LmNvcHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHguc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHgubGVuZ3RoID4gMCAmJiB0eXBlb2YgeFswXSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIG9wdHMpIHtcbiAgdmFyIGksIGtleTtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCBvcHRzKTtcbiAgfVxuICBpZiAoaXNCdWZmZXIoYSkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYik7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgb3B0cykpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9nb2xvc2pzLWxpYi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID0gKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKVxufSkoKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA/IHN1cHBvcnRlZCA6IHVuc3VwcG9ydGVkO1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIHN1cHBvcnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuZXhwb3J0cy51bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWQob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdjYWxsZWUnKSAmJlxuICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAnY2FsbGVlJykgfHxcbiAgICBmYWxzZTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2dvbG9zanMtbGliL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9pc19hcmd1bWVudHMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nXG4gID8gT2JqZWN0LmtleXMgOiBzaGltO1xuXG5leHBvcnRzLnNoaW0gPSBzaGltO1xuZnVuY3Rpb24gc2hpbSAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2tleXMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ29sb3Nqcy1saWIvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvaWVlZTc1NFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2luaGVyaXRzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLypcclxuIENvcHlyaWdodCAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiBDb3B5cmlnaHQgMjAwOSBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcblxyXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcclxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBsaWNlbnNlIGxvbmcuanMgKGMpIDIwMTMgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxyXG4gKiBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL2xvbmcuanMgZm9yIGRldGFpbHNcclxuICovXHJcbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcclxuXHJcbiAgICAvKiBBTUQgKi8gaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lW1wiYW1kXCJdKVxyXG4gICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XHJcbiAgICAvKiBDb21tb25KUyAqLyBlbHNlIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZSAmJiBtb2R1bGVbXCJleHBvcnRzXCJdKVxyXG4gICAgICAgIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBmYWN0b3J5KCk7XHJcbiAgICAvKiBHbG9iYWwgKi8gZWxzZVxyXG4gICAgICAgIChnbG9iYWxbXCJkY29kZUlPXCJdID0gZ2xvYmFsW1wiZGNvZGVJT1wiXSB8fCB7fSlbXCJMb25nXCJdID0gZmFjdG9yeSgpO1xyXG5cclxufSkodGhpcywgZnVuY3Rpb24oKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXHJcbiAgICAgKiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmUgY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cclxuICAgICAqIEBleHBvcnRzIExvbmdcclxuICAgICAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIHNpZ25lZFxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIExvbmcobG93LCBoaWdoLCB1bnNpZ25lZCkge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxvdyA9IGxvdyB8IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgbG9uZyBpcyB0aGUgdHdvIGdpdmVuIHNpZ25lZCwgMzItYml0IHZhbHVlcy5cclxuICAgIC8vIFdlIHVzZSAzMi1iaXQgcGllY2VzIGJlY2F1c2UgdGhlc2UgYXJlIHRoZSBzaXplIG9mIGludGVnZXJzIG9uIHdoaWNoXHJcbiAgICAvLyBKYXZhc2NyaXB0IHBlcmZvcm1zIGJpdC1vcGVyYXRpb25zLiAgRm9yIG9wZXJhdGlvbnMgbGlrZSBhZGRpdGlvbiBhbmRcclxuICAgIC8vIG11bHRpcGxpY2F0aW9uLCB3ZSBzcGxpdCBlYWNoIG51bWJlciBpbnRvIDE2IGJpdCBwaWVjZXMsIHdoaWNoIGNhbiBlYXNpbHkgYmVcclxuICAgIC8vIG11bHRpcGxpZWQgd2l0aGluIEphdmFzY3JpcHQncyBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiB3aXRob3V0IG92ZXJmbG93XHJcbiAgICAvLyBvciBjaGFuZ2UgaW4gc2lnbi5cclxuICAgIC8vXHJcbiAgICAvLyBJbiB0aGUgYWxnb3JpdGhtcyBiZWxvdywgd2UgZnJlcXVlbnRseSByZWR1Y2UgdGhlIG5lZ2F0aXZlIGNhc2UgdG8gdGhlXHJcbiAgICAvLyBwb3NpdGl2ZSBjYXNlIGJ5IG5lZ2F0aW5nIHRoZSBpbnB1dChzKSBhbmQgdGhlbiBwb3N0LXByb2Nlc3NpbmcgdGhlIHJlc3VsdC5cclxuICAgIC8vIE5vdGUgdGhhdCB3ZSBtdXN0IEFMV0FZUyBjaGVjayBzcGVjaWFsbHkgd2hldGhlciB0aG9zZSB2YWx1ZXMgYXJlIE1JTl9WQUxVRVxyXG4gICAgLy8gKC0yXjYzKSBiZWNhdXNlIC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFIChzaW5jZSAyXjYzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhc1xyXG4gICAgLy8gYSBwb3NpdGl2ZSBudW1iZXIsIGl0IG92ZXJmbG93cyBiYWNrIGludG8gYSBuZWdhdGl2ZSkuICBOb3QgaGFuZGxpbmcgdGhpc1xyXG4gICAgLy8gY2FzZSB3b3VsZCBvZnRlbiByZXN1bHQgaW4gaW5maW5pdGUgcmVjdXJzaW9uLlxyXG4gICAgLy9cclxuICAgIC8vIENvbW1vbiBjb25zdGFudCB2YWx1ZXMgWkVSTywgT05FLCBORUdfT05FLCBldGMuIGFyZSBkZWZpbmVkIGJlbG93IHRoZSBmcm9tKlxyXG4gICAgLy8gbWV0aG9kcyBvbiB3aGljaCB0aGV5IGRlcGVuZC5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBMb25nIG9yIG5vdC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBMb25nLnByb3RvdHlwZS5fX2lzTG9uZ19fO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHtcclxuICAgICAgICB2YWx1ZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0xvbmcob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmogJiYgb2JqW1wiX19pc0xvbmdfX1wiXSkgPT09IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIExvbmcuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmcuaXNMb25nID0gaXNMb25nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXHJcbiAgICAgKiBAdHlwZSB7IU9iamVjdH1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgSU5UX0NBQ0hFID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy5cclxuICAgICAqIEB0eXBlIHshT2JqZWN0fVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBVSU5UX0NBQ0hFID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgICAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xyXG4gICAgICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA+Pj49IDA7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZSA9ICgwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkT2JqKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsICh2YWx1ZSB8IDApIDwgMCA/IC0xIDogMCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZSlcclxuICAgICAgICAgICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlIHw9IDA7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZSA9ICgtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZSlcclxuICAgICAgICAgICAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiAzMiBiaXQgaW50ZWdlciB2YWx1ZS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMiBiaXQgaW50ZWdlciBpbiBxdWVzdGlvblxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIHNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbUludCA9IGZyb21JbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpXHJcbiAgICAgICAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgICAgICBpZiAodW5zaWduZWQpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBVWkVSTztcclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgICAgIHJldHVybiBNQVhfVkFMVUU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZSwgdW5zaWduZWQpLm5lZygpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygodmFsdWUgJSBUV09fUFdSXzMyX0RCTCkgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZhbHVlLCBwcm92aWRlZCB0aGF0IGl0IGlzIGEgZmluaXRlIG51bWJlci4gT3RoZXJ3aXNlLCB6ZXJvIGlzIHJldHVybmVkLlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBpbiBxdWVzdGlvblxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIHNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93Qml0c1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSA2NCBiaXQgaW50ZWdlciB0aGF0IGNvbWVzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxvdyBhbmQgaGlnaCBiaXRzLiBFYWNoIGlzXHJcbiAgICAgKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHMgVGhlIGxvdyAzMiBiaXRzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIHNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbUJpdHMgPSBmcm9tQml0cztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhc2VcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgcG93X2RibCA9IE1hdGgucG93OyAvLyBVc2VkIDQgdGltZXMgKDQqOCB0byAxNSs0KVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gICAgICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXhcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XHJcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdlbXB0eSBzdHJpbmcnKTtcclxuICAgICAgICBpZiAoc3RyID09PSBcIk5hTlwiIHx8IHN0ciA9PT0gXCJJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCIrSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiLUluZmluaXR5XCIpXHJcbiAgICAgICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBnb29nLm1hdGgubG9uZyBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgICAgIHJhZGl4ID0gdW5zaWduZWQsXHJcbiAgICAgICAgICAgIHVuc2lnbmVkID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdW5zaWduZWQgPSAhISB1bnNpZ25lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XHJcblxyXG4gICAgICAgIHZhciBwO1xyXG4gICAgICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2ludGVyaW9yIGh5cGhlbicpO1xyXG4gICAgICAgIGVsc2UgaWYgKHAgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgICAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA4KSk7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBaRVJPO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XHJcbiAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xyXG4gICAgICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgc2l6ZSkpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIExvbmdcclxuICAgICAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggVGhlIHJhZGl4IGluIHdoaWNoIHRoZSB0ZXh0IGlzIHdyaXR0ZW4gKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCkge1xyXG4gICAgICAgIGlmICh2YWwgLyogaXMgY29tcGF0aWJsZSAqLyBpbnN0YW5jZW9mIExvbmcpXHJcbiAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcih2YWwpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsKTtcclxuICAgICAgICAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh2YWwubG93LCB2YWwuaGlnaCwgdmFsLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBMb25nLlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbCBWYWx1ZVxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21WYWx1ZSA9IGZyb21WYWx1ZTtcclxuXHJcbiAgICAvLyBOT1RFOiB0aGUgY29tcGlsZXIgc2hvdWxkIGlubGluZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmVsb3cgYW5kIHRoZW4gcmVtb3ZlIHRoZXNlIHZhcmlhYmxlcywgc28gdGhlcmUgc2hvdWxkIGJlXHJcbiAgICAvLyBubyBydW50aW1lIHBlbmFsdHkgZm9yIHRoZXNlLlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgWkVSTyA9IGZyb21JbnQoMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaWduZWQgemVyby5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5aRVJPID0gWkVSTztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5zaWduZWQgemVyby5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5VWkVSTyA9IFVaRVJPO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBPTkUgPSBmcm9tSW50KDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmVkIG9uZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5PTkUgPSBPTkU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5zaWduZWQgb25lLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLlVPTkUgPSBVT05FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBORUdfT05FID0gZnJvbUludCgtMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaWduZWQgbmVnYXRpdmUgb25lLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLk5FR19PTkUgPSBORUdfT05FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBNQVhfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGfDAsIDB4N0ZGRkZGRkZ8MCwgZmFsc2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF4aW11bSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBNQVhfVU5TSUdORURfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGfDAsIDB4RkZGRkZGRkZ8MCwgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIHVuc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMHg4MDAwMDAwMHwwLCBmYWxzZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNaW5pbXVtIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5NSU5fVkFMVUUgPSBNSU5fVkFMVUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAYWxpYXMgTG9uZy5wcm90b3R5cGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTG9uZ1Byb3RvdHlwZSA9IExvbmcucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSB0aGUgbmVhcmVzdCBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZhbHVlIChkb3VibGUsIDUzIGJpdCBtYW50aXNzYSkuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgICAgIHJldHVybiAoKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCkgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBSYWRpeCAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcmFkaXhgIGlzIG91dCBvZiByYW5nZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcocmFkaXgpIHtcclxuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xyXG4gICAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcclxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuICcwJztcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgYm90dG9tLW1vc3QgZGlnaXQgaW4gdGhpcyBiYXNlIGFuZCB0aGVuIHJlY3Vyc2UgdG8gZG8gdGhlIHJlc3QuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksXHJcbiAgICAgICAgICAgICAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcclxuICAgICAgICAgICAgICAgICAgICByZW0xID0gZGl2Lm11bChyYWRpeExvbmcpLnN1Yih0aGlzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJy0nICsgdGhpcy5uZWcoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAgICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXHJcbiAgICAgICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLFxyXG4gICAgICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLFxyXG4gICAgICAgICAgICAgICAgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDAsXHJcbiAgICAgICAgICAgICAgICBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgICAgICByZW0gPSByZW1EaXY7XHJcbiAgICAgICAgICAgIGlmIChyZW0uaXNaZXJvKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgNilcclxuICAgICAgICAgICAgICAgICAgICBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0cyA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2g7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBoaWdoIGJpdHNcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgbG93IGJpdHNcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzID0gZnVuY3Rpb24gZ2V0TG93Qml0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb3c7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGxvdyBiaXRzXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0TG93Qml0c1Vuc2lnbmVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xyXG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xyXG4gICAgICAgIGZvciAodmFyIGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSlcclxuICAgICAgICAgICAgaWYgKCh2YWwgJiAoMSA8PCBiaXQpKSAhPSAwKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAhPSAwID8gYml0ICsgMzMgOiBiaXQgKyAxO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbmVnYXRpdmUuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBwb3NpdGl2ZS5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG9kZC5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGV2ZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgICAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgKHRoaXMuaGlnaCA+Pj4gMzEpID09PSAxICYmIChvdGhlci5oaWdoID4+PiAzMSkgPT09IDEpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNlcXVhbHN9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5lcSA9IExvbmdQcm90b3R5cGUuZXF1YWxzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5lcSgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPiAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW59LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID49IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxyXG4gICAgICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICAgICAgaWYgKHRoaXMuZXEob3RoZXIpKVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLFxyXG4gICAgICAgICAgICBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcclxuICAgICAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHNpZ24gYml0cyBhcmUgdGhlIHNhbWVcclxuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xyXG4gICAgICAgIC8vIEJvdGggYXJlIHBvc2l0aXZlIGlmIGF0IGxlYXN0IG9uZSBpcyB1bnNpZ25lZFxyXG4gICAgICAgIHJldHVybiAob3RoZXIuaGlnaCA+Pj4gMCkgPiAodGhpcy5oaWdoID4+PiAwKSB8fCAob3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIChvdGhlci5sb3cgPj4+IDApID4gKHRoaXMubG93ID4+PiAwKSkgPyAtMSA6IDE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY29tcGFyZX0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICAgICAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5jb21wID0gTG9uZ1Byb3RvdHlwZS5jb21wYXJlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKE9ORSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNuZWdhdGV9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3VtIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gYWRkZW5kIEFkZGVuZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTdW1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcoYWRkZW5kKSlcclxuICAgICAgICAgICAgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7XHJcblxyXG4gICAgICAgIC8vIERpdmlkZSBlYWNoIG51bWJlciBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIHN1bSB0aGUgY2h1bmtzLlxyXG5cclxuICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2O1xyXG4gICAgICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgICAgIGMwMCArPSBhMDAgKyBiMDA7XHJcbiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7XHJcbiAgICAgICAgYzAwICY9IDB4RkZGRjtcclxuICAgICAgICBjMTYgKz0gYTE2ICsgYjE2O1xyXG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzMyICs9IGEzMiArIGIzMjtcclxuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgICAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgICAgIGM0OCArPSBhNDggKyBiNDg7XHJcbiAgICAgICAgYzQ4ICY9IDB4RkZGRjtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhzdWJ0cmFoZW5kKSlcclxuICAgICAgICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc3VidHJhY3R9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikge1xyXG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgICAgICByZXR1cm4gWkVSTztcclxuICAgICAgICBpZiAoIWlzTG9uZyhtdWx0aXBsaWVyKSlcclxuICAgICAgICAgICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTtcclxuICAgICAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XHJcbiAgICAgICAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7XHJcblxyXG4gICAgICAgIC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cclxuICAgICAgICBpZiAodGhpcy5sdChUV09fUFdSXzI0KSAmJiBtdWx0aXBsaWVyLmx0KFRXT19QV1JfMjQpKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpO1xyXG5cclxuICAgICAgICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cclxuICAgICAgICAvLyBXZSBjYW4gc2tpcCBwcm9kdWN0cyB0aGF0IHdvdWxkIG92ZXJmbG93LlxyXG5cclxuICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgMHhGRkZGO1xyXG4gICAgICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgICAgICBjMDAgKz0gYTAwICogYjAwO1xyXG4gICAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICAgICAgYzE2ICs9IGExNiAqIGIwMDtcclxuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgICAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMxNiArPSBhMDAgKiBiMTY7XHJcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICAgICAgYzE2ICY9IDB4RkZGRjtcclxuICAgICAgICBjMzIgKz0gYTMyICogYjAwO1xyXG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzMyICs9IGExNiAqIGIxNjtcclxuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgICAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMzMiArPSBhMDAgKiBiMzI7XHJcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcclxuICAgICAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xyXG4gICAgICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbXVsdGlwbHl9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhlIHJlc3VsdCBpcyBzaWduZWQgaWYgdGhpcyBMb25nIGlzIHNpZ25lZCBvclxyXG4gICAgICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlKGRpdmlzb3IpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcclxuICAgICAgICBpZiAoZGl2aXNvci5pc1plcm8oKSlcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcclxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICAgICAgdmFyIGFwcHJveCwgcmVtLCByZXM7XHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgc2VjdGlvbiBpcyBvbmx5IHJlbGV2YW50IGZvciBzaWduZWQgbG9uZ3MgYW5kIGlzIGRlcml2ZWQgZnJvbSB0aGVcclxuICAgICAgICAgICAgLy8gY2xvc3VyZSBsaWJyYXJ5IGFzIGEgd2hvbGUuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkaXZpc29yLmVxKE9ORSkgfHwgZGl2aXNvci5lcShORUdfT05FKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFOyAgLy8gcmVjYWxsIHRoYXQgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUVcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT05FO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBPTkUgOiBORUdfT05FO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYoZGl2aXNvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xyXG4gICAgICAgICAgICByZXMgPSBaRVJPO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBhbGdvcml0aG0gYmVsb3cgaGFzIG5vdCBiZWVuIG1hZGUgZm9yIHVuc2lnbmVkIGxvbmdzLiBJdCdzIHRoZXJlZm9yZVxyXG4gICAgICAgICAgICAvLyByZXF1aXJlZCB0byB0YWtlIHNwZWNpYWwgY2FyZSBvZiB0aGUgTVNCIHByaW9yIHRvIHJ1bm5pbmcgaXQuXHJcbiAgICAgICAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZClcclxuICAgICAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVVpFUk87XHJcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVU9ORTtcclxuICAgICAgICAgICAgcmVzID0gVVpFUk87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXBlYXQgdGhlIGZvbGxvd2luZyB1bnRpbCB0aGUgcmVtYWluZGVyIGlzIGxlc3MgdGhhbiBvdGhlcjogIGZpbmQgYVxyXG4gICAgICAgIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcclxuICAgICAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XHJcbiAgICAgICAgLy8gdGhlIGFwcHJveGltYXRlIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcmVhbCB2YWx1ZSBzbyB0aGF0IHRoZVxyXG4gICAgICAgIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxyXG4gICAgICAgIHJlbSA9IHRoaXM7XHJcbiAgICAgICAgd2hpbGUgKHJlbS5ndGUoZGl2aXNvcikpIHtcclxuICAgICAgICAgICAgLy8gQXBwcm94aW1hdGUgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbi4gVGhpcyBtYXkgYmUgYSBsaXR0bGUgZ3JlYXRlciBvclxyXG4gICAgICAgICAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cclxuICAgICAgICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpO1xyXG5cclxuICAgICAgICAgICAgLy8gV2Ugd2lsbCB0d2VhayB0aGUgYXBwcm94aW1hdGUgcmVzdWx0IGJ5IGNoYW5naW5nIGl0IGluIHRoZSA0OC10aCBkaWdpdCBvclxyXG4gICAgICAgICAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXHJcbiAgICAgICAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksXHJcbiAgICAgICAgICAgICAgICBkZWx0YSA9IChsb2cyIDw9IDQ4KSA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksXHJcblxyXG4gICAgICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcclxuICAgICAgICAgICAgLy8gdGhhdCBpZiBpdCBpcyB0b28gbGFyZ2UsIHRoZSBwcm9kdWN0IG92ZXJmbG93cyBhbmQgaXMgbmVnYXRpdmUuXHJcbiAgICAgICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksXHJcbiAgICAgICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3QocmVtKSkge1xyXG4gICAgICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXHJcbiAgICAgICAgICAgIC8vIGluZmluaXRlIHJlY3Vyc2lvbiBzaW5jZSB3ZSB3b3VsZCBtYWtlIG5vIHByb2dyZXNzLlxyXG4gICAgICAgICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKVxyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gT05FO1xyXG5cclxuICAgICAgICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xyXG4gICAgICAgICAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgZGl2aWRlZCBieSB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2RpdmlkZX0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIG1vZHVsbyhkaXZpc29yKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE5PVCBvZiB0aGlzIExvbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkge1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgQU5EIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3Iob3RoZXIpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgXiBvdGhlci5sb3csIHRoaXMuaGlnaCBeIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xyXG4gICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cygwLCB0aGlzLmxvdyA8PCAobnVtQml0cyAtIDMyKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdExlZnR9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykge1xyXG4gICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+IChudW1CaXRzIC0gMzIpLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKSB7XHJcbiAgICAgICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgICAgICBudW1CaXRzICY9IDYzO1xyXG4gICAgICAgIGlmIChudW1CaXRzID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2g7XHJcbiAgICAgICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsb3cgPSB0aGlzLmxvdztcclxuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tQml0cygobG93ID4+PiBudW1CaXRzKSB8IChoaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtQml0cyA9PT0gMzIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaHJ1ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gc2lnbmVkLlxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvU2lnbmVkID0gZnVuY3Rpb24gdG9TaWduZWQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byB1bnNpZ25lZC5cclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVW5zaWduZWQgbG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gICAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbihsZSkge1xyXG4gICAgICAgIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgIGxvID0gdGhpcy5sb3c7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgIGxvICAgICAgICAgJiAweGZmLFxyXG4gICAgICAgICAgICAobG8gPj4+ICA4KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChsbyA+Pj4gMTYpICYgMHhmZixcclxuICAgICAgICAgICAgKGxvID4+PiAyNCkgJiAweGZmLFxyXG4gICAgICAgICAgICAgaGkgICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChoaSA+Pj4gIDgpICYgMHhmZixcclxuICAgICAgICAgICAgKGhpID4+PiAxNikgJiAweGZmLFxyXG4gICAgICAgICAgICAoaGkgPj4+IDI0KSAmIDB4ZmZcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzQkUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgIGxvID0gdGhpcy5sb3c7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgKGhpID4+PiAyNCkgJiAweGZmLFxyXG4gICAgICAgICAgICAoaGkgPj4+IDE2KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChoaSA+Pj4gIDgpICYgMHhmZixcclxuICAgICAgICAgICAgIGhpICAgICAgICAgJiAweGZmLFxyXG4gICAgICAgICAgICAobG8gPj4+IDI0KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChsbyA+Pj4gMTYpICYgMHhmZixcclxuICAgICAgICAgICAgKGxvID4+PiAgOCkgJiAweGZmLFxyXG4gICAgICAgICAgICAgbG8gICAgICAgICAmIDB4ZmZcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBMb25nO1xyXG59KTtcclxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9sb25nL2Rpc3QvbG9uZy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9sb25nL2Rpc3RcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnblwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qXG5DcnlwdG9KUyB2My4xLjJcbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuKGMpIDIwMDktMjAxMyBieSBKZWZmIE1vdHQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG4qL1xuLyoqIEBwcmVzZXJ2ZVxuKGMpIDIwMTIgYnkgQ8OpZHJpYyBNZXNuaWwuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4vLyBjb25zdGFudHMgdGFibGVcbnZhciB6bCA9IFtcbiAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbiAgMywgMTAsIDE0LCA0LCA5LCAxNSwgOCwgMSwgMiwgNywgMCwgNiwgMTMsIDExLCA1LCAxMixcbiAgMSwgOSwgMTEsIDEwLCAwLCA4LCAxMiwgNCwgMTMsIDMsIDcsIDE1LCAxNCwgNSwgNiwgMixcbiAgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuXVxuXG52YXIgenIgPSBbXG4gIDUsIDE0LCA3LCAwLCA5LCAyLCAxMSwgNCwgMTMsIDYsIDE1LCA4LCAxLCAxMCwgMywgMTIsXG4gIDYsIDExLCAzLCA3LCAwLCAxMywgNSwgMTAsIDE0LCAxNSwgOCwgMTIsIDQsIDksIDEsIDIsXG4gIDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTMsXG4gIDgsIDYsIDQsIDEsIDMsIDExLCAxNSwgMCwgNSwgMTIsIDIsIDEzLCA5LCA3LCAxMCwgMTQsXG4gIDEyLCAxNSwgMTAsIDQsIDEsIDUsIDgsIDcsIDYsIDIsIDEzLCAxNCwgMCwgMywgOSwgMTFcbl1cblxudmFyIHNsID0gW1xuICAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDgsXG4gIDcsIDYsIDgsIDEzLCAxMSwgOSwgNywgMTUsIDcsIDEyLCAxNSwgOSwgMTEsIDcsIDEzLCAxMixcbiAgMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1LFxuICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTIsXG4gIDksIDE1LCA1LCAxMSwgNiwgOCwgMTMsIDEyLCA1LCAxMiwgMTMsIDE0LCAxMSwgOCwgNSwgNlxuXVxuXG52YXIgc3IgPSBbXG4gIDgsIDksIDksIDExLCAxMywgMTUsIDE1LCA1LCA3LCA3LCA4LCAxMSwgMTQsIDE0LCAxMiwgNixcbiAgOSwgMTMsIDE1LCA3LCAxMiwgOCwgOSwgMTEsIDcsIDcsIDEyLCA3LCA2LCAxNSwgMTMsIDExLFxuICA5LCA3LCAxNSwgMTEsIDgsIDYsIDYsIDE0LCAxMiwgMTMsIDUsIDE0LCAxMywgMTMsIDcsIDUsXG4gIDE1LCA1LCA4LCAxMSwgMTQsIDE0LCA2LCAxNCwgNiwgOSwgMTIsIDksIDEyLCA1LCAxNSwgOCxcbiAgOCwgNSwgMTIsIDksIDEyLCA1LCAxNCwgNiwgOCwgMTMsIDYsIDUsIDE1LCAxMywgMTEsIDExXG5dXG5cbnZhciBobCA9IFsweDAwMDAwMDAwLCAweDVBODI3OTk5LCAweDZFRDlFQkExLCAweDhGMUJCQ0RDLCAweEE5NTNGRDRFXVxudmFyIGhyID0gWzB4NTBBMjhCRTYsIDB4NUM0REQxMjQsIDB4NkQ3MDNFRjMsIDB4N0E2RDc2RTksIDB4MDAwMDAwMDBdXG5cbmZ1bmN0aW9uIGJ5dGVzVG9Xb3JkcyAoYnl0ZXMpIHtcbiAgdmFyIHdvcmRzID0gW11cbiAgZm9yICh2YXIgaSA9IDAsIGIgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyssIGIgKz0gOCkge1xuICAgIHdvcmRzW2IgPj4+IDVdIHw9IGJ5dGVzW2ldIDw8ICgyNCAtIGIgJSAzMilcbiAgfVxuICByZXR1cm4gd29yZHNcbn1cblxuZnVuY3Rpb24gd29yZHNUb0J5dGVzICh3b3Jkcykge1xuICB2YXIgYnl0ZXMgPSBbXVxuICBmb3IgKHZhciBiID0gMDsgYiA8IHdvcmRzLmxlbmd0aCAqIDMyOyBiICs9IDgpIHtcbiAgICBieXRlcy5wdXNoKCh3b3Jkc1tiID4+PiA1XSA+Pj4gKDI0IC0gYiAlIDMyKSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzQmxvY2sgKEgsIE0sIG9mZnNldCkge1xuICAvLyBzd2FwIGVuZGlhblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpXG4gICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXVxuXG4gICAgLy8gU3dhcFxuICAgIE1bb2Zmc2V0X2ldID0gKFxuICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSB8IChNX29mZnNldF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICAgKCgoTV9vZmZzZXRfaSA8PCAyNCkgfCAoTV9vZmZzZXRfaSA+Pj4gOCkpICYgMHhmZjAwZmYwMClcbiAgICApXG4gIH1cblxuICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuICB2YXIgYWwsIGJsLCBjbCwgZGwsIGVsXG4gIHZhciBhciwgYnIsIGNyLCBkciwgZXJcblxuICBhciA9IGFsID0gSFswXVxuICBiciA9IGJsID0gSFsxXVxuICBjciA9IGNsID0gSFsyXVxuICBkciA9IGRsID0gSFszXVxuICBlciA9IGVsID0gSFs0XVxuXG4gIC8vIGNvbXB1dGF0aW9uXG4gIHZhciB0XG4gIGZvciAoaSA9IDA7IGkgPCA4MDsgaSArPSAxKSB7XG4gICAgdCA9IChhbCArIE1bb2Zmc2V0ICsgemxbaV1dKSB8IDBcbiAgICBpZiAoaSA8IDE2KSB7XG4gICAgICB0ICs9IGYxKGJsLCBjbCwgZGwpICsgaGxbMF1cbiAgICB9IGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgdCArPSBmMihibCwgY2wsIGRsKSArIGhsWzFdXG4gICAgfSBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgIHQgKz0gZjMoYmwsIGNsLCBkbCkgKyBobFsyXVxuICAgIH0gZWxzZSBpZiAoaSA8IDY0KSB7XG4gICAgICB0ICs9IGY0KGJsLCBjbCwgZGwpICsgaGxbM11cbiAgICB9IGVsc2Ugey8vIGlmIChpPDgwKSB7XG4gICAgICB0ICs9IGY1KGJsLCBjbCwgZGwpICsgaGxbNF1cbiAgICB9XG4gICAgdCA9IHQgfCAwXG4gICAgdCA9IHJvdGwodCwgc2xbaV0pXG4gICAgdCA9ICh0ICsgZWwpIHwgMFxuICAgIGFsID0gZWxcbiAgICBlbCA9IGRsXG4gICAgZGwgPSByb3RsKGNsLCAxMClcbiAgICBjbCA9IGJsXG4gICAgYmwgPSB0XG5cbiAgICB0ID0gKGFyICsgTVtvZmZzZXQgKyB6cltpXV0pIHwgMFxuICAgIGlmIChpIDwgMTYpIHtcbiAgICAgIHQgKz0gZjUoYnIsIGNyLCBkcikgKyBoclswXVxuICAgIH0gZWxzZSBpZiAoaSA8IDMyKSB7XG4gICAgICB0ICs9IGY0KGJyLCBjciwgZHIpICsgaHJbMV1cbiAgICB9IGVsc2UgaWYgKGkgPCA0OCkge1xuICAgICAgdCArPSBmMyhiciwgY3IsIGRyKSArIGhyWzJdXG4gICAgfSBlbHNlIGlmIChpIDwgNjQpIHtcbiAgICAgIHQgKz0gZjIoYnIsIGNyLCBkcikgKyBoclszXVxuICAgIH0gZWxzZSB7Ly8gaWYgKGk8ODApIHtcbiAgICAgIHQgKz0gZjEoYnIsIGNyLCBkcikgKyBocls0XVxuICAgIH1cblxuICAgIHQgPSB0IHwgMFxuICAgIHQgPSByb3RsKHQsIHNyW2ldKVxuICAgIHQgPSAodCArIGVyKSB8IDBcbiAgICBhciA9IGVyXG4gICAgZXIgPSBkclxuICAgIGRyID0gcm90bChjciwgMTApXG4gICAgY3IgPSBiclxuICAgIGJyID0gdFxuICB9XG5cbiAgLy8gaW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcbiAgdCA9IChIWzFdICsgY2wgKyBkcikgfCAwXG4gIEhbMV0gPSAoSFsyXSArIGRsICsgZXIpIHwgMFxuICBIWzJdID0gKEhbM10gKyBlbCArIGFyKSB8IDBcbiAgSFszXSA9IChIWzRdICsgYWwgKyBicikgfCAwXG4gIEhbNF0gPSAoSFswXSArIGJsICsgY3IpIHwgMFxuICBIWzBdID0gdFxufVxuXG5mdW5jdGlvbiBmMSAoeCwgeSwgeikge1xuICByZXR1cm4gKCh4KSBeICh5KSBeICh6KSlcbn1cblxuZnVuY3Rpb24gZjIgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoKHgpICYgKHkpKSB8ICgofngpICYgKHopKSlcbn1cblxuZnVuY3Rpb24gZjMgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoKHgpIHwgKH4oeSkpKSBeICh6KSlcbn1cblxuZnVuY3Rpb24gZjQgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoKHgpICYgKHopKSB8ICgoeSkgJiAofih6KSkpKVxufVxuXG5mdW5jdGlvbiBmNSAoeCwgeSwgeikge1xuICByZXR1cm4gKCh4KSBeICgoeSkgfCAofih6KSkpKVxufVxuXG5mdW5jdGlvbiByb3RsICh4LCBuKSB7XG4gIHJldHVybiAoeCA8PCBuKSB8ICh4ID4+PiAoMzIgLSBuKSlcbn1cblxuZnVuY3Rpb24gcmlwZW1kMTYwIChtZXNzYWdlKSB7XG4gIHZhciBIID0gWzB4Njc0NTIzMDEsIDB4RUZDREFCODksIDB4OThCQURDRkUsIDB4MTAzMjU0NzYsIDB4QzNEMkUxRjBdXG5cbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBuZXcgQnVmZmVyKG1lc3NhZ2UsICd1dGY4JylcbiAgfVxuXG4gIHZhciBtID0gYnl0ZXNUb1dvcmRzKG1lc3NhZ2UpXG5cbiAgdmFyIG5CaXRzTGVmdCA9IG1lc3NhZ2UubGVuZ3RoICogOFxuICB2YXIgbkJpdHNUb3RhbCA9IG1lc3NhZ2UubGVuZ3RoICogOFxuXG4gIC8vIEFkZCBwYWRkaW5nXG4gIG1bbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKVxuICBtWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSAoXG4gICAgKCgobkJpdHNUb3RhbCA8PCA4KSB8IChuQml0c1RvdGFsID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICgoKG5CaXRzVG90YWwgPDwgMjQpIHwgKG5CaXRzVG90YWwgPj4+IDgpKSAmIDB4ZmYwMGZmMDApXG4gIClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgcHJvY2Vzc0Jsb2NrKEgsIG0sIGkpXG4gIH1cblxuICAvLyBzd2FwIGVuZGlhblxuICBmb3IgKGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgLy8gc2hvcnRjdXRcbiAgICB2YXIgSF9pID0gSFtpXVxuXG4gICAgLy8gU3dhcFxuICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICAgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAmIDB4ZmYwMGZmMDApXG4gIH1cblxuICB2YXIgZGlnZXN0Ynl0ZXMgPSB3b3Jkc1RvQnl0ZXMoSClcbiAgcmV0dXJuIG5ldyBCdWZmZXIoZGlnZXN0Ynl0ZXMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmlwZW1kMTYwXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3JpcGVtZDE2MC9saWIvcmlwZW1kMTYwLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3JpcGVtZDE2MC9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4hZnVuY3Rpb24oZ2xvYmFscyl7XG4ndXNlIHN0cmljdCdcblxuLy8qKiogVU1EIEJFR0lOXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkgeyAvL3JlcXVpcmUuanMgLyBBTURcbiAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VjdXJlUmFuZG9tXG4gIH0pXG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7IC8vQ29tbW9uSlNcbiAgbW9kdWxlLmV4cG9ydHMgPSBzZWN1cmVSYW5kb21cbn0gZWxzZSB7IC8vc2NyaXB0IC8gYnJvd3NlclxuICBnbG9iYWxzLnNlY3VyZVJhbmRvbSA9IHNlY3VyZVJhbmRvbVxufVxuLy8qKiogVU1EIEVORFxuXG4vL29wdGlvbnMudHlwZSBpcyB0aGUgb25seSB2YWxpZCBvcHRpb25cbmZ1bmN0aW9uIHNlY3VyZVJhbmRvbShjb3VudCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7dHlwZTogJ0FycmF5J31cbiAgLy93ZSBjaGVjayBmb3IgcHJvY2Vzcy5waWQgdG8gcHJldmVudCBicm93c2VyaWZ5IGZyb20gdHJpY2tpbmcgdXNcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzLnBpZCA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBub2RlUmFuZG9tKGNvdW50LCBvcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIHZhciBjcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0b1xuICAgIGlmICghY3J5cHRvKSB0aHJvdyBuZXcgRXJyb3IoXCJZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB3aW5kb3cuY3J5cHRvLlwiKVxuICAgIHJldHVybiBicm93c2VyUmFuZG9tKGNvdW50LCBvcHRpb25zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vZGVSYW5kb20oY291bnQsIG9wdGlvbnMpIHtcbiAgdmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG4gIHZhciBidWYgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoY291bnQpXG5cbiAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICBjYXNlICdBcnJheSc6XG4gICAgICByZXR1cm4gW10uc2xpY2UuY2FsbChidWYpXG4gICAgY2FzZSAnQnVmZmVyJzpcbiAgICAgIHJldHVybiBidWZcbiAgICBjYXNlICdVaW50OEFycmF5JzpcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShjb3VudClcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkgeyBhcnJbaV0gPSBidWYucmVhZFVJbnQ4KGkpIH1cbiAgICAgIHJldHVybiBhcnJcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG9wdGlvbnMudHlwZSArIFwiIGlzIHVuc3VwcG9ydGVkLlwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJyb3dzZXJSYW5kb20oY291bnQsIG9wdGlvbnMpIHtcbiAgdmFyIG5hdGl2ZUFyciA9IG5ldyBVaW50OEFycmF5KGNvdW50KVxuICB2YXIgY3J5cHRvID0gd2luZG93LmNyeXB0byB8fCB3aW5kb3cubXNDcnlwdG9cbiAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuYXRpdmVBcnIpXG5cbiAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICBjYXNlICdBcnJheSc6XG4gICAgICByZXR1cm4gW10uc2xpY2UuY2FsbChuYXRpdmVBcnIpXG4gICAgY2FzZSAnQnVmZmVyJzpcbiAgICAgIHRyeSB7IHZhciBiID0gbmV3IEJ1ZmZlcigxKSB9IGNhdGNoKGUpIHsgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LiBVc2UgTm9kZS5qcyBvciBCcm93c2VyaWZ5IGZvciBicm93c2VyIHN1cHBvcnQuJyl9XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcihuYXRpdmVBcnIpXG4gICAgY2FzZSAnVWludDhBcnJheSc6XG4gICAgICByZXR1cm4gbmF0aXZlQXJyXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihvcHRpb25zLnR5cGUgKyBcIiBpcyB1bnN1cHBvcnRlZC5cIilcbiAgfVxufVxuXG5zZWN1cmVSYW5kb20ucmFuZG9tQXJyYXkgPSBmdW5jdGlvbihieXRlQ291bnQpIHtcbiAgcmV0dXJuIHNlY3VyZVJhbmRvbShieXRlQ291bnQsIHt0eXBlOiAnQXJyYXknfSlcbn1cblxuc2VjdXJlUmFuZG9tLnJhbmRvbVVpbnQ4QXJyYXkgPSBmdW5jdGlvbihieXRlQ291bnQpIHtcbiAgcmV0dXJuIHNlY3VyZVJhbmRvbShieXRlQ291bnQsIHt0eXBlOiAnVWludDhBcnJheSd9KVxufVxuXG5zZWN1cmVSYW5kb20ucmFuZG9tQnVmZmVyID0gZnVuY3Rpb24oYnl0ZUNvdW50KSB7XG4gIHJldHVybiBzZWN1cmVSYW5kb20oYnl0ZUNvdW50LCB7dHlwZTogJ0J1ZmZlcid9KVxufVxuXG5cbn0odGhpcyk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3NlY3VyZS1yYW5kb20vbGliL3NlY3VyZS1yYW5kb20uanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc2VjdXJlLXJhbmRvbS9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBwcm90b3R5cGUgY2xhc3MgZm9yIGhhc2ggZnVuY3Rpb25zXG5mdW5jdGlvbiBIYXNoIChibG9ja1NpemUsIGZpbmFsU2l6ZSkge1xuICB0aGlzLl9ibG9jayA9IG5ldyBCdWZmZXIoYmxvY2tTaXplKVxuICB0aGlzLl9maW5hbFNpemUgPSBmaW5hbFNpemVcbiAgdGhpcy5fYmxvY2tTaXplID0gYmxvY2tTaXplXG4gIHRoaXMuX2xlbiA9IDBcbiAgdGhpcy5fcyA9IDBcbn1cblxuSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jID0gZW5jIHx8ICd1dGY4J1xuICAgIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGVuYylcbiAgfVxuXG4gIHZhciBsID0gdGhpcy5fbGVuICs9IGRhdGEubGVuZ3RoXG4gIHZhciBzID0gdGhpcy5fcyB8fCAwXG4gIHZhciBmID0gMFxuICB2YXIgYnVmZmVyID0gdGhpcy5fYmxvY2tcblxuICB3aGlsZSAocyA8IGwpIHtcbiAgICB2YXIgdCA9IE1hdGgubWluKGRhdGEubGVuZ3RoLCBmICsgdGhpcy5fYmxvY2tTaXplIC0gKHMgJSB0aGlzLl9ibG9ja1NpemUpKVxuICAgIHZhciBjaCA9ICh0IC0gZilcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2g7IGkrKykge1xuICAgICAgYnVmZmVyWyhzICUgdGhpcy5fYmxvY2tTaXplKSArIGldID0gZGF0YVtpICsgZl1cbiAgICB9XG5cbiAgICBzICs9IGNoXG4gICAgZiArPSBjaFxuXG4gICAgaWYgKChzICUgdGhpcy5fYmxvY2tTaXplKSA9PT0gMCkge1xuICAgICAgdGhpcy5fdXBkYXRlKGJ1ZmZlcilcbiAgICB9XG4gIH1cbiAgdGhpcy5fcyA9IHNcblxuICByZXR1cm4gdGhpc1xufVxuXG5IYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIC8vIFN1cHBvc2UgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZSBNLCBpbiBiaXRzLCBpcyBsXG4gIHZhciBsID0gdGhpcy5fbGVuICogOFxuXG4gIC8vIEFwcGVuZCB0aGUgYml0IDEgdG8gdGhlIGVuZCBvZiB0aGUgbWVzc2FnZVxuICB0aGlzLl9ibG9ja1t0aGlzLl9sZW4gJSB0aGlzLl9ibG9ja1NpemVdID0gMHg4MFxuXG4gIC8vIGFuZCB0aGVuIGsgemVybyBiaXRzLCB3aGVyZSBrIGlzIHRoZSBzbWFsbGVzdCBub24tbmVnYXRpdmUgc29sdXRpb24gdG8gdGhlIGVxdWF0aW9uIChsICsgMSArIGspID09PSBmaW5hbFNpemUgbW9kIGJsb2NrU2l6ZVxuICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2xlbiAlIHRoaXMuX2Jsb2NrU2l6ZSArIDEpXG5cbiAgaWYgKGwgJSAodGhpcy5fYmxvY2tTaXplICogOCkgPj0gdGhpcy5fZmluYWxTaXplICogOCkge1xuICAgIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcbiAgICB0aGlzLl9ibG9jay5maWxsKDApXG4gIH1cblxuICAvLyB0byB0aGlzIGFwcGVuZCB0aGUgYmxvY2sgd2hpY2ggaXMgZXF1YWwgdG8gdGhlIG51bWJlciBsIHdyaXR0ZW4gaW4gYmluYXJ5XG4gIC8vIFRPRE86IGhhbmRsZSBjYXNlIHdoZXJlIGwgaXMgPiBNYXRoLnBvdygyLCAyOSlcbiAgdGhpcy5fYmxvY2sud3JpdGVJbnQzMkJFKGwsIHRoaXMuX2Jsb2NrU2l6ZSAtIDQpXG5cbiAgdmFyIGhhc2ggPSB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spIHx8IHRoaXMuX2hhc2goKVxuXG4gIHJldHVybiBlbmMgPyBoYXNoLnRvU3RyaW5nKGVuYykgOiBoYXNoXG59XG5cbkhhc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3NoYS5qcy9oYXNoLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3NoYS5qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTSEEgKGFsZ29yaXRobSkge1xuICBhbGdvcml0aG0gPSBhbGdvcml0aG0udG9Mb3dlckNhc2UoKVxuXG4gIHZhciBBbGdvcml0aG0gPSBleHBvcnRzW2FsZ29yaXRobV1cbiAgaWYgKCFBbGdvcml0aG0pIHRocm93IG5ldyBFcnJvcihhbGdvcml0aG0gKyAnIGlzIG5vdCBzdXBwb3J0ZWQgKHdlIGFjY2VwdCBwdWxsIHJlcXVlc3RzKScpXG5cbiAgcmV0dXJuIG5ldyBBbGdvcml0aG0oKVxufVxuXG5leHBvcnRzLnNoYSA9IHJlcXVpcmUoJy4vc2hhJylcbmV4cG9ydHMuc2hhMSA9IHJlcXVpcmUoJy4vc2hhMScpXG5leHBvcnRzLnNoYTIyNCA9IHJlcXVpcmUoJy4vc2hhMjI0JylcbmV4cG9ydHMuc2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxuZXhwb3J0cy5zaGEzODQgPSByZXF1aXJlKCcuL3NoYTM4NCcpXG5leHBvcnRzLnNoYTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc2hhLmpzL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3NoYS5qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTAsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGRlcml2ZWQgZnJvbSBzaGExLmpzIG9mIHRoZSBzYW1lIHJlcG9zaXRvcnkuXG4gKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIFNIQS0wIGFuZCBTSEEtMSBpcyBqdXN0IGEgYml0d2lzZSByb3RhdGUgbGVmdFxuICogb3BlcmF0aW9uIHdhcyBhZGRlZC5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG5cbnZhciBLID0gW1xuICAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjIHwgMCwgMHhjYTYyYzFkNiB8IDBcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoODApXG5cbmZ1bmN0aW9uIFNoYSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhLCBIYXNoKVxuXG5TaGEucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDY3NDUyMzAxXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5XG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlXG4gIHRoaXMuX2QgPSAweDEwMzI1NDc2XG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gcm90bDUgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCA1KSB8IChudW0gPj4+IDI3KVxufVxuXG5mdW5jdGlvbiByb3RsMzAgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAzMCkgfCAobnVtID4+PiAyKVxufVxuXG5mdW5jdGlvbiBmdCAocywgYiwgYywgZCkge1xuICBpZiAocyA9PT0gMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpXG4gIGlmIChzID09PSAyKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpXG4gIHJldHVybiBiIF4gYyBeIGRcbn1cblxuU2hhLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA4MDsgKytpKSBXW2ldID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3NoYS5qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhMSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMSwgSGFzaClcblxuU2hhMS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsMSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDEpIHwgKG51bSA+Pj4gMzEpXG59XG5cbmZ1bmN0aW9uIHJvdGw1IChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgNSkgfCAobnVtID4+PiAyNylcbn1cblxuZnVuY3Rpb24gcm90bDMwIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMzApIHwgKG51bSA+Pj4gMilcbn1cblxuZnVuY3Rpb24gZnQgKHMsIGIsIGMsIGQpIHtcbiAgaWYgKHMgPT09IDApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKVxuICBpZiAocyA9PT0gMikgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKVxuICByZXR1cm4gYiBeIGMgXiBkXG59XG5cblNoYTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSByb3RsMShXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdKVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYTEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMjApXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IgfCAwLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lIHwgMCwgMTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGExXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGExLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3NoYS5qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgVyA9IG5ldyBBcnJheSg2NClcblxuZnVuY3Rpb24gU2hhMjI0ICgpIHtcbiAgdGhpcy5pbml0KClcblxuICB0aGlzLl93ID0gVyAvLyBuZXcgQXJyYXkoNjQpXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMjI0LCBTaGEyNTYpXG5cblNoYTIyNC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4YzEwNTllZDhcbiAgdGhpcy5fYiA9IDB4MzY3Y2Q1MDdcbiAgdGhpcy5fYyA9IDB4MzA3MGRkMTdcbiAgdGhpcy5fZCA9IDB4ZjcwZTU5MzlcbiAgdGhpcy5fZSA9IDB4ZmZjMDBiMzFcbiAgdGhpcy5fZiA9IDB4Njg1ODE1MTFcbiAgdGhpcy5fZyA9IDB4NjRmOThmYTdcbiAgdGhpcy5faCA9IDB4YmVmYTRmYTRcblxuICByZXR1cm4gdGhpc1xufVxuXG5TaGEyMjQucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMjgpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyMjRcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTIyNC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zaGEuanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKipcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMjU2LCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIDE4MC0yXG4gKiBWZXJzaW9uIDIuMi1iZXRhIENvcHlyaWdodCBBbmdlbCBNYXJpbiwgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwOS5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgSyA9IFtcbiAgMHg0MjhBMkY5OCwgMHg3MTM3NDQ5MSwgMHhCNUMwRkJDRiwgMHhFOUI1REJBNSxcbiAgMHgzOTU2QzI1QiwgMHg1OUYxMTFGMSwgMHg5MjNGODJBNCwgMHhBQjFDNUVENSxcbiAgMHhEODA3QUE5OCwgMHgxMjgzNUIwMSwgMHgyNDMxODVCRSwgMHg1NTBDN0RDMyxcbiAgMHg3MkJFNUQ3NCwgMHg4MERFQjFGRSwgMHg5QkRDMDZBNywgMHhDMTlCRjE3NCxcbiAgMHhFNDlCNjlDMSwgMHhFRkJFNDc4NiwgMHgwRkMxOURDNiwgMHgyNDBDQTFDQyxcbiAgMHgyREU5MkM2RiwgMHg0QTc0ODRBQSwgMHg1Q0IwQTlEQywgMHg3NkY5ODhEQSxcbiAgMHg5ODNFNTE1MiwgMHhBODMxQzY2RCwgMHhCMDAzMjdDOCwgMHhCRjU5N0ZDNyxcbiAgMHhDNkUwMEJGMywgMHhENUE3OTE0NywgMHgwNkNBNjM1MSwgMHgxNDI5Mjk2NyxcbiAgMHgyN0I3MEE4NSwgMHgyRTFCMjEzOCwgMHg0RDJDNkRGQywgMHg1MzM4MEQxMyxcbiAgMHg2NTBBNzM1NCwgMHg3NjZBMEFCQiwgMHg4MUMyQzkyRSwgMHg5MjcyMkM4NSxcbiAgMHhBMkJGRThBMSwgMHhBODFBNjY0QiwgMHhDMjRCOEI3MCwgMHhDNzZDNTFBMyxcbiAgMHhEMTkyRTgxOSwgMHhENjk5MDYyNCwgMHhGNDBFMzU4NSwgMHgxMDZBQTA3MCxcbiAgMHgxOUE0QzExNiwgMHgxRTM3NkMwOCwgMHgyNzQ4Nzc0QywgMHgzNEIwQkNCNSxcbiAgMHgzOTFDMENCMywgMHg0RUQ4QUE0QSwgMHg1QjlDQ0E0RiwgMHg2ODJFNkZGMyxcbiAgMHg3NDhGODJFRSwgMHg3OEE1NjM2RiwgMHg4NEM4NzgxNCwgMHg4Q0M3MDIwOCxcbiAgMHg5MEJFRkZGQSwgMHhBNDUwNkNFQiwgMHhCRUY5QTNGNywgMHhDNjcxNzhGMlxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg2NClcblxuZnVuY3Rpb24gU2hhMjU2ICgpIHtcbiAgdGhpcy5pbml0KClcblxuICB0aGlzLl93ID0gVyAvLyBuZXcgQXJyYXkoNjQpXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMjU2LCBIYXNoKVxuXG5TaGEyNTYucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDZhMDllNjY3XG4gIHRoaXMuX2IgPSAweGJiNjdhZTg1XG4gIHRoaXMuX2MgPSAweDNjNmVmMzcyXG4gIHRoaXMuX2QgPSAweGE1NGZmNTNhXG4gIHRoaXMuX2UgPSAweDUxMGU1MjdmXG4gIHRoaXMuX2YgPSAweDliMDU2ODhjXG4gIHRoaXMuX2cgPSAweDFmODNkOWFiXG4gIHRoaXMuX2ggPSAweDViZTBjZDE5XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gY2ggKHgsIHksIHopIHtcbiAgcmV0dXJuIHogXiAoeCAmICh5IF4geikpXG59XG5cbmZ1bmN0aW9uIG1haiAoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSB8ICh6ICYgKHggfCB5KSlcbn1cblxuZnVuY3Rpb24gc2lnbWEwICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gMiB8IHggPDwgMzApIF4gKHggPj4+IDEzIHwgeCA8PCAxOSkgXiAoeCA+Pj4gMjIgfCB4IDw8IDEwKVxufVxuXG5mdW5jdGlvbiBzaWdtYTEgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiA2IHwgeCA8PCAyNikgXiAoeCA+Pj4gMTEgfCB4IDw8IDIxKSBeICh4ID4+PiAyNSB8IHggPDwgNylcbn1cblxuZnVuY3Rpb24gZ2FtbWEwICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gNyB8IHggPDwgMjUpIF4gKHggPj4+IDE4IHwgeCA8PCAxNCkgXiAoeCA+Pj4gMylcbn1cblxuZnVuY3Rpb24gZ2FtbWExICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gMTcgfCB4IDw8IDE1KSBeICh4ID4+PiAxOSB8IHggPDwgMTMpIF4gKHggPj4+IDEwKVxufVxuXG5TaGEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcbiAgdmFyIGYgPSB0aGlzLl9mIHwgMFxuICB2YXIgZyA9IHRoaXMuX2cgfCAwXG4gIHZhciBoID0gdGhpcy5faCB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDY0OyArK2kpIFdbaV0gPSAoZ2FtbWExKFdbaSAtIDJdKSArIFdbaSAtIDddICsgZ2FtbWEwKFdbaSAtIDE1XSkgKyBXW2kgLSAxNl0pIHwgMFxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgNjQ7ICsraikge1xuICAgIHZhciBUMSA9IChoICsgc2lnbWExKGUpICsgY2goZSwgZiwgZykgKyBLW2pdICsgV1tqXSkgfCAwXG4gICAgdmFyIFQyID0gKHNpZ21hMChhKSArIG1haihhLCBiLCBjKSkgfCAwXG5cbiAgICBoID0gZ1xuICAgIGcgPSBmXG4gICAgZiA9IGVcbiAgICBlID0gKGQgKyBUMSkgfCAwXG4gICAgZCA9IGNcbiAgICBjID0gYlxuICAgIGIgPSBhXG4gICAgYSA9IChUMSArIFQyKSB8IDBcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbiAgdGhpcy5fZiA9IChmICsgdGhpcy5fZikgfCAwXG4gIHRoaXMuX2cgPSAoZyArIHRoaXMuX2cpIHwgMFxuICB0aGlzLl9oID0gKGggKyB0aGlzLl9oKSB8IDBcbn1cblxuU2hhMjU2LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDMyKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9oLCAyOClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTI1NlxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjU2LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3NoYS5qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTSEE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG5cbnZhciBXID0gbmV3IEFycmF5KDE2MClcblxuZnVuY3Rpb24gU2hhMzg0ICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgMTI4LCAxMTIpXG59XG5cbmluaGVyaXRzKFNoYTM4NCwgU0hBNTEyKVxuXG5TaGEzODQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2FoID0gMHhjYmJiOWQ1ZFxuICB0aGlzLl9iaCA9IDB4NjI5YTI5MmFcbiAgdGhpcy5fY2ggPSAweDkxNTkwMTVhXG4gIHRoaXMuX2RoID0gMHgxNTJmZWNkOFxuICB0aGlzLl9laCA9IDB4NjczMzI2NjdcbiAgdGhpcy5fZmggPSAweDhlYjQ0YTg3XG4gIHRoaXMuX2doID0gMHhkYjBjMmUwZFxuICB0aGlzLl9oaCA9IDB4NDdiNTQ4MWRcblxuICB0aGlzLl9hbCA9IDB4YzEwNTllZDhcbiAgdGhpcy5fYmwgPSAweDM2N2NkNTA3XG4gIHRoaXMuX2NsID0gMHgzMDcwZGQxN1xuICB0aGlzLl9kbCA9IDB4ZjcwZTU5MzlcbiAgdGhpcy5fZWwgPSAweGZmYzAwYjMxXG4gIHRoaXMuX2ZsID0gMHg2ODU4MTUxMVxuICB0aGlzLl9nbCA9IDB4NjRmOThmYTdcbiAgdGhpcy5faGwgPSAweGJlZmE0ZmE0XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuU2hhMzg0LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDQ4KVxuXG4gIGZ1bmN0aW9uIHdyaXRlSW50NjRCRSAoaCwgbCwgb2Zmc2V0KSB7XG4gICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXG4gIH1cblxuICB3cml0ZUludDY0QkUodGhpcy5fYWgsIHRoaXMuX2FsLCAwKVxuICB3cml0ZUludDY0QkUodGhpcy5fYmgsIHRoaXMuX2JsLCA4KVxuICB3cml0ZUludDY0QkUodGhpcy5fY2gsIHRoaXMuX2NsLCAxNilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2RoLCB0aGlzLl9kbCwgMjQpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9laCwgdGhpcy5fZWwsIDMyKVxuICB3cml0ZUludDY0QkUodGhpcy5fZmgsIHRoaXMuX2ZsLCA0MClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTM4NFxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMzg0LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3NoYS5qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIEsgPSBbXG4gIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG5mdW5jdGlvbiBTaGE1MTIgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbn1cblxuaW5oZXJpdHMoU2hhNTEyLCBIYXNoKVxuXG5TaGE1MTIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2FoID0gMHg2YTA5ZTY2N1xuICB0aGlzLl9iaCA9IDB4YmI2N2FlODVcbiAgdGhpcy5fY2ggPSAweDNjNmVmMzcyXG4gIHRoaXMuX2RoID0gMHhhNTRmZjUzYVxuICB0aGlzLl9laCA9IDB4NTEwZTUyN2ZcbiAgdGhpcy5fZmggPSAweDliMDU2ODhjXG4gIHRoaXMuX2doID0gMHgxZjgzZDlhYlxuICB0aGlzLl9oaCA9IDB4NWJlMGNkMTlcblxuICB0aGlzLl9hbCA9IDB4ZjNiY2M5MDhcbiAgdGhpcy5fYmwgPSAweDg0Y2FhNzNiXG4gIHRoaXMuX2NsID0gMHhmZTk0ZjgyYlxuICB0aGlzLl9kbCA9IDB4NWYxZDM2ZjFcbiAgdGhpcy5fZWwgPSAweGFkZTY4MmQxXG4gIHRoaXMuX2ZsID0gMHgyYjNlNmMxZlxuICB0aGlzLl9nbCA9IDB4ZmI0MWJkNmJcbiAgdGhpcy5faGwgPSAweDEzN2UyMTc5XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gQ2ggKHgsIHksIHopIHtcbiAgcmV0dXJuIHogXiAoeCAmICh5IF4geikpXG59XG5cbmZ1bmN0aW9uIG1haiAoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSB8ICh6ICYgKHggfCB5KSlcbn1cblxuZnVuY3Rpb24gc2lnbWEwICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDI4IHwgeGwgPDwgNCkgXiAoeGwgPj4+IDIgfCB4IDw8IDMwKSBeICh4bCA+Pj4gNyB8IHggPDwgMjUpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMSAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxNCB8IHhsIDw8IDE4KSBeICh4ID4+PiAxOCB8IHhsIDw8IDE0KSBeICh4bCA+Pj4gOSB8IHggPDwgMjMpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxIHwgeGwgPDwgMzEpIF4gKHggPj4+IDggfCB4bCA8PCAyNCkgXiAoeCA+Pj4gNylcbn1cblxuZnVuY3Rpb24gR2FtbWEwbCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxIHwgeGwgPDwgMzEpIF4gKHggPj4+IDggfCB4bCA8PCAyNCkgXiAoeCA+Pj4gNyB8IHhsIDw8IDI1KVxufVxuXG5mdW5jdGlvbiBHYW1tYTEgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTkgfCB4bCA8PCAxMykgXiAoeGwgPj4+IDI5IHwgeCA8PCAzKSBeICh4ID4+PiA2KVxufVxuXG5mdW5jdGlvbiBHYW1tYTFsICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE5IHwgeGwgPDwgMTMpIF4gKHhsID4+PiAyOSB8IHggPDwgMykgXiAoeCA+Pj4gNiB8IHhsIDw8IDI2KVxufVxuXG5mdW5jdGlvbiBnZXRDYXJyeSAoYSwgYikge1xuICByZXR1cm4gKGEgPj4+IDApIDwgKGIgPj4+IDApID8gMSA6IDBcbn1cblxuU2hhNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGFoID0gdGhpcy5fYWggfCAwXG4gIHZhciBiaCA9IHRoaXMuX2JoIHwgMFxuICB2YXIgY2ggPSB0aGlzLl9jaCB8IDBcbiAgdmFyIGRoID0gdGhpcy5fZGggfCAwXG4gIHZhciBlaCA9IHRoaXMuX2VoIHwgMFxuICB2YXIgZmggPSB0aGlzLl9maCB8IDBcbiAgdmFyIGdoID0gdGhpcy5fZ2ggfCAwXG4gIHZhciBoaCA9IHRoaXMuX2hoIHwgMFxuXG4gIHZhciBhbCA9IHRoaXMuX2FsIHwgMFxuICB2YXIgYmwgPSB0aGlzLl9ibCB8IDBcbiAgdmFyIGNsID0gdGhpcy5fY2wgfCAwXG4gIHZhciBkbCA9IHRoaXMuX2RsIHwgMFxuICB2YXIgZWwgPSB0aGlzLl9lbCB8IDBcbiAgdmFyIGZsID0gdGhpcy5fZmwgfCAwXG4gIHZhciBnbCA9IHRoaXMuX2dsIHwgMFxuICB2YXIgaGwgPSB0aGlzLl9obCB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpICs9IDIpIHtcbiAgICBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgICBXW2kgKyAxXSA9IE0ucmVhZEludDMyQkUoaSAqIDQgKyA0KVxuICB9XG4gIGZvciAoOyBpIDwgMTYwOyBpICs9IDIpIHtcbiAgICB2YXIgeGggPSBXW2kgLSAxNSAqIDJdXG4gICAgdmFyIHhsID0gV1tpIC0gMTUgKiAyICsgMV1cbiAgICB2YXIgZ2FtbWEwID0gR2FtbWEwKHhoLCB4bClcbiAgICB2YXIgZ2FtbWEwbCA9IEdhbW1hMGwoeGwsIHhoKVxuXG4gICAgeGggPSBXW2kgLSAyICogMl1cbiAgICB4bCA9IFdbaSAtIDIgKiAyICsgMV1cbiAgICB2YXIgZ2FtbWExID0gR2FtbWExKHhoLCB4bClcbiAgICB2YXIgZ2FtbWExbCA9IEdhbW1hMWwoeGwsIHhoKVxuXG4gICAgLy8gV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdXG4gICAgdmFyIFdpN2ggPSBXW2kgLSA3ICogMl1cbiAgICB2YXIgV2k3bCA9IFdbaSAtIDcgKiAyICsgMV1cblxuICAgIHZhciBXaTE2aCA9IFdbaSAtIDE2ICogMl1cbiAgICB2YXIgV2kxNmwgPSBXW2kgLSAxNiAqIDIgKyAxXVxuXG4gICAgdmFyIFdpbCA9IChnYW1tYTBsICsgV2k3bCkgfCAwXG4gICAgdmFyIFdpaCA9IChnYW1tYTAgKyBXaTdoICsgZ2V0Q2FycnkoV2lsLCBnYW1tYTBsKSkgfCAwXG4gICAgV2lsID0gKFdpbCArIGdhbW1hMWwpIHwgMFxuICAgIFdpaCA9IChXaWggKyBnYW1tYTEgKyBnZXRDYXJyeShXaWwsIGdhbW1hMWwpKSB8IDBcbiAgICBXaWwgPSAoV2lsICsgV2kxNmwpIHwgMFxuICAgIFdpaCA9IChXaWggKyBXaTE2aCArIGdldENhcnJ5KFdpbCwgV2kxNmwpKSB8IDBcblxuICAgIFdbaV0gPSBXaWhcbiAgICBXW2kgKyAxXSA9IFdpbFxuICB9XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjA7IGogKz0gMikge1xuICAgIFdpaCA9IFdbal1cbiAgICBXaWwgPSBXW2ogKyAxXVxuXG4gICAgdmFyIG1hamggPSBtYWooYWgsIGJoLCBjaClcbiAgICB2YXIgbWFqbCA9IG1haihhbCwgYmwsIGNsKVxuXG4gICAgdmFyIHNpZ21hMGggPSBzaWdtYTAoYWgsIGFsKVxuICAgIHZhciBzaWdtYTBsID0gc2lnbWEwKGFsLCBhaClcbiAgICB2YXIgc2lnbWExaCA9IHNpZ21hMShlaCwgZWwpXG4gICAgdmFyIHNpZ21hMWwgPSBzaWdtYTEoZWwsIGVoKVxuXG4gICAgLy8gdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2pdICsgV1tqXVxuICAgIHZhciBLaWggPSBLW2pdXG4gICAgdmFyIEtpbCA9IEtbaiArIDFdXG5cbiAgICB2YXIgY2hoID0gQ2goZWgsIGZoLCBnaClcbiAgICB2YXIgY2hsID0gQ2goZWwsIGZsLCBnbClcblxuICAgIHZhciB0MWwgPSAoaGwgKyBzaWdtYTFsKSB8IDBcbiAgICB2YXIgdDFoID0gKGhoICsgc2lnbWExaCArIGdldENhcnJ5KHQxbCwgaGwpKSB8IDBcbiAgICB0MWwgPSAodDFsICsgY2hsKSB8IDBcbiAgICB0MWggPSAodDFoICsgY2hoICsgZ2V0Q2FycnkodDFsLCBjaGwpKSB8IDBcbiAgICB0MWwgPSAodDFsICsgS2lsKSB8IDBcbiAgICB0MWggPSAodDFoICsgS2loICsgZ2V0Q2FycnkodDFsLCBLaWwpKSB8IDBcbiAgICB0MWwgPSAodDFsICsgV2lsKSB8IDBcbiAgICB0MWggPSAodDFoICsgV2loICsgZ2V0Q2FycnkodDFsLCBXaWwpKSB8IDBcblxuICAgIC8vIHQyID0gc2lnbWEwICsgbWFqXG4gICAgdmFyIHQybCA9IChzaWdtYTBsICsgbWFqbCkgfCAwXG4gICAgdmFyIHQyaCA9IChzaWdtYTBoICsgbWFqaCArIGdldENhcnJ5KHQybCwgc2lnbWEwbCkpIHwgMFxuXG4gICAgaGggPSBnaFxuICAgIGhsID0gZ2xcbiAgICBnaCA9IGZoXG4gICAgZ2wgPSBmbFxuICAgIGZoID0gZWhcbiAgICBmbCA9IGVsXG4gICAgZWwgPSAoZGwgKyB0MWwpIHwgMFxuICAgIGVoID0gKGRoICsgdDFoICsgZ2V0Q2FycnkoZWwsIGRsKSkgfCAwXG4gICAgZGggPSBjaFxuICAgIGRsID0gY2xcbiAgICBjaCA9IGJoXG4gICAgY2wgPSBibFxuICAgIGJoID0gYWhcbiAgICBibCA9IGFsXG4gICAgYWwgPSAodDFsICsgdDJsKSB8IDBcbiAgICBhaCA9ICh0MWggKyB0MmggKyBnZXRDYXJyeShhbCwgdDFsKSkgfCAwXG4gIH1cblxuICB0aGlzLl9hbCA9ICh0aGlzLl9hbCArIGFsKSB8IDBcbiAgdGhpcy5fYmwgPSAodGhpcy5fYmwgKyBibCkgfCAwXG4gIHRoaXMuX2NsID0gKHRoaXMuX2NsICsgY2wpIHwgMFxuICB0aGlzLl9kbCA9ICh0aGlzLl9kbCArIGRsKSB8IDBcbiAgdGhpcy5fZWwgPSAodGhpcy5fZWwgKyBlbCkgfCAwXG4gIHRoaXMuX2ZsID0gKHRoaXMuX2ZsICsgZmwpIHwgMFxuICB0aGlzLl9nbCA9ICh0aGlzLl9nbCArIGdsKSB8IDBcbiAgdGhpcy5faGwgPSAodGhpcy5faGwgKyBobCkgfCAwXG5cbiAgdGhpcy5fYWggPSAodGhpcy5fYWggKyBhaCArIGdldENhcnJ5KHRoaXMuX2FsLCBhbCkpIHwgMFxuICB0aGlzLl9iaCA9ICh0aGlzLl9iaCArIGJoICsgZ2V0Q2FycnkodGhpcy5fYmwsIGJsKSkgfCAwXG4gIHRoaXMuX2NoID0gKHRoaXMuX2NoICsgY2ggKyBnZXRDYXJyeSh0aGlzLl9jbCwgY2wpKSB8IDBcbiAgdGhpcy5fZGggPSAodGhpcy5fZGggKyBkaCArIGdldENhcnJ5KHRoaXMuX2RsLCBkbCkpIHwgMFxuICB0aGlzLl9laCA9ICh0aGlzLl9laCArIGVoICsgZ2V0Q2FycnkodGhpcy5fZWwsIGVsKSkgfCAwXG4gIHRoaXMuX2ZoID0gKHRoaXMuX2ZoICsgZmggKyBnZXRDYXJyeSh0aGlzLl9mbCwgZmwpKSB8IDBcbiAgdGhpcy5fZ2ggPSAodGhpcy5fZ2ggKyBnaCArIGdldENhcnJ5KHRoaXMuX2dsLCBnbCkpIHwgMFxuICB0aGlzLl9oaCA9ICh0aGlzLl9oaCArIGhoICsgZ2V0Q2FycnkodGhpcy5faGwsIGhsKSkgfCAwXG59XG5cblNoYTUxMi5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcig2NClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2FoLCB0aGlzLl9hbCwgMClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2JoLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2NoLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kaCwgdGhpcy5fZGwsIDI0KVxuICB3cml0ZUludDY0QkUodGhpcy5fZWgsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2ZoLCB0aGlzLl9mbCwgNDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9naCwgdGhpcy5fZ2wsIDQ4KVxuICB3cml0ZUludDY0QkUodGhpcy5faGgsIHRoaXMuX2hsLCA1NilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTUxMlxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhNTEyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3NoYS5qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgV3NScGMgPSByZXF1aXJlKFwiLi9XZWJTb2NrZXRScGNcIik7XG52YXIgU3RlZW1BcGkgPSByZXF1aXJlKFwiLi9TdGVlbUFwaVwiKTtcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHVybDogXCJ3c3M6Ly9ub2RlLnN0ZWVtLndzXCIsXG4gICAgdXNlcjogXCJcIixcbiAgICBwYXNzOiBcIlwiLFxuICAgIGRlYnVnOiBmYWxzZSxcbiAgICBhcGlzOiBbXCJkYXRhYmFzZV9hcGlcIiwgXCJuZXR3b3JrX2Jyb2FkY2FzdF9hcGlcIiwgXCJmb2xsb3dfYXBpXCIsIFwibWFya2V0X2hpc3RvcnlfYXBpXCIsIFwibG9naW5fYXBpXCIsIFwicHJpdmF0ZV9tZXNzYWdlX2FwaVwiXVxufTtcblxudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIGFwaUluc3RhbmNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICBpZiAoYXBpSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBhcGlJbnN0YW5jZSA9IG5ldyBBcGlJbnN0YW5jZShvcHRpb25zKTtcbiAgICAgICAgYXBpSW5zdGFuY2UuY29ubmVjdCgpO1xuXG4gICAgICAgIHJldHVybiBhcGlJbnN0YW5jZTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBjb25uZWN0ID0gYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIGlmICghYXBpSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGFwaUluc3RhbmNlID0gbmV3IEFwaUluc3RhbmNlKG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbm5lY3QpIHtcbiAgICAgICAgICAgIGFwaUluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICBhcGlJbnN0YW5jZS5jb25uZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXBpSW5zdGFuY2U7XG4gICAgfSxcblxuXG4gICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICBhcGlJbnN0YW5jZS5jbG9zZSgpO2FwaUluc3RhbmNlID0gbnVsbDtcbiAgICB9XG59O1xuXG52YXIgQXBpSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXBpSW5zdGFuY2Uob3B0aW9ucykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXBpSW5zdGFuY2UpO1xuXG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zdGF0dXNDYWxsYmFjayA9IG9wdGlvbnMuc3RhdHVzQ2FsbGJhY2s7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEFwaUluc3RhbmNlLCBbe1xuICAgICAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvYmplY3RBc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTsvL09iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXBpcy5pbmRleE9mKFwiZGF0YWJhc2VfYXBpXCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hcGlzLnVuc2hpZnQoXCJkYXRhYmFzZV9hcGlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJjb25uZWN0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMud3NScGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy53c1JwYyA9IG5ldyBXc1JwYyh0aGlzLm9wdGlvbnMsIHRoaXMub25SZWNvbm5lY3QuYmluZCh0aGlzKSwgdGhpcy5vblN0YXR1c0NoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2dpbigpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIndzUnBjIG9wZW4gZXJyb3I6XCIsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJsb2dpblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbG9naW4oKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZSA9IHRoaXMud3NScGMubG9naW4odGhpcy5vcHRpb25zLnVzZXIsIHRoaXMub3B0aW9ucy5wYXNzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBpUHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIF90aGlzLm9wdGlvbnMuYXBpcy5mb3JFYWNoKGZ1bmN0aW9uIChhcGkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNbXCJfXCIgKyBhcGldID0gbmV3IFN0ZWVtQXBpKF90aGlzLndzUnBjLCBhcGkpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpc1thcGldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCJfXCIgKyBhcGldO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBhcGlQcm9taXNlcy5wdXNoKF90aGlzW1wiX1wiICsgYXBpXS5pbml0KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXBpID09PSBcImRhdGFiYXNlX2FwaVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzW2FwaV0oKS5leGVjKFwiZ2V0X2NvbmZpZ1wiLCBbXSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNoYWluSWQgPSByZXMuU1RFRU1JVF9DSEFJTl9JRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29ubmVjdGVkIHRvIFwiICsgYXBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb25uZWN0ZWQgdG8gXCIgKyBhcGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYXBpUHJvbWlzZXMpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gY29ubmVjdCB0b1wiLCB0aGlzLm9wdGlvbnMudXJsKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY29ubmVjdCB0byBcIiArIF90aGlzLm9wdGlvbnMudXJsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwib25SZWNvbm5lY3RcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVjb25uZWN0KCkge1xuICAgICAgICAgICAgdGhpcy5sb2dpbigpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwib25TdGF0dXNDaGFuZ2VcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3RhdHVzQ2hhbmdlKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1c0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNDYWxsYmFjayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImNsb3NlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndzUnBjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53c1JwYy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMud3NScGMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFwaUluc3RhbmNlO1xufSgpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW0tcnBjL2xpYi9BcGlJbnN0YW5jZS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbS1ycGMvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBTdGVlbUFwaSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gU3RlZW1BcGkod3NScGMsIGFwaU5hbWUpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RlZW1BcGkpO1xuXG5cdFx0dGhpcy53c1JwYyA9IHdzUnBjO1xuXHRcdHRoaXMuYXBpTmFtZSA9IGFwaU5hbWU7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoU3RlZW1BcGksIFt7XG5cdFx0a2V5OiBcImluaXRcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcblx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHRcdHJldHVybiB0aGlzLndzUnBjLmdldEFwaUJ5TmFtZSh0aGlzLmFwaU5hbWUpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdFx0XHRcdF90aGlzLmFwaUlkID0gcmVzcG9uc2U7XG5cdFx0XHRcdHJldHVybiBfdGhpcztcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogXCJleGVjXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGV4ZWMobWV0aG9kLCBwYXJhbXMpIHtcblx0XHRcdHJldHVybiB0aGlzLndzUnBjLmNhbGwoW3RoaXMuYXBpSWQsIG1ldGhvZCwgcGFyYW1zXSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJTdGVlbUFwaSBlcnJvcjpcIiwgbWV0aG9kLCBwYXJhbXMsIEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG5cdFx0XHRcdHZhciBuZXdFcnIgPSBuZXcgRXJyb3IoXCJTdGVlbUFwaSBlcnJvcjpcIiArIG1ldGhvZCArIHBhcmFtcyArIEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG5cdFx0XHRcdG5ld0Vyci5vcmlnaW5hbCA9IGVycm9yO1xuXHRcdFx0XHRsb2NhbFN0b3JhZ2UuZXJyb3IgPSAxO1xuXHRcdFx0XHRsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlID0gZXJyb3IubWVzc2FnZT9lcnJvci5tZXNzYWdlLnNwbGl0KFwiXFxuXCIpWzFdOidDb25uZWN0aW9uIGxvc3QsIHJlY29ubmVjdGluZy4uLic7XG5cdFx0XHRcdHRocm93IG5ld0Vycjtcblx0XHRcdH0pO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBTdGVlbUFwaTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGVlbUFwaTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWIvU3RlZW1BcGkuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW0tcnBjL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUldlYlNvY2tldCA9IHJlcXVpcmUoXCIuL3JlY29ubmVjdGluZy13ZWJzb2NrZXRcIik7XG5cbnZhciBXZWJTb2NrZXRScGMgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIFdlYlNvY2tldFJwYyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdHZhciByY0NhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtcblx0XHR2YXIgc3RhdHVzQ2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzJdO1xuXG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYlNvY2tldFJwYyk7XG5cblx0XHR0aGlzLnJjQ2FsbGJhY2sgPSByY0NhbGxiYWNrO1xuXHRcdHRoaXMuc3RhdHVzQ2FsbGJhY2sgPSBzdGF0dXNDYWxsYmFjaztcblxuXHRcdGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRvcHRpb25zLldlYlNvY2tldCA9IFdlYlNvY2tldDtcblx0XHRcdG9wdGlvbnMuaWRsZVRyZXNob2xkID0gXCJpZGxlVHJlc2hvbGRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5pZGxlVHJlc2hvbGQgOiA2MDAwMDsgLy8gT25seSB1c2UgaWRsZSB0aHJlc2hvbGQgaW4gYnJvd3NlcnNcblx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb25zLldlYlNvY2tldCA9IHJlcXVpcmUoXCJ3c1wiKTtcblx0XHRcdFx0b3B0aW9ucy5pZGxlVHJlc2hvbGQgPSAwOyAvLyBBbHdheXMgcmVjb25uZWN0IGluIG5vZGUuanNcblx0XHRcdH1cblx0XHRvcHRpb25zLnJlY29ubmVjdEludGVydmFsID0gMTAwMDtcblx0XHRvcHRpb25zLnJlY29ubmVjdERlY2F5ID0gMS4yO1xuXG5cdFx0dGhpcy53cyA9IG5ldyBSV2ViU29ja2V0KG9wdGlvbnMpO1xuXHRcdHRoaXMud3MudGltZW91dEludGVydmFsID0gMTUwMDA7XG5cblx0XHR2YXIgaW5pdGlhbENvbm5lY3QgPSB0cnVlO1xuXG5cdFx0dGhpcy5jb25uZWN0UHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuXHRcdFx0X3RoaXMud3Mub25vcGVuID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoX3RoaXMuc3RhdHVzQ2FsbGJhY2spIF90aGlzLnN0YXR1c0NhbGxiYWNrKFwib3BlblwiKTtcblx0XHRcdFx0aWYgKGluaXRpYWxDb25uZWN0KSB7XG5cdFx0XHRcdFx0aW5pdGlhbENvbm5lY3QgPSBmYWxzZTtcblx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKF90aGlzLnJjQ2FsbGJhY2spIF90aGlzLnJjQ2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0X3RoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0aWYgKF90aGlzLnN0YXR1c0NhbGxiYWNrKSBfdGhpcy5zdGF0dXNDYWxsYmFjayhcImVycm9yXCIpO1xuXHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdH07XG5cblx0XHRcdF90aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cdFx0XHRcdHZhciBkYXRhID0ge307XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZGF0YSA9IEpTT04ucGFyc2UobWVzc2FnZS5kYXRhKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiVW5hYmxlIHRvIHBhcnNlIEFQSSByZXNwb25zZTpcIiwgZSk7XG5cdFx0XHRcdFx0ZGF0YS5lcnJvciA9IFwiVW5hYmxlIHRvIHBhcnNlIHJlc3BvbnNlIFwiICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3RoaXMubGlzdGVuZXIoZGF0YSk7XG5cdFx0XHR9O1xuXG5cdFx0XHRfdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyB3ZWIgc29ja2V0IG1heSByZS1jb25uZWN0XG5cdFx0XHRcdF90aGlzLmNicy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRcdHZhbHVlLnJlamVjdCgnY29ubmVjdGlvbiBjbG9zZWQnKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0X3RoaXMubWV0aG9kQ2JzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdFx0dmFsdWUucmVqZWN0KCdjb25uZWN0aW9uIGNsb3NlZCcpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRfdGhpcy5jYnMuY2xlYXIoKTtcblx0XHRcdFx0X3RoaXMubWV0aG9kQ2JzLmNsZWFyKCk7XG5cdFx0XHRcdF90aGlzLmNiSWQgPSAwO1xuXG5cdFx0XHRcdGlmIChfdGhpcy5zdGF0dXNDYWxsYmFjaykgX3RoaXMuc3RhdHVzQ2FsbGJhY2soXCJjbG9zZWRcIik7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5jYklkID0gMDtcblx0XHR0aGlzLmNicyA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLm1ldGhvZENicyA9IG5ldyBNYXAoKTtcblxuXHRcdGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR3aW5kb3cub25iZWZvcmV1bmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF90aGlzLmNsb3NlKCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhXZWJTb2NrZXRScGMsIFt7XG5cdFx0a2V5OiBcImxpc3RlbmVyXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGxpc3RlbmVyKG1lc3NhZ2UpIHtcblx0XHRcdHZhciBjYWxsYmFjayA9IHRoaXMuY2JzLmdldChtZXNzYWdlLmlkKTtcblx0XHRcdHZhciBtZXRob2RDYWxsYmFjayA9IHRoaXMubWV0aG9kQ2JzLmdldChtZXNzYWdlLmlkKTtcblxuXHRcdFx0aWYgKG1ldGhvZENhbGxiYWNrKSB7XG5cdFx0XHRcdHRoaXMubWV0aG9kQ2JzLmRlbGV0ZShtZXNzYWdlLmlkKTtcblx0XHRcdFx0aWYgKFwiZXJyb3JcIiBpbiBtZXNzYWdlICYmIFwicmVqZWN0XCIgaW4gbWV0aG9kQ2FsbGJhY2spIHtcblx0XHRcdFx0XHRtZXRob2RDYWxsYmFjay5yZWplY3QobWVzc2FnZS5lcnJvcik7XG5cdFx0XHRcdH0gZWxzZSBpZiAoXCJyZXNvbHZlXCIgaW4gbWV0aG9kQ2FsbGJhY2spIHtcblx0XHRcdFx0XHRtZXRob2RDYWxsYmFjay5yZXNvbHZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdHRoaXMuY2JzLmRlbGV0ZShtZXNzYWdlLmlkKTtcblx0XHRcdFx0aWYgKFwiZXJyb3JcIiBpbiBtZXNzYWdlKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sucmVqZWN0KG1lc3NhZ2UuZXJyb3IpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNhbGxiYWNrLnJlc29sdmUobWVzc2FnZS5yZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiBcImNhbGxcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gY2FsbChwYXJhbXMpIHtcblx0XHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdFx0XHR2YXIgcmVxdWVzdCA9IHtcblx0XHRcdFx0bWV0aG9kOiBcImNhbGxcIixcblx0XHRcdFx0cGFyYW1zOiBwYXJhbXMsXG5cdFx0XHRcdGlkOiB0aGlzLmNiSWQrK1xuXHRcdFx0fTtcblxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuXHRcdFx0XHRfdGhpczIuY2JzLnNldChyZXF1ZXN0LmlkLCB7XG5cdFx0XHRcdFx0dGltZTogbmV3IERhdGUoKSxcblx0XHRcdFx0XHRyZXNvbHZlOiByZXNvbHZlLFxuXHRcdFx0XHRcdHJlamVjdDogcmVqZWN0XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChyZXF1ZXN0LnBhcmFtc1sxXSA9PT0gXCJicm9hZGNhc3RfdHJhbnNhY3Rpb25fd2l0aF9jYWxsYmFja1wiICYmIHJlcXVlc3QucGFyYW1zWzJdWzBdKSB7XG5cdFx0XHRcdFx0X3RoaXMyLm1ldGhvZENicy5zZXQocmVxdWVzdC5pZCwgcmVxdWVzdC5wYXJhbXNbMl1bMF0pO1xuXHRcdFx0XHRcdHJlcXVlc3QucGFyYW1zWzJdWzBdID0gcmVxdWVzdC5wYXJhbXNbMl1bMF0ucmVzb2x2ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF90aGlzMi53cy5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRfdGhpczIud3Muc2VuZChKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6IFwiZ2V0QXBpQnlOYW1lXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldEFwaUJ5TmFtZShhcGkpIHtcblx0XHRcdHJldHVybiB0aGlzLmNhbGwoWzEsIFwiZ2V0X2FwaV9ieV9uYW1lXCIsIFthcGldXSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiBcImxvZ2luXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGxvZ2luKHVzZXIsIHBhc3N3b3JkKSB7XG5cdFx0XHR2YXIgX3RoaXMzID0gdGhpcztcblxuXHRcdFx0cmV0dXJuIHRoaXMuY29ubmVjdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBfdGhpczMuY2FsbChbMSwgXCJsb2dpblwiLCBbdXNlciwgcGFzc3dvcmRdXSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6IFwiY2xvc2VcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG5cdFx0XHRpZiAodGhpcy53cykge1xuXHRcdFx0XHR0aGlzLndzLm9uY2xvc2UoKTtcblx0XHRcdFx0dGhpcy53cy5jbG9zZSgpO1xuXHRcdFx0XHR0aGlzLndzID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gV2ViU29ja2V0UnBjO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFJwYztcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWIvV2ViU29ja2V0UnBjLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIENsaWVudCA9IHJlcXVpcmUoXCIuL0FwaUluc3RhbmNlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Q2xpZW50OiBDbGllbnRcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbS1ycGMvbGliL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIE1JVCBMaWNlbnNlOlxuLy9cbi8vIENvcHlyaWdodCAoYykgMjAxMC0yMDEyLCBKb2UgV2FsbmVzXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyoqXG4gKiBUaGlzIGJlaGF2ZXMgbGlrZSBhIFdlYlNvY2tldCBpbiBldmVyeSB3YXksIGV4Y2VwdCBpZiBpdCBmYWlscyB0byBjb25uZWN0LFxuICogb3IgaXQgZ2V0cyBkaXNjb25uZWN0ZWQsIGl0IHdpbGwgcmVwZWF0ZWRseSBwb2xsIHVudGlsIGl0IHN1Y2Nlc3NmdWxseSBjb25uZWN0c1xuICogYWdhaW4uXG4gKlxuICogSXQgaXMgQVBJIGNvbXBhdGlibGUsIHNvIHdoZW4geW91IGhhdmU6XG4gKiAgIHdzID0gbmV3IFdlYlNvY2tldCgnd3M6Ly8uLi4uJyk7XG4gKiB5b3UgY2FuIHJlcGxhY2Ugd2l0aDpcbiAqICAgd3MgPSBuZXcgUmVjb25uZWN0aW5nV2ViU29ja2V0KCd3czovLy4uLi4nKTtcbiAqXG4gKiBUaGUgZXZlbnQgc3RyZWFtIHdpbGwgdHlwaWNhbGx5IGxvb2sgbGlrZTpcbiAqICBvbmNvbm5lY3RpbmdcbiAqICBvbm9wZW5cbiAqICBvbm1lc3NhZ2VcbiAqICBvbm1lc3NhZ2VcbiAqICBvbmNsb3NlIC8vIGxvc3QgY29ubmVjdGlvblxuICogIG9uY29ubmVjdGluZ1xuICogIG9ub3BlbiAgLy8gc29tZXRpbWUgbGF0ZXIuLi5cbiAqICBvbm1lc3NhZ2VcbiAqICBvbm1lc3NhZ2VcbiAqICBldGMuLi5cbiAqXG4gKiBJdCBpcyBBUEkgY29tcGF0aWJsZSB3aXRoIHRoZSBzdGFuZGFyZCBXZWJTb2NrZXQgQVBJLCBhcGFydCBmcm9tIHRoZSBmb2xsb3dpbmcgbWVtYmVyczpcbiAqXG4gKiAtIGBidWZmZXJlZEFtb3VudGBcbiAqIC0gYGV4dGVuc2lvbnNgXG4gKiAtIGBiaW5hcnlUeXBlYFxuICpcbiAqIExhdGVzdCB2ZXJzaW9uOiBodHRwczovL2dpdGh1Yi5jb20vam9ld2FsbmVzL3JlY29ubmVjdGluZy13ZWJzb2NrZXQvXG4gKiAtIEpvZSBXYWxuZXNcbiAqXG4gKiBTeW50YXhcbiAqID09PT09PVxuICogdmFyIHNvY2tldCA9IG5ldyBSZWNvbm5lY3RpbmdXZWJTb2NrZXQodXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICpcbiAqIFBhcmFtZXRlcnNcbiAqID09PT09PT09PT1cbiAqIHVybCAtIFRoZSB1cmwgeW91IGFyZSBjb25uZWN0aW5nIHRvLlxuICogcHJvdG9jb2xzIC0gT3B0aW9uYWwgc3RyaW5nIG9yIGFycmF5IG9mIHByb3RvY29scy5cbiAqIG9wdGlvbnMgLSBTZWUgYmVsb3dcbiAqXG4gKiBPcHRpb25zXG4gKiA9PT09PT09XG4gKiBPcHRpb25zIGNhbiBlaXRoZXIgYmUgcGFzc2VkIHVwb24gaW5zdGFudGlhdGlvbiBvciBzZXQgYWZ0ZXIgaW5zdGFudGlhdGlvbjpcbiAqXG4gKiB2YXIgc29ja2V0ID0gbmV3IFJlY29ubmVjdGluZ1dlYlNvY2tldCh1cmwsIG51bGwsIHsgZGVidWc6IHRydWUsIHJlY29ubmVjdEludGVydmFsOiA0MDAwIH0pO1xuICpcbiAqIG9yXG4gKlxuICogdmFyIHNvY2tldCA9IG5ldyBSZWNvbm5lY3RpbmdXZWJTb2NrZXQodXJsKTtcbiAqIHNvY2tldC5kZWJ1ZyA9IHRydWU7XG4gKiBzb2NrZXQucmVjb25uZWN0SW50ZXJ2YWwgPSA0MDAwO1xuICpcbiAqIGRlYnVnXG4gKiAtIFdoZXRoZXIgdGhpcyBpbnN0YW5jZSBzaG91bGQgbG9nIGRlYnVnIG1lc3NhZ2VzLiBBY2NlcHRzIHRydWUgb3IgZmFsc2UuIERlZmF1bHQ6IGZhbHNlLlxuICpcbiAqIGF1dG9tYXRpY09wZW5cbiAqIC0gV2hldGhlciBvciBub3QgdGhlIHdlYnNvY2tldCBzaG91bGQgYXR0ZW1wdCB0byBjb25uZWN0IGltbWVkaWF0ZWx5IHVwb24gaW5zdGFudGlhdGlvbi4gVGhlIHNvY2tldCBjYW4gYmUgbWFudWFsbHkgb3BlbmVkIG9yIGNsb3NlZCBhdCBhbnkgdGltZSB1c2luZyB3cy5vcGVuKCkgYW5kIHdzLmNsb3NlKCkuXG4gKlxuICogcmVjb25uZWN0SW50ZXJ2YWxcbiAqIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgYmVmb3JlIGF0dGVtcHRpbmcgdG8gcmVjb25uZWN0LiBBY2NlcHRzIGludGVnZXIuIERlZmF1bHQ6IDEwMDAuXG4gKlxuICogbWF4UmVjb25uZWN0SW50ZXJ2YWxcbiAqIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBhIHJlY29ubmVjdGlvbiBhdHRlbXB0LiBBY2NlcHRzIGludGVnZXIuIERlZmF1bHQ6IDMwMDAwLlxuICpcbiAqIHJlY29ubmVjdERlY2F5XG4gKiAtIFRoZSByYXRlIG9mIGluY3JlYXNlIG9mIHRoZSByZWNvbm5lY3QgZGVsYXkuIEFsbG93cyByZWNvbm5lY3QgYXR0ZW1wdHMgdG8gYmFjayBvZmYgd2hlbiBwcm9ibGVtcyBwZXJzaXN0LiBBY2NlcHRzIGludGVnZXIgb3IgZmxvYXQuIERlZmF1bHQ6IDEuNS5cbiAqXG4gKiB0aW1lb3V0SW50ZXJ2YWxcbiAqIC0gVGhlIG1heGltdW0gdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgYSBjb25uZWN0aW9uIHRvIHN1Y2NlZWQgYmVmb3JlIGNsb3NpbmcgYW5kIHJldHJ5aW5nLiBBY2NlcHRzIGludGVnZXIuIERlZmF1bHQ6IDIwMDAuXG4gKlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbC5SZWNvbm5lY3RpbmdXZWJTb2NrZXQgPSBmYWN0b3J5KCk7XG4gICAgfVxufSkodW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAvL2lmICghKCdXZWJTb2NrZXQnIGluIHdpbmRvdykpIHtcbiAgICAvLyAgICByZXR1cm47XG4gICAgLy99XG5cbiAgICB2YXIgV2ViU29ja2V0O1xuXG4gICAgZnVuY3Rpb24gUmVjb25uZWN0aW5nV2ViU29ja2V0KG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBEZWZhdWx0IHNldHRpbmdzXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHtcblxuICAgICAgICAgICAgLyoqIFdoZXRoZXIgdGhpcyBpbnN0YW5jZSBzaG91bGQgbG9nIGRlYnVnIG1lc3NhZ2VzLiAqL1xuICAgICAgICAgICAgZGVidWc6IGZhbHNlLFxuXG4gICAgICAgICAgICAvKiogV2hldGhlciBvciBub3QgdGhlIHdlYnNvY2tldCBzaG91bGQgYXR0ZW1wdCB0byBjb25uZWN0IGltbWVkaWF0ZWx5IHVwb24gaW5zdGFudGlhdGlvbi4gKi9cbiAgICAgICAgICAgIGF1dG9tYXRpY09wZW46IHRydWUsXG5cbiAgICAgICAgICAgIC8qKiBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBiZWZvcmUgYXR0ZW1wdGluZyB0byByZWNvbm5lY3QuICovXG4gICAgICAgICAgICByZWNvbm5lY3RJbnRlcnZhbDogMjAwMCxcbiAgICAgICAgICAgIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGEgcmVjb25uZWN0aW9uIGF0dGVtcHQuICovXG4gICAgICAgICAgICBtYXhSZWNvbm5lY3RJbnRlcnZhbDogMzAwMDAwLFxuICAgICAgICAgICAgLyoqIFRoZSByYXRlIG9mIGluY3JlYXNlIG9mIHRoZSByZWNvbm5lY3QgZGVsYXkuIEFsbG93cyByZWNvbm5lY3QgYXR0ZW1wdHMgdG8gYmFjayBvZmYgd2hlbiBwcm9ibGVtcyBwZXJzaXN0LiAqL1xuICAgICAgICAgICAgcmVjb25uZWN0RGVjYXk6IDEuNSxcblxuICAgICAgICAgICAgLyoqIFRoZSBtYXhpbXVtIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIGEgY29ubmVjdGlvbiB0byBzdWNjZWVkIGJlZm9yZSBjbG9zaW5nIGFuZCByZXRyeWluZy4gKi9cbiAgICAgICAgICAgIHRpbWVvdXRJbnRlcnZhbDogMjAwMCxcblxuICAgICAgICAgICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgdG8gbWFrZS4gVW5saW1pdGVkIGlmIG51bGwuICovXG4gICAgICAgICAgICBtYXhSZWNvbm5lY3RBdHRlbXB0czogMTAwLFxuXG4gICAgICAgICAgICAvKiogVGhlIGJpbmFyeSB0eXBlLCBwb3NzaWJsZSB2YWx1ZXMgJ2Jsb2InIG9yICdhcnJheWJ1ZmZlcicsIGRlZmF1bHQgJ2Jsb2InLiAqL1xuICAgICAgICAgICAgYmluYXJ5VHlwZTogJ2FycmF5YnVmZmVyJyxcblxuICAgICAgICAgICAgLyoqIERvbid0IHJlY29ubmVjdCBpZiBpZGxlIChubyB1c2VyIGFjdGl2aXR5IGFmdGVyIGlkbGVUcmVzaG9sZCksIHBhc3MgMCB0byBhbHdheXMgcmVjb25uZWN0ICoqL1xuICAgICAgICAgICAgaWRsZVRyZXNob2xkOiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgV2ViU29ja2V0ID0gb3B0aW9ucy5XZWJTb2NrZXQ7XG4gICAgICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5DT05ORUNUSU5HID0gV2ViU29ja2V0LkNPTk5FQ1RJTkc7XG4gICAgICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5PUEVOID0gV2ViU29ja2V0Lk9QRU47XG4gICAgICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5DTE9TSU5HID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5DTE9TRUQgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgICAgICBpZiAoIWNvbnNvbGUuZGVidWcpIGNvbnNvbGUuZGVidWcgPSBjb25zb2xlLmxvZztcblxuICAgICAgICAvLyBPdmVyd3JpdGUgYW5kIGRlZmluZSBzZXR0aW5ncyB3aXRoIG9wdGlvbnMgaWYgdGhleSBleGlzdC5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHNldHRpbmdzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVzZSBzaG91bGQgYmUgdHJlYXRlZCBhcyByZWFkLW9ubHkgcHJvcGVydGllc1xuXG4gICAgICAgIC8qKiBUaGUgVVJMIGFzIHJlc29sdmVkIGJ5IHRoZSBjb25zdHJ1Y3Rvci4gVGhpcyBpcyBhbHdheXMgYW4gYWJzb2x1dGUgVVJMLiBSZWFkIG9ubHkuICovXG4gICAgICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmw7XG5cbiAgICAgICAgLyoqIFRoZSBudW1iZXIgb2YgYXR0ZW1wdGVkIHJlY29ubmVjdHMgc2luY2Ugc3RhcnRpbmcsIG9yIHRoZSBsYXN0IHN1Y2Nlc3NmdWwgY29ubmVjdGlvbi4gUmVhZCBvbmx5LiAqL1xuICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgICAqIENhbiBiZSBvbmUgb2Y6IFdlYlNvY2tldC5DT05ORUNUSU5HLCBXZWJTb2NrZXQuT1BFTiwgV2ViU29ja2V0LkNMT1NJTkcsIFdlYlNvY2tldC5DTE9TRURcbiAgICAgICAgICogUmVhZCBvbmx5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNPTk5FQ1RJTkc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc3RyaW5nIGluZGljYXRpbmcgdGhlIG5hbWUgb2YgdGhlIHN1Yi1wcm90b2NvbCB0aGUgc2VydmVyIHNlbGVjdGVkOyB0aGlzIHdpbGwgYmUgb25lIG9mXG4gICAgICAgICAqIHRoZSBzdHJpbmdzIHNwZWNpZmllZCBpbiB0aGUgcHJvdG9jb2xzIHBhcmFtZXRlciB3aGVuIGNyZWF0aW5nIHRoZSBXZWJTb2NrZXQgb2JqZWN0LlxuICAgICAgICAgKiBSZWFkIG9ubHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3RvY29sID0gbnVsbDtcblxuICAgICAgICAvLyBQcml2YXRlIHN0YXRlIHZhcmlhYmxlc1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHdzO1xuICAgICAgICB2YXIgZm9yY2VkQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRpbWVkT3V0ID0gZmFsc2U7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IHt9O1xuICAgICAgICB2YXIgZXZlbnRUYXJnZXQgPSB7XG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdID0gaGFuZGxlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tldmVudC5uYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcikgaGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07IC8vZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgLy8gV2lyZSB1cCBcIm9uKlwiIHByb3BlcnRpZXMgYXMgZXZlbnQgaGFuZGxlcnNcblxuICAgICAgICBldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLm9ub3BlbihldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgc2VsZi5vbmNsb3NlKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3RpbmcnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGYub25jb25uZWN0aW5nKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGYub25tZXNzYWdlKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLm9uZXJyb3IoZXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBFeHBvc2UgdGhlIEFQSSByZXF1aXJlZCBieSBFdmVudFRhcmdldFxuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIuYmluZChldmVudFRhcmdldCk7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIuYmluZChldmVudFRhcmdldCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCA9IGV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQuYmluZChldmVudFRhcmdldCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIGFuIGV2ZW50IHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIHN0YW5kYXJkXG4gICAgICAgICAqIGNvbXBsaWFudCBicm93c2VycyBhbmQgSUU5IC0gSUUxMVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHdpbGwgcHJldmVudCB0aGUgZXJyb3I6XG4gICAgICAgICAqIE9iamVjdCBkb2Vzbid0IHN1cHBvcnQgdGhpcyBhY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTM0NTM5Mi93aHktYXJlbnQtbXktcGFyYW1ldGVycy1nZXR0aW5nLXBhc3NlZC10aHJvdWdoLXRvLWEtZGlzcGF0Y2hlZC1ldmVudC8xOTM0NTU2MyMxOTM0NTU2M1xuICAgICAgICAgKiBAcGFyYW0gcyBTdHJpbmcgVGhlIG5hbWUgdGhhdCB0aGUgZXZlbnQgc2hvdWxkIHVzZVxuICAgICAgICAgKiBAcGFyYW0gYXJncyBPYmplY3QgYW4gb3B0aW9uYWwgb2JqZWN0IHRoYXQgdGhlIGV2ZW50IHdpbGwgdXNlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZUV2ZW50KHMsIGFyZ3MpIHtcbiAgICAgICAgICAgIC8vdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICAvL2V2dC5pbml0Q3VzdG9tRXZlbnQocywgZmFsc2UsIGZhbHNlLCBhcmdzKTtcbiAgICAgICAgICAgIC8vcmV0dXJuIGV2dDtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IHMgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLnBlbmRpbmdSZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5pZGxlU2luY2UgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlkbGVUcmVzaG9sZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5vbmtleXByZXNzID0gZG9jdW1lbnQub25tb3VzZW1vdmUgPSBkb2N1bWVudC5vbmNsaWNrID0gZG9jdW1lbnQub25zY3JvbGwgPSBkb2N1bWVudC50b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmlkbGVTaW5jZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnBlbmRpbmdSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGVuZGluZ1JlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gc2VsZi5yZWNvbm5lY3RJbnRlcnZhbCAqIE1hdGgucG93KHNlbGYucmVjb25uZWN0RGVjYXksIHNlbGYucmVjb25uZWN0QXR0ZW1wdHMpO1xuICAgICAgICAgICAgdGltZW91dCA9IHRpbWVvdXQgPiBzZWxmLm1heFJlY29ubmVjdEludGVydmFsID8gc2VsZi5tYXhSZWNvbm5lY3RJbnRlcnZhbCA6IHRpbWVvdXQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1dlYlNvY2tldDogd2lsbCB0cnkgdG8gcmVjb25uZWN0IGluICcgKyBwYXJzZUludCh0aW1lb3V0IC8gMTAwMCkgKyAnIHNlYywgYXR0ZW1wdCAjJyArIChzZWxmLnJlY29ubmVjdEF0dGVtcHRzICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZWNvbm5lY3RBdHRlbXB0cysrO1xuICAgICAgICAgICAgICAgIHNlbGYub3Blbih0cnVlKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMub3BlbiA9IGZ1bmN0aW9uIChyZWNvbm5lY3RBdHRlbXB0KSB7XG4gICAgICAgICAgICBpZiAocmVjb25uZWN0QXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heFJlY29ubmVjdEF0dGVtcHRzICYmIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPiB0aGlzLm1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VuZXJhdGVFdmVudCgnY29ubmVjdGluZycpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1cmwgPSBzZWxmLnVybDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGYudXJsKSkge1xuICAgICAgICAgICAgICAgIHN1cmwgPSBzZWxmLnVybFt0aGlzLnJlY29ubmVjdEF0dGVtcHRzICUgc2VsZi51cmwubGVuZ3RoXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdjb25uZWN0aW5nIHRvJywgc3VybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cyA9IG5ldyBXZWJTb2NrZXQoc3VybCk7XG4gICAgICAgICAgICB3cy5iaW5hcnlUeXBlID0gdGhpcy5iaW5hcnlUeXBlO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5kZWJ1ZyB8fCBSZWNvbm5lY3RpbmdXZWJTb2NrZXQuZGVidWdBbGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdSZWNvbm5lY3RpbmdXZWJTb2NrZXQnLCAnYXR0ZW1wdC1jb25uZWN0Jywgc2VsZi51cmwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbG9jYWxXcyA9IHdzO1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kZWJ1ZyB8fCBSZWNvbm5lY3RpbmdXZWJTb2NrZXQuZGVidWdBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnUmVjb25uZWN0aW5nV2ViU29ja2V0JywgJ2Nvbm5lY3Rpb24tdGltZW91dCcsIHNlbGYudXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxvY2FsV3MuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0aW1lZE91dCA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgc2VsZi50aW1lb3V0SW50ZXJ2YWwpO1xuXG4gICAgICAgICAgICB3cy5vbm9wZW4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZGVidWcgfHwgUmVjb25uZWN0aW5nV2ViU29ja2V0LmRlYnVnQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1JlY29ubmVjdGluZ1dlYlNvY2tldCoqJywgJ29ub3BlbicsIHNlbGYudXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5wcm90b2NvbCA9IHdzLnByb3RvY29sO1xuICAgICAgICAgICAgICAgIHNlbGYucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5PUEVOO1xuICAgICAgICAgICAgICAgIHNlbGYucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBlID0gZ2VuZXJhdGVFdmVudCgnb3BlbicpO1xuICAgICAgICAgICAgICAgIGUuaXNSZWNvbm5lY3QgPSByZWNvbm5lY3RBdHRlbXB0O1xuICAgICAgICAgICAgICAgIHJlY29ubmVjdEF0dGVtcHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBldmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KGUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd3Mub25jbG9zZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5jb2RlICE9PSAxMDAwICYmIHNlbGYuZGVidWcpIGNvbnNvbGUubG9nKCdXQVJOSU5HISB3cyBjb25uZWN0aW9uJywgc3VybCwgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB3cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlZENsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VuZXJhdGVFdmVudCgnY2xvc2UnKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNPTk5FQ1RJTkc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gZ2VuZXJhdGVFdmVudCgnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICBlLmNvZGUgPSBldmVudC5jb2RlO1xuICAgICAgICAgICAgICAgICAgICBlLnJlYXNvbiA9IGV2ZW50LnJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgZS53YXNDbGVhbiA9IGV2ZW50Lndhc0NsZWFuO1xuICAgICAgICAgICAgICAgICAgICBldmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY29ubmVjdEF0dGVtcHQgJiYgIXRpbWVkT3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5kZWJ1ZyB8fCBSZWNvbm5lY3RpbmdXZWJTb2NrZXQuZGVidWdBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdSZWNvbm5lY3RpbmdXZWJTb2NrZXQnLCAnb25jbG9zZScsIHNlbGYudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VuZXJhdGVFdmVudCgnY2xvc2UnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuaWRsZVRyZXNob2xkIHx8IG5ldyBEYXRlKCkgLSBzZWxmLmlkbGVTaW5jZSA8IHNlbGYuaWRsZVRyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdpZGxlIC0gd2lsbCByZWNvbm5lY3QgbGF0ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGVuZGluZ1JlY29ubmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZGVidWcgfHwgUmVjb25uZWN0aW5nV2ViU29ja2V0LmRlYnVnQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1JlY29ubmVjdGluZ1dlYlNvY2tldCcsICdvbm1lc3NhZ2UnLCBzZWxmLnVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlID0gZ2VuZXJhdGVFdmVudCgnbWVzc2FnZScpO1xuICAgICAgICAgICAgICAgIGUuZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgZXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3cy5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZGVidWcgfHwgUmVjb25uZWN0aW5nV2ViU29ja2V0LmRlYnVnQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1JlY29ubmVjdGluZ1dlYlNvY2tldCcsICdvbmVycm9yJywgc2VsZi51cmwsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudChnZW5lcmF0ZUV2ZW50KGV2ZW50KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFdoZXRoZXIgb3Igbm90IHRvIGNyZWF0ZSBhIHdlYnNvY2tldCB1cG9uIGluc3RhbnRpYXRpb25cbiAgICAgICAgaWYgKHRoaXMuYXV0b21hdGljT3BlbiA9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4oZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zbWl0cyBkYXRhIHRvIHRoZSBzZXJ2ZXIgb3ZlciB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIGEgdGV4dCBzdHJpbmcsIEFycmF5QnVmZmVyIG9yIEJsb2IgdG8gc2VuZCB0byB0aGUgc2VydmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh3cykge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmRlYnVnIHx8IFJlY29ubmVjdGluZ1dlYlNvY2tldC5kZWJ1Z0FsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdSZWNvbm5lY3RpbmdXZWJTb2NrZXQnLCAnc2VuZCcsIHNlbGYudXJsLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdzLnNlbmQoZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93ICdJTlZBTElEX1NUQVRFX0VSUiA6IFBhdXNpbmcgdG8gcmVjb25uZWN0IHdlYnNvY2tldCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb3NlcyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gb3IgY29ubmVjdGlvbiBhdHRlbXB0LCBpZiBhbnkuXG4gICAgICAgICAqIElmIHRoZSBjb25uZWN0aW9uIGlzIGFscmVhZHkgQ0xPU0VELCB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlID0gZnVuY3Rpb24gKGNvZGUsIHJlYXNvbikge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBDTE9TRV9OT1JNQUwgY29kZVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IDEwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3JjZWRDbG9zZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAod3MpIHtcbiAgICAgICAgICAgICAgICB3cy5jbG9zZShjb2RlLCByZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIHB1YmxpYyBBUEkgbWV0aG9kIHRvIHJlZnJlc2ggdGhlIGNvbm5lY3Rpb24gaWYgc3RpbGwgb3BlbiAoY2xvc2UsIHJlLW9wZW4pLlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIGFwcCBzdXNwZWN0cyBiYWQgZGF0YSAvIG1pc3NlZCBoZWFydCBiZWF0cywgaXQgY2FuIHRyeSB0byByZWZyZXNoLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHdzKSB7XG4gICAgICAgICAgICAgICAgd3MuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCBsaXN0ZW5lciB0byBiZSBjYWxsZWQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24ncyByZWFkeVN0YXRlIGNoYW5nZXMgdG8gT1BFTjtcbiAgICAgKiB0aGlzIGluZGljYXRlcyB0aGF0IHRoZSBjb25uZWN0aW9uIGlzIHJlYWR5IHRvIHNlbmQgYW5kIHJlY2VpdmUgZGF0YS5cbiAgICAgKi9cbiAgICBSZWNvbm5lY3RpbmdXZWJTb2NrZXQucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uIChldmVudCkge307XG4gICAgLyoqIEFuIGV2ZW50IGxpc3RlbmVyIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbidzIHJlYWR5U3RhdGUgY2hhbmdlcyB0byBDTE9TRUQuICovXG4gICAgUmVjb25uZWN0aW5nV2ViU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7fTtcbiAgICAvKiogQW4gZXZlbnQgbGlzdGVuZXIgdG8gYmUgY2FsbGVkIHdoZW4gYSBjb25uZWN0aW9uIGJlZ2lucyBiZWluZyBhdHRlbXB0ZWQuICovXG4gICAgUmVjb25uZWN0aW5nV2ViU29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3RpbmcgPSBmdW5jdGlvbiAoZXZlbnQpIHt9O1xuICAgIC8qKiBBbiBldmVudCBsaXN0ZW5lciB0byBiZSBjYWxsZWQgd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLiAqL1xuICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5wcm90b3R5cGUub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7fTtcbiAgICAvKiogQW4gZXZlbnQgbGlzdGVuZXIgdG8gYmUgY2FsbGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzLiAqL1xuICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge307XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGFsbCBpbnN0YW5jZXMgb2YgUmVjb25uZWN0aW5nV2ViU29ja2V0IHNob3VsZCBsb2cgZGVidWcgbWVzc2FnZXMuXG4gICAgICogU2V0dGluZyB0aGlzIHRvIHRydWUgaXMgdGhlIGVxdWl2YWxlbnQgb2Ygc2V0dGluZyBhbGwgaW5zdGFuY2VzIG9mIFJlY29ubmVjdGluZ1dlYlNvY2tldC5kZWJ1ZyB0byB0cnVlLlxuICAgICAqL1xuICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5kZWJ1Z0FsbCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIFJlY29ubmVjdGluZ1dlYlNvY2tldDtcbn0pO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW0tcnBjL2xpYi9yZWNvbm5lY3Rpbmctd2Vic29ja2V0LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFRyYW5zYWN0aW9uQnVpbGRlciA9IHJlcXVpcmUoXCIuL3NyYy9UcmFuc2FjdGlvbkJ1aWxkZXJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFRyYW5zYWN0aW9uQnVpbGRlcjogVHJhbnNhY3Rpb25CdWlsZGVyLFxuXG4gICAgQ2hhaW5UeXBlczogcmVxdWlyZShcIi4vc3JjL0NoYWluVHlwZXNcIiksXG4gICAgT2JqZWN0SWQ6IHJlcXVpcmUoXCIuL3NyYy9PYmplY3RJZFwiKSxcbiAgICBOdW1iZXJVdGlsczogcmVxdWlyZShcIi4vc3JjL051bWJlclV0aWxzXCIpLFxuICAgIFRyYW5zYWN0aW9uSGVscGVyOiByZXF1aXJlKFwiLi9zcmMvVHJhbnNhY3Rpb25IZWxwZXJcIiksXG4gICAgQ2hhaW5WYWxpZGF0aW9uOiByZXF1aXJlKFwiLi9zcmMvQ2hhaW5WYWxpZGF0aW9uXCIpLFxuICAgIExvZ2luOiByZXF1aXJlKFwiLi9zcmMvQWNjb3VudExvZ2luXCIpXG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9jaGFpbi9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2NoYWluXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZShcIi4uLy4uL2VjYy9zcmMvUHJpdmF0ZUtleVwiKTtcbnZhciBrZXkgPSByZXF1aXJlKFwiLi4vLi4vZWNjL3NyYy9LZXlVdGlsc1wiKTtcblxudmFyIEtleUNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEtleUNhY2hlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgS2V5Q2FjaGUpO1xuXG4gICAgICAgIHRoaXMuX2tleUNhY2hlUHJpdiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fa2V5Q2FjaGVQdWIgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX215S2V5cyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoS2V5Q2FjaGUsIFt7XG4gICAgICAgIGtleTogXCJzZXRQcml2S2V5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQcml2S2V5KGtleSwgcHJpdktleSkge1xuICAgICAgICAgICAgdGhpcy5fa2V5Q2FjaGVQcml2LnNldChrZXksIHByaXZLZXkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiaGFzUHJpdktleVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUHJpdktleShrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlDYWNoZVByaXYuaGFzKGtleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRQcml2S2V5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcml2S2V5KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleUNhY2hlUHJpdi5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNldFB1YktleVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHViS2V5KGtleSwgcHViS2V5KSB7XG4gICAgICAgICAgICB0aGlzLl9rZXlDYWNoZVB1Yi5zZXQoa2V5LCBwdWJLZXkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiaGFzUHViS2V5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNQdWJLZXkoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5Q2FjaGVQdWIuaGFzKGtleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRQdWJLZXlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFB1YktleShrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlDYWNoZVB1Yi5nZXQoa2V5KTs7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJzZXRNeUtleVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TXlLZXkoa2V5LCBwcml2S2V5KSB7XG4gICAgICAgICAgICB0aGlzLl9teUtleXMuc2V0KGtleSwgcHJpdktleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRNeUtleVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TXlLZXkoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbXlLZXlzLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEtleUNhY2hlO1xufSgpO1xuXG52YXIgQWNjb3VudExvZ2luID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFjY291bnRMb2dpbigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFjY291bnRMb2dpbik7XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLmtleUNhY2hlID0gbmV3IEtleUNhY2hlKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEFjY291bnRMb2dpbiwgW3tcbiAgICAgICAga2V5OiBcInJlc2V0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB7IGxvZ2dlZEluOiBmYWxzZSwgcm9sZXM6IFtcImFjdGl2ZVwiLCBcIm93bmVyXCIsIFwicG9zdGluZ1wiLCBcIm1lbW9cIl0gfTtcblxuICAgICAgICAgICAgdGhpcy5zdWJzID0ge307XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhZGRTdWJzY3JpcHRpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFN1YnNjcmlwdGlvbihjYikge1xuICAgICAgICAgICAgdGhpcy5zdWJzW2NiXSA9IGNiO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwic2V0Um9sZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFJvbGVzKHJvbGVzKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnJvbGVzID0gcm9sZXM7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRSb2xlc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um9sZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5yb2xlcztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdlbmVyYXRlS2V5c1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVLZXlzKGFjY291bnROYW1lLCBwYXNzd29yZCwgcm9sZXMsIHByZWZpeCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKCFhY2NvdW50TmFtZSB8fCAhcGFzc3dvcmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY2NvdW50IG5hbWUgb3IgcGFzc3dvcmQgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFzc3dvcmQubGVuZ3RoIDwgMTIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXNzd29yZCBtdXN0IGhhdmUgYXQgbGVhc3QgMTIgY2hhcmFjdGVyc1wiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByaXZLZXlzID0ge307XG4gICAgICAgICAgICB2YXIgcHViS2V5cyA9IHt9O1xuXG4gICAgICAgICAgICAocm9sZXMgfHwgdGhpcy5zdGF0ZS5yb2xlcykuZm9yRWFjaChmdW5jdGlvbiAocm9sZSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWVkID0gYWNjb3VudE5hbWUgKyByb2xlICsgcGFzc3dvcmQ7XG4gICAgICAgICAgICAgICAgdmFyIHBrZXkgPSBfdGhpcy5rZXlDYWNoZS5oYXNQcml2S2V5KHJvbGUpID8gX3RoaXMua2V5Q2FjaGUuZ2V0UHJpdktleShyb2xlKSA6IFByaXZhdGVLZXkuZnJvbVNlZWQoa2V5Lm5vcm1hbGl6ZV9icmFpbktleShzZWVkKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMua2V5Q2FjaGUuc2V0UHJpdktleShyb2xlLCBwa2V5KTtcblxuICAgICAgICAgICAgICAgIHByaXZLZXlzW3JvbGVdID0gcGtleTtcbiAgICAgICAgICAgICAgICBwdWJLZXlzW3JvbGVdID0gX3RoaXMua2V5Q2FjaGUuZ2V0UHViS2V5KHJvbGUpID8gX3RoaXMua2V5Q2FjaGUuZ2V0UHViS2V5KHJvbGUpIDogcGtleS50b1B1YmxpY0tleSgpLnRvU3RyaW5nKHByZWZpeCk7XG5cbiAgICAgICAgICAgICAgICBfdGhpcy5rZXlDYWNoZS5zZXRQdWJLZXkocm9sZSwgcHViS2V5c1tyb2xlXSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHsgcHJpdktleXM6IHByaXZLZXlzLCBwdWJLZXlzOiBwdWJLZXlzIH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJmcm9tUHJpdktleVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVByaXZLZXkoYWNjb3VudE5hbWUsIHByaXZhdGVLZXksIHJvbGVzLCBwcmVmaXgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoIXByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcml2S2V5cyA9IHt9O1xuICAgICAgICAgICAgdmFyIHB1YktleXMgPSB7fTtcblxuICAgICAgICAgICAgKHJvbGVzIHx8IHRoaXMuc3RhdGUucm9sZXMpLmZvckVhY2goZnVuY3Rpb24gKHJvbGUpIHtcblxuICAgICAgICAgICAgICAgIHZhciBwa2V5ID0gX3RoaXMyLmtleUNhY2hlLmhhc1ByaXZLZXkocm9sZSkgPyBfdGhpczIua2V5Q2FjaGUuZ2V0UHJpdktleShyb2xlKSA6IFByaXZhdGVLZXkuZnJvbVdpZihwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICBfdGhpczIua2V5Q2FjaGUuc2V0UHJpdktleShyb2xlLCBwa2V5KTtcblxuICAgICAgICAgICAgICAgIHByaXZLZXlzW3JvbGVdID0gcGtleTtcbiAgICAgICAgICAgICAgICBwdWJLZXlzW3JvbGVdID0gX3RoaXMyLmtleUNhY2hlLmdldFB1YktleShyb2xlKSA/IF90aGlzMi5rZXlDYWNoZS5nZXRQdWJLZXkocm9sZSkgOiBwa2V5LnRvUHVibGljS2V5KCkudG9TdHJpbmcocHJlZml4KTtcblxuICAgICAgICAgICAgICAgIF90aGlzMi5rZXlDYWNoZS5zZXRQdWJLZXkocm9sZSwgcHViS2V5c1tyb2xlXSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHsgcHJpdktleXM6IHByaXZLZXlzLCBwdWJLZXlzOiBwdWJLZXlzIH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRQdWJLZXlzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQdWJLZXlzKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnJvbGVzLm1hcChmdW5jdGlvbiAocm9sZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMua2V5Q2FjaGUuZ2V0UHViS2V5KHJvbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJjaGVja0tleXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrS2V5cyhfcmVmKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGFjY291bnROYW1lID0gX3JlZi5hY2NvdW50TmFtZTtcbiAgICAgICAgICAgIHZhciBwYXNzd29yZCA9IF9yZWYucGFzc3dvcmQ7XG4gICAgICAgICAgICB2YXIgYXV0aHMgPSBfcmVmLmF1dGhzO1xuICAgICAgICAgICAgdmFyIF9yZWYkcHJpdmF0ZUtleSA9IF9yZWYucHJpdmF0ZUtleTtcbiAgICAgICAgICAgIHZhciBwcml2YXRlS2V5ID0gX3JlZiRwcml2YXRlS2V5ID09PSB1bmRlZmluZWQgPyBudWxsIDogX3JlZiRwcml2YXRlS2V5O1xuXG4gICAgICAgICAgICBpZiAoIWFjY291bnROYW1lIHx8ICFwYXNzd29yZCAmJiAhcHJpdmF0ZUtleSB8fCAhYXV0aHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaGVja0tleXM6IE1pc3NpbmcgaW5wdXRzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhhc0tleSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChyb2xlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHBhc3N3b3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMgPSBfdGhpczQuZ2VuZXJhdGVLZXlzKGFjY291bnROYW1lLCBwYXNzd29yZCwgW3JvbGVdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cyA9IF90aGlzNC5mcm9tUHJpdktleShhY2NvdW50TmFtZSwgcHJpdmF0ZUtleSwgW3JvbGVdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5cyAmJiBPYmplY3Qua2V5cyhrZXlzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfa2V5cyA9IGtleXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJpdktleXMgPSBfa2V5cy5wcml2S2V5cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdWJLZXlzID0gX2tleXMucHViS2V5cztcblxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aHNbcm9sZV0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleVswXSA9PT0gcHViS2V5c1tyb2xlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczQua2V5Q2FjaGUuc2V0TXlLZXkocm9sZSwgeyBwcml2OiBwcml2S2V5c1tyb2xlXSwgcHViOiBwdWJLZXlzW3JvbGVdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIHJvbGUgaW4gYXV0aHMpIHtcbiAgICAgICAgICAgICAgICBfbG9vcChyb2xlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChoYXNLZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBhY2NvdW50TmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5sb2dnZWRJbiA9IGhhc0tleTtcblxuICAgICAgICAgICAgcmV0dXJuIGhhc0tleTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNpZ25UcmFuc2FjdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2lnblRyYW5zYWN0aW9uKHRyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHNpZ25lclB1YmtleXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciByZXF1aXJlZFB1YmtleXMgPSBhcmd1bWVudHNbMl07XG5cblxuICAgICAgICAgICAgdmFyIG15S2V5cyA9IHt9O1xuICAgICAgICAgICAgdmFyIGhhc0tleSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnJvbGVzLmZvckVhY2goZnVuY3Rpb24gKHJvbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXlLZXkgPSBfdGhpczUua2V5Q2FjaGUuZ2V0TXlLZXkocm9sZSk7XG4gICAgICAgICAgICAgICAgaWYgKG15S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWduZXJQdWJrZXlzW215S2V5LnB1Yl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0tleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVyUHVia2V5c1tteUtleS5wdWJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkUHVia2V5cyAmJiByZXF1aXJlZFB1YmtleXMuaW5kZXhPZihteUtleS5wdWIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkX3NpZ25lcihteUtleS5wcml2LCBteUtleS5wdWIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFyZXF1aXJlZFB1YmtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZF9zaWduZXIobXlLZXkucHJpdiwgbXlLZXkucHViKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWhhc0tleSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJZb3UgZG8gbm90IGhhdmUgYW55IHByaXZhdGUga2V5cyB0byBzaWduIHRoaXMgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGRvIG5vdCBoYXZlIGFueSBwcml2YXRlIGtleXMgdG8gc2lnbiB0aGlzIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFjY291bnRMb2dpbjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBY2NvdW50TG9naW47XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2NoYWluL3NyYy9BY2NvdW50TG9naW4uanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9jaGFpbi9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF90aGlzO1xuXG52YXIgZWNjX2NvbmZpZyA9IHtcbiAgICBhZGRyZXNzX3ByZWZpeDogXCJTVE1cIlxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBfdGhpcyA9IHtcbiAgICBjb3JlX2Fzc2V0OiBcIlNURUVNXCIsXG4gICAgdmVzdF9hc3NldDogXCJWRVNUU1wiLFxuICAgIGRvbGxhcl9hc3NldDogXCJTQkRcIixcbiAgICBhZGRyZXNzX3ByZWZpeDogXCJTVE1cIixcbiAgICBleHBpcmVfaW5fc2VjczogMTUsXG4gICAgZXhwaXJlX2luX3NlY3NfcHJvcG9zYWw6IDI0ICogNjAgKiA2MCxcbiAgICBuZXR3b3Jrczoge1xuICAgICAgICBTdGVlbToge1xuICAgICAgICAgICAgY29yZV9hc3NldDogXCJTVEVFTVwiLFxuICAgICAgICAgICAgYWRkcmVzc19wcmVmaXg6IFwiU1RNXCIsXG4gICAgICAgICAgICBjaGFpbl9pZDogXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqIFNldCBhIGZldyBwcm9wZXJ0aWVzIGZvciBrbm93biBjaGFpbiBJRHMuICovXG4gICAgc2V0Q2hhaW5JZDogZnVuY3Rpb24gc2V0Q2hhaW5JZChjaGFpbl9pZCkge1xuXG4gICAgICAgIHZhciBpLCBsZW4sIG5ldHdvcmssIG5ldHdvcmtfbmFtZSwgcmVmO1xuICAgICAgICByZWYgPSBPYmplY3Qua2V5cyhfdGhpcy5uZXR3b3Jrcyk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgIG5ldHdvcmtfbmFtZSA9IHJlZltpXTtcbiAgICAgICAgICAgIG5ldHdvcmsgPSBfdGhpcy5uZXR3b3Jrc1tuZXR3b3JrX25hbWVdO1xuXG4gICAgICAgICAgICBpZiAobmV0d29yay5jaGFpbl9pZCA9PT0gY2hhaW5faWQpIHtcblxuICAgICAgICAgICAgICAgIF90aGlzLm5ldHdvcmtfbmFtZSA9IG5ldHdvcmtfbmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrLmFkZHJlc3NfcHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZHJlc3NfcHJlZml4ID0gbmV0d29yay5hZGRyZXNzX3ByZWZpeDtcbiAgICAgICAgICAgICAgICAgICAgZWNjX2NvbmZpZy5hZGRyZXNzX3ByZWZpeCA9IG5ldHdvcmsuYWRkcmVzc19wcmVmaXg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJJTkZPICAgIENvbmZpZ3VyZWQgZm9yXCIsIG5ldHdvcmtfbmFtZSwgXCI6XCIsIG5ldHdvcmsuY29yZV9hc3NldCwgXCJcXG5cIik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrX25hbWU6IG5ldHdvcmtfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29yazogbmV0d29ya1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIV90aGlzLm5ldHdvcmtfbmFtZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIGNoYWluIGlkICh0aGlzIG1heSBiZSBhIHRlc3RuZXQpXCIsIGNoYWluX2lkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIF90aGlzLmNvcmVfYXNzZXQgPSBcIlNURUVNXCI7XG4gICAgICAgIF90aGlzLmFkZHJlc3NfcHJlZml4ID0gXCJTVE1cIjtcbiAgICAgICAgZWNjX2NvbmZpZy5hZGRyZXNzX3ByZWZpeCA9IFwiU1RNXCI7XG4gICAgICAgIF90aGlzLmV4cGlyZV9pbl9zZWNzID0gMTU7XG4gICAgICAgIF90aGlzLmV4cGlyZV9pbl9zZWNzX3Byb3Bvc2FsID0gMjQgKiA2MCAqIDYwO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ2hhaW4gY29uZmlnIHJlc2V0XCIpO1xuICAgIH0sXG5cbiAgICBzZXRQcmVmaXg6IGZ1bmN0aW9uIHNldFByZWZpeCgpIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IFwiU1RNXCIgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgX3RoaXMuYWRkcmVzc19wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIGVjY19jb25maWcuYWRkcmVzc19wcmVmaXggPSBwcmVmaXg7XG4gICAgfVxufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvY2hhaW4vc3JjL0NoYWluQ29uZmlnLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvY2hhaW4vc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDaGFpblR5cGVzID0ge307XG5cbkNoYWluVHlwZXMub3BlcmF0aW9ucyA9IHtcbiAgICB2b3RlOiAwLFxuICAgIGNvbW1lbnQ6IDEsXG4gICAgdHJhbnNmZXI6IDIsXG4gICAgdHJhbnNmZXJfdG9fdmVzdGluZzogMyxcbiAgICB3aXRoZHJhd192ZXN0aW5nOiA0LFxuICAgIGxpbWl0X29yZGVyX2NyZWF0ZTogNSxcbiAgICBsaW1pdF9vcmRlcl9jYW5jZWw6IDYsXG4gICAgZmVlZF9wdWJsaXNoOiA3LFxuICAgIGNvbnZlcnQ6IDgsXG4gICAgYWNjb3VudF9jcmVhdGU6IDksXG4gICAgYWNjb3VudF91cGRhdGU6IDEwLFxuICAgIHdpdG5lc3NfdXBkYXRlOiAxMSxcbiAgICBhY2NvdW50X3dpdG5lc3Nfdm90ZTogMTIsXG4gICAgYWNjb3VudF93aXRuZXNzX3Byb3h5OiAxMyxcbiAgICBwb3c6IDE0LFxuICAgIGN1c3RvbTogMTUsXG4gICAgcmVwb3J0X292ZXJfcHJvZHVjdGlvbjogMTYsXG4gICAgZGVsZXRlX2NvbW1lbnQ6IDE3LFxuICAgIGN1c3RvbV9qc29uOiAxOCxcbiAgICBjb21tZW50X29wdGlvbnM6IDE5LFxuICAgIHNldF93aXRoZHJhd192ZXN0aW5nX3JvdXRlOiAyMCxcbiAgICBmaWxsX2NvbnZlcnRfcmVxdWVzdDogMjEsXG4gICAgYXV0aG9yX3Jld2FyZDogMjIsXG4gICAgY3VyYXRpb25fcmV3YXJkOiAyMyxcbiAgICBsaXF1aWRpdHlfcmV3YXJkOiAyNCxcbiAgICBpbnRlcmVzdDogMjUsXG4gICAgZmlsbF92ZXN0aW5nX3dpdGhkcmF3OiAyNixcbiAgICBmaWxsX29yZGVyOiAyNyxcbiAgICBjb21tZW50X3BheW91dDogMjgsXG4gICAgZXNjcm93X3RyYW5zZmVyOiAyOSxcbiAgICBlc2Nyb3dfYXBwcm92ZTogMzAsXG4gICAgZXNjcm93X2Rpc3B1dGU6IDMxLFxuICAgIGVzY3Jvd19yZWxlYXNlOiAzMlxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFpblR5cGVzO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9jaGFpbi9zcmMvQ2hhaW5UeXBlcy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2NoYWluL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gICAgQWNjb3VudCBuYW1lcyBtYXkgY29udGFpbiBvbmUgb3IgbW9yZSBuYW1lcyBzZXBhcmF0ZWQgYnkgYSBkb3QuXG4gICAgRWFjaCBuYW1lIG5lZWRzIHRvIHN0YXJ0IHdpdGggYSBsZXR0ZXIgYW5kIG1heSBjb250YWluXG4gICAgbnVtYmVycywgb3Igd2VsbCBwbGFjZWQgZGFzaGVzLlxuICAgIEBzZWUgaXNfdmFsaWRfbmFtZSBncmFwaGVuZS9saWJyYXJpZXMvY2hhaW4vcHJvdG9jb2wvYWNjb3VudC5jcHBcbiovXG52YXIgaWRfcmVnZXggPSAvXFxiXFxkK1xcLlxcZCtcXC4oXFxkKylcXGIvO1xuXG52YXIgY2hhaW5WYWxpZGF0aW9uID0ge1xuICAgIGlzX2FjY291bnRfbmFtZTogZnVuY3Rpb24gaXNfYWNjb3VudF9uYW1lKHZhbHVlKSB7XG4gICAgICAgIHZhciBhbGxvd190b29fc2hvcnQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgaSwgbGFiZWwsIGxlbiwgbGVuZ3RoLCByZWY7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCFhbGxvd190b29fc2hvcnQgJiYgbGVuZ3RoIDwgMyB8fCBsZW5ndGggPiA2Mykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVmID0gdmFsdWUuc3BsaXQoJy4nKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICAgICAgbGFiZWwgPSByZWZbaV07XG5cbiAgICAgICAgICAgIGlmICghKC9eW2Etel1bYS16MC05LV0qJC8udGVzdChsYWJlbCkgJiYgIS8tLS8udGVzdChsYWJlbCkgJiYgL1thLXowLTldJC8udGVzdChsYWJlbCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBpc19vYmplY3RfaWQ6IGZ1bmN0aW9uIGlzX29iamVjdF9pZChvYmpfaWQpIHtcbiAgICAgICAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBvYmpfaWQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgbWF0Y2ggPSBpZF9yZWdleC5leGVjKG9ial9pZCk7XG4gICAgICAgIHJldHVybiBtYXRjaCAhPT0gbnVsbCAmJiBvYmpfaWQuc3BsaXQoXCIuXCIpLmxlbmd0aCA9PT0gMztcbiAgICB9LFxuXG4gICAgaXNfZW1wdHk6IGZ1bmN0aW9uIGlzX2VtcHR5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgICB9LFxuXG4gICAgaXNfYWNjb3VudF9uYW1lX2Vycm9yOiBmdW5jdGlvbiBpc19hY2NvdW50X25hbWVfZXJyb3IodmFsdWUsIGFsbG93X3Rvb19zaG9ydCkge1xuICAgICAgICB2YXIgaSwgbGFiZWwsIGxlbiwgbGVuZ3RoLCByZWYsIHN1ZmZpeDtcbiAgICAgICAgaWYgKGFsbG93X3Rvb19zaG9ydCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbGxvd190b29fc2hvcnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzdWZmaXggPSBcIkFjY291bnQgbmFtZSBzaG91bGQgXCI7XG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwibm90IGJlIGVtcHR5LlwiO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgaWYgKCFhbGxvd190b29fc2hvcnQgJiYgbGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiYmUgbG9uZ2VyLlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPiA2Mykge1xuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiYmUgc2hvcnRlci5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoL1xcLi8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHN1ZmZpeCA9IFwiRWFjaCBhY2NvdW50IHNlZ21lbnQgc2hvdWxkIFwiO1xuICAgICAgICB9XG4gICAgICAgIHJlZiA9IHZhbHVlLnNwbGl0KCcuJyk7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbGFiZWwgPSByZWZbaV07XG4gICAgICAgICAgICBpZiAoIS9eW35hLXpdLy50ZXN0KGxhYmVsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcInN0YXJ0IHdpdGggYSBsZXR0ZXIuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIS9eW35hLXowLTktXSokLy50ZXN0KGxhYmVsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcImhhdmUgb25seSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGRhc2hlcy5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvLS0vLnRlc3QobGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiaGF2ZSBvbmx5IG9uZSBkYXNoIGluIGEgcm93LlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEvW2EtejAtOV0kLy50ZXN0KGxhYmVsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcImVuZCB3aXRoIGEgbGV0dGVyIG9yIGRpZ2l0LlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEobGFiZWwubGVuZ3RoID49IDMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiYmUgbG9uZ2VyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGlzX2NoZWFwX25hbWU6IGZ1bmN0aW9uIGlzX2NoZWFwX25hbWUoYWNjb3VudF9uYW1lKSB7XG4gICAgICAgIHJldHVybiAoL1swLTktXS8udGVzdChhY2NvdW50X25hbWUpIHx8ICEvW2FlaW91eV0vLnRlc3QoYWNjb3VudF9uYW1lKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBpc19lbXB0eV91c2VyX2lucHV0OiBmdW5jdGlvbiBpc19lbXB0eV91c2VyX2lucHV0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh2YWx1ZSArIFwiXCIpLnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICByZXF1aXJlZDogZnVuY3Rpb24gcmVxdWlyZWQodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBcIlwiIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmFsdWUgcmVxdWlyZWQgZm9yIFwiICsgZmllbGRfbmFtZSArIFwiOiBcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKiBAc2VlIGlzX3ZhbGlkX3N5bWJvbCBncmFwaGVuZS9saWJyYXJpZXMvY2hhaW4vcHJvdG9jb2wvYXNzZXRfb3BzLmNwcCAqL1xuICAgIGlzX3ZhbGlkX3N5bWJvbF9lcnJvcjogZnVuY3Rpb24gaXNfdmFsaWRfc3ltYm9sX2Vycm9yKHZhbHVlKSB7XG4gICAgICAgIHZhciBzdWZmaXggPSBcIkFzc2V0IG5hbWUgc2hvdWxkIFwiO1xuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcIm5vdCBiZSBlbXB0eS5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuc3BsaXQoJy4nKS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJoYXZlIG9ubHkgb25lIGRvdC5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiYmUgbG9uZ2VyLlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxNikge1xuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiYmUgc2hvcnRlci5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIS9eW0EtWl0vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJzdGFydCB3aXRoIGEgbGV0dGVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEvW0EtWl0kLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiZW5kIHdpdGggYSBsZXR0ZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoL15bQS1aMC05XFwuXSQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJjb250YWluIG9ubHkgbGV0dGVycyBudW1iZXJzIGFuZCBwZXJoYXBzIGEgZG90LlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2hhaW5WYWxpZGF0aW9uO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9jaGFpbi9zcmMvQ2hhaW5WYWxpZGF0aW9uLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvY2hhaW4vc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG4vKipcbiAgICBDb252ZXJ0IDEyLjM0IHdpdGggYSBwcmVjaXNpb24gb2YgMyBpbnRvIDEyMzQwXG4gICAgXG4gICAgQGFyZyB7bnVtYmVyfHN0cmluZ30gbnVtYmVyIC0gVXNlIHN0cmluZ3MgZm9yIGxhcmdlIG51bWJlcnMuICBUaGlzIG1heSBjb250YWluIG9uZSBkZWNpbWFsIGJ1dCBubyBzaWduXG4gICAgQGFyZyB7bnVtYmVyfSBwcmVjaXNpb24gLSBudW1iZXIgb2YgaW1wbGllZCBkZWNpbWFsIHBsYWNlcyAodXN1YWxseSBjYXVzZXMgcmlnaHQgemVybyBwYWRkaW5nKVxuICAgIEByZXR1cm4ge3N0cmluZ30gLVxuKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHRvSW1wbGllZERlY2ltYWw6IGZ1bmN0aW9uIHRvSW1wbGllZERlY2ltYWwobnVtYmVyLCBwcmVjaXNpb24pIHtcblxuICAgICAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgYXNzZXJ0KG51bWJlciA8PSA5MDA3MTk5MjU0NzQwOTkxLCBcIm92ZXJmbG93XCIpO1xuICAgICAgICAgICAgbnVtYmVyID0gXCJcIiArIG51bWJlcjtcbiAgICAgICAgfSBlbHNlIGlmIChudW1iZXIudG9TdHJpbmcpIG51bWJlciA9IG51bWJlci50b1N0cmluZygpO1xuXG4gICAgICAgIGFzc2VydCh0eXBlb2YgbnVtYmVyID09PSBcInN0cmluZ1wiLCBcIm51bWJlciBzaG91bGQgYmUgYW4gYWN0dWFsIG51bWJlciBvciBzdHJpbmc6IFwiICsgKHR5cGVvZiBudW1iZXIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihudW1iZXIpKSk7XG4gICAgICAgIG51bWJlciA9IG51bWJlci50cmltKCk7XG4gICAgICAgIGFzc2VydCgvXlswLTldKlxcLj9bMC05XSokLy50ZXN0KG51bWJlciksIFwiSW52YWxpZCBkZWNpbWFsIG51bWJlciBcIiArIG51bWJlcik7XG5cbiAgICAgICAgdmFyIF9udW1iZXIkc3BsaXQgPSBudW1iZXIuc3BsaXQoXCIuXCIpO1xuXG4gICAgICAgIHZhciBfbnVtYmVyJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9udW1iZXIkc3BsaXQsIDIpO1xuXG4gICAgICAgIHZhciBfbnVtYmVyJHNwbGl0MiQgPSBfbnVtYmVyJHNwbGl0MlswXTtcbiAgICAgICAgdmFyIHdob2xlID0gX251bWJlciRzcGxpdDIkID09PSB1bmRlZmluZWQgPyBcIlwiIDogX251bWJlciRzcGxpdDIkO1xuICAgICAgICB2YXIgX251bWJlciRzcGxpdDIkMiA9IF9udW1iZXIkc3BsaXQyWzFdO1xuICAgICAgICB2YXIgZGVjaW1hbCA9IF9udW1iZXIkc3BsaXQyJDIgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBfbnVtYmVyJHNwbGl0MiQyO1xuXG5cbiAgICAgICAgdmFyIHBhZGRpbmcgPSBwcmVjaXNpb24gLSBkZWNpbWFsLmxlbmd0aDtcbiAgICAgICAgYXNzZXJ0KHBhZGRpbmcgPj0gMCwgXCJUb28gbWFueSBkZWNpbWFsIGRpZ2l0cyBpbiBcIiArIG51bWJlciArIFwiIHRvIGNyZWF0ZSBhbiBpbXBsaWVkIGRlY2ltYWwgb2YgXCIgKyBwcmVjaXNpb24pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFkZGluZzsgaSsrKSB7XG4gICAgICAgICAgICBkZWNpbWFsICs9IFwiMFwiO1xuICAgICAgICB9d2hpbGUgKHdob2xlLmNoYXJBdCgwKSA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdob2xlID0gd2hvbGUuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9cmV0dXJuIHdob2xlICsgZGVjaW1hbDtcbiAgICB9XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9jaGFpbi9zcmMvTnVtYmVyVXRpbHMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9jaGFpbi9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2J5dGVidWZmZXInKTtcblxudmFyIExvbmcgPSBfcmVxdWlyZS5Mb25nO1xuXG5cbnZhciB2ID0gcmVxdWlyZSgnLi4vLi4vc2VyaWFsaXplci9zcmMvU2VyaWFsaXplclZhbGlkYXRpb24nKTtcblxudmFyIERCX01BWF9JTlNUQU5DRV9JRCA9IExvbmcuZnJvbU51bWJlcihNYXRoLnBvdygyLCA0OCkgLSAxKTtcblxudmFyIE9iamVjdElkID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9iamVjdElkKHNwYWNlLCB0eXBlLCBpbnN0YW5jZSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0SWQpO1xuXG4gICAgICAgIHRoaXMuc3BhY2UgPSBzcGFjZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICB2YXIgaW5zdGFuY2Vfc3RyaW5nID0gdGhpcy5pbnN0YW5jZS50b1N0cmluZygpO1xuICAgICAgICB2YXIgX09iamVjdElkID0gdGhpcy5zcGFjZSArICcuJyArIHRoaXMudHlwZSArICcuJyArIGluc3RhbmNlX3N0cmluZztcbiAgICAgICAgaWYgKCF2LmlzX2RpZ2l0cyhpbnN0YW5jZV9zdHJpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgKCdJbnZhbGlkIG9iamVjdCBpZCAnICsgX09iamVjdElkKSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE9iamVjdElkLCBbe1xuICAgICAgICBrZXk6ICd0b0xvbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9Mb25nKCkge1xuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbU51bWJlcih0aGlzLnNwYWNlKS5zaGlmdExlZnQoNTYpLm9yKExvbmcuZnJvbU51bWJlcih0aGlzLnR5cGUpLnNoaWZ0TGVmdCg0OCkub3IodGhpcy5pbnN0YW5jZSkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhcHBlbmRCeXRlQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYikge1xuICAgICAgICAgICAgcmV0dXJuIGIud3JpdGVVaW50NjQodGhpcy50b0xvbmcoKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BhY2UgKyAnLicgKyB0aGlzLnR5cGUgKyAnLicgKyB0aGlzLmluc3RhbmNlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiAnZnJvbVN0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3BhY2UgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS50eXBlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUuaW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHYucmVxdWlyZV9tYXRjaCgvXihbMC05XSspXFwuKFswLTldKylcXC4oWzAtOV0rKSQvLCB2LnJlcXVpcmVkKHZhbHVlLCBcIk9iamVjdElkXCIpLCBcIk9iamVjdElkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RJZChwYXJzZUludChwYXJhbXNbMV0pLCBwYXJzZUludChwYXJhbXNbMl0pLCBMb25nLmZyb21TdHJpbmcocGFyYW1zWzNdKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21Mb25nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Mb25nKGxvbmcpIHtcbiAgICAgICAgICAgIHZhciBzcGFjZSA9IGxvbmcuc2hpZnRSaWdodCg1NikudG9JbnQoKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbG9uZy5zaGlmdFJpZ2h0KDQ4KS50b0ludCgpICYgMHgwMGZmO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbG9uZy5hbmQoREJfTUFYX0lOU1RBTkNFX0lEKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoc3BhY2UsIHR5cGUsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbUJ5dGVCdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdElkLmZyb21Mb25nKGIucmVhZFVpbnQ2NCgpKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBPYmplY3RJZDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RJZDtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvY2hhaW4vc3JjL09iamVjdElkLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvY2hhaW4vc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi8uLi9lY2NcIik7XG5cbnZhciBTaWduYXR1cmUgPSBfcmVxdWlyZS5TaWduYXR1cmU7XG52YXIgUHVibGljS2V5ID0gX3JlcXVpcmUuUHVibGljS2V5O1xudmFyIGhhc2ggPSBfcmVxdWlyZS5oYXNoO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4uLy4uL3NlcmlhbGl6ZXJcIik7XG5cbnZhciBvcHMgPSBfcmVxdWlyZTIub3BzO1xuXG52YXIgQ2hhaW5Db25maWcgPSByZXF1aXJlKFwiLi4vLi4vY2hhaW4vc3JjL0NoYWluQ29uZmlnXCIpO1xuXG52YXIgX3JlcXVpcmUzID0gcmVxdWlyZSgnc3RlZW0tcnBjJyk7XG5cbnZhciBDbGllbnQgPSBfcmVxdWlyZTMuQ2xpZW50O1xuXG52YXIgQXBpID0gQ2xpZW50LmdldCgpO1xuXG52YXIgX3JlcXVpcmU0ID0gcmVxdWlyZSgnYnl0ZWJ1ZmZlcicpO1xuXG52YXIgTG9uZyA9IF9yZXF1aXJlNC5Mb25nO1xuXG5cbnZhciBDaGFpblR5cGVzID0gcmVxdWlyZSgnLi9DaGFpblR5cGVzJyk7XG5cbnZhciBoZWFkX2Jsb2NrX3RpbWVfc3RyaW5nO1xuXG52YXIgVHJhbnNhY3Rpb25CdWlsZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zYWN0aW9uQnVpbGRlcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zYWN0aW9uQnVpbGRlcik7XG5cbiAgICAgICAgdGhpcy5yZWZfYmxvY2tfbnVtID0gMDtcbiAgICAgICAgdGhpcy5yZWZfYmxvY2tfcHJlZml4ID0gMDtcbiAgICAgICAgdGhpcy5leHBpcmF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zID0gW107XG4gICAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IFtdO1xuICAgICAgICB0aGlzLnNpZ25lcl9wcml2YXRlX2tleXMgPSBbXTtcblxuICAgICAgICAvLyBzZW1pLXByaXZhdGUgbWV0aG9kIGJpbmRpbmdzXG4gICAgICAgIHRoaXMuX2Jyb2FkY2FzdCA9IF9icm9hZGNhc3QuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAgQGFyZyB7c3RyaW5nfSBuYW1lIC0gbGlrZSBcInRyYW5zZmVyXCJcbiAgICAgICAgQGFyZyB7b2JqZWN0fSBvcGVyYXRpb24gLSBKU09OIG1hdGNoY2hpbmcgdGhlIG9wZXJhdGlvbidzIGZvcm1hdFxuICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhUcmFuc2FjdGlvbkJ1aWxkZXIsIFt7XG4gICAgICAgIGtleTogXCJhZGRfdHlwZV9vcGVyYXRpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZF90eXBlX29wZXJhdGlvbihuYW1lLCBvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYWRkX29wZXJhdGlvbih0aGlzLmdldF90eXBlX29wZXJhdGlvbihuYW1lLCBvcGVyYXRpb24pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgVGhpcyBkb2VzIGl0IGFsbDogc2V0IGZlZXMsIGZpbmFsaXplLCBzaWduLCBhbmQgYnJvYWRjYXN0IChpZiB3YW50ZWQpLlxuICAgICAgICAgICAgIEBhcmcge0NvbmZpZGVudGlhbFdhbGxldH0gY3dhbGxldCAtIG11c3QgYmUgdW5sb2NrZWQsIHVzZWQgdG8gZ2F0aGVyIHNpZ25pbmcga2V5c1xuICAgICAgICAgICAgIEBhcmcge2FycmF5PHN0cmluZz59IFtzaWduZXJfcHVia2V5cyA9IG51bGxdIC0gT3B0aW9uYWwgW1wiR1BIQWJjOURlZjAuLi5cIiwgLi4uXS4gIFRoZXNlIGFyZSBhZGRpdGlvbmFsIHNpZ25pbmcga2V5cy4gIFNvbWUgYmFsYW5jZSBjbGFpbXMgcmVxdWlyZSBwcm9wcml0YXJ5IGFkZHJlc3MgZm9ybWF0cywgdGhlIHdpdG5lc3Mgbm9kZSBjYW4ndCB0ZWxsIHVzIHdoaWNoIG9uZXMgYXJlIG5lZWRlZCBzbyB0aGV5IG11c3QgYmUgcGFzc2VkIGluLiAgSWYgdGhlIHdpdG5lc3Mgbm9kZSBjYW4gZmlndXJlIG91dCBhIHNpZ25pbmcga2V5IChtb3N0bHkgYWxsIG90aGVyIHRyYW5zYWN0aW9ucyksIGl0IHNob3VsZCBub3QgYmUgcGFzc2VkIGluIGhlcmUuXG4gICAgICAgICAgICAgQGFyZyB7Ym9vbGVhbn0gW2Jyb2FkY2FzdCA9IGZhbHNlXVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwicHJvY2Vzc190cmFuc2FjdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc190cmFuc2FjdGlvbihhY2NvdW50TG9naW4pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBzaWduZXJfcHVia2V5cyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB2YXIgYnJvYWRjYXN0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMl07XG5cblxuICAgICAgICAgICAgLy8gbGV0IHdhbGxldF9vYmplY3QgPSBjd2FsbGV0LndhbGxldC53YWxsZXRfb2JqZWN0XG4gICAgICAgICAgICAvLyBpZihBcGkuY2hhaW5faWQgIT09IHdhbGxldF9vYmplY3QuZ2V0KFwiY2hhaW5faWRcIikpXG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiTWlzbWF0Y2hlZCBjaGFpbl9pZDsgZXhwZWN0aW5nIFwiICtcbiAgICAgICAgICAgIC8vICAgICAgICAgd2FsbGV0X29iamVjdC5nZXQoXCJjaGFpbl9pZFwiKSArIFwiLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIC8vICAgICAgICAgQXBpLmNoYWluX2lkKVxuXG4gICAgICAgICAgICB2YXIgc2lnbmVyX3B1YmtleXNfYWRkZWQgPSB7fTtcbiAgICAgICAgICAgIC8vIGlmKHNpZ25lcl9wdWJrZXlzKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIC8vIEJhbGFuY2UgY2xhaW1zIGFyZSBieSBhZGRyZXNzLCBvbmx5IHRoZSBwcml2YXRlXG4gICAgICAgICAgICAvLyAgICAgLy8ga2V5IGhvbGRlciBjYW4ga25vdyBhYm91dCB0aGVzZSBhZGRpdGlvbmFsXG4gICAgICAgICAgICAvLyAgICAgLy8gcG90ZW50aWFsIGtleXMuXG4gICAgICAgICAgICAvLyAgICAgdmFyIHB1YmtleXMgPSBhY2NvdW50TG9naW4uZ2V0UHViS2V5cygpXG4gICAgICAgICAgICAvLyAgICAgaWYoICEgcHVia2V5cy5sZW5ndGgpXG4gICAgICAgICAgICAvLyAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc2lnbmluZyBrZXlcIilcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgZm9yKGxldCBwdWJrZXlfc3RyaW5nIG9mIHB1YmtleXMpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgdmFyIHByaXZhdGVfa2V5ID0gY3dhbGxldC5nZXRQcml2YXRlS2V5KHB1YmtleV9zdHJpbmcpXG4gICAgICAgICAgICAvLyAgICAgICAgIHRoaXMuYWRkX3NpZ25lcihwcml2YXRlX2tleSwgcHVia2V5X3N0cmluZylcbiAgICAgICAgICAgIC8vICAgICAgICAgc2lnbmVyX3B1YmtleXNfYWRkZWRbcHVia2V5X3N0cmluZ10gPSB0cnVlXG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAvLyByZXR1cm4gdGhpcy5nZXRfcG90ZW50aWFsX3NpZ25hdHVyZXMoKS50aGVuKCAocHVia2V5cyk9PiB7XG4gICAgICAgICAgICB2YXIgbXlfcHVia2V5cyA9IGFjY291bnRMb2dpbi5nZXRQdWJLZXlzKCk7XG5cbiAgICAgICAgICAgIC8vey8vVGVzdGluZyBvbmx5LCBkb24ndCBzZW5kIEFsbCBwdWJsaWMga2V5cyFcbiAgICAgICAgICAgIC8vICAgIHZhciBwdWJrZXlzX2FsbCA9IFByaXZhdGVLZXlTdG9yZS5nZXRQdWJrZXlzKCkgLy8gQWxsIHB1YmxpYyBrZXlzXG4gICAgICAgICAgICAvLyAgICB0aGlzLmdldF9yZXF1aXJlZF9zaWduYXR1cmVzKHB1YmtleXNfYWxsKS50aGVuKCByZXF1aXJlZF9wdWJrZXlfc3RyaW5ncyA9PlxuICAgICAgICAgICAgLy8gICAgICAgIGNvbnNvbGUubG9nKCdnZXRfcmVxdWlyZWRfc2lnbmF0dXJlcyBhbGxcXHQnLHJlcXVpcmVkX3B1YmtleV9zdHJpbmdzLnNvcnQoKSwgcHVia2V5c19hbGwpKVxuICAgICAgICAgICAgLy8gICAgdGhpcy5nZXRfcmVxdWlyZWRfc2lnbmF0dXJlcyhteV9wdWJrZXlzKS50aGVuKCByZXF1aXJlZF9wdWJrZXlfc3RyaW5ncyA9PlxuICAgICAgICAgICAgLy8gICAgICAgIGNvbnNvbGUubG9nKCdnZXRfcmVxdWlyZWRfc2lnbmF0dXJlcyBub3JtYWxcXHQnLHJlcXVpcmVkX3B1YmtleV9zdHJpbmdzLnNvcnQoKSwgcHVia2V5cykpXG4gICAgICAgICAgICAvL31cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXMobXlfcHVia2V5cykudGhlbihmdW5jdGlvbiAocmVxdWlyZWRfcHVia2V5cykge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicmVxdWlyZWRfcHVia2V5c1wiLCByZXF1aXJlZF9wdWJrZXlzKTtcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gbXlfcHVia2V5c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdWJrZXlfc3RyaW5nID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicHVia2V5X3N0cmluZ1wiLCBwdWJrZXlfc3RyaW5nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25lcl9wdWJrZXlzX2FkZGVkW3B1YmtleV9zdHJpbmddKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudExvZ2luLnNpZ25UcmFuc2FjdGlvbihfdGhpcywgc2lnbmVyX3B1YmtleXNfYWRkZWQsIHJlcXVpcmVkX3B1YmtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyIHByaXZhdGVfa2V5ID0gY3dhbGxldC5nZXRQcml2YXRlS2V5KHB1YmtleV9zdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiggISBwcml2YXRlX2tleSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBnZXRfcmVxdWlyZWRfc2lnbmF0dXJlcyB3aWxsIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAvLyByZXR1cm5lZCBrZXlzIGZyb20gbXlfcHVia2V5c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc2lnbmluZyBrZXkgZm9yIFwiICsgcHVia2V5X3N0cmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuYWRkX3NpZ25lcihwcml2YXRlX2tleSwgcHVia2V5X3N0cmluZylcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwic2lnbmVyX3B1YmtleXNfYWRkZWRcIiwgc2lnbmVyX3B1YmtleXNfYWRkZWQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyb2FkY2FzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYnJvYWRjYXN0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFR5cGljYWxseSB0aGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGp1c3QgcHJpb3IgdG8gc2lnbmluZy4gIE9uY2UgZmluYWxpemVkIHRoaXMgdHJhbnNhY3Rpb24gY2FuIG5vdCBiZSBjaGFuZ2VkLiAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZmluYWxpemVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmFsaXplKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiVHJ5IHRvIGZpbmFsaXplXCIsIFwiZXhwaXJhdGlvbjpcIiwgdGhpcy5leHBpcmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMyLnRyX2J1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IGZpbmFsaXplZFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKEFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2R5bmFtaWNfZ2xvYmFsX3Byb3BlcnRpZXNcIiwgW10pLnRoZW4oZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZF9ibG9ja190aW1lX3N0cmluZyA9IHIudGltZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMi5leHBpcmF0aW9uID09PSAwKSBfdGhpczIuZXhwaXJhdGlvbiA9IGJhc2VfZXhwaXJhdGlvbl9zZWMoKSArIENoYWluQ29uZmlnLmV4cGlyZV9pbl9zZWNzO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm5ldyBleHBpcmF0aW9uOlwiLCB0aGlzLmV4cGlyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIucmVmX2Jsb2NrX251bSA9IHIuaGVhZF9ibG9ja19udW1iZXIgJiAweEZGRkY7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMi5yZWZfYmxvY2tfcHJlZml4ID0gbmV3IEJ1ZmZlcihyLmhlYWRfYmxvY2tfaWQsICdoZXgnKS5yZWFkVUludDMyTEUoNCk7XG4gICAgICAgICAgICAgICAgICAgIC8vREVCVUcgY29uc29sZS5sb2coXCJyZWZfYmxvY2tcIixAcmVmX2Jsb2NrX251bSxAcmVmX2Jsb2NrX3ByZWZpeCxyKVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVyYWJsZSA9IF90aGlzMi5vcGVyYXRpb25zO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgb3A7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFsxXVtcImZpbmFsaXplXCJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BbMV0uZmluYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpczIudHJfYnVmZmVyID0gb3BzLnRyYW5zYWN0aW9uLnRvQnVmZmVyKF90aGlzMik7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImdldF9keW5hbWljX2dsb2JhbF9wcm9wZXJ0aWVzIGVycjpcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtzdHJpbmd9IGhleCB0cmFuc2FjdGlvbiBJRCAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiaWRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlkKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRyX2J1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBmaW5hbGl6ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFzaC5zaGEyNTYodGhpcy50cl9idWZmZXIpLnRvU3RyaW5nKCdoZXgnKS5zdWJzdHJpbmcoMCwgNDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBUeXBpY2FsbHkgb25lIHdpbGwgdXNlIHtAbGluayB0aGlzLmFkZF90eXBlX29wZXJhdGlvbn0gaW5zdGVhZC5cbiAgICAgICAgICAgIEBhcmcge2FycmF5fSBvcGVyYXRpb24gLSBbb3BlcmF0aW9uX2lkLCBvcGVyYXRpb25dXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhZGRfb3BlcmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRfb3BlcmF0aW9uKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJfYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbGl6ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQob3BlcmF0aW9uLCBcIm9wZXJhdGlvblwiKTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcGVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0aW5nIGFycmF5IFtvcGVyYXRpb25faWQsIG9wZXJhdGlvbl1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0X3R5cGVfb3BlcmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRfdHlwZV9vcGVyYXRpb24obmFtZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cl9idWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IGZpbmFsaXplZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChuYW1lLCBcIm5hbWVcIik7XG4gICAgICAgICAgICBhc3NlcnQob3BlcmF0aW9uLCBcIm9wZXJhdGlvblwiKTtcbiAgICAgICAgICAgIHZhciBfdHlwZSA9IG9wc1tuYW1lXTtcbiAgICAgICAgICAgIGFzc2VydChfdHlwZSwgXCJVbmtub3duIG9wZXJhdGlvbiBcIiArIG5hbWUpO1xuICAgICAgICAgICAgdmFyIG9wZXJhdGlvbl9pZCA9IENoYWluVHlwZXMub3BlcmF0aW9uc1tfdHlwZS5vcGVyYXRpb25fbmFtZV07XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIG9wZXJhdGlvbjogXCIgKyBfdHlwZS5vcGVyYXRpb25fbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wZXJhdGlvbi5mZWUpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uZmVlID0geyBhbW91bnQ6IDAsIGFzc2V0X2lkOiAwIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3Byb3Bvc2FsX2NyZWF0ZScpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uZXhwaXJhdGlvbl90aW1lIHx8IChvcGVyYXRpb24uZXhwaXJhdGlvbl90aW1lID0gYmFzZV9leHBpcmF0aW9uX3NlYygpICsgQ2hhaW5Db25maWcuZXhwaXJlX2luX3NlY3NfcHJvcG9zYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9wZXJhdGlvbl9pbnN0YW5jZSA9IF90eXBlLmZyb21PYmplY3Qob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBbb3BlcmF0aW9uX2lkLCBvcGVyYXRpb25faW5zdGFuY2VdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIG9wdGlvbmFsOiB0aGVyZSBpcyBhIGRlYWZ1bHQgZXhwaXJhdGlvbiAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwic2V0X2V4cGlyZV9zZWNvbmRzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRfZXhwaXJlX3NlY29uZHMoc2VjKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cl9idWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IGZpbmFsaXplZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGlyYXRpb24gPSBiYXNlX2V4cGlyYXRpb25fc2VjKCkgKyBzZWM7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBXcmFwcyB0aGlzIHRyYW5zYWN0aW9uIGluIGEgcHJvcG9zYWxfY3JlYXRlIHRyYW5zYWN0aW9uICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJwcm9wb3NlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wb3NlKHByb3Bvc2FsX2NyZWF0ZV9vcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cl9idWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IGZpbmFsaXplZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5vcGVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZCBvcGVyYXRpb24gZmlyc3RcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFzc2VydChwcm9wb3NhbF9jcmVhdGVfb3B0aW9ucywgXCJwcm9wb3NhbF9jcmVhdGVfb3B0aW9uc1wiKTtcbiAgICAgICAgICAgIGFzc2VydChwcm9wb3NhbF9jcmVhdGVfb3B0aW9ucy5mZWVfcGF5aW5nX2FjY291bnQsIFwicHJvcG9zYWxfY3JlYXRlX29wdGlvbnMuZmVlX3BheWluZ19hY2NvdW50XCIpO1xuXG4gICAgICAgICAgICB2YXIgcHJvcG9zZWRfb3BzID0gdGhpcy5vcGVyYXRpb25zLm1hcChmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBvcDogb3AgfTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zaWduZXJfcHJpdmF0ZV9rZXlzID0gW107XG4gICAgICAgICAgICBwcm9wb3NhbF9jcmVhdGVfb3B0aW9ucy5wcm9wb3NlZF9vcHMgPSBwcm9wb3NlZF9vcHM7XG4gICAgICAgICAgICB0aGlzLmFkZF90eXBlX29wZXJhdGlvbihcInByb3Bvc2FsX2NyZWF0ZVwiLCBwcm9wb3NhbF9jcmVhdGVfb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImhhc19wcm9wb3NlZF9vcGVyYXRpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhc19wcm9wb3NlZF9vcGVyYXRpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFzUHJvcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcGVyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwicHJvcG9zZWRfb3BzXCIgaW4gdGhpcy5vcGVyYXRpb25zW2ldWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1Byb3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaGFzUHJvcG9zZWQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRfcG90ZW50aWFsX3NpZ25hdHVyZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldF9wb3RlbnRpYWxfc2lnbmF0dXJlcygpIHtcbiAgICAgICAgICAgIHZhciB0cl9vYmplY3QgPSBvcHMuc2lnbmVkX3RyYW5zYWN0aW9uLnRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIEFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X3BvdGVudGlhbF9zaWduYXR1cmVzXCIsIFt0cl9vYmplY3RdKS50aGVuKGZ1bmN0aW9uIChwdWJrZXlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcHVia2V5czogcHVia2V5cyB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRfcmVxdWlyZWRfc2lnbmF0dXJlc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXMoYXZhaWxhYmxlX2tleXMpIHtcblxuICAgICAgICAgICAgaWYgKCFhdmFpbGFibGVfa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cl9vYmplY3QgPSBvcHMuc2lnbmVkX3RyYW5zYWN0aW9uLnRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy4uLiB0cl9vYmplY3QnLHRyX29iamVjdClcbiAgICAgICAgICAgIC8vREVCVUcgY29uc29sZS5sb2coJy4uLiB0cl9vYmplY3QnLHRyX29iamVjdClcbiAgICAgICAgICAgIHJldHVybiBBcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9yZXF1aXJlZF9zaWduYXR1cmVzXCIsIFt0cl9vYmplY3QsIGF2YWlsYWJsZV9rZXlzXSkudGhlbihmdW5jdGlvbiAocmVxdWlyZWRfcHVibGljX2tleXMpIHtcbiAgICAgICAgICAgICAgICAvLyBERUJVRyBjb25zb2xlLmxvZygnLi4uIGdldF9yZXF1aXJlZF9zaWduYXR1cmVzJyxyZXF1aXJlZF9wdWJsaWNfa2V5cylcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWlyZWRfcHVibGljX2tleXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFkZF9zaWduZXJcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZF9zaWduZXIocHJpdmF0ZV9rZXkpIHtcbiAgICAgICAgICAgIHZhciBwdWJsaWNfa2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gcHJpdmF0ZV9rZXkudG9QdWJsaWNLZXkoKSA6IGFyZ3VtZW50c1sxXTtcblxuXG4gICAgICAgICAgICBhc3NlcnQocHJpdmF0ZV9rZXkuZCwgXCJyZXF1aXJlZCBQcml2YXRlS2V5IG9iamVjdFwiKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBzaWduZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXB1YmxpY19rZXkuUSkge1xuICAgICAgICAgICAgICAgIHB1YmxpY19rZXkgPSBQdWJsaWNLZXkuZnJvbVB1YmxpY0tleVN0cmluZyhwdWJsaWNfa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICAgICAgdmFyIHNwSGV4ID0gcHJpdmF0ZV9rZXkudG9IZXgoKTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB0aGlzLnNpZ25lcl9wcml2YXRlX2tleXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcFswXS50b0hleCgpID09PSBzcEhleCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNpZ25lcl9wcml2YXRlX2tleXMucHVzaChbcHJpdmF0ZV9rZXksIHB1YmxpY19rZXldKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNpZ25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5faWQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBDaGFpbkNvbmZpZy5uZXR3b3Jrcy5TdGVlbS5jaGFpbl9pZCA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnRyX2J1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBmaW5hbGl6ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IHNpZ25lZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLnNpZ25lcl9wcml2YXRlX2tleXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IDAgPCBlbmQgPyBpIDwgZW5kIDogaSA+IGVuZDsgMCA8IGVuZCA/IGkrKyA6IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBfc2lnbmVyX3ByaXZhdGVfa2V5cyQgPSBfc2xpY2VkVG9BcnJheSh0aGlzLnNpZ25lcl9wcml2YXRlX2tleXNbaV0sIDIpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHByaXZhdGVfa2V5ID0gX3NpZ25lcl9wcml2YXRlX2tleXMkWzBdO1xuICAgICAgICAgICAgICAgIHZhciBwdWJsaWNfa2V5ID0gX3NpZ25lcl9wcml2YXRlX2tleXMkWzFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNpZyA9IFNpZ25hdHVyZS5zaWduQnVmZmVyKEJ1ZmZlci5jb25jYXQoW25ldyBCdWZmZXIoY2hhaW5faWQsICdoZXgnKSwgdGhpcy50cl9idWZmZXJdKSwgcHJpdmF0ZV9rZXksIHB1YmxpY19rZXkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2lnbmF0dXJlcy5wdXNoKHNpZy50b0J1ZmZlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2lnbmVyX3ByaXZhdGVfa2V5cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3BzLnNpZ25lZF90cmFuc2FjdGlvbi50b09iamVjdCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInRvT2JqZWN0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHMuc2lnbmVkX3RyYW5zYWN0aW9uLnRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYnJvYWRjYXN0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBicm9hZGNhc3Qod2FzX2Jyb2FkY2FzdF9jYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRyX2J1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9icm9hZGNhc3Qod2FzX2Jyb2FkY2FzdF9jYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMuX2Jyb2FkY2FzdCh3YXNfYnJvYWRjYXN0X2NhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUcmFuc2FjdGlvbkJ1aWxkZXI7XG59KCk7XG5cbnZhciBiYXNlX2V4cGlyYXRpb25fc2VjID0gZnVuY3Rpb24gYmFzZV9leHBpcmF0aW9uX3NlYygpIHtcbiAgICB2YXIgaGVhZF9ibG9ja19zZWMgPSBNYXRoLmNlaWwoZ2V0SGVhZEJsb2NrRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApO1xuICAgIHZhciBub3dfc2VjID0gTWF0aC5jZWlsKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAvLyBUaGUgaGVhZCBibG9jayB0aW1lIHNob3VsZCBiZSB1cGRhdGVkIGV2ZXJ5IDMgc2Vjb25kcy4gIElmIGl0IGlzbid0XG4gICAgLy8gdGhlbiBoZWxwIHRoZSB0cmFuc2FjdGlvbiB0byBleHBpcmUgKHVzZSBoZWFkX2Jsb2NrX3NlYylcbiAgICBpZiAobm93X3NlYyAtIGhlYWRfYmxvY2tfc2VjID4gMzApIHtcbiAgICAgICAgcmV0dXJuIGhlYWRfYmxvY2tfc2VjO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgdXNlcidzIGNsb2NrIGlzIHZlcnkgZmFyIGJlaGluZCwgdXNlIHRoZSBoZWFkIGJsb2NrIHRpbWUuXG4gICAgcmV0dXJuIE1hdGgubWF4KG5vd19zZWMsIGhlYWRfYmxvY2tfc2VjKTtcbn07XG5cbmZ1bmN0aW9uIF9icm9hZGNhc3Qod2FzX2Jyb2FkY2FzdF9jYWxsYmFjaykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKCFfdGhpczQuc2lnbmVkKSB7XG4gICAgICAgICAgICBfdGhpczQuc2lnbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX3RoaXM0LnRyX2J1ZmZlcikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIm5vdCBmaW5hbGl6ZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX3RoaXM0LnNpZ25hdHVyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwibm90IHNpZ25lZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfdGhpczQub3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJubyBvcGVyYXRpb25zXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKFwibmV0d29ya19icm9hZGNhc3RfYXBpXCIgaW4gQXBpKSkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFwaSBkb2VzIG5vdCBpbmNsdWRlIG5ldHdvcmtfYnJvYWRjYXN0X2FwaVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyX29iamVjdCA9IG9wcy5zaWduZWRfdHJhbnNhY3Rpb24udG9PYmplY3QoX3RoaXM0KTtcblxuICAgICAgICByZXR1cm4gQXBpLm5ldHdvcmtfYnJvYWRjYXN0X2FwaSgpLmV4ZWMoXCJicm9hZGNhc3RfdHJhbnNhY3Rpb25fd2l0aF9jYWxsYmFja1wiLCBbeyByZWplY3Q6IHJlamVjdCwgcmVzb2x2ZTogcmVzb2x2ZSB9LCB0cl9vYmplY3RdKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcuLi4gYnJvYWRjYXN0IHN1Y2Nlc3MsIHdhaXRpbmcgZm9yIGNhbGxiYWNrJylcbiAgICAgICAgICAgIGlmICh3YXNfYnJvYWRjYXN0X2NhbGxiYWNrKSB3YXNfYnJvYWRjYXN0X2NhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2cgbWF5IGJlIHJlZHVuZGFudCBmb3IgbmV0d29yayBlcnJvcnMsIG90aGVyIGVycm9ycyBjb3VsZCBvY2N1clxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKG1lc3NhZ2UgKyBcIlxcblwiICsgJ2dyYXBoZW5lLWNyeXB0byAnICsgJyBkaWdlc3QgJyArIGhhc2guc2hhMjU2KF90aGlzNC50cl9idWZmZXIpLnRvU3RyaW5nKCdoZXgnKSArICcgdHJhbnNhY3Rpb24gJyArIF90aGlzNC50cl9idWZmZXIudG9TdHJpbmcoJ2hleCcpICsgJyAnICsgSlNPTi5zdHJpbmdpZnkodHJfb2JqZWN0KSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SGVhZEJsb2NrRGF0ZSgpIHtcbiAgICByZXR1cm4gdGltZVN0cmluZ1RvRGF0ZShoZWFkX2Jsb2NrX3RpbWVfc3RyaW5nKTtcbn1cblxuZnVuY3Rpb24gdGltZVN0cmluZ1RvRGF0ZSh0aW1lX3N0cmluZykge1xuICAgIGlmICghdGltZV9zdHJpbmcpIHJldHVybiBuZXcgRGF0ZShcIjE5NzAtMDEtMDFUMDA6MDA6MDAuMDAwWlwiKTtcbiAgICBpZiAoIS9aJC8udGVzdCh0aW1lX3N0cmluZykpIC8vZG9lcyBub3QgZW5kIGluIFpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b25vbWV4L2dyYXBoZW5lL2lzc3Vlcy8zNjhcbiAgICAgICAgdGltZV9zdHJpbmcgPSB0aW1lX3N0cmluZyArIFwiWlwiO1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lX3N0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb25CdWlsZGVyO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9jaGFpbi9zcmMvVHJhbnNhY3Rpb25CdWlsZGVyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvY2hhaW4vc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGVscGVyO1xubW9kdWxlLmV4cG9ydHMgPSBoZWxwZXIgPSB7fTtcblxudmFyIHNlY3VyZVJhbmRvbSA9IHJlcXVpcmUoJ3NlY3VyZS1yYW5kb20nKTtcblxuLy9Qcm9taXNlID0gcmVxdWlyZSAnLi4vY29tbW9uL1Byb21pc2UnXG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2J5dGVidWZmZXInKTtcblxudmFyIExvbmcgPSBfcmVxdWlyZS5Mb25nO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4uLy4uL2VjY1wiKTtcblxudmFyIFNpZ25hdHVyZSA9IF9yZXF1aXJlMi5TaWduYXR1cmU7XG5cbnZhciBfcmVxdWlyZTMgPSByZXF1aXJlKFwiLi4vLi4vc2VyaWFsaXplclwiKTtcblxudmFyIG9wcyA9IF9yZXF1aXJlMy5vcHM7XG5cblxuaGVscGVyLnVuaXF1ZV9ub25jZV9lbnRyb3B5ID0gbnVsbDtcbmhlbHBlci51bmlxdWVfbm9uY2VfdWludDY0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbnRyb3B5ID0gaGVscGVyLnVuaXF1ZV9ub25jZV9lbnRyb3B5ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIGlmIChoZWxwZXIudW5pcXVlX25vbmNlX2VudHJvcHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJy4uLiBzZWN1cmVSYW5kb20ucmFuZG9tVWludDhBcnJheSgxKVswXScsc2VjdXJlUmFuZG9tLnJhbmRvbVVpbnQ4QXJyYXkoMSlbMF0pXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoc2VjdXJlUmFuZG9tLnJhbmRvbVVpbnQ4QXJyYXkoMSlbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICsraGVscGVyLnVuaXF1ZV9ub25jZV9lbnRyb3B5ICUgMjU2O1xuICAgICAgICB9XG4gICAgfSgpO1xuICAgIHZhciBsb25nID0gTG9uZy5mcm9tTnVtYmVyKERhdGUubm93KCkpO1xuICAgIC8vY29uc29sZS5sb2coJ3VuaXF1ZV9ub25jZV91aW50NjQgZGF0ZVxcdCcsQnl0ZUJ1ZmZlci5hbGxvY2F0ZSg4KS53cml0ZVVpbnQ2NChsb25nKS50b0hleCgwKSlcbiAgICAvL2NvbnNvbGUubG9nKCd1bmlxdWVfbm9uY2VfdWludDY0IGVudHJvcHlcXHQnLEJ5dGVCdWZmZXIuYWxsb2NhdGUoOCkud3JpdGVVaW50NjQoTG9uZy5mcm9tTnVtYmVyKGVudHJvcHkpKS50b0hleCgwKSlcbiAgICBsb25nID0gbG9uZy5zaGlmdExlZnQoOCkub3IoTG9uZy5mcm9tTnVtYmVyKGVudHJvcHkpKTtcbiAgICAvL2NvbnNvbGUubG9nKCd1bmlxdWVfbm9uY2VfdWludDY0IHNoaWZ0OFxcdCcsQnl0ZUJ1ZmZlci5hbGxvY2F0ZSg4KS53cml0ZVVpbnQ2NChsb25nKS50b0hleCgwKSlcbiAgICByZXR1cm4gbG9uZy50b1N0cmluZygpO1xufTtcblxuLyogVG9kbywgc2V0IGZlZXMgKi9cbmhlbHBlci50b19qc29uID0gZnVuY3Rpb24gKHRyKSB7XG4gICAgdmFyIGJyb2FkY2FzdCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0ciwgYnJvYWRjYXN0KSB7XG4gICAgICAgIHZhciB0cl9vYmplY3QgPSBvcHMuc2lnbmVkX3RyYW5zYWN0aW9uLnRvT2JqZWN0KHRyKTtcbiAgICAgICAgaWYgKGJyb2FkY2FzdCkge1xuICAgICAgICAgICAgdmFyIG5ldCA9IEFwaXMuaW5zdGFuY2UoKS5uZXR3b3JrX2FwaSgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJy4uLiB0cl9vYmplY3QnLCBKU09OLnN0cmluZ2lmeSh0cl9vYmplY3QpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXQuZXhlYyhcImJyb2FkY2FzdF90cmFuc2FjdGlvblwiLCBbdHJfb2JqZWN0XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJfb2JqZWN0O1xuICAgICAgICB9XG4gICAgfSh0ciwgYnJvYWRjYXN0KTtcbn07XG5cbmhlbHBlci5zaWduZWRfdHJfanNvbiA9IGZ1bmN0aW9uICh0ciwgcHJpdmF0ZV9rZXlzKSB7XG4gICAgdmFyIHRyX2J1ZmZlciA9IG9wcy50cmFuc2FjdGlvbi50b0J1ZmZlcih0cik7XG4gICAgdHIgPSBvcHMudHJhbnNhY3Rpb24udG9PYmplY3QodHIpO1xuICAgIHRyLnNpZ25hdHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IDAgPCBwcml2YXRlX2tleXMubGVuZ3RoID8gaSA8IHByaXZhdGVfa2V5cy5sZW5ndGggOiBpID4gcHJpdmF0ZV9rZXlzLmxlbmd0aDsgMCA8IHByaXZhdGVfa2V5cy5sZW5ndGggPyBpKysgOiBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcml2YXRlX2tleSA9IHByaXZhdGVfa2V5c1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFNpZ25hdHVyZS5zaWduQnVmZmVyKHRyX2J1ZmZlciwgcHJpdmF0ZV9rZXkpLnRvSGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSgpO1xuICAgIHJldHVybiB0cjtcbn07XG5cbmhlbHBlci5leHBpcmVfaW5fbWluID0gZnVuY3Rpb24gKG1pbikge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKSArIG1pbiAqIDYwO1xufTtcblxuaGVscGVyLnNlY29uZHNfZnJvbV9ub3cgPSBmdW5jdGlvbiAodGltZW91dF9zZWMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkgKyB0aW1lb3V0X3NlYztcbn07XG5cbi8qKlxuICAgIFByaW50IHRvIHRoZSBjb25zb2xlIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbnkgb2JqZWN0IGluXG4gICAgQGdyYXBoZW5lL3NlcmlhbGl6ZXIgeyB0eXBlcyB9XG4qL1xuaGVscGVyLnRlbXBsYXRlID0gZnVuY3Rpb24gKHNlcmlhbGl6ZXJfb3BlcmF0aW9uX3R5cGVfbmFtZSkge1xuICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHsgdXNlX2RlZmF1bHQ6IHRydWUsIGFubm90YXRlOiB0cnVlIH0gOiBhcmd1bWVudHNbMV07XG5cbiAgICB2YXIgc28gPSB0eXBlW3NlcmlhbGl6ZXJfb3BlcmF0aW9uX3R5cGVfbmFtZV07XG4gICAgaWYgKCFzbykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gc2VyaWFsaXplcl9vcGVyYXRpb25fdHlwZSAnICsgc2VyaWFsaXplcl9vcGVyYXRpb25fdHlwZV9uYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvLnRvT2JqZWN0KHVuZGVmaW5lZCwgZGVidWcpO1xufTtcblxuaGVscGVyLm5ld19vcGVyYXRpb24gPSBmdW5jdGlvbiAoc2VyaWFsaXplcl9vcGVyYXRpb25fdHlwZV9uYW1lKSB7XG4gICAgdmFyIHNvID0gdHlwZVtzZXJpYWxpemVyX29wZXJhdGlvbl90eXBlX25hbWVdO1xuICAgIGlmICghc28pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHNlcmlhbGl6ZXJfb3BlcmF0aW9uX3R5cGUgJyArIHNlcmlhbGl6ZXJfb3BlcmF0aW9uX3R5cGVfbmFtZSk7XG4gICAgfVxuICAgIHZhciBvYmplY3QgPSBzby50b09iamVjdCh1bmRlZmluZWQsIHsgdXNlX2RlZmF1bHQ6IHRydWUsIGFubm90YXRlOiB0cnVlIH0pO1xuICAgIHJldHVybiBzby5mcm9tT2JqZWN0KG9iamVjdCk7XG59O1xuXG5oZWxwZXIuaW5zdGFuY2UgPSBmdW5jdGlvbiAoT2JqZWN0SWQpIHtcbiAgICByZXR1cm4gT2JqZWN0SWQuc3Vic3RyaW5nKFwiMC4wLlwiLmxlbmd0aCk7XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9jaGFpbi9zcmMvVHJhbnNhY3Rpb25IZWxwZXIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9jaGFpbi9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQWRkcmVzczogcmVxdWlyZShcIi4vc3JjL2FkZHJlc3NcIiksXG4gICAgQWVzOiByZXF1aXJlKFwiLi9zcmMvYWVzXCIpLFxuICAgIFByaXZhdGVLZXk6IHJlcXVpcmUoXCIuL3NyYy9Qcml2YXRlS2V5XCIpLFxuICAgIFB1YmxpY0tleTogcmVxdWlyZShcIi4vc3JjL1B1YmxpY0tleVwiKSxcbiAgICBTaWduYXR1cmU6IHJlcXVpcmUoXCIuL3NyYy9zaWduYXR1cmVcIiksXG4gICAgYnJhaW5LZXk6IHJlcXVpcmUoXCIuL3NyYy9CcmFpbktleVwiKSxcbiAgICBoYXNoOiByZXF1aXJlKFwiLi9zcmMvaGFzaFwiKSxcbiAgICBrZXk6IHJlcXVpcmUoXCIuL3NyYy9LZXlVdGlsc1wiKVxufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvZWNjL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvZWNjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShicmFpbktleSkge1xuICAgIGlmICh0eXBlb2YgYnJhaW5LZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0cmluZyByZXF1aXJlZCBmb3IgYnJhaW5LZXlcIik7XG4gICAgfVxuICAgIGJyYWluS2V5ID0gYnJhaW5LZXkudHJpbSgpO1xuICAgIHJldHVybiBicmFpbktleS5zcGxpdCgvW1xcdFxcblxcdlxcZlxcciBdKy8pLmpvaW4oJyAnKTtcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmMvQnJhaW5LZXkuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9lY2Mvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBrZXk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vUHJpdmF0ZUtleScpO1xudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vUHVibGljS2V5Jyk7XG52YXIgQWRkcmVzcyA9IHJlcXVpcmUoJy4vYWRkcmVzcycpO1xudmFyIEFlcyA9IHJlcXVpcmUoJy4vYWVzJyk7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnLi9oYXNoJyk7XG4vLyB2YXIgZGljdGlvbmFyeSA9IHJlcXVpcmUoJy4vZGljdGlvbmFyeV9lbicpO1xudmFyIHNlY3VyZVJhbmRvbSA9IHJlcXVpcmUoJ3NlY3VyZS1yYW5kb20nKTtcbnZhciBDaGFpbkNvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jaGFpbi9zcmMvQ2hhaW5Db25maWdcIik7XG5cbi8vIGhhc2ggZm9yIC4yNSBzZWNvbmRcbnZhciBIQVNIX1BPV0VSX01JTExTID0gMjUwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleSA9IHtcblxuICAgIC8qKiBVc2VzIDEgc2Vjb25kIG9mIGhhc2hpbmcgcG93ZXIgdG8gY3JlYXRlIGEga2V5L3Bhc3N3b3JkIGNoZWNrc3VtLiAgQW5cbiAgICBpbXBsZW1lbnRhdGlvbiBjYW4gcmUtY2FsbCB0aGlzIG1ldGhvZCB3aXRoIHRoZSBzYW1lIHBhc3N3b3JkIHRvIHJlLW1hdGNoXG4gICAgdGhlIHN0cmVuZ3RoIG9mIHRoZSBDUFUgKGVpdGhlciBhZnRlciBtb3ZpbmcgZnJvbSBhIGRlc2t0b3AgdG8gYSBtb2JpbGUsXG4gICAgbW9iaWxlIHRvIGRlc2t0b3AsIG9yIE4geWVhcnMgZnJvbSBub3cgd2hlbiBDUFVzIGFyZSBwcmVzdW1hYmx5IHN0cm9uZ2VyKS5cbiAgICAgQSBzYWx0IGlzIHVzZWQgZm9yIGFsbCB0aGUgbm9ybWFsIHJlYXNvbnMuLi5cbiAgICAgQHJldHVybiBvYmplY3Qge1xuICAgICAgICBhZXNfcHJpdmF0ZTogQWVzLFxuICAgICAgICBjaGVja3N1bTogXCJ7aGFzaF9pdGVyYXRpb25fY291bnR9LHtzYWx0fSx7Y2hlY2tzdW19XCJcbiAgICB9XG4gICAgKi9cblxuICAgIGFlc19jaGVja3N1bTogZnVuY3Rpb24gYWVzX2NoZWNrc3VtKHBhc3N3b3JkKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiBwYXNzd29yZCA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBcInBhc3N3b3JkIHN0cmluZyByZXF1aXJlZFwiKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNhbHQgPSBzZWN1cmVSYW5kb20ucmFuZG9tQnVmZmVyKDQpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgICB2YXIgc2VjcmV0ID0gc2FsdCArIHBhc3N3b3JkO1xuICAgICAgICAvLyBoYXNoIGZvciAuMSBzZWNvbmRcbiAgICAgICAgdmFyIHN0YXJ0X3QgPSBEYXRlLm5vdygpO1xuICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0X3QgPCBIQVNIX1BPV0VSX01JTExTKSB7XG4gICAgICAgICAgICBzZWNyZXQgPSBoYXNoLnNoYTI1NihzZWNyZXQpO1xuICAgICAgICAgICAgaXRlcmF0aW9ucyArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoZWNrc3VtID0gaGFzaC5zaGEyNTYoc2VjcmV0KTtcbiAgICAgICAgdmFyIGNoZWNrc3VtX3N0cmluZyA9IFtpdGVyYXRpb25zLCBzYWx0LnRvU3RyaW5nKCdoZXgnKSwgY2hlY2tzdW0uc2xpY2UoMCwgNCkudG9TdHJpbmcoJ2hleCcpXS5qb2luKCcsJyk7XG5cbiAgICAgICAgcmV0dXJuIHsgYWVzX3ByaXZhdGU6IEFlcy5mcm9tU2VlZChzZWNyZXQpLFxuICAgICAgICAgICAgY2hlY2tzdW06IGNoZWNrc3VtX3N0cmluZ1xuICAgICAgICB9O1xuICAgIH0sXG5cblxuICAgIC8qKiBQcm92aWRlIGEgbWF0Y2hpbmcgcGFzc3dvcmQgYW5kIGtleV9jaGVja3N1bS4gIEEgXCJ3cm9uZyBwYXNzd29yZFwiXG4gICAgZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBwYXNzd29yZCBkb2VzIG5vdCBtYXRjaC4gIElmIHRoaXMgbWV0aG9kIHRha2VzXG4gICAgbXVjaCBtb3JlIG9yIGxlc3MgdGhhbiAxIHNlY29uZCB0byByZXR1cm4sIG9uZSBzaG91bGQgY29uc2lkZXIgdXBkYXRpbmdcbiAgICBhbGwgZW5jeXJwdGVkIGZpZWxkcyB1c2luZyBhIG5ldyBrZXkua2V5X2NoZWNrc3VtLlxuICAgICovXG4gICAgYWVzX3ByaXZhdGU6IGZ1bmN0aW9uIGFlc19wcml2YXRlKHBhc3N3b3JkLCBrZXlfY2hlY2tzdW0pIHtcbiAgICAgICAgdmFyIF9rZXlfY2hlY2tzdW0kc3BsaXQgPSBrZXlfY2hlY2tzdW0uc3BsaXQoJywnKTtcblxuICAgICAgICB2YXIgX2tleV9jaGVja3N1bSRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfa2V5X2NoZWNrc3VtJHNwbGl0LCAzKTtcblxuICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IF9rZXlfY2hlY2tzdW0kc3BsaXQyWzBdO1xuICAgICAgICB2YXIgc2FsdCA9IF9rZXlfY2hlY2tzdW0kc3BsaXQyWzFdO1xuICAgICAgICB2YXIgY2hlY2tzdW0gPSBfa2V5X2NoZWNrc3VtJHNwbGl0MlsyXTtcblxuICAgICAgICB2YXIgc2VjcmV0ID0gc2FsdCArIHBhc3N3b3JkO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgMCA8IGl0ZXJhdGlvbnMgPyBpIDwgaXRlcmF0aW9ucyA6IGkgPiBpdGVyYXRpb25zOyAwIDwgaXRlcmF0aW9ucyA/IGkrKyA6IGkrKykge1xuICAgICAgICAgICAgc2VjcmV0ID0gaGFzaC5zaGEyNTYoc2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3X2NoZWNrc3VtID0gaGFzaC5zaGEyNTYoc2VjcmV0KTtcbiAgICAgICAgaWYgKCEobmV3X2NoZWNrc3VtLnNsaWNlKDAsIDQpLnRvU3RyaW5nKCdoZXgnKSA9PT0gY2hlY2tzdW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3cm9uZyBwYXNzd29yZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQWVzLmZyb21TZWVkKHNlY3JldCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICAgIEEgd2VlayByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBjYW4gcnVuIG91dCBvZiBlbnRyb3B5LiAgVGhpcyBzaG91bGQgZW5zdXJlIGV2ZW4gdGhlIHdvcnN0IHJhbmRvbSBudW1iZXIgaW1wbGVtZW50YXRpb24gd2lsbCBiZSByZWFzb25hYmx5IHNhZmUuXG4gICAgICAgICBAcGFyYW0xIHN0cmluZyBlbnRyb3B5IG9mIGF0IGxlYXN0IDMyIGJ5dGVzXG4gICAgKi9cbiAgICByYW5kb20zMkJ5dGVCdWZmZXI6IGZ1bmN0aW9uIHJhbmRvbTMyQnl0ZUJ1ZmZlcigpIHtcbiAgICAgICAgdmFyIGVudHJvcHkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0aGlzLmJyb3dzZXJFbnRyb3B5KCkgOiBhcmd1bWVudHNbMF07XG5cblxuICAgICAgICBpZiAoISh0eXBlb2YgZW50cm9weSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgcmVxdWlyZWQgZm9yIGVudHJvcHlcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cm9weS5sZW5ndGggPCAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0aW5nIGF0IGxlYXN0IDMyIGJ5dGVzIG9mIGVudHJvcHlcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRfdCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydF90IDwgSEFTSF9QT1dFUl9NSUxMUykge1xuICAgICAgICAgICAgZW50cm9weSA9IGhhc2guc2hhMjU2KGVudHJvcHkpO1xuICAgICAgICB9dmFyIGhhc2hfYXJyYXkgPSBbXTtcbiAgICAgICAgaGFzaF9hcnJheS5wdXNoKGVudHJvcHkpO1xuXG4gICAgICAgIC8vIEhhc2hpbmcgZm9yIDEgc2Vjb25kIG1heSBoZWxwcyB0aGUgY29tcHV0ZXIgaXMgbm90IGxvdyBvbiBlbnRyb3B5ICh0aGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIGJhY2stdG8tYmFjaykuXG4gICAgICAgIGhhc2hfYXJyYXkucHVzaChzZWN1cmVSYW5kb20ucmFuZG9tQnVmZmVyKDMyKSk7XG5cbiAgICAgICAgcmV0dXJuIGhhc2guc2hhMjU2KEJ1ZmZlci5jb25jYXQoaGFzaF9hcnJheSkpO1xuICAgIH0sXG5cblxuICAgIHN1Z2dlc3RfYnJhaW5fa2V5OiBmdW5jdGlvbiBzdWdnZXN0X2JyYWluX2tleSgpIHtcbiAgICAgICAgdmFyIGRpY3Rpb25hcnkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBcIixcIiA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGVudHJvcHkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0aGlzLmJyb3dzZXJFbnRyb3B5KCkgOiBhcmd1bWVudHNbMV07XG5cblxuICAgICAgICB2YXIgcmFuZG9tQnVmZmVyID0gdGhpcy5yYW5kb20zMkJ5dGVCdWZmZXIoZW50cm9weSk7XG5cbiAgICAgICAgdmFyIHdvcmRfY291bnQgPSAxNjtcbiAgICAgICAgdmFyIGRpY3Rpb25hcnlfbGluZXMgPSBkaWN0aW9uYXJ5LnNwbGl0KCcsJyk7XG5cbiAgICAgICAgaWYgKCEoZGljdGlvbmFyeV9saW5lcy5sZW5ndGggPT09IDQ5NzQ0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgJyArIDQ5NzQ0ICsgJyBidXQgZ290ICcgKyBkaWN0aW9uYXJ5X2xpbmVzLmxlbmd0aCArICcgZGljdGlvbmFyeSB3b3JkcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJyYWlua2V5ID0gW107XG4gICAgICAgIHZhciBlbmQgPSB3b3JkX2NvdW50ICogMjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSArPSAyKSB7XG5cbiAgICAgICAgICAgIC8vIHJhbmRvbUJ1ZmZlciBoYXMgMjU2IGJpdHMgLyAxNiBiaXRzIHBlciB3b3JkID09IDE2IHdvcmRzXG4gICAgICAgICAgICB2YXIgbnVtID0gKHJhbmRvbUJ1ZmZlcltpXSA8PCA4KSArIHJhbmRvbUJ1ZmZlcltpICsgMV07XG5cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgaW50byBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgKGluY2x1c2l2ZSlcbiAgICAgICAgICAgIHZhciBybmRNdWx0aXBsaWVyID0gbnVtIC8gTWF0aC5wb3coMiwgMTYpO1xuICAgICAgICAgICAgdmFyIHdvcmRJbmRleCA9IE1hdGgucm91bmQoZGljdGlvbmFyeV9saW5lcy5sZW5ndGggKiBybmRNdWx0aXBsaWVyKTtcblxuICAgICAgICAgICAgYnJhaW5rZXkucHVzaChkaWN0aW9uYXJ5X2xpbmVzW3dvcmRJbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZV9icmFpbktleShicmFpbmtleS5qb2luKCcgJykpO1xuICAgIH0sXG5cbiAgICBnZXRfcmFuZG9tX2tleTogZnVuY3Rpb24gZ2V0X3JhbmRvbV9rZXkoZW50cm9weSkge1xuICAgICAgICByZXR1cm4gUHJpdmF0ZUtleS5mcm9tQnVmZmVyKHRoaXMucmFuZG9tMzJCeXRlQnVmZmVyKGVudHJvcHkpKTtcbiAgICB9LFxuICAgIGdldF9icmFpblByaXZhdGVLZXk6IGZ1bmN0aW9uIGdldF9icmFpblByaXZhdGVLZXkoYnJhaW5LZXkpIHtcbiAgICAgICAgdmFyIHNlcXVlbmNlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICBpZiAoc2VxdWVuY2UgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlcXVlbmNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyYWluS2V5ID0ga2V5Lm5vcm1hbGl6ZV9icmFpbktleShicmFpbktleSk7XG4gICAgICAgIHJldHVybiBQcml2YXRlS2V5LmZyb21CdWZmZXIoaGFzaC5zaGEyNTYoaGFzaC5zaGE1MTIoYnJhaW5LZXkgKyBcIiBcIiArIHNlcXVlbmNlKSkpO1xuICAgIH0sXG5cblxuICAgIC8vIFR1cm4gaW52aXNpYmxlIHNwYWNlIGxpa2UgY2hhcmFjdGVycyBpbnRvIGEgc2luZ2xlIHNwYWNlXG4gICAgbm9ybWFsaXplX2JyYWluS2V5OiBmdW5jdGlvbiBub3JtYWxpemVfYnJhaW5LZXkoYnJhaW5LZXkpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIGJyYWluS2V5ID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0cmluZyByZXF1aXJlZCBmb3IgYnJhaW5LZXlcIik7XG4gICAgICAgIH1cblxuICAgICAgICBicmFpbktleSA9IGJyYWluS2V5LnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIGJyYWluS2V5LnNwbGl0KC9bXFx0XFxuXFx2XFxmXFxyIF0rLykuam9pbignICcpO1xuICAgIH0sXG4gICAgYnJvd3NlckVudHJvcHk6IGZ1bmN0aW9uIGJyb3dzZXJFbnRyb3B5KCkge1xuXG4gICAgICAgIHZhciBlbnRyb3B5U3RyID0gXCJcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVudHJvcHlTdHIgPSBuZXcgRGF0ZSgpLnRvU3RyaW5nKCkgKyBcIiBcIiArIHdpbmRvdy5zY3JlZW4uaGVpZ2h0ICsgXCIgXCIgKyB3aW5kb3cuc2NyZWVuLndpZHRoICsgXCIgXCIgKyB3aW5kb3cuc2NyZWVuLmNvbG9yRGVwdGggKyBcIiBcIiArIFwiIFwiICsgd2luZG93LnNjcmVlbi5hdmFpbEhlaWdodCArIFwiIFwiICsgd2luZG93LnNjcmVlbi5hdmFpbFdpZHRoICsgXCIgXCIgKyB3aW5kb3cuc2NyZWVuLnBpeGVsRGVwdGggKyBuYXZpZ2F0b3IubGFuZ3VhZ2UgKyBcIiBcIiArIHdpbmRvdy5sb2NhdGlvbiArIFwiIFwiICsgd2luZG93Lmhpc3RvcnkubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbWltZVR5cGU7IGkgPCBuYXZpZ2F0b3IubWltZVR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWltZVR5cGUgPSBuYXZpZ2F0b3IubWltZVR5cGVzW2ldO1xuICAgICAgICAgICAgICAgIGVudHJvcHlTdHIgKz0gbWltZVR5cGUuZGVzY3JpcHRpb24gKyBcIiBcIiArIG1pbWVUeXBlLnR5cGUgKyBcIiBcIiArIG1pbWVUeXBlLnN1ZmZpeGVzICsgXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIklORk9cXHRicm93c2VyRW50cm9weSBnYXRoZXJlZFwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vbm9kZWpzOlJlZmVyZW5jZUVycm9yOiB3aW5kb3cgaXMgbm90IGRlZmluZWRcbiAgICAgICAgICAgIGVudHJvcHlTdHIgPSBoYXNoLnNoYTI1NihuZXcgRGF0ZSgpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGIgPSBuZXcgQnVmZmVyKGVudHJvcHlTdHIpO1xuICAgICAgICBlbnRyb3B5U3RyICs9IGIudG9TdHJpbmcoJ2JpbmFyeScpICsgXCIgXCIgKyBuZXcgRGF0ZSgpLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBlbnRyb3B5U3RyO1xuICAgIH0sXG5cblxuICAgIC8vIEByZXR1cm4gYXJyYXkgb2YgNSBsZWdhY3kgYWRkcmVzc2VzIGZvciBhIHB1YmtleSBzdHJpbmcgcGFyYW1ldGVyLlxuICAgIGFkZHJlc3NlczogZnVuY3Rpb24gYWRkcmVzc2VzKHB1YmtleSkge1xuICAgICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBDaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeCA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICB2YXIgcHVibGljX2tleSA9IFB1YmxpY0tleS5mcm9tUHVibGljS2V5U3RyaW5nKHB1YmtleSwgYWRkcmVzc19wcmVmaXgpO1xuICAgICAgICAvLyBTIEwgTyBXXG4gICAgICAgIHZhciBhZGRyZXNzX3N0cmluZyA9IFtBZGRyZXNzLmZyb21QdWJsaWMocHVibGljX2tleSwgZmFsc2UsIDApLnRvU3RyaW5nKGFkZHJlc3NfcHJlZml4KSwgLy8gYnRjX3VuY29tcHJlc3NlZFxuICAgICAgICBBZGRyZXNzLmZyb21QdWJsaWMocHVibGljX2tleSwgdHJ1ZSwgMCkudG9TdHJpbmcoYWRkcmVzc19wcmVmaXgpLCAvLyBidGNfY29tcHJlc3NlZFxuICAgICAgICBBZGRyZXNzLmZyb21QdWJsaWMocHVibGljX2tleSwgZmFsc2UsIDU2KS50b1N0cmluZyhhZGRyZXNzX3ByZWZpeCksIC8vIHB0c191bmNvbXByZXNzZWRcbiAgICAgICAgQWRkcmVzcy5mcm9tUHVibGljKHB1YmxpY19rZXksIHRydWUsIDU2KS50b1N0cmluZyhhZGRyZXNzX3ByZWZpeCksIC8vIHB0c19jb21wcmVzc2VkXG4gICAgICAgIHB1YmxpY19rZXkudG9BZGRyZXNzU3RyaW5nKGFkZHJlc3NfcHJlZml4KSAvLyBidHNfc2hvcnQsIG1vc3QgcmVjZW50IGZvcm1hdFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gYWRkcmVzc19zdHJpbmc7XG4gICAgfVxufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvZWNjL3NyYy9LZXlVdGlscy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBlY3VydmUgPSByZXF1aXJlKCdlY3VydmUnKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnZWN1cnZlJyk7XG5cbnZhciBQb2ludCA9IF9yZXF1aXJlLlBvaW50O1xudmFyIGdldEN1cnZlQnlOYW1lID0gX3JlcXVpcmUuZ2V0Q3VydmVCeU5hbWU7XG5cbnZhciBzZWNwMjU2azEgPSBnZXRDdXJ2ZUJ5TmFtZSgnc2VjcDI1NmsxJyk7XG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKTtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ2JzNTgnKTtcblxudmFyIGVuY29kZSA9IF9yZXF1aXJlMi5lbmNvZGU7XG52YXIgZGVjb2RlID0gX3JlcXVpcmUyLmRlY29kZTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIGhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKTtcbnZhciBQdWJsaWNLZXkgPSByZXF1aXJlKCcuL1B1YmxpY0tleScpO1xudmFyIGRlZXBFcXVhbCA9IHJlcXVpcmUoXCJkZWVwLWVxdWFsXCIpO1xuXG52YXIgRyA9IHNlY3AyNTZrMS5HO1xudmFyIG4gPSBzZWNwMjU2azEubjtcblxudmFyIFByaXZhdGVLZXkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgICAgQHByaXZhdGUgc2VlIHN0YXRpYyBmdW5jdGlvbnNcbiAgICAgICAgQHBhcmFtIHtCaWdJbnRlZ2VyfVxuICAgICovXG5cbiAgICBmdW5jdGlvbiBQcml2YXRlS2V5KGQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByaXZhdGVLZXkpO1xuXG4gICAgICAgIHRoaXMuZCA9IGQ7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFByaXZhdGVLZXksIFt7XG4gICAgICAgIGtleTogJ3RvV2lmJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvV2lmKCkge1xuICAgICAgICAgICAgdmFyIHByaXZhdGVfa2V5ID0gdGhpcy50b0J1ZmZlcigpO1xuICAgICAgICAgICAgLy8gY2hlY2tzdW0gaW5jbHVkZXMgdGhlIHZlcnNpb25cbiAgICAgICAgICAgIHByaXZhdGVfa2V5ID0gQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihbMHg4MF0pLCBwcml2YXRlX2tleV0pO1xuICAgICAgICAgICAgdmFyIGNoZWNrc3VtID0gaGFzaC5zaGEyNTYocHJpdmF0ZV9rZXkpO1xuICAgICAgICAgICAgY2hlY2tzdW0gPSBoYXNoLnNoYTI1NihjaGVja3N1bSk7XG4gICAgICAgICAgICBjaGVja3N1bSA9IGNoZWNrc3VtLnNsaWNlKDAsIDQpO1xuICAgICAgICAgICAgdmFyIHByaXZhdGVfd2lmID0gQnVmZmVyLmNvbmNhdChbcHJpdmF0ZV9rZXksIGNoZWNrc3VtXSk7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlKHByaXZhdGVfd2lmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgQHJldHVybiB7UG9pbnR9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvUHVibGljS2V5UG9pbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9QdWJsaWNLZXlQb2ludCgpIHtcbiAgICAgICAgICAgIHZhciBRO1xuICAgICAgICAgICAgcmV0dXJuIFEgPSBzZWNwMjU2azEuRy5tdWx0aXBseSh0aGlzLmQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1B1YmxpY0tleScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1B1YmxpY0tleSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnB1YmxpY19rZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNfa2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVibGljX2tleSA9IFB1YmxpY0tleS5mcm9tUG9pbnQodGhpcy50b1B1YmxpY0tleVBvaW50KCkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0J1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmQudG9CdWZmZXIoMzIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEVDSUVTICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldF9zaGFyZWRfc2VjcmV0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldF9zaGFyZWRfc2VjcmV0KHB1YmxpY19rZXkpIHtcbiAgICAgICAgICAgIHZhciBsZWdhY3kgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgICAgcHVibGljX2tleSA9IHRvUHVibGljKHB1YmxpY19rZXkpO1xuICAgICAgICAgICAgdmFyIEtCID0gcHVibGljX2tleS50b1VuY29tcHJlc3NlZCgpLnRvQnVmZmVyKCk7XG4gICAgICAgICAgICB2YXIgS0JQID0gUG9pbnQuZnJvbUFmZmluZShzZWNwMjU2azEsIEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihLQi5zbGljZSgxLCAzMykpLCAvLyB4XG4gICAgICAgICAgICBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoS0Iuc2xpY2UoMzMsIDY1KSkgLy8geVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciByID0gdGhpcy50b0J1ZmZlcigpO1xuICAgICAgICAgICAgdmFyIFAgPSBLQlAubXVsdGlwbHkoQmlnSW50ZWdlci5mcm9tQnVmZmVyKHIpKTtcbiAgICAgICAgICAgIHZhciBTID0gUC5hZmZpbmVYLnRvQnVmZmVyKHsgc2l6ZTogMzIgfSk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgdGhlIGlucHV0IHRvIHNoYTUxMiBtdXN0IGJlIGV4YWN0bHkgMzItYnl0ZXMsIHRvIG1hdGNoIHRoZSBjKysgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgIG9mIGdldF9zaGFyZWRfc2VjcmV0LiAgUmlnaHQgbm93IFMgd2lsbCBiZSBzaG9ydGVyIGlmIHRoZSBtb3N0IHNpZ25pZmljYW50XG4gICAgICAgICAgICBieXRlKHMpIGlzIHplcm8uICBQYWQgaXQgYmFjayB0byB0aGUgZnVsbCAzMi1ieXRlc1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghbGVnYWN5ICYmIFMubGVuZ3RoIDwgMzIpIHtcbiAgICAgICAgICAgICAgICBwYWQgPSBuZXcgQnVmZmVyKDMyIC0gUy5sZW5ndGgpLmZpbGwoMCk7XG4gICAgICAgICAgICAgICAgUyA9IEJ1ZmZlci5jb25jYXQoW3BhZCwgU10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTSEE1MTIgdXNlZCBpbiBFQ0lFU1xuICAgICAgICAgICAgcmV0dXJuIGhhc2guc2hhNTEyKFMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLyoqIEVDSUVTIChkb2VzIG5vdCBhbHdheXMgbWF0Y2ggdGhlIFBvaW50LmZyb21BZmZpbmUgdmVyc2lvbiBhYm92ZSkgKi9cbiAgICAgICAgLy8gZ2V0X3NoYXJlZF9zZWNyZXQocHVibGljX2tleSl7XG4gICAgICAgIC8vICAgICBwdWJsaWNfa2V5ID0gdG9QdWJsaWMocHVibGljX2tleSlcbiAgICAgICAgLy8gICAgIHZhciBQID0gcHVibGljX2tleS5RLm11bHRpcGx5KCB0aGlzLmQgKTtcbiAgICAgICAgLy8gICAgIHZhciBTID0gUC5hZmZpbmVYLnRvQnVmZmVyKHtzaXplOiAzMn0pO1xuICAgICAgICAvLyAgICAgLy8gRUNJRVMsIGFkZHMgYW4gZXh0cmEgc2hhNTEyXG4gICAgICAgIC8vICAgICByZXR1cm4gaGFzaC5zaGE1MTIoUyk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvKiogQHRocm93cyB7RXJyb3J9IC0gb3ZlcmZsb3cgb2YgdGhlIGtleSBjb3VsZCBub3QgYmUgZGVyaXZlZCAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGlsZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGlsZChvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IEJ1ZmZlci5jb25jYXQoW3RoaXMudG9QdWJsaWNLZXkoKS50b0J1ZmZlcigpLCBvZmZzZXRdKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGhhc2guc2hhMjU2KG9mZnNldCk7XG4gICAgICAgICAgICB2YXIgYyA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihvZmZzZXQpO1xuXG4gICAgICAgICAgICBpZiAoYy5jb21wYXJlVG8obikgPj0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgb2Zmc2V0IHdlbnQgb3V0IG9mIGJvdW5kcywgdHJ5IGFnYWluXCIpO1xuXG4gICAgICAgICAgICB2YXIgZGVyaXZlZCA9IHRoaXMuZC5hZGQoYyk7IC8vLm1vZChuKVxuXG4gICAgICAgICAgICBpZiAoZGVyaXZlZC5zaWdudW0oKSA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgb2Zmc2V0IGRlcml2ZWQgdG8gYW4gaW52YWxpZCBrZXksIHRyeSBhZ2FpblwiKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcml2YXRlS2V5KGRlcml2ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogPGhlbHBlcl9mdW5jdGlvbnM+ICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQnl0ZUJ1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J5dGVCdWZmZXIoKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBCeXRlQnVmZmVyKEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWSwgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQnl0ZUJ1ZmZlcihiKTtcbiAgICAgICAgICAgIHJldHVybiBiLmNvcHkoMCwgYi5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0hleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0hleCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogPC9oZWxwZXJfZnVuY3Rpb25zPiAqL1xuXG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2Zyb21CdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWYpIHtcbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RpbmcgcGFyYW10ZXIgdG8gYmUgYSBCdWZmZXIgdHlwZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgzMiAhPT0gYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXQVJOOiBFeHBlY3RpbmcgMzIgYnl0ZXMsIGluc3RlYWQgZ290ICcgKyBidWYubGVuZ3RoICsgJywgc3RhY2sgdHJhY2U6JywgbmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbXB0eSBidWZmZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByaXZhdGVLZXkoQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1ZikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBhcmcge3N0cmluZ30gc2VlZCAtIGFueSBsZW5ndGggc3RyaW5nLiAgVGhpcyBpcyBwcml2YXRlLCB0aGUgc2FtZSBzZWVkIHByb2R1Y2VzIHRoZSBzYW1lIHByaXZhdGUga2V5IGV2ZXJ5IHRpbWUuICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tU2VlZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU2VlZChzZWVkKSB7XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZV9wcml2YXRlX2tleVxuICAgICAgICAgICAgaWYgKCEodHlwZW9mIHNlZWQgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VlZCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJpdmF0ZUtleS5mcm9tQnVmZmVyKGhhc2guc2hhMjU2KHNlZWQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtzdHJpbmd9IFdhbGxldCBJbXBvcnQgRm9ybWF0IChzdGlsbCBhIHNlY3JldCwgTm90IGVuY3J5cHRlZCkgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbVdpZicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tV2lmKF9wcml2YXRlX3dpZikge1xuICAgICAgICAgICAgdmFyIHByaXZhdGVfd2lmID0gbmV3IEJ1ZmZlcihkZWNvZGUoX3ByaXZhdGVfd2lmKSk7XG4gICAgICAgICAgICB2YXIgdmVyc2lvbiA9IHByaXZhdGVfd2lmLnJlYWRVSW50OCgwKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbCgweDgwLCB2ZXJzaW9uLCAnRXhwZWN0ZWQgdmVyc2lvbiAnICsgMHg4MCArICcsIGluc3RlYWQgZ290ICcgKyB2ZXJzaW9uKTtcbiAgICAgICAgICAgIC8vIGNoZWNrc3VtIGluY2x1ZGVzIHRoZSB2ZXJzaW9uXG4gICAgICAgICAgICB2YXIgcHJpdmF0ZV9rZXkgPSBwcml2YXRlX3dpZi5zbGljZSgwLCAtNCk7XG4gICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBwcml2YXRlX3dpZi5zbGljZSgtNCk7XG4gICAgICAgICAgICB2YXIgbmV3X2NoZWNrc3VtID0gaGFzaC5zaGEyNTYocHJpdmF0ZV9rZXkpO1xuICAgICAgICAgICAgbmV3X2NoZWNrc3VtID0gaGFzaC5zaGEyNTYobmV3X2NoZWNrc3VtKTtcbiAgICAgICAgICAgIG5ld19jaGVja3N1bSA9IG5ld19jaGVja3N1bS5zbGljZSgwLCA0KTtcbiAgICAgICAgICAgIHZhciBpc0VxdWFsID0gZGVlcEVxdWFsKGNoZWNrc3VtLCBuZXdfY2hlY2tzdW0pOyAvLywgJ0ludmFsaWQgY2hlY2tzdW0nXG4gICAgICAgICAgICBpZiAoIWlzRXF1YWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGVja3N1bSBkaWQgbm90IG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJpdmF0ZV9rZXkgPSBwcml2YXRlX2tleS5zbGljZSgxKTtcbiAgICAgICAgICAgIHJldHVybiBQcml2YXRlS2V5LmZyb21CdWZmZXIocHJpdmF0ZV9rZXkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tSGV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gUHJpdmF0ZUtleS5mcm9tQnVmZmVyKG5ldyBCdWZmZXIoaGV4LCAnaGV4JykpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFByaXZhdGVLZXk7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJpdmF0ZUtleTtcblxudmFyIHRvUHVibGljID0gZnVuY3Rpb24gdG9QdWJsaWMoZGF0YSkge1xuICAgIHJldHVybiBkYXRhID09IG51bGwgPyBkYXRhIDogZGF0YS5RID8gZGF0YSA6IFB1YmxpY0tleS5mcm9tU3RyaW5nT3JUaHJvdyhkYXRhKTtcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmMvUHJpdmF0ZUtleS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdlY3VydmUnKTtcblxudmFyIFBvaW50ID0gX3JlcXVpcmUuUG9pbnQ7XG52YXIgZ2V0Q3VydmVCeU5hbWUgPSBfcmVxdWlyZS5nZXRDdXJ2ZUJ5TmFtZTtcblxudmFyIHNlY3AyNTZrMSA9IGdldEN1cnZlQnlOYW1lKCdzZWNwMjU2azEnKTtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ2JzNTgnKTtcblxudmFyIGVuY29kZSA9IF9yZXF1aXJlMi5lbmNvZGU7XG52YXIgZGVjb2RlID0gX3JlcXVpcmUyLmRlY29kZTtcblxudmFyIGhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKTtcbnZhciBDaGFpbkNvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jaGFpbi9zcmMvQ2hhaW5Db25maWdcIik7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgZGVlcEVxdWFsID0gcmVxdWlyZShcImRlZXAtZXF1YWxcIik7XG5cbnZhciBHID0gc2VjcDI1NmsxLkc7XG52YXIgbiA9IHNlY3AyNTZrMS5uO1xuXG52YXIgUHVibGljS2V5ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqIEBwYXJhbSB7UG9pbnR9IHB1YmxpYyBrZXkgKi9cblxuICAgIGZ1bmN0aW9uIFB1YmxpY0tleShRKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQdWJsaWNLZXkpO1xuXG4gICAgICAgIHRoaXMuUSA9IFE7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFB1YmxpY0tleSwgW3tcbiAgICAgICAga2V5OiAndG9CdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9CdWZmZXIoKSB7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3NlZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHRoaXMuUSA/IHRoaXMuUS5jb21wcmVzc2VkIDogbnVsbCA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuUSA9PT0gbnVsbCkgcmV0dXJuIG5ldyBCdWZmZXIoJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsICdoZXgnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlEuZ2V0RW5jb2RlZChjb21wcmVzc2VkKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9VbmNvbXByZXNzZWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9VbmNvbXByZXNzZWQoKSB7XG4gICAgICAgICAgICB2YXIgYnVmID0gdGhpcy5RLmdldEVuY29kZWQoZmFsc2UpO1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQuZGVjb2RlRnJvbShzZWNwMjU2azEsIGJ1Zik7XG4gICAgICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21Qb2ludChwb2ludCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogYnRzOjpibG9ja2NoYWluOjphZGRyZXNzICh1bmlxdWUgYnV0IG5vdCBhIGZ1bGwgcHVibGljIGtleSkgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9CbG9ja2NoYWluQWRkcmVzcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0Jsb2NrY2hhaW5BZGRyZXNzKCkge1xuICAgICAgICAgICAgdmFyIHB1Yl9idWYgPSB0aGlzLnRvQnVmZmVyKCk7XG4gICAgICAgICAgICB2YXIgcHViX3NoYSA9IGhhc2guc2hhNTEyKHB1Yl9idWYpO1xuICAgICAgICAgICAgcmV0dXJuIGhhc2gucmlwZW1kMTYwKHB1Yl9zaGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEFsaWFzIGZvciB7QGxpbmsgdG9QdWJsaWNLZXlTdHJpbmd9ICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gQ2hhaW5Db25maWcuYWRkcmVzc19wcmVmaXggOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvUHVibGljS2V5U3RyaW5nKGFkZHJlc3NfcHJlZml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgRnVsbCBwdWJsaWMga2V5XG4gICAgICAgICAgICB7cmV0dXJufSBzdHJpbmdcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9QdWJsaWNLZXlTdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9QdWJsaWNLZXlTdHJpbmcoKSB7XG4gICAgICAgICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBDaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeCA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgICAgdmFyIHB1Yl9idWYgPSB0aGlzLnRvQnVmZmVyKCk7XG4gICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBoYXNoLnJpcGVtZDE2MChwdWJfYnVmKTtcbiAgICAgICAgICAgIHZhciBhZGR5ID0gQnVmZmVyLmNvbmNhdChbcHViX2J1ZiwgY2hlY2tzdW0uc2xpY2UoMCwgNCldKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzX3ByZWZpeCArIGVuY29kZShhZGR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfSBwdWJsaWNfa2V5IC0gbGlrZSBHUEhYeXouLi5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gYWRkcmVzc19wcmVmaXggLSBsaWtlIEdQSFxuICAgICAgICAgICAgQHJldHVybiBQdWJsaWNLZXkgb3IgYG51bGxgIChpZiB0aGUgcHVibGljX2tleSBzdHJpbmcgaXMgaW52YWxpZClcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9BZGRyZXNzU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQWRkcmVzc1N0cmluZygpIHtcbiAgICAgICAgICAgIHZhciBhZGRyZXNzX3ByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IENoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgICAgICB2YXIgcHViX2J1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICAgICAgICAgIHZhciBwdWJfc2hhID0gaGFzaC5zaGE1MTIocHViX2J1Zik7XG4gICAgICAgICAgICB2YXIgYWRkeSA9IGhhc2gucmlwZW1kMTYwKHB1Yl9zaGEpO1xuICAgICAgICAgICAgdmFyIGNoZWNrc3VtID0gaGFzaC5yaXBlbWQxNjAoYWRkeSk7XG4gICAgICAgICAgICBhZGR5ID0gQnVmZmVyLmNvbmNhdChbYWRkeSwgY2hlY2tzdW0uc2xpY2UoMCwgNCldKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzX3ByZWZpeCArIGVuY29kZShhZGR5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9QdHNBZGR5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvUHRzQWRkeSgpIHtcbiAgICAgICAgICAgIHZhciBwdWJfYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICAgICAgICAgICAgdmFyIHB1Yl9zaGEgPSBoYXNoLnNoYTI1NihwdWJfYnVmKTtcbiAgICAgICAgICAgIHZhciBhZGR5ID0gaGFzaC5yaXBlbWQxNjAocHViX3NoYSk7XG4gICAgICAgICAgICBhZGR5ID0gQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihbMHgzOF0pLCBhZGR5XSk7IC8vdmVyc2lvbiA1NihkZWNpbWFsKVxuXG4gICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBoYXNoLnNoYTI1NihhZGR5KTtcbiAgICAgICAgICAgIGNoZWNrc3VtID0gaGFzaC5zaGEyNTYoY2hlY2tzdW0pO1xuXG4gICAgICAgICAgICBhZGR5ID0gQnVmZmVyLmNvbmNhdChbYWRkeSwgY2hlY2tzdW0uc2xpY2UoMCwgNCldKTtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGUoYWRkeSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoaWxkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoaWxkKG9mZnNldCkge1xuXG4gICAgICAgICAgICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKG9mZnNldCksIFwiQnVmZmVyIHJlcXVpcmVkOiBvZmZzZXRcIik7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwob2Zmc2V0Lmxlbmd0aCwgMzIsIFwib2Zmc2V0IGxlbmd0aFwiKTtcblxuICAgICAgICAgICAgb2Zmc2V0ID0gQnVmZmVyLmNvbmNhdChbdGhpcy50b0J1ZmZlcigpLCBvZmZzZXRdKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGhhc2guc2hhMjU2KG9mZnNldCk7XG5cbiAgICAgICAgICAgIHZhciBjID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKG9mZnNldCk7XG5cbiAgICAgICAgICAgIGlmIChjLmNvbXBhcmVUbyhuKSA+PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBvZmZzZXQgd2VudCBvdXQgb2YgYm91bmRzLCB0cnkgYWdhaW5cIik7XG5cbiAgICAgICAgICAgIHZhciBjRyA9IEcubXVsdGlwbHkoYyk7XG4gICAgICAgICAgICB2YXIgUXByaW1lID0gdGhpcy5RLmFkZChjRyk7XG5cbiAgICAgICAgICAgIGlmIChzZWNwMjU2azEuaXNJbmZpbml0eShRcHJpbWUpKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBvZmZzZXQgZGVyaXZlZCB0byBhbiBpbnZhbGlkIGtleSwgdHJ5IGFnYWluXCIpO1xuXG4gICAgICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21Qb2ludChRcHJpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogPEhFWD4gKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9CeXRlQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQnl0ZUJ1ZmZlcigpIHtcbiAgICAgICAgICAgIHZhciBiID0gbmV3IEJ5dGVCdWZmZXIoQnl0ZUJ1ZmZlci5ERUZBVUxUX0NBUEFDSVRZLCBCeXRlQnVmZmVyLkxJVFRMRV9FTkRJQU4pO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRCeXRlQnVmZmVyKGIpO1xuICAgICAgICAgICAgcmV0dXJuIGIuY29weSgwLCBiLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvSGV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiAnZnJvbUJpbmFyeScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQmluYXJ5KGJpbikge1xuICAgICAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tQnVmZmVyKG5ldyBCdWZmZXIoYmluLCAnYmluYXJ5JykpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLnRvU3RyaW5nKCdoZXgnKSA9PT0gJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpIHJldHVybiBuZXcgUHVibGljS2V5KG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoUG9pbnQuZGVjb2RlRnJvbShzZWNwMjU2azEsIGJ1ZmZlcikpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tUG9pbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVBvaW50KHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFB1YmxpY0tleShwb2ludCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21QdWJsaWNLZXlTdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVB1YmxpY0tleVN0cmluZyhwdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBDaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeCA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21TdHJpbmdPclRocm93KHB1YmxpY19rZXksIGFkZHJlc3NfcHJlZml4KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfSBwdWJsaWNfa2V5IC0gbGlrZSBHUEhYeXouLi5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gYWRkcmVzc19wcmVmaXggLSBsaWtlIEdQSFxuICAgICAgICAgICAgQHRocm93cyB7RXJyb3J9IGlmIHB1YmxpYyBrZXkgaXMgaW52YWxpZFxuICAgICAgICAgICAgQHJldHVybiBQdWJsaWNLZXlcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbVN0cmluZ09yVGhyb3cnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVN0cmluZ09yVGhyb3cocHVibGljX2tleSkge1xuICAgICAgICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gQ2hhaW5Db25maWcuYWRkcmVzc19wcmVmaXggOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBwdWJsaWNfa2V5LnNsaWNlKDAsIGFkZHJlc3NfcHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoYWRkcmVzc19wcmVmaXgsIHByZWZpeCwgJ0V4cGVjdGluZyBrZXkgdG8gYmVnaW4gd2l0aCAnICsgYWRkcmVzc19wcmVmaXggKyAnLCBpbnN0ZWFkIGdvdCAnICsgcHJlZml4KTtcbiAgICAgICAgICAgIHB1YmxpY19rZXkgPSBwdWJsaWNfa2V5LnNsaWNlKGFkZHJlc3NfcHJlZml4Lmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHB1YmxpY19rZXkgPSBuZXcgQnVmZmVyKGRlY29kZShwdWJsaWNfa2V5KSwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgdmFyIGNoZWNrc3VtID0gcHVibGljX2tleS5zbGljZSgtNCk7XG4gICAgICAgICAgICBwdWJsaWNfa2V5ID0gcHVibGljX2tleS5zbGljZSgwLCAtNCk7XG4gICAgICAgICAgICB2YXIgbmV3X2NoZWNrc3VtID0gaGFzaC5yaXBlbWQxNjAocHVibGljX2tleSk7XG4gICAgICAgICAgICBuZXdfY2hlY2tzdW0gPSBuZXdfY2hlY2tzdW0uc2xpY2UoMCwgNCk7XG4gICAgICAgICAgICB2YXIgaXNFcXVhbCA9IGRlZXBFcXVhbChjaGVja3N1bSwgbmV3X2NoZWNrc3VtKTsgLy8sICdJbnZhbGlkIGNoZWNrc3VtJ1xuICAgICAgICAgICAgaWYgKCFpc0VxdWFsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hlY2tzdW0gZGlkIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbUJ1ZmZlcihwdWJsaWNfa2V5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbUhleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tQnVmZmVyKG5ldyBCdWZmZXIoaGV4LCAnaGV4JykpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tUHVibGljS2V5U3RyaW5nSGV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21QdWJsaWNLZXlTdHJpbmdIZXgoaGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21QdWJsaWNLZXlTdHJpbmcobmV3IEJ1ZmZlcihoZXgsICdoZXgnKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiA8L0hFWD4gKi9cblxuICAgIH1dKTtcblxuICAgIHJldHVybiBQdWJsaWNLZXk7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHVibGljS2V5O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9lY2Mvc3JjL1B1YmxpY0tleS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBDaGFpbkNvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jaGFpbi9zcmMvQ2hhaW5Db25maWdcIik7XG52YXIgaGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdiczU4Jyk7XG5cbnZhciBlbmNvZGUgPSBfcmVxdWlyZS5lbmNvZGU7XG52YXIgZGVjb2RlID0gX3JlcXVpcmUuZGVjb2RlO1xuXG52YXIgZGVlcEVxdWFsID0gcmVxdWlyZShcImRlZXAtZXF1YWxcIik7XG5cbi8qKiBBZGRyZXNzZXMgYXJlIHNob3J0ZW5lZCBub24tcmV2ZXJzYWJsZSBoYXNoZXMgb2YgYSBwdWJsaWMga2V5LiAgVGhlIGZ1bGwgUHVibGljS2V5IGlzIHByZWZlcnJlZC5cbiAgICBAZGVwcmVjYXRlZFxuKi9cblxudmFyIEFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWRkcmVzcyhhZGR5KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBZGRyZXNzKTtcblxuICAgICAgICB0aGlzLmFkZHkgPSBhZGR5O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhBZGRyZXNzLCBbe1xuICAgICAgICBrZXk6ICd0b0J1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZHk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gQ2hhaW5Db25maWcuYWRkcmVzc19wcmVmaXggOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgICAgIHZhciBjaGVja3N1bSA9IGhhc2gucmlwZW1kMTYwKHRoaXMuYWRkeSk7XG4gICAgICAgICAgICB2YXIgYWRkeSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuYWRkeSwgY2hlY2tzdW0uc2xpY2UoMCwgNCldKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzX3ByZWZpeCArIGVuY29kZShhZGR5KTtcbiAgICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAgICBrZXk6ICdmcm9tQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgX2hhc2ggPSBoYXNoLnNoYTUxMihidWZmZXIpO1xuICAgICAgICAgICAgdmFyIGFkZHkgPSBoYXNoLnJpcGVtZDE2MChfaGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoYWRkeSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21TdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBhZGRyZXNzX3ByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IENoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gc3RyaW5nLnNsaWNlKDAsIGFkZHJlc3NfcHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoYWRkcmVzc19wcmVmaXgsIHByZWZpeCwgJ0V4cGVjdGluZyBrZXkgdG8gYmVnaW4gd2l0aCAnICsgYWRkcmVzc19wcmVmaXggKyAnLCBpbnN0ZWFkIGdvdCAnICsgcHJlZml4KTtcbiAgICAgICAgICAgIHZhciBhZGR5ID0gc3RyaW5nLnNsaWNlKGFkZHJlc3NfcHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICBhZGR5ID0gbmV3IEJ1ZmZlcihkZWNvZGUoYWRkeSksICdiaW5hcnknKTtcbiAgICAgICAgICAgIHZhciBjaGVja3N1bSA9IGFkZHkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgYWRkeSA9IGFkZHkuc2xpY2UoMCwgLTQpO1xuICAgICAgICAgICAgdmFyIG5ld19jaGVja3N1bSA9IGhhc2gucmlwZW1kMTYwKGFkZHkpO1xuICAgICAgICAgICAgbmV3X2NoZWNrc3VtID0gbmV3X2NoZWNrc3VtLnNsaWNlKDAsIDQpO1xuICAgICAgICAgICAgdmFyIGlzRXF1YWwgPSBkZWVwRXF1YWwoY2hlY2tzdW0sIG5ld19jaGVja3N1bSk7IC8vLCAnSW52YWxpZCBjaGVja3N1bSdcbiAgICAgICAgICAgIGlmICghaXNFcXVhbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoZWNrc3VtIGRpZCBub3QgbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoYWRkeSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21QdWJsaWMnLFxuXG5cbiAgICAgICAgLyoqIEByZXR1cm4gQWRkcmVzcyAtIENvbXByZXNzZWQgUFRTIGZvcm1hdCAoYnkgZGVmYXVsdCkgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21QdWJsaWMocHVibGljX2tleSkge1xuICAgICAgICAgICAgdmFyIGNvbXByZXNzZWQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdmFyIHZlcnNpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyA1NiA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgICAgICAgdmFyIHNoYTIgPSBoYXNoLnNoYTI1NihwdWJsaWNfa2V5LnRvQnVmZmVyKGNvbXByZXNzZWQpKTtcbiAgICAgICAgICAgIHZhciByZXAgPSBoYXNoLnJpcGVtZDE2MChzaGEyKTtcbiAgICAgICAgICAgIHZhciB2ZXJzaW9uQnVmZmVyID0gbmV3IEJ1ZmZlcigxKTtcbiAgICAgICAgICAgIHZlcnNpb25CdWZmZXIud3JpdGVVSW50OCgweEZGICYgdmVyc2lvbiwgMCk7XG4gICAgICAgICAgICB2YXIgYWRkciA9IEJ1ZmZlci5jb25jYXQoW3ZlcnNpb25CdWZmZXIsIHJlcF0pO1xuICAgICAgICAgICAgdmFyIGNoZWNrID0gaGFzaC5zaGEyNTYoYWRkcik7XG4gICAgICAgICAgICBjaGVjayA9IGhhc2guc2hhMjU2KGNoZWNrKTtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFthZGRyLCBjaGVjay5zbGljZSgwLCA0KV0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKGhhc2gucmlwZW1kMTYwKGJ1ZmZlcikpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFkZHJlc3M7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWRkcmVzcztcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvZWNjL3NyYy9hZGRyZXNzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvZWNjL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xudmFyIEFFUyA9IHJlcXVpcmUoXCJjcnlwdG8tanMvYWVzXCIpO1xudmFyIGVuY0hleCA9IHJlcXVpcmUoXCJjcnlwdG8tanMvZW5jLWhleFwiKTtcbnZhciBlbmNCYXNlNjQgPSByZXF1aXJlKFwiY3J5cHRvLWpzL2VuYy1iYXNlNjRcIik7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcImJ5dGVidWZmZXJcIik7XG5cbnZhciBMb25nID0gX3JlcXVpcmUuTG9uZztcblxudmFyIGhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKTtcblxuLyoqIFByb3ZpZGVzIHN5bWV0cmljIGVuY3J5cHQgYW5kIGRlY3J5cHQgdmlhIEFFUy4gKi9cblxudmFyIEFlcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgZnVuY3Rpb24gQWVzKGl2LCBrZXkpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFlcyk7XG5cbiAgICAgICAgdGhpcy5pdiA9IGl2LCB0aGlzLmtleSA9IGtleTtcbiAgICB9XG5cbiAgICAvKiogVGhpcyBpcyBhbiBleGNlbGxlbnQgd2F5IHRvIGVuc3VyZSB0aGF0IGFsbCByZWZlcmVuY2VzIHRvIEFlcyBjYW4gbm90IG9wZXJhdGUgYW55bW9yZSAoZXhhbXBsZTogYSB3YWxsZXQgYmVjb21lcyBsb2NrZWQpLiAgQW4gYXBwbGljYXRpb24gc2hvdWxkIGVuc3VyZSB0aGVyZSBpcyBvbmx5IG9uZSBBZXMgb2JqZWN0IGluc3RhbmNlIGZvciBhIGdpdmVuIHNlY3JldCBgc2VlZGAuICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhBZXMsIFt7XG4gICAgICAgIGtleTogXCJjbGVhclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdiA9IHRoaXMua2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBhcmcge3N0cmluZ30gc2VlZCAtIHNlY3JldCBzZWVkIG1heSBiZSB1c2VkIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC4gKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9kZWNyeXB0X3dvcmRfYXJyYXlcIixcblxuXG4gICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlY3J5cHRfd29yZF9hcnJheShjaXBoZXIpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzLyNDdXN0b21fS2V5X2FuZF9JVlxuICAgICAgICAgICAgLy8gc2VlIHdhbGxldF9yZWNvcmRzLmNwcCBtYXN0ZXJfa2V5OjpkZWNyeXB0X2tleVxuICAgICAgICAgICAgcmV0dXJuIEFFUy5kZWNyeXB0KHsgY2lwaGVydGV4dDogY2lwaGVyLCBzYWx0OiBudWxsIH0sIHRoaXMua2V5LCB7IGl2OiB0aGlzLml2IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBwcml2YXRlICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfZW5jcnlwdF93b3JkX2FycmF5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZW5jcnlwdF93b3JkX2FycmF5KHBsYWludGV4dCkge1xuICAgICAgICAgICAgLy9odHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy9pc3N1ZXMvZGV0YWlsP2lkPTg1XG4gICAgICAgICAgICB2YXIgY2lwaGVyID0gQUVTLmVuY3J5cHQocGxhaW50ZXh0LCB0aGlzLmtleSwgeyBpdjogdGhpcy5pdiB9KTtcbiAgICAgICAgICAgIHJldHVybiBlbmNCYXNlNjQucGFyc2UoY2lwaGVyLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVzZSBhIGNoZWNrc3VtLCB0aGUgcmV0dXJuZWQgZGF0YSBtdXN0IGJlIHZhbGlkYXRlZCBzb21lIG90aGVyIHdheS5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gY2lwaGVydGV4dFxuICAgICAgICAgICAgQHJldHVybiB7QnVmZmVyfSBiaW5hcnlcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlY3J5cHRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaXBoZXJ0ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dCA9IG5ldyBCdWZmZXIoY2lwaGVydGV4dCwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2lwaGVydGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJidWZmZXIgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoY2lwaGVydGV4dCwgXCJNaXNzaW5nIGNpcGhlciB0ZXh0XCIpO1xuICAgICAgICAgICAgLy8gaGV4IGlzIHRoZSBvbmx5IGNvbW1vbiBmb3JtYXRcbiAgICAgICAgICAgIHZhciBoZXggPSB0aGlzLmRlY3J5cHRIZXgoY2lwaGVydGV4dC50b1N0cmluZygnaGV4JykpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoaGV4LCAnaGV4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogVGhpcyBtZXRob2QgZG9lcyBub3QgdXNlIGEgY2hlY2tzdW0sIHRoZSByZXR1cm5lZCBkYXRhIG11c3QgYmUgdmFsaWRhdGVkIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfSBwbGFpbnRleHRcbiAgICAgICAgICAgIEByZXR1cm4ge0J1ZmZlcn0gYmluYXJ5XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJlbmNyeXB0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbGFpbnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBwbGFpbnRleHQgPSBuZXcgQnVmZmVyKHBsYWludGV4dCwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGxhaW50ZXh0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJ1ZmZlciByZXF1aXJlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vYXNzZXJ0IHBsYWludGV4dCwgXCJNaXNzaW5nIHBsYWluIHRleHRcIlxuICAgICAgICAgICAgLy8gaGV4IGlzIHRoZSBvbmx5IGNvbW1vbiBmb3JtYXRcbiAgICAgICAgICAgIHZhciBoZXggPSB0aGlzLmVuY3J5cHRIZXgocGxhaW50ZXh0LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihoZXgsICdoZXgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB1c2UgYSBjaGVja3N1bSwgdGhlIHJldHVybmVkIGRhdGEgbXVzdCBiZSB2YWxpZGF0ZWQgc29tZSBvdGhlciB3YXkuXG4gICAgICAgICAgICBAYXJnIHtzdHJpbmd8QnVmZmVyfSBwbGFpbnRleHRcbiAgICAgICAgICAgIEByZXR1cm4ge3N0cmluZ30gaGV4XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJlbmNyeXB0VG9IZXhcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuY3J5cHRUb0hleChwbGFpbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGxhaW50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcGxhaW50ZXh0ID0gbmV3IEJ1ZmZlcihwbGFpbnRleHQsICdiaW5hcnknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHBsYWludGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJidWZmZXIgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2Fzc2VydCBwbGFpbnRleHQsIFwiTWlzc2luZyBwbGFpbiB0ZXh0XCJcbiAgICAgICAgICAgIC8vIGhleCBpcyB0aGUgb25seSBjb21tb24gZm9ybWF0XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0SGV4KHBsYWludGV4dC50b1N0cmluZygnaGV4JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVzZSBhIGNoZWNrc3VtLCB0aGUgcmV0dXJuZWQgZGF0YSBtdXN0IGJlIHZhbGlkYXRlZCBzb21lIG90aGVyIHdheS5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gY2lwaGVyIC0gaGV4XG4gICAgICAgICAgICBAcmV0dXJuIHtzdHJpbmd9IGJpbmFyeSAoY291bGQgZWFzaWx5IGJlIHJlYWRhYmxlIHRleHQpXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJkZWNyeXB0SGV4XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyeXB0SGV4KGNpcGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0KGNpcGhlciwgXCJNaXNzaW5nIGNpcGhlciB0ZXh0XCIpO1xuICAgICAgICAgICAgLy8gQ29udmVydCBkYXRhIGludG8gd29yZCBhcnJheXMgKHVzZWQgYnkgQ3J5cHRvKVxuICAgICAgICAgICAgdmFyIGNpcGhlcl9hcnJheSA9IGVuY0hleC5wYXJzZShjaXBoZXIpO1xuICAgICAgICAgICAgdmFyIHBsYWlud29yZHMgPSB0aGlzLl9kZWNyeXB0X3dvcmRfYXJyYXkoY2lwaGVyX2FycmF5KTtcbiAgICAgICAgICAgIHJldHVybiBlbmNIZXguc3RyaW5naWZ5KHBsYWlud29yZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVzZSBhIGNoZWNrc3VtLCB0aGUgcmV0dXJuZWQgZGF0YSBtdXN0IGJlIHZhbGlkYXRlZCBzb21lIG90aGVyIHdheS5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gY2lwaGVyIC0gaGV4XG4gICAgICAgICAgICBAcmV0dXJuIHtCdWZmZXJ9IGVuY29kZWQgYXMgc3BlY2lmaWVkIGJ5IHRoZSBwYXJhbWV0ZXJcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlY3J5cHRIZXhUb0J1ZmZlclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVjcnlwdEhleFRvQnVmZmVyKGNpcGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0KGNpcGhlciwgXCJNaXNzaW5nIGNpcGhlciB0ZXh0XCIpO1xuICAgICAgICAgICAgLy8gQ29udmVydCBkYXRhIGludG8gd29yZCBhcnJheXMgKHVzZWQgYnkgQ3J5cHRvKVxuICAgICAgICAgICAgdmFyIGNpcGhlcl9hcnJheSA9IGVuY0hleC5wYXJzZShjaXBoZXIpO1xuICAgICAgICAgICAgdmFyIHBsYWlud29yZHMgPSB0aGlzLl9kZWNyeXB0X3dvcmRfYXJyYXkoY2lwaGVyX2FycmF5KTtcbiAgICAgICAgICAgIHZhciBwbGFpbmhleCA9IGVuY0hleC5zdHJpbmdpZnkocGxhaW53b3Jkcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihwbGFpbmhleCwgJ2hleCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVzZSBhIGNoZWNrc3VtLCB0aGUgcmV0dXJuZWQgZGF0YSBtdXN0IGJlIHZhbGlkYXRlZCBzb21lIG90aGVyIHdheS5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gY2lwaGVyIC0gaGV4XG4gICAgICAgICAgICBAYXJnIHtzdHJpbmd9IFtlbmNvZGluZyA9ICdiaW5hcnknXSAtIGEgdmFsaWQgQnVmZmVyIGVuY29kaW5nXG4gICAgICAgICAgICBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWQgYXMgc3BlY2lmaWVkIGJ5IHRoZSBwYXJhbWV0ZXJcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlY3J5cHRIZXhUb1RleHRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlY3J5cHRIZXhUb1RleHQoY2lwaGVyKSB7XG4gICAgICAgICAgICB2YXIgZW5jb2RpbmcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyAnYmluYXJ5JyA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdEhleFRvQnVmZmVyKGNpcGhlcikudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVzZSBhIGNoZWNrc3VtLCB0aGUgcmV0dXJuZWQgZGF0YSBtdXN0IGJlIHZhbGlkYXRlZCBzb21lIG90aGVyIHdheS5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gcGxhaW5oZXggLSBoZXggZm9ybWF0XG4gICAgICAgICAgICBAcmV0dXJuIHtTdHJpbmd9IGhleFxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZW5jcnlwdEhleFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW5jcnlwdEhleChwbGFpbmhleCkge1xuICAgICAgICAgICAgdmFyIHBsYWluX2FycmF5ID0gZW5jSGV4LnBhcnNlKHBsYWluaGV4KTtcbiAgICAgICAgICAgIHZhciBjaXBoZXJfYXJyYXkgPSB0aGlzLl9lbmNyeXB0X3dvcmRfYXJyYXkocGxhaW5fYXJyYXkpO1xuICAgICAgICAgICAgcmV0dXJuIGVuY0hleC5zdHJpbmdpZnkoY2lwaGVyX2FycmF5KTtcbiAgICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAgICBrZXk6IFwiZnJvbVNlZWRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TZWVkKHNlZWQpIHtcbiAgICAgICAgICAgIGlmIChzZWVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZWVkIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9oYXNoID0gaGFzaC5zaGE1MTIoc2VlZCk7XG4gICAgICAgICAgICBfaGFzaCA9IF9oYXNoLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICAgIC8vIERFQlVHIGNvbnNvbGUubG9nKCcuLi4gZnJvbVNlZWQgX2hhc2gnLF9oYXNoKVxuICAgICAgICAgICAgcmV0dXJuIEFlcy5mcm9tU2hhNTEyKF9oYXNoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImZyb21TaGE1MTJcIixcblxuXG4gICAgICAgIC8qKiBAYXJnIHtzdHJpbmd9IGhhc2ggLSBBIDEyOCBieXRlIGhleCBzdHJpbmcsIHR5cGljYWxseSBvbmUgd291bGQgY2FsbCB7QGxpbmsgZnJvbVNlZWR9IGluc3RlYWQuICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU2hhNTEyKGhhc2gpIHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChoYXNoLmxlbmd0aCwgMTI4LCBcIkEgU2hhNTEyIGluIEhFWCBzaG91bGQgYmUgMTI4IGNoYXJhY3RlcnMgbG9uZywgaW5zdGVhZCBnb3QgXCIgKyBoYXNoLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgaXYgPSBlbmNIZXgucGFyc2UoaGFzaC5zdWJzdHJpbmcoNjQsIDk2KSk7XG4gICAgICAgICAgICB2YXIga2V5ID0gZW5jSGV4LnBhcnNlKGhhc2guc3Vic3RyaW5nKDAsIDY0KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFlcyhpdiwga2V5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImZyb21CdWZmZXJcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmKSB7XG4gICAgICAgICAgICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGJ1ZiksIFwiRXhwZWN0aW5nIEJ1ZmZlclwiKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChidWYubGVuZ3RoLCA2NCwgXCJBIFNoYTUxMiBCdWZmZXIgc2hvdWxkIGJlIDY0IGNoYXJhY3RlcnMgbG9uZywgaW5zdGVhZCBnb3QgXCIgKyBidWYubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBBZXMuZnJvbVNoYTUxMihidWYudG9TdHJpbmcoXCJoZXhcIikpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgICAgQHRocm93cyB7RXJyb3J9IC0gXCJJbnZhbGlkIEtleSwgLi4uXCJcbiAgICAgICAgICAgIEBhcmcge1ByaXZhdGVLZXl9IHByaXZhdGVfa2V5IC0gcmVxdWlyZWQgYW5kIHVzZWQgZm9yIGRlY3J5cHRpb25cbiAgICAgICAgICAgIEBhcmcge1B1YmxpY0tleX0gcHVibGljX2tleSAtIHJlcXVpcmVkIGFuZCB1c2VkIHRvIGNhbGN1YWx0ZSB0aGUgc2hhcmVkIHNlY3JldFxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfSBbbm9uY2UgPSBcIlwiXSBvcHRpb25hbCBidXQgc2hvdWxkIGFsd2F5cyBiZSBwcm92aWRlZCBhbmQgYmUgdW5pcXVlIHdoZW4gcmUtdXNpbmcgdGhlIHNhbWUgcHJpdmF0ZS9wdWJsaWMga2V5cyBtb3JlIHRoYW4gb25jZS4gIFRoaXMgbm9uY2UgaXMgbm90IGEgc2VjcmV0LlxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfEJ1ZmZlcn0gbWVzc2FnZSAtIEVuY3J5cHRlZCBtZXNzYWdlIGNvbnRhaW5pbmcgYSBjaGVja3N1bVxuICAgICAgICAgICAgQHJldHVybiB7QnVmZmVyfVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZGVjcnlwdF93aXRoX2NoZWNrc3VtXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyeXB0X3dpdGhfY2hlY2tzdW0ocHJpdmF0ZV9rZXksIHB1YmxpY19rZXksIG5vbmNlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgbGVnYWN5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSA0IHx8IGFyZ3VtZW50c1s0XSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbNF07XG5cblxuICAgICAgICAgICAgLy8gV2FybmluZzogRG8gbm90IHB1dCBgbm9uY2UgPSBcIlwiYCBpbiB0aGUgYXJndW1lbnRzLCBpbiBlczYgdGhpcyB3aWxsIG5vdCBjb252ZXJ0IFwibnVsbFwiIGludG8gYW4gZW10cHkgc3RyaW5nXG4gICAgICAgICAgICBpZiAobm9uY2UgPT0gbnVsbCkgLy8gbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICBub25jZSA9IFwiXCI7XG5cbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG5ldyBCdWZmZXIobWVzc2FnZSwgJ2hleCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgUyA9IHByaXZhdGVfa2V5LmdldF9zaGFyZWRfc2VjcmV0KHB1YmxpY19rZXksIGxlZ2FjeSk7XG4gICAgICAgICAgICAvLyBEIEUgQiBVIEdcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdkZWNyeXB0X3dpdGhfY2hlY2tzdW0nLCB7XG4gICAgICAgICAgICAvLyAgICAgcHJpdl90b19wdWI6IHByaXZhdGVfa2V5LnRvUHVibGljS2V5KCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIC8vICAgICBwdWI6IHB1YmxpY19rZXkudG9QdWJsaWNLZXlTdHJpbmcoKSxcbiAgICAgICAgICAgIC8vICAgICBub25jZTogbm9uY2UsXG4gICAgICAgICAgICAvLyAgICAgbWVzc2FnZTogbWVzc2FnZS5sZW5ndGgsXG4gICAgICAgICAgICAvLyAgICAgUzogUy50b1N0cmluZygnaGV4JylcbiAgICAgICAgICAgIC8vIH0pXG5cbiAgICAgICAgICAgIHZhciBhZXMgPSBBZXMuZnJvbVNlZWQoQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAvLyBBIG51bGwgb3IgZW1wdHkgc3RyaW5nIG5vbmNlIHdpbGwgbm90IGVmZmVjdCB0aGUgaGFzaFxuICAgICAgICAgICAgbmV3IEJ1ZmZlcihcIlwiICsgbm9uY2UpLCBuZXcgQnVmZmVyKFMudG9TdHJpbmcoJ2hleCcpKV0pKTtcblxuICAgICAgICAgICAgdmFyIHBsYW5lYnVmZmVyID0gYWVzLmRlY3J5cHQobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoIShwbGFuZWJ1ZmZlci5sZW5ndGggPj0gNCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleSwgY291bGQgbm90IGRlY3J5cHQgbWVzc2FnZSgxKVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gREVCVUcgY29uc29sZS5sb2coJy4uLiBwbGFuZWJ1ZmZlcicscGxhbmVidWZmZXIpXG4gICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBwbGFuZWJ1ZmZlci5zbGljZSgwLCA0KTtcbiAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBwbGFuZWJ1ZmZlci5zbGljZSg0KTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy4uLiBjaGVja3N1bScsY2hlY2tzdW0udG9TdHJpbmcoJ2hleCcpKVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy4uLiBwbGFpbnRleHQnLHBsYWludGV4dC50b1N0cmluZygpKVxuXG4gICAgICAgICAgICB2YXIgbmV3X2NoZWNrc3VtID0gaGFzaC5zaGEyNTYocGxhaW50ZXh0KTtcbiAgICAgICAgICAgIG5ld19jaGVja3N1bSA9IG5ld19jaGVja3N1bS5zbGljZSgwLCA0KTtcbiAgICAgICAgICAgIG5ld19jaGVja3N1bSA9IG5ld19jaGVja3N1bS50b1N0cmluZygnaGV4Jyk7XG5cbiAgICAgICAgICAgIGlmICghKGNoZWNrc3VtLnRvU3RyaW5nKCdoZXgnKSA9PT0gbmV3X2NoZWNrc3VtKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2V5LCBjb3VsZCBub3QgZGVjcnlwdCBtZXNzYWdlKDIpXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZW5jcnlwdF93aXRoX2NoZWNrc3VtXCIsXG5cblxuICAgICAgICAvKiogSWRlbnRpY2FsIHRvIHtAbGluayBkZWNyeXB0X3dpdGhfY2hlY2tzdW19IGJ1dCB1c2VkIHRvIGVuY3J5cHQuICBTaG91bGQgbm90IHRocm93IGFuIGVycm9yLlxuICAgICAgICAgICAgQHJldHVybiB7QnVmZmVyfSBtZXNzYWdlIC0gRW5jcnlwdGVkIG1lc3NhZ2Ugd2hpY2ggaW5jbHVkZXMgYSBjaGVja3N1bVxuICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW5jcnlwdF93aXRoX2NoZWNrc3VtKHByaXZhdGVfa2V5LCBwdWJsaWNfa2V5LCBub25jZSwgbWVzc2FnZSkge1xuXG4gICAgICAgICAgICAvLyBXYXJuaW5nOiBEbyBub3QgcHV0IGBub25jZSA9IFwiXCJgIGluIHRoZSBhcmd1bWVudHMsIGluIGVzNiB0aGlzIHdpbGwgbm90IGNvbnZlcnQgXCJudWxsXCIgaW50byBhbiBlbXRweSBzdHJpbmdcblxuICAgICAgICAgICAgaWYgKG5vbmNlID09IG51bGwpIC8vIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgbm9uY2UgPSBcIlwiO1xuXG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgQnVmZmVyKG1lc3NhZ2UsICdiaW5hcnknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIFMgPSBwcml2YXRlX2tleS5nZXRfc2hhcmVkX3NlY3JldChwdWJsaWNfa2V5KTtcblxuICAgICAgICAgICAgLy8gRCBFIEIgVSBHXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZW5jcnlwdF93aXRoX2NoZWNrc3VtJywge1xuICAgICAgICAgICAgLy8gICAgIHByaXZfdG9fcHViOiBwcml2YXRlX2tleS50b1B1YmxpY0tleSgpLnRvU3RyaW5nKClcbiAgICAgICAgICAgIC8vICAgICBwdWI6IHB1YmxpY19rZXkudG9QdWJsaWNLZXlTdHJpbmcoKVxuICAgICAgICAgICAgLy8gICAgIG5vbmNlOiBub25jZVxuICAgICAgICAgICAgLy8gICAgIG1lc3NhZ2U6IG1lc3NhZ2UubGVuZ3RoXG4gICAgICAgICAgICAvLyAgICAgUzogUy50b1N0cmluZygnaGV4JylcbiAgICAgICAgICAgIC8vIH0pXG5cbiAgICAgICAgICAgIHZhciBhZXMgPSBBZXMuZnJvbVNlZWQoQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAvLyBBIG51bGwgb3IgZW1wdHkgc3RyaW5nIG5vbmNlIHdpbGwgbm90IGVmZmVjdCB0aGUgaGFzaFxuICAgICAgICAgICAgbmV3IEJ1ZmZlcihcIlwiICsgbm9uY2UpLCBuZXcgQnVmZmVyKFMudG9TdHJpbmcoJ2hleCcpKV0pKTtcbiAgICAgICAgICAgIC8vIERFQlVHIGNvbnNvbGUubG9nKCcuLi4gUycsUy50b1N0cmluZygnaGV4JykpXG4gICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBoYXNoLnNoYTI1NihtZXNzYWdlKS5zbGljZSgwLCA0KTtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gQnVmZmVyLmNvbmNhdChbY2hlY2tzdW0sIG1lc3NhZ2VdKTtcbiAgICAgICAgICAgIC8vIERFQlVHIGNvbnNvbGUubG9nKCcuLi4gcGF5bG9hZCcscGF5bG9hZC50b1N0cmluZygpKVxuICAgICAgICAgICAgcmV0dXJuIGFlcy5lbmNyeXB0KHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFlcztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZXM7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmMvYWVzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvZWNjL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOyAvLyBmcm9tIGdpdGh1Yi5jb20vYml0Y29pbmpzL2JpdGNvaW5qcy1saWIgZnJvbSBnaXRodWIuY29tL2NyeXB0b2NvaW5qcy9lY2RzYVxudmFyIGNyeXB0byA9IHJlcXVpcmUoJy4vaGFzaCcpO1xudmFyIGVuZm9yY2VUeXBlID0gcmVxdWlyZSgnLi9lbmZvcmNlX3R5cGVzJyk7XG5cbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpO1xudmFyIEVDU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9lY3NpZ25hdHVyZScpO1xuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjk3OSNzZWN0aW9uLTMuMlxuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY0dlbmVyYXRlSyhjdXJ2ZSwgaGFzaCwgZCwgY2hlY2tTaWcsIG5vbmNlKSB7XG5cbiAgZW5mb3JjZVR5cGUoJ0J1ZmZlcicsIGhhc2gpO1xuICBlbmZvcmNlVHlwZShCaWdJbnRlZ2VyLCBkKTtcblxuICBpZiAobm9uY2UpIHtcbiAgICBoYXNoID0gY3J5cHRvLnNoYTI1NihCdWZmZXIuY29uY2F0KFtoYXNoLCBuZXcgQnVmZmVyKG5vbmNlKV0pKTtcbiAgfVxuXG4gIC8vIHNhbml0eSBjaGVja1xuICBhc3NlcnQuZXF1YWwoaGFzaC5sZW5ndGgsIDMyLCAnSGFzaCBtdXN0IGJlIDI1NiBiaXQnKTtcblxuICB2YXIgeCA9IGQudG9CdWZmZXIoMzIpO1xuICB2YXIgayA9IG5ldyBCdWZmZXIoMzIpO1xuICB2YXIgdiA9IG5ldyBCdWZmZXIoMzIpO1xuXG4gIC8vIFN0ZXAgQlxuICB2LmZpbGwoMSk7XG5cbiAgLy8gU3RlcCBDXG4gIGsuZmlsbCgwKTtcblxuICAvLyBTdGVwIERcbiAgayA9IGNyeXB0by5IbWFjU0hBMjU2KEJ1ZmZlci5jb25jYXQoW3YsIG5ldyBCdWZmZXIoWzBdKSwgeCwgaGFzaF0pLCBrKTtcblxuICAvLyBTdGVwIEVcbiAgdiA9IGNyeXB0by5IbWFjU0hBMjU2KHYsIGspO1xuXG4gIC8vIFN0ZXAgRlxuICBrID0gY3J5cHRvLkhtYWNTSEEyNTYoQnVmZmVyLmNvbmNhdChbdiwgbmV3IEJ1ZmZlcihbMV0pLCB4LCBoYXNoXSksIGspO1xuXG4gIC8vIFN0ZXAgR1xuICB2ID0gY3J5cHRvLkhtYWNTSEEyNTYodiwgayk7XG5cbiAgLy8gU3RlcCBIMS9IMmEsIGlnbm9yZWQgYXMgdGxlbiA9PT0gcWxlbiAoMjU2IGJpdClcbiAgLy8gU3RlcCBIMmJcbiAgdiA9IGNyeXB0by5IbWFjU0hBMjU2KHYsIGspO1xuXG4gIHZhciBUID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKHYpO1xuXG4gIC8vIFN0ZXAgSDMsIHJlcGVhdCB1bnRpbCBUIGlzIHdpdGhpbiB0aGUgaW50ZXJ2YWwgWzEsIG4gLSAxXVxuICB3aGlsZSAoVC5zaWdudW0oKSA8PSAwIHx8IFQuY29tcGFyZVRvKGN1cnZlLm4pID49IDAgfHwgIWNoZWNrU2lnKFQpKSB7XG4gICAgayA9IGNyeXB0by5IbWFjU0hBMjU2KEJ1ZmZlci5jb25jYXQoW3YsIG5ldyBCdWZmZXIoWzBdKV0pLCBrKTtcbiAgICB2ID0gY3J5cHRvLkhtYWNTSEEyNTYodiwgayk7XG5cbiAgICAvLyBTdGVwIEgxL0gyYSwgYWdhaW4sIGlnbm9yZWQgYXMgdGxlbiA9PT0gcWxlbiAoMjU2IGJpdClcbiAgICAvLyBTdGVwIEgyYiBhZ2FpblxuICAgIHYgPSBjcnlwdG8uSG1hY1NIQTI1Nih2LCBrKTtcblxuICAgIFQgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIodik7XG4gIH1cblxuICByZXR1cm4gVDtcbn1cblxuZnVuY3Rpb24gc2lnbihjdXJ2ZSwgaGFzaCwgZCwgbm9uY2UpIHtcblxuICB2YXIgZSA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihoYXNoKTtcbiAgdmFyIG4gPSBjdXJ2ZS5uO1xuICB2YXIgRyA9IGN1cnZlLkc7XG5cbiAgdmFyIHIsIHM7XG4gIHZhciBrID0gZGV0ZXJtaW5pc3RpY0dlbmVyYXRlSyhjdXJ2ZSwgaGFzaCwgZCwgZnVuY3Rpb24gKGspIHtcbiAgICAvLyBmaW5kIGNhbm9uaWNhbGx5IHZhbGlkIHNpZ25hdHVyZVxuICAgIHZhciBRID0gRy5tdWx0aXBseShrKTtcblxuICAgIGlmIChjdXJ2ZS5pc0luZmluaXR5KFEpKSByZXR1cm4gZmFsc2U7XG5cbiAgICByID0gUS5hZmZpbmVYLm1vZChuKTtcbiAgICBpZiAoci5zaWdudW0oKSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcyA9IGsubW9kSW52ZXJzZShuKS5tdWx0aXBseShlLmFkZChkLm11bHRpcGx5KHIpKSkubW9kKG4pO1xuICAgIGlmIChzLnNpZ251bSgpID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbm9uY2UpO1xuXG4gIHZhciBOX09WRVJfVFdPID0gbi5zaGlmdFJpZ2h0KDEpO1xuXG4gIC8vIGVuZm9yY2UgbG93IFMgdmFsdWVzLCBzZWUgYmlwNjI6ICdsb3cgcyB2YWx1ZXMgaW4gc2lnbmF0dXJlcydcbiAgaWYgKHMuY29tcGFyZVRvKE5fT1ZFUl9UV08pID4gMCkge1xuICAgIHMgPSBuLnN1YnRyYWN0KHMpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBFQ1NpZ25hdHVyZShyLCBzKTtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5UmF3KGN1cnZlLCBlLCBzaWduYXR1cmUsIFEpIHtcbiAgdmFyIG4gPSBjdXJ2ZS5uO1xuICB2YXIgRyA9IGN1cnZlLkc7XG5cbiAgdmFyIHIgPSBzaWduYXR1cmUucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUucztcblxuICAvLyAxLjQuMSBFbmZvcmNlIHIgYW5kIHMgYXJlIGJvdGggaW50ZWdlcnMgaW4gdGhlIGludGVydmFsIFsxLCBuIOKIkiAxXVxuICBpZiAoci5zaWdudW0oKSA8PSAwIHx8IHIuY29tcGFyZVRvKG4pID49IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKHMuc2lnbnVtKCkgPD0gMCB8fCBzLmNvbXBhcmVUbyhuKSA+PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gYyA9IHNeLTEgbW9kIG5cbiAgdmFyIGMgPSBzLm1vZEludmVyc2Uobik7XG5cbiAgLy8gMS40LjQgQ29tcHV0ZSB1MSA9IGVzXuKIkjEgbW9kIG5cbiAgLy8gICAgICAgICAgICAgICB1MiA9IHJzXuKIkjEgbW9kIG5cbiAgdmFyIHUxID0gZS5tdWx0aXBseShjKS5tb2Qobik7XG4gIHZhciB1MiA9IHIubXVsdGlwbHkoYykubW9kKG4pO1xuXG4gIC8vIDEuNC41IENvbXB1dGUgUiA9ICh4UiwgeVIpID0gdTFHICsgdTJRXG4gIHZhciBSID0gRy5tdWx0aXBseVR3byh1MSwgUSwgdTIpO1xuXG4gIC8vIDEuNC41IChjb250LikgRW5mb3JjZSBSIGlzIG5vdCBhdCBpbmZpbml0eVxuICBpZiAoY3VydmUuaXNJbmZpbml0eShSKSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIDEuNC42IENvbnZlcnQgdGhlIGZpZWxkIGVsZW1lbnQgUi54IHRvIGFuIGludGVnZXJcbiAgdmFyIHhSID0gUi5hZmZpbmVYO1xuXG4gIC8vIDEuNC43IFNldCB2ID0geFIgbW9kIG5cbiAgdmFyIHYgPSB4Ui5tb2Qobik7XG5cbiAgLy8gMS40LjggSWYgdiA9IHIsIG91dHB1dCBcInZhbGlkXCIsIGFuZCBpZiB2ICE9IHIsIG91dHB1dCBcImludmFsaWRcIlxuICByZXR1cm4gdi5lcXVhbHMocik7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeShjdXJ2ZSwgaGFzaCwgc2lnbmF0dXJlLCBRKSB7XG4gIC8vIDEuNC4yIEggPSBIYXNoKE0pLCBhbHJlYWR5IGRvbmUgYnkgdGhlIHVzZXJcbiAgLy8gMS40LjMgZSA9IEhcbiAgdmFyIGUgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoaGFzaCk7XG4gIHJldHVybiB2ZXJpZnlSYXcoY3VydmUsIGUsIHNpZ25hdHVyZSwgUSk7XG59XG5cbi8qKlxuICAqIFJlY292ZXIgYSBwdWJsaWMga2V5IGZyb20gYSBzaWduYXR1cmUuXG4gICpcbiAgKiBTZWUgU0VDIDE6IEVsbGlwdGljIEN1cnZlIENyeXB0b2dyYXBoeSwgc2VjdGlvbiA0LjEuNiwgXCJQdWJsaWNcbiAgKiBLZXkgUmVjb3ZlcnkgT3BlcmF0aW9uXCIuXG4gICpcbiAgKiBodHRwOi8vd3d3LnNlY2cub3JnL2Rvd25sb2FkL2FpZC03ODAvc2VjMS12Mi5wZGZcbiAgKi9cbmZ1bmN0aW9uIHJlY292ZXJQdWJLZXkoY3VydmUsIGUsIHNpZ25hdHVyZSwgaSkge1xuICBhc3NlcnQuc3RyaWN0RXF1YWwoaSAmIDMsIGksICdSZWNvdmVyeSBwYXJhbSBpcyBtb3JlIHRoYW4gdHdvIGJpdHMnKTtcblxuICB2YXIgbiA9IGN1cnZlLm47XG4gIHZhciBHID0gY3VydmUuRztcblxuICB2YXIgciA9IHNpZ25hdHVyZS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZS5zO1xuXG4gIGFzc2VydChyLnNpZ251bSgpID4gMCAmJiByLmNvbXBhcmVUbyhuKSA8IDAsICdJbnZhbGlkIHIgdmFsdWUnKTtcbiAgYXNzZXJ0KHMuc2lnbnVtKCkgPiAwICYmIHMuY29tcGFyZVRvKG4pIDwgMCwgJ0ludmFsaWQgcyB2YWx1ZScpO1xuXG4gIC8vIEEgc2V0IExTQiBzaWduaWZpZXMgdGhhdCB0aGUgeS1jb29yZGluYXRlIGlzIG9kZFxuICB2YXIgaXNZT2RkID0gaSAmIDE7XG5cbiAgLy8gVGhlIG1vcmUgc2lnbmlmaWNhbnQgYml0IHNwZWNpZmllcyB3aGV0aGVyIHdlIHNob3VsZCB1c2UgdGhlXG4gIC8vIGZpcnN0IG9yIHNlY29uZCBjYW5kaWRhdGUga2V5LlxuICB2YXIgaXNTZWNvbmRLZXkgPSBpID4+IDE7XG5cbiAgLy8gMS4xIExldCB4ID0gciArIGpuXG4gIHZhciB4ID0gaXNTZWNvbmRLZXkgPyByLmFkZChuKSA6IHI7XG4gIHZhciBSID0gY3VydmUucG9pbnRGcm9tWChpc1lPZGQsIHgpO1xuXG4gIC8vIDEuNCBDaGVjayB0aGF0IG5SIGlzIGF0IGluZmluaXR5XG4gIHZhciBuUiA9IFIubXVsdGlwbHkobik7XG4gIGFzc2VydChjdXJ2ZS5pc0luZmluaXR5KG5SKSwgJ25SIGlzIG5vdCBhIHZhbGlkIGN1cnZlIHBvaW50Jyk7XG5cbiAgLy8gQ29tcHV0ZSAtZSBmcm9tIGVcbiAgdmFyIGVOZWcgPSBlLm5lZ2F0ZSgpLm1vZChuKTtcblxuICAvLyAxLjYuMSBDb21wdXRlIFEgPSByXi0xIChzUiAtICBlRylcbiAgLy8gICAgICAgICAgICAgICBRID0gcl4tMSAoc1IgKyAtZUcpXG4gIHZhciBySW52ID0gci5tb2RJbnZlcnNlKG4pO1xuXG4gIHZhciBRID0gUi5tdWx0aXBseVR3byhzLCBHLCBlTmVnKS5tdWx0aXBseShySW52KTtcbiAgY3VydmUudmFsaWRhdGUoUSk7XG5cbiAgcmV0dXJuIFE7XG59XG5cbi8qKlxuICAqIENhbGN1bGF0ZSBwdWJrZXkgZXh0cmFjdGlvbiBwYXJhbWV0ZXIuXG4gICpcbiAgKiBXaGVuIGV4dHJhY3RpbmcgYSBwdWJrZXkgZnJvbSBhIHNpZ25hdHVyZSwgd2UgaGF2ZSB0b1xuICAqIGRpc3Rpbmd1aXNoIGZvdXIgZGlmZmVyZW50IGNhc2VzLiBSYXRoZXIgdGhhbiBwdXR0aW5nIHRoaXNcbiAgKiBidXJkZW4gb24gdGhlIHZlcmlmaWVyLCBCaXRjb2luIGluY2x1ZGVzIGEgMi1iaXQgdmFsdWUgd2l0aCB0aGVcbiAgKiBzaWduYXR1cmUuXG4gICpcbiAgKiBUaGlzIGZ1bmN0aW9uIHNpbXBseSB0cmllcyBhbGwgZm91ciBjYXNlcyBhbmQgcmV0dXJucyB0aGUgdmFsdWVcbiAgKiB0aGF0IHJlc3VsdGVkIGluIGEgc3VjY2Vzc2Z1bCBwdWJrZXkgcmVjb3ZlcnkuXG4gICovXG5mdW5jdGlvbiBjYWxjUHViS2V5UmVjb3ZlcnlQYXJhbShjdXJ2ZSwgZSwgc2lnbmF0dXJlLCBRKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgdmFyIFFwcmltZSA9IHJlY292ZXJQdWJLZXkoY3VydmUsIGUsIHNpZ25hdHVyZSwgaSk7XG5cbiAgICAvLyAxLjYuMiBWZXJpZnkgUVxuICAgIGlmIChRcHJpbWUuZXF1YWxzKFEpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHZhbGlkIHJlY292ZXJ5IGZhY3RvcicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2FsY1B1YktleVJlY292ZXJ5UGFyYW06IGNhbGNQdWJLZXlSZWNvdmVyeVBhcmFtLFxuICBkZXRlcm1pbmlzdGljR2VuZXJhdGVLOiBkZXRlcm1pbmlzdGljR2VuZXJhdGVLLFxuICByZWNvdmVyUHViS2V5OiByZWNvdmVyUHViS2V5LFxuICBzaWduOiBzaWduLFxuICB2ZXJpZnk6IHZlcmlmeSxcbiAgdmVyaWZ5UmF3OiB2ZXJpZnlSYXdcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmMvZWNkc2EuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9lY2Mvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7IC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXRjb2luanMtbGliXG52YXIgZW5mb3JjZVR5cGUgPSByZXF1aXJlKCcuL2VuZm9yY2VfdHlwZXMnKTtcblxudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCdiaWdpJyk7XG5cbmZ1bmN0aW9uIEVDU2lnbmF0dXJlKHIsIHMpIHtcbiAgZW5mb3JjZVR5cGUoQmlnSW50ZWdlciwgcik7XG4gIGVuZm9yY2VUeXBlKEJpZ0ludGVnZXIsIHMpO1xuXG4gIHRoaXMuciA9IHI7XG4gIHRoaXMucyA9IHM7XG59XG5cbi8vIEltcG9ydCBvcGVyYXRpb25zXG5FQ1NpZ25hdHVyZS5wYXJzZUNvbXBhY3QgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIGFzc2VydC5lcXVhbChidWZmZXIubGVuZ3RoLCA2NSwgJ0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICB2YXIgaSA9IGJ1ZmZlci5yZWFkVUludDgoMCkgLSAyNztcblxuICAvLyBBdCBtb3N0IDMgYml0c1xuICBhc3NlcnQuZXF1YWwoaSwgaSAmIDcsICdJbnZhbGlkIHNpZ25hdHVyZSBwYXJhbWV0ZXInKTtcbiAgdmFyIGNvbXByZXNzZWQgPSAhIShpICYgNCk7XG5cbiAgLy8gUmVjb3ZlcnkgcGFyYW0gb25seVxuICBpID0gaSAmIDM7XG5cbiAgdmFyIHIgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoYnVmZmVyLnNsaWNlKDEsIDMzKSk7XG4gIHZhciBzID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1ZmZlci5zbGljZSgzMykpO1xuXG4gIHJldHVybiB7XG4gICAgY29tcHJlc3NlZDogY29tcHJlc3NlZCxcbiAgICBpOiBpLFxuICAgIHNpZ25hdHVyZTogbmV3IEVDU2lnbmF0dXJlKHIsIHMpXG4gIH07XG59O1xuXG5FQ1NpZ25hdHVyZS5mcm9tREVSID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICBhc3NlcnQuZXF1YWwoYnVmZmVyLnJlYWRVSW50OCgwKSwgMHgzMCwgJ05vdCBhIERFUiBzZXF1ZW5jZScpO1xuICBhc3NlcnQuZXF1YWwoYnVmZmVyLnJlYWRVSW50OCgxKSwgYnVmZmVyLmxlbmd0aCAtIDIsICdJbnZhbGlkIHNlcXVlbmNlIGxlbmd0aCcpO1xuICBhc3NlcnQuZXF1YWwoYnVmZmVyLnJlYWRVSW50OCgyKSwgMHgwMiwgJ0V4cGVjdGVkIGEgREVSIGludGVnZXInKTtcblxuICB2YXIgckxlbiA9IGJ1ZmZlci5yZWFkVUludDgoMyk7XG4gIGFzc2VydChyTGVuID4gMCwgJ1IgbGVuZ3RoIGlzIHplcm8nKTtcblxuICB2YXIgb2Zmc2V0ID0gNCArIHJMZW47XG4gIGFzc2VydC5lcXVhbChidWZmZXIucmVhZFVJbnQ4KG9mZnNldCksIDB4MDIsICdFeHBlY3RlZCBhIERFUiBpbnRlZ2VyICgyKScpO1xuXG4gIHZhciBzTGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQgKyAxKTtcbiAgYXNzZXJ0KHNMZW4gPiAwLCAnUyBsZW5ndGggaXMgemVybycpO1xuXG4gIHZhciByQiA9IGJ1ZmZlci5zbGljZSg0LCBvZmZzZXQpO1xuICB2YXIgc0IgPSBidWZmZXIuc2xpY2Uob2Zmc2V0ICsgMik7XG4gIG9mZnNldCArPSAyICsgc0xlbjtcblxuICBpZiAockxlbiA+IDEgJiYgckIucmVhZFVJbnQ4KDApID09PSAweDAwKSB7XG4gICAgYXNzZXJ0KHJCLnJlYWRVSW50OCgxKSAmIDB4ODAsICdSIHZhbHVlIGV4Y2Vzc2l2ZWx5IHBhZGRlZCcpO1xuICB9XG5cbiAgaWYgKHNMZW4gPiAxICYmIHNCLnJlYWRVSW50OCgwKSA9PT0gMHgwMCkge1xuICAgIGFzc2VydChzQi5yZWFkVUludDgoMSkgJiAweDgwLCAnUyB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWQnKTtcbiAgfVxuXG4gIGFzc2VydC5lcXVhbChvZmZzZXQsIGJ1ZmZlci5sZW5ndGgsICdJbnZhbGlkIERFUiBlbmNvZGluZycpO1xuICB2YXIgciA9IEJpZ0ludGVnZXIuZnJvbURFUkludGVnZXIockIpO1xuICB2YXIgcyA9IEJpZ0ludGVnZXIuZnJvbURFUkludGVnZXIoc0IpO1xuXG4gIGFzc2VydChyLnNpZ251bSgpID49IDAsICdSIHZhbHVlIGlzIG5lZ2F0aXZlJyk7XG4gIGFzc2VydChzLnNpZ251bSgpID49IDAsICdTIHZhbHVlIGlzIG5lZ2F0aXZlJyk7XG5cbiAgcmV0dXJuIG5ldyBFQ1NpZ25hdHVyZShyLCBzKTtcbn07XG5cbi8vIEZJWE1FOiAweDAwLCAweDA0LCAweDgwIGFyZSBTSUdIQVNIXyogYm91bmRhcnkgY29uc3RhbnRzLCBpbXBvcnRpbmcgVHJhbnNhY3Rpb24gY2F1c2VzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeVxuRUNTaWduYXR1cmUucGFyc2VTY3JpcHRTaWduYXR1cmUgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHZhciBoYXNoVHlwZSA9IGJ1ZmZlci5yZWFkVUludDgoYnVmZmVyLmxlbmd0aCAtIDEpO1xuICB2YXIgaGFzaFR5cGVNb2QgPSBoYXNoVHlwZSAmIH4weDgwO1xuXG4gIGFzc2VydChoYXNoVHlwZU1vZCA+IDB4MDAgJiYgaGFzaFR5cGVNb2QgPCAweDA0LCAnSW52YWxpZCBoYXNoVHlwZScpO1xuXG4gIHJldHVybiB7XG4gICAgc2lnbmF0dXJlOiBFQ1NpZ25hdHVyZS5mcm9tREVSKGJ1ZmZlci5zbGljZSgwLCAtMSkpLFxuICAgIGhhc2hUeXBlOiBoYXNoVHlwZVxuICB9O1xufTtcblxuLy8gRXhwb3J0IG9wZXJhdGlvbnNcbkVDU2lnbmF0dXJlLnByb3RvdHlwZS50b0NvbXBhY3QgPSBmdW5jdGlvbiAoaSwgY29tcHJlc3NlZCkge1xuICBpZiAoY29tcHJlc3NlZCkgaSArPSA0O1xuICBpICs9IDI3O1xuXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKDY1KTtcbiAgYnVmZmVyLndyaXRlVUludDgoaSwgMCk7XG5cbiAgdGhpcy5yLnRvQnVmZmVyKDMyKS5jb3B5KGJ1ZmZlciwgMSk7XG4gIHRoaXMucy50b0J1ZmZlcigzMikuY29weShidWZmZXIsIDMzKTtcblxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuRUNTaWduYXR1cmUucHJvdG90eXBlLnRvREVSID0gZnVuY3Rpb24gKCkge1xuICB2YXIgckJhID0gdGhpcy5yLnRvREVSSW50ZWdlcigpO1xuICB2YXIgc0JhID0gdGhpcy5zLnRvREVSSW50ZWdlcigpO1xuXG4gIHZhciBzZXF1ZW5jZSA9IFtdO1xuXG4gIC8vIElOVEVHRVJcbiAgc2VxdWVuY2UucHVzaCgweDAyLCByQmEubGVuZ3RoKTtcbiAgc2VxdWVuY2UgPSBzZXF1ZW5jZS5jb25jYXQockJhKTtcblxuICAvLyBJTlRFR0VSXG4gIHNlcXVlbmNlLnB1c2goMHgwMiwgc0JhLmxlbmd0aCk7XG4gIHNlcXVlbmNlID0gc2VxdWVuY2UuY29uY2F0KHNCYSk7XG5cbiAgLy8gU0VRVUVOQ0VcbiAgc2VxdWVuY2UudW5zaGlmdCgweDMwLCBzZXF1ZW5jZS5sZW5ndGgpO1xuXG4gIHJldHVybiBuZXcgQnVmZmVyKHNlcXVlbmNlKTtcbn07XG5cbkVDU2lnbmF0dXJlLnByb3RvdHlwZS50b1NjcmlwdFNpZ25hdHVyZSA9IGZ1bmN0aW9uIChoYXNoVHlwZSkge1xuICB2YXIgaGFzaFR5cGVCdWZmZXIgPSBuZXcgQnVmZmVyKDEpO1xuICBoYXNoVHlwZUJ1ZmZlci53cml0ZVVJbnQ4KGhhc2hUeXBlLCAwKTtcblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbdGhpcy50b0RFUigpLCBoYXNoVHlwZUJ1ZmZlcl0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFQ1NpZ25hdHVyZTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvZWNjL3NyYy9lY3NpZ25hdHVyZS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5mb3JjZSh0eXBlLCB2YWx1ZSkge1xuICAvLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL2JpdGNvaW5qcy1saWJcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnQXJyYXknOlxuICAgICAge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnQnVmZmVyJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdOdW1iZXInOlxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSByZXR1cm47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKGdldE5hbWUodmFsdWUuY29uc3RydWN0b3IpID09PSBnZXROYW1lKHR5cGUpKSByZXR1cm47XG4gICAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCAnICsgKGdldE5hbWUodHlwZSkgfHwgdHlwZSkgKyAnLCBnb3QgJyArIHZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIGdldE5hbWUoZm4pIHtcbiAgLy8gV2h5IG5vdCBmbi5uYW1lOiBodHRwczovL2thbmdheC5naXRodWIuaW8vY29tcGF0LXRhYmxlL2VzNi8jZnVuY3Rpb25fbmFtZV9wcm9wZXJ0eVxuICB2YXIgbWF0Y2ggPSBmbi50b1N0cmluZygpLm1hdGNoKC9mdW5jdGlvbiAoLio/KVxcKC8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IG51bGw7XG59XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmMvZW5mb3JjZV90eXBlcy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKFwiY3JlYXRlLWhhc2hcIik7XG52YXIgY3JlYXRlSG1hYyA9IHJlcXVpcmUoXCJjcmVhdGUtaG1hY1wiKTtcblxuLyoqIEBhcmcge3N0cmluZ3xCdWZmZXJ9IGRhdGFcbiAgICBAYXJnIHtzdHJpbmd9IFtkaWdlc3QgPSBudWxsXSAtICdoZXgnLCAnYmluYXJ5JyBvciAnYmFzZTY0J1xuICAgIEByZXR1cm4ge3N0cmluZ3xCdWZmZXJ9IC0gQnVmZmVyIHdoZW4gZGlnZXN0IGlzIG51bGwsIG9yIHN0cmluZ1xuKi9cbmZ1bmN0aW9uIHNoYTEoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShkYXRhKS5kaWdlc3QoZW5jb2RpbmcpO1xufVxuXG4vKiogQGFyZyB7c3RyaW5nfEJ1ZmZlcn0gZGF0YVxuICAgIEBhcmcge3N0cmluZ30gW2RpZ2VzdCA9IG51bGxdIC0gJ2hleCcsICdiaW5hcnknIG9yICdiYXNlNjQnXG4gICAgQHJldHVybiB7c3RyaW5nfEJ1ZmZlcn0gLSBCdWZmZXIgd2hlbiBkaWdlc3QgaXMgbnVsbCwgb3Igc3RyaW5nXG4qL1xuZnVuY3Rpb24gc2hhMjU2KGRhdGEsIGVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShkYXRhKS5kaWdlc3QoZW5jb2RpbmcpO1xufVxuXG4vKiogQGFyZyB7c3RyaW5nfEJ1ZmZlcn0gZGF0YVxuICAgIEBhcmcge3N0cmluZ30gW2RpZ2VzdCA9IG51bGxdIC0gJ2hleCcsICdiaW5hcnknIG9yICdiYXNlNjQnXG4gICAgQHJldHVybiB7c3RyaW5nfEJ1ZmZlcn0gLSBCdWZmZXIgd2hlbiBkaWdlc3QgaXMgbnVsbCwgb3Igc3RyaW5nXG4qL1xuZnVuY3Rpb24gc2hhNTEyKGRhdGEsIGVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTUxMicpLnVwZGF0ZShkYXRhKS5kaWdlc3QoZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBIbWFjU0hBMjU2KGJ1ZmZlciwgc2VjcmV0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhtYWMoJ3NoYTI1NicsIHNlY3JldCkudXBkYXRlKGJ1ZmZlcikuZGlnZXN0KCk7XG59XG5cbmZ1bmN0aW9uIHJpcGVtZDE2MChkYXRhKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goJ3JtZDE2MCcpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn1cblxuLy8gZnVuY3Rpb24gaGFzaDE2MChidWZmZXIpIHtcbi8vICAgcmV0dXJuIHJpcGVtZDE2MChzaGEyNTYoYnVmZmVyKSlcbi8vIH1cbi8vXG4vLyBmdW5jdGlvbiBoYXNoMjU2KGJ1ZmZlcikge1xuLy8gICByZXR1cm4gc2hhMjU2KHNoYTI1NihidWZmZXIpKVxuLy8gfVxuXG4vL1xuLy8gZnVuY3Rpb24gSG1hY1NIQTUxMihidWZmZXIsIHNlY3JldCkge1xuLy8gICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTUxMicsIHNlY3JldCkudXBkYXRlKGJ1ZmZlcikuZGlnZXN0KClcbi8vIH1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc2hhMTogc2hhMSxcbiAgICBzaGEyNTY6IHNoYTI1NixcbiAgICBzaGE1MTI6IHNoYTUxMixcbiAgICBIbWFjU0hBMjU2OiBIbWFjU0hBMjU2LFxuICAgIHJpcGVtZDE2MDogcmlwZW1kMTYwXG4gICAgLy8gaGFzaDE2MDogaGFzaDE2MCxcbiAgICAvLyBoYXNoMjU2OiBoYXNoMjU2LFxuICAgIC8vIEhtYWNTSEE1MTI6IEhtYWNTSEE1MTJcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmMvaGFzaC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L2VjYy9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBlY2RzYSA9IHJlcXVpcmUoJy4vZWNkc2EnKTtcbnZhciBoYXNoID0gcmVxdWlyZSgnLi9oYXNoJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2VjdXJ2ZScpO1xuXG52YXIgZ2V0Q3VydmVCeU5hbWUgPSBfcmVxdWlyZS5nZXRDdXJ2ZUJ5TmFtZTtcblxudmFyIHNlY3AyNTZrMSA9IGdldEN1cnZlQnlOYW1lKCdzZWNwMjU2azEnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpO1xudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vUHVibGljS2V5Jyk7XG5cbnZhciBTaWduYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2lnbmF0dXJlKHIxLCBzMSwgaTEpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpZ25hdHVyZSk7XG5cbiAgICAgICAgdGhpcy5yID0gcjE7XG4gICAgICAgIHRoaXMucyA9IHMxO1xuICAgICAgICB0aGlzLmkgPSBpMTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHRoaXMuciAhPSBudWxsLCB0cnVlLCAnTWlzc2luZyBwYXJhbWV0ZXInKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHRoaXMucyAhPSBudWxsLCB0cnVlLCAnTWlzc2luZyBwYXJhbWV0ZXInKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHRoaXMuaSAhPSBudWxsLCB0cnVlLCAnTWlzc2luZyBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU2lnbmF0dXJlLCBbe1xuICAgICAgICBrZXk6ICd0b0J1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcbiAgICAgICAgICAgIHZhciBidWY7XG4gICAgICAgICAgICBidWYgPSBuZXcgQnVmZmVyKDY1KTtcbiAgICAgICAgICAgIGJ1Zi53cml0ZVVJbnQ4KHRoaXMuaSwgMCk7XG4gICAgICAgICAgICB0aGlzLnIudG9CdWZmZXIoMzIpLmNvcHkoYnVmLCAxKTtcbiAgICAgICAgICAgIHRoaXMucy50b0J1ZmZlcigzMikuY29weShidWYsIDMzKTtcbiAgICAgICAgICAgIHJldHVybiBidWY7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlY292ZXJQdWJsaWNLZXlGcm9tQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXlGcm9tQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjb3ZlclB1YmxpY0tleShoYXNoLnNoYTI1NihidWZmZXIpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVjb3ZlclB1YmxpY0tleScsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICAgIEByZXR1cm4ge1B1YmxpY0tleX1cbiAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkoc2hhMjU2X2J1ZmZlcikge1xuICAgICAgICAgICAgdmFyIFEgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBpID0gdm9pZCAwO1xuICAgICAgICAgICAgZSA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihzaGEyNTZfYnVmZmVyKTtcbiAgICAgICAgICAgIGkgPSB0aGlzLmk7XG4gICAgICAgICAgICBpIC09IDI3O1xuICAgICAgICAgICAgaSA9IGkgJiAzO1xuICAgICAgICAgICAgUSA9IGVjZHNhLnJlY292ZXJQdWJLZXkoc2VjcDI1NmsxLCBlLCB0aGlzLCBpKTtcbiAgICAgICAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbVBvaW50KFEpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd2ZXJpZnlCdWZmZXInLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBAcGFyYW0ge0J1ZmZlcn0gdW4taGFzaGVkXG4gICAgICAgICAgICBAcGFyYW0gey4vUHVibGljS2V5fVxuICAgICAgICAgICAgQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZlcmlmeUJ1ZmZlcihidWYsIHB1YmxpY19rZXkpIHtcbiAgICAgICAgICAgIHZhciBfaGFzaCA9IGhhc2guc2hhMjU2KGJ1Zik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlIYXNoKF9oYXNoLCBwdWJsaWNfa2V5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndmVyaWZ5SGFzaCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnlIYXNoKGhhc2gsIHB1YmxpY19rZXkpIHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChoYXNoLmxlbmd0aCwgMzIsIFwiQSBTSEEgMjU2IHNob3VsZCBiZSAzMiBieXRlcyBsb25nLCBpbnN0ZWFkIGdvdCBcIiArIGhhc2gubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBlY2RzYS52ZXJpZnkoc2VjcDI1NmsxLCBoYXNoLCB7XG4gICAgICAgICAgICAgICAgcjogdGhpcy5yLFxuICAgICAgICAgICAgICAgIHM6IHRoaXMuc1xuICAgICAgICAgICAgfSwgcHVibGljX2tleS5RKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9CeXRlQnVmZmVyJyxcblxuXG4gICAgICAgIC8qIDxIRVg+ICovXG5cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQnl0ZUJ1ZmZlcigpIHtcbiAgICAgICAgICAgIHZhciBiO1xuICAgICAgICAgICAgYiA9IG5ldyBCeXRlQnVmZmVyKEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWSwgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQnl0ZUJ1ZmZlcihiKTtcbiAgICAgICAgICAgIHJldHVybiBiLmNvcHkoMCwgYi5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0hleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0hleCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQnVmZmVyKCkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3ZlcmlmeUhleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnlIZXgoaGV4LCBwdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICB2YXIgYnVmO1xuICAgICAgICAgICAgYnVmID0gbmV3IEJ1ZmZlcihoZXgsICdoZXgnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeUJ1ZmZlcihidWYsIHB1YmxpY19rZXkpO1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2Zyb21CdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWYpIHtcbiAgICAgICAgICAgIHZhciBpLCByLCBzO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGJ1Zi5sZW5ndGgsIDY1LCAnSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gICAgICAgICAgICBpID0gYnVmLnJlYWRVSW50OCgwKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChpIC0gMjcsIGkgLSAyNyAmIDcsICdJbnZhbGlkIHNpZ25hdHVyZSBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIHIgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoYnVmLnNsaWNlKDEsIDMzKSk7XG4gICAgICAgICAgICBzID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1Zi5zbGljZSgzMykpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcywgaSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NpZ25CdWZmZXInLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gICAgICAgICAgICBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVfa2V5XG4gICAgICAgICAgICBAcmV0dXJuIHtTaWduYXR1cmV9XG4gICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaWduQnVmZmVyKGJ1ZiwgcHJpdmF0ZV9rZXkpIHtcbiAgICAgICAgICAgIHZhciBfaGFzaCA9IGhhc2guc2hhMjU2KGJ1Zik7XG4gICAgICAgICAgICByZXR1cm4gU2lnbmF0dXJlLnNpZ25CdWZmZXJTaGEyNTYoX2hhc2gsIHByaXZhdGVfa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBTaWduIGEgYnVmZmVyIG9mIGV4YWN0YWxseSAzMiBieXRlcyBpbiBzaXplIChzaGEyNTYodGV4dCkpXG4gICAgICAgICAgICBAcGFyYW0ge0J1ZmZlcn0gYnVmIC0gMzIgYnl0ZXMgYmluYXJ5XG4gICAgICAgICAgICBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVfa2V5XG4gICAgICAgICAgICBAcmV0dXJuIHtTaWduYXR1cmV9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NpZ25CdWZmZXJTaGEyNTYnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbkJ1ZmZlclNoYTI1NihidWZfc2hhMjU2LCBwcml2YXRlX2tleSkge1xuICAgICAgICAgICAgaWYgKGJ1Zl9zaGEyNTYubGVuZ3RoICE9PSAzMiB8fCAhQnVmZmVyLmlzQnVmZmVyKGJ1Zl9zaGEyNTYpKSB0aHJvdyBuZXcgRXJyb3IoXCJidWZfc2hhMjU2OiAzMiBieXRlIGJ1ZmZlciByZXF1cmVkXCIpO1xuICAgICAgICAgICAgdmFyIGRlciwgZSwgZWNzaWduYXR1cmUsIGksIGxlblIsIGxlblMsIG5vbmNlO1xuICAgICAgICAgICAgaSA9IG51bGw7XG4gICAgICAgICAgICBub25jZSA9IDA7XG4gICAgICAgICAgICBlID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1Zl9zaGEyNTYpO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBlY3NpZ25hdHVyZSA9IGVjZHNhLnNpZ24oc2VjcDI1NmsxLCBidWZfc2hhMjU2LCBwcml2YXRlX2tleS5kLCBub25jZSsrKTtcbiAgICAgICAgICAgICAgICBkZXIgPSBlY3NpZ25hdHVyZS50b0RFUigpO1xuICAgICAgICAgICAgICAgIGxlblIgPSBkZXJbM107XG4gICAgICAgICAgICAgICAgbGVuUyA9IGRlcls1ICsgbGVuUl07XG4gICAgICAgICAgICAgICAgaWYgKGxlblIgPT09IDMyICYmIGxlblMgPT09IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBlY2RzYS5jYWxjUHViS2V5UmVjb3ZlcnlQYXJhbShzZWNwMjU2azEsIGUsIGVjc2lnbmF0dXJlLCBwcml2YXRlX2tleS50b1B1YmxpY0tleSgpLlEpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDQ7IC8vIGNvbXByZXNzZWRcbiAgICAgICAgICAgICAgICAgICAgaSArPSAyNzsgLy8gY29tcGFjdCAgLy8gIDI0IG9yIDI3IDooIGZvcmNpbmcgb2RkLXkgMm5kIGtleSBjYW5kaWRhdGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9uY2UgJSAxMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUk46IFwiICsgbm9uY2UgKyBcIiBhdHRlbXB0cyB0byBmaW5kIGNhbm9uaWNhbCBzaWduYXR1cmVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoZWNzaWduYXR1cmUuciwgZWNzaWduYXR1cmUucywgaSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NpZ24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbihzdHJpbmcsIHByaXZhdGVfa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gU2lnbmF0dXJlLnNpZ25CdWZmZXIobmV3IEJ1ZmZlcihzdHJpbmcpLCBwcml2YXRlX2tleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21IZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBTaWduYXR1cmUuZnJvbUJ1ZmZlcihuZXcgQnVmZmVyKGhleCwgXCJoZXhcIikpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzaWduSGV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ25IZXgoaGV4LCBwcml2YXRlX2tleSkge1xuICAgICAgICAgICAgdmFyIGJ1ZjtcbiAgICAgICAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIoaGV4LCAnaGV4Jyk7XG4gICAgICAgICAgICByZXR1cm4gU2lnbmF0dXJlLnNpZ25CdWZmZXIoYnVmLCBwcml2YXRlX2tleSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU2lnbmF0dXJlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25hdHVyZTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3QvZWNjL3NyYy9zaWduYXR1cmUuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9lY2Mvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBvYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0QXNzaWduKHJlcXVpcmUoXCIuL2NoYWluXCIpLCByZXF1aXJlKFwiLi9lY2NcIiksIHJlcXVpcmUoXCIuL3NlcmlhbGl6ZXJcIikpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIC8vIFByaW1hcnkgY2xhc3MgZm9yIGNyZWF0aW5nIG9wZXJhdGlvbnNcbiAgICBTZXJpYWxpemVyOiByZXF1aXJlKCcuL3NyYy9zZXJpYWxpemVyJyksXG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb25zIGZvciBjcmVhdGluZyBvcGVyYXRpb25zXG4gICAgZnA6IHJlcXVpcmUoJy4vc3JjL0Zhc3RQYXJzZXInKSxcblxuICAgIC8vIExvdyBsZXZlbCB0eXBlc1xuICAgIHR5cGVzOiByZXF1aXJlKCcuL3NyYy90eXBlcycpLFxuXG4gICAgLy8gSGlnaGVyIGxldmVsIG9wZXJhdGlvbnMgKG1hZGUgb3V0IG9mIGdlbmVyaWMgdHlwZXMpXG4gICAgb3BzOiByZXF1aXJlKCcuL3NyYy9vcGVyYXRpb25zJyksXG5cbiAgICAvLyBVdGlsaXR5IHRoYXQgZ2VuZXJhdGVzIEpTT04gZXhhbXBsZXNcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9zcmMvdGVtcGxhdGUnKSxcblxuICAgIC8vIFNlcmlhbGl6ZXIgdmFsaWRhdGlvblxuICAgIFNlcmlhbGl6ZXJWYWxpZGF0aW9uOiByZXF1aXJlKCcuL3NyYy9TZXJpYWxpemVyVmFsaWRhdGlvbicpXG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9zZXJpYWxpemVyL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3Qvc2VyaWFsaXplclwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoXCIuLi8uLi9lY2Mvc3JjL1B1YmxpY0tleVwiKTtcblxudmFyIEZhc3RQYXJzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmFzdFBhcnNlcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZhc3RQYXJzZXIpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhGYXN0UGFyc2VyLCBudWxsLCBbe1xuICAgICAgICBrZXk6ICdmaXhlZF9kYXRhJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpeGVkX2RhdGEoYiwgbGVuLCBidWZmZXIpIHtcbiAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGJ1ZmZlci5zbGljZSgwLCBsZW4pLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgICAgICAgICAgICBiLmFwcGVuZChkYXRhLCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGxlbi0tID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYi53cml0ZVVpbnQ4KDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGJfY29weSA9IGIuY29weShiLm9mZnNldCwgYi5vZmZzZXQgKyBsZW4pO1xuICAgICAgICAgICAgICAgIGIuc2tpcChsZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGJfY29weS50b0JpbmFyeSgpLCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3B1YmxpY19rZXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGljX2tleShiLCBfcHVibGljX2tleSkge1xuICAgICAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9wdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IF9wdWJsaWNfa2V5LnRvQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgYi5hcHBlbmQoYnVmZmVyLnRvU3RyaW5nKCdiaW5hcnknKSwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gRmFzdFBhcnNlci5maXhlZF9kYXRhKGIsIDMzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21CdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmlwZW1kMTYwJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJpcGVtZDE2MChiLCBfcmlwZW1kKSB7XG4gICAgICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3JpcGVtZCkge1xuICAgICAgICAgICAgICAgIEZhc3RQYXJzZXIuZml4ZWRfZGF0YShiLCAyMCwgX3JpcGVtZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRmFzdFBhcnNlci5maXhlZF9kYXRhKGIsIDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndGltZV9wb2ludF9zZWMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdGltZV9wb2ludF9zZWMoYiwgZXBvY2gpIHtcbiAgICAgICAgICAgIGlmIChlcG9jaCkge1xuICAgICAgICAgICAgICAgIGVwb2NoID0gTWF0aC5jZWlsKGVwb2NoIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgYi53cml0ZUludDMyKGVwb2NoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVwb2NoID0gYi5yZWFkSW50MzIoKTsgLy8gZmM6OnRpbWVfcG9pbnRfc2VjXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGVwb2NoICogMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRmFzdFBhcnNlcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYXN0UGFyc2VyO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9GYXN0UGFyc2VyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdieXRlYnVmZmVyJyk7XG5cbnZhciBMb25nID0gX3JlcXVpcmUuTG9uZztcblxudmFyIENoYWluVHlwZXMgPSByZXF1aXJlKCcuLi8uLi9jaGFpbi9zcmMvQ2hhaW5UeXBlcycpO1xuXG52YXIgTUFYX1NBRkVfSU5UID0gOTAwNzE5OTI1NDc0MDk5MTtcbnZhciBNSU5fU0FGRV9JTlQgPSAtOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gICAgTW9zdCB2YWxpZGF0aW9ucyBhcmUgc2tpcHBlZCBhbmQgdGhlIHZhbHVlIHJldHVybmVkIHVuY2hhbmdlZCB3aGVuIGFuIGVtcHR5IHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkIGlzIGVuY291bnRlcmVkIChleGNlcHQgXCJyZXF1aXJlZFwiKS5cblxuICAgIFZhbGlkYXRpb25zIHN1cHBvcnQgYSBzdHJpbmcgZm9ybWF0IGZvciBkZWFsaW5nIHdpdGggbGFyZ2UgbnVtYmVycy5cbiovXG52YXIgX215ID0ge1xuXG4gICAgaXNfZW1wdHk6IGZ1bmN0aW9uIGlzX2VtcHR5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICByZXF1aXJlZDogZnVuY3Rpb24gcmVxdWlyZWQodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBcIlwiIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZSByZXF1aXJlZCAnICsgZmllbGRfbmFtZSArICcgJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZXF1aXJlX2xvbmc6IGZ1bmN0aW9uIHJlcXVpcmVfbG9uZyh2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTG9uZyB2YWx1ZSByZXF1aXJlZCAnICsgZmllbGRfbmFtZSArICcgJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyByZXF1aXJlZDogJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBudW1iZXI6IGZ1bmN0aW9uIG51bWJlcih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciByZXF1aXJlZDogJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICB3aG9sZV9udW1iZXI6IGZ1bmN0aW9uIHdob2xlX251bWJlcih2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9cXC4vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dob2xlIG51bWJlciByZXF1aXJlZCAnICsgZmllbGRfbmFtZSArICcgJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICB1bnNpZ25lZDogZnVuY3Rpb24gdW5zaWduZWQodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBcIlwiIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvLS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zaWduZWQgcmVxdWlyZWQgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cblxuICAgIGlzX2RpZ2l0czogZnVuY3Rpb24gaXNfZGlnaXRzKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtZXJpY1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKC9eWzAtOV0rJC8udGVzdCh2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgdG9fbnVtYmVyOiBmdW5jdGlvbiB0b19udW1iZXIodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBcIlwiIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9fb3ZlcmZsb3c1Myh2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIHZhciBpbnRfdmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiBpbnRfdmFsdWU7XG4gICAgfSxcblxuICAgIHRvX2xvbmc6IGZ1bmN0aW9uIHRvX2xvbmcodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBcIlwiIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChMb25nLmlzTG9uZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubm9fb3ZlcmZsb3c2NCh2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gXCJcIiArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgIH0sXG4gICAgdG9fc3RyaW5nOiBmdW5jdGlvbiB0b19zdHJpbmcodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBcIlwiIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLm5vX292ZXJmbG93NTModmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTG9uZy5pc0xvbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyAndW5zdXBwb3J0ZWQgdHlwZSAnICsgZmllbGRfbmFtZSArICc6ICgnICsgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSArICcpICcgKyB2YWx1ZTtcbiAgICB9LFxuICAgIHJlcXVpcmVfdGVzdDogZnVuY3Rpb24gcmVxdWlyZV90ZXN0KHJlZ2V4LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bm1hdGNoZWQgJyArIHJlZ2V4ICsgJyAnICsgZmllbGRfbmFtZSArICcgJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuXG4gICAgcmVxdWlyZV9tYXRjaDogZnVuY3Rpb24gcmVxdWlyZV9tYXRjaChyZWdleCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBcIlwiIDogYXJndW1lbnRzWzJdO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VubWF0Y2hlZCAnICsgcmVnZXggKyAnICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9LFxuXG4gICAgcmVxdWlyZV9vYmplY3RfaWQ6IGZ1bmN0aW9uIHJlcXVpcmVfb2JqZWN0X2lkKHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlX21hdGNoKC9eKFswLTldKylcXC4oWzAtOV0rKVxcLihbMC05XSspJC8sIHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICB9LFxuXG4gICAgLy8gRG9lcyBub3Qgc3VwcG9ydCBvdmVyIDUzIGJpdHNcbiAgICByZXF1aXJlX3JhbmdlOiBmdW5jdGlvbiByZXF1aXJlX3JhbmdlKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBhcmd1bWVudHNbM107XG5cbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG51bWJlciA9IHRoaXMudG9fbnVtYmVyKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlIDwgbWluIHx8IHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dCBvZiByYW5nZSAnICsgdmFsdWUgKyAnICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG5cbiAgICByZXF1aXJlX29iamVjdF90eXBlOiBmdW5jdGlvbiByZXF1aXJlX29iamVjdF90eXBlKCkge1xuICAgICAgICB2YXIgcmVzZXJ2ZWRfc3BhY2VzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gMSA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyBcIlwiIDogYXJndW1lbnRzWzNdO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvYmplY3RfdHlwZSA9IENoYWluVHlwZXMub2JqZWN0X3R5cGVbdHlwZV07XG4gICAgICAgIGlmICghb2JqZWN0X3R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBvYmplY3QgdHlwZSAnICsgdHlwZSArICcgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cChyZXNlcnZlZF9zcGFjZXMgKyAnLicgKyBvYmplY3RfdHlwZSArICcuWzAtOV0rJCcpO1xuICAgICAgICBpZiAoIXJlLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGluZyAnICsgdHlwZSArICcgaW4gZm9ybWF0ICcgKyAocmVzZXJ2ZWRfc3BhY2VzICsgJy4nICsgb2JqZWN0X3R5cGUgKyAnLlswLTldKyAnKSArICgnaW5zdGVhZCBvZiAnICsgdmFsdWUgKyAnICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldF9pbnN0YW5jZTogZnVuY3Rpb24gZ2V0X2luc3RhbmNlKHJlc2VydmVfc3BhY2VzLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVpcmVfb2JqZWN0X3R5cGUocmVzZXJ2ZV9zcGFjZXMsIHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9fbnVtYmVyKHZhbHVlLnNwbGl0KCcuJylbMl0pO1xuICAgIH0sXG5cbiAgICByZXF1aXJlX3JlbGF0aXZlX3R5cGU6IGZ1bmN0aW9uIHJlcXVpcmVfcmVsYXRpdmVfdHlwZSh0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICB0aGlzLnJlcXVpcmVfb2JqZWN0X3R5cGUoMCwgdHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldF9yZWxhdGl2ZV9pbnN0YW5jZTogZnVuY3Rpb24gZ2V0X3JlbGF0aXZlX2luc3RhbmNlKHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWlyZV9vYmplY3RfdHlwZSgwLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvX251bWJlcih2YWx1ZS5zcGxpdCgnLicpWzJdKTtcbiAgICB9LFxuXG4gICAgcmVxdWlyZV9wcm90b2NvbF90eXBlOiBmdW5jdGlvbiByZXF1aXJlX3Byb3RvY29sX3R5cGUodHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpIHtcbiAgICAgICAgdGhpcy5yZXF1aXJlX29iamVjdF90eXBlKDEsIHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXRfcHJvdG9jb2xfaW5zdGFuY2U6IGZ1bmN0aW9uIGdldF9wcm90b2NvbF9pbnN0YW5jZSh0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVpcmVfb2JqZWN0X3R5cGUoMSwgdHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy50b19udW1iZXIodmFsdWUuc3BsaXQoJy4nKVsyXSk7XG4gICAgfSxcblxuICAgIGdldF9wcm90b2NvbF90eXBlOiBmdW5jdGlvbiBnZXRfcHJvdG9jb2xfdHlwZSh2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVpcmVfb2JqZWN0X2lkKHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHZhbHVlLnNwbGl0KCcuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvX251bWJlcih2YWx1ZXNbMV0pO1xuICAgIH0sXG5cbiAgICBnZXRfcHJvdG9jb2xfdHlwZV9uYW1lOiBmdW5jdGlvbiBnZXRfcHJvdG9jb2xfdHlwZV9uYW1lKHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlX2lkID0gdGhpcy5nZXRfcHJvdG9jb2xfdHlwZSh2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhDaGFpblR5cGVzLm9iamVjdF90eXBlKVt0eXBlX2lkXTtcbiAgICB9LFxuXG5cbiAgICByZXF1aXJlX2ltcGxlbWVudGF0aW9uX3R5cGU6IGZ1bmN0aW9uIHJlcXVpcmVfaW1wbGVtZW50YXRpb25fdHlwZSh0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICB0aGlzLnJlcXVpcmVfb2JqZWN0X3R5cGUoMiwgdHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldF9pbXBsZW1lbnRhdGlvbl9pbnN0YW5jZTogZnVuY3Rpb24gZ2V0X2ltcGxlbWVudGF0aW9uX2luc3RhbmNlKHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWlyZV9vYmplY3RfdHlwZSgyLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvX251bWJlcih2YWx1ZS5zcGxpdCgnLicpWzJdKTtcbiAgICB9LFxuXG4gICAgLy8gc2lnbmVkIC8gdW5zaWduZWQgZGVjaW1hbFxuICAgIG5vX292ZXJmbG93NTM6IGZ1bmN0aW9uIG5vX292ZXJmbG93NTModmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBcIlwiIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IE1BWF9TQUZFX0lOVCB8fCB2YWx1ZSA8IE1JTl9TQUZFX0lOVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3ZlcmZsb3cgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIGludCA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IE1BWF9TQUZFX0lOVCB8fCB2YWx1ZSA8IE1JTl9TQUZFX0lOVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3ZlcmZsb3cgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKExvbmcuaXNMb25nKHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gdHlwZW9mIHZhbHVlLnRvSW50KCkgaXMgJ251bWJlcidcbiAgICAgICAgICAgIHRoaXMubm9fb3ZlcmZsb3c1Myh2YWx1ZS50b0ludCgpLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyAndW5zdXBwb3J0ZWQgdHlwZSAnICsgZmllbGRfbmFtZSArICc6ICgnICsgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSArICcpICcgKyB2YWx1ZTtcbiAgICB9LFxuXG5cbiAgICAvLyBzaWduZWQgLyB1bnNpZ25lZCB3aG9sZSBudW1iZXJzIG9ubHlcbiAgICBub19vdmVyZmxvdzY0OiBmdW5jdGlvbiBub19vdmVyZmxvdzY0KHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9Mb25nLmpzL2lzc3Vlcy8yMFxuICAgICAgICBpZiAoTG9uZy5pc0xvbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCaWdJbnRlZ2VyI2lzQmlnSW50ZWdlciBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL2JpZ2kvaXNzdWVzLzIwXG4gICAgICAgIGlmICh2YWx1ZS50ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm5vX292ZXJmbG93NjQodmFsdWUudG9TdHJpbmcoKSwgZmllbGRfbmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgbGVhZGluZyB6ZXJvcywgd2lsbCBjYXVzZSBhIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL14wKy8sICcnKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvc1xuICAgICAgICAgICAgd2hpbGUgKC8wJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvXFwuJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgZG90XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxvbmdfc3RyaW5nID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKGxvbmdfc3RyaW5nICE9PSB2YWx1ZS50cmltKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ292ZXJmbG93ICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IE1BWF9TQUZFX0lOVCB8fCB2YWx1ZSA8IE1JTl9TQUZFX0lOVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3ZlcmZsb3cgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyAndW5zdXBwb3J0ZWQgdHlwZSAnICsgZmllbGRfbmFtZSArICc6ICgnICsgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSArICcpICcgKyB2YWx1ZTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9teTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvU2VyaWFsaXplclZhbGlkYXRpb24uanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9zZXJpYWxpemVyL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKiogRXhjZXB0aW9uIG5lc3RpbmcuICAqL1xuXG52YXIgRXJyb3JXaXRoQ2F1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXJyb3JXaXRoQ2F1c2UobWVzc2FnZSwgY2F1c2UpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVycm9yV2l0aENhdXNlKTtcblxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICBpZiAodHlwZW9mIGNhdXNlICE9PSBcInVuZGVmaW5lZFwiICYmIGNhdXNlICE9PSBudWxsID8gY2F1c2UubWVzc2FnZSA6IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJjYXVzZVxcdFwiICsgY2F1c2UubWVzc2FnZSArIFwiXFx0XCIgKyB0aGlzLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhY2sgPSBcIlwiOyAvLyhuZXcgRXJyb3IpLnN0YWNrXG4gICAgICAgIGlmICh0eXBlb2YgY2F1c2UgIT09IFwidW5kZWZpbmVkXCIgJiYgY2F1c2UgIT09IG51bGwgPyBjYXVzZS5zdGFjayA6IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhY2sgPSBcImNhdXNlZCBieVxcblxcdFwiICsgY2F1c2Uuc3RhY2sgKyBcIlxcdFwiICsgc3RhY2s7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YWNrID0gdGhpcy5tZXNzYWdlICsgXCJcXG5cIiArIHN0YWNrO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhFcnJvcldpdGhDYXVzZSwgbnVsbCwgW3tcbiAgICAgICAga2V5OiBcInRocm93XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGhyb3cobWVzc2FnZSwgY2F1c2UpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSBtZXNzYWdlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYXVzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYXVzZSAhPT0gbnVsbCA/IGNhdXNlLm1lc3NhZ2UgOiB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtc2cgKz0gXCJcXHQgY2F1c2U6IFwiICsgY2F1c2UubWVzc2FnZSArIFwiIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYXVzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYXVzZSAhPT0gbnVsbCA/IGNhdXNlLnN0YWNrIDogdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbXNnICs9IFwiXFxuIHN0YWNrOiBcIiArIGNhdXNlLnN0YWNrICsgXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBFcnJvcldpdGhDYXVzZTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBFcnJvcldpdGhDYXVzZTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvZXJyb3Jfd2l0aF9jYXVzZS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG4vKipcbiAgICBDb252ZXJ0IDEyLjM0IHdpdGggYSBwcmVjaXNpb24gb2YgMyBpbnRvIDEyMzQwXG5cbiAgICBAYXJnIHtudW1iZXJ8c3RyaW5nfSBudW1iZXIgLSBVc2Ugc3RyaW5ncyBmb3IgbGFyZ2UgbnVtYmVycy4gIFRoaXMgbWF5IGNvbnRhaW4gb25lIGRlY2ltYWwgYnV0IG5vIHNpZ25cbiAgICBAYXJnIHtudW1iZXJ9IHByZWNpc2lvbiAtIG51bWJlciBvZiBpbXBsaWVkIGRlY2ltYWwgcGxhY2VzICh1c3VhbGx5IGNhdXNlcyByaWdodCB6ZXJvIHBhZGRpbmcpXG4gICAgQHJldHVybiB7c3RyaW5nfSAtXG4qL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdG9JbXBsaWVkRGVjaW1hbDogZnVuY3Rpb24gdG9JbXBsaWVkRGVjaW1hbChudW1iZXIsIHByZWNpc2lvbikge1xuXG4gICAgICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBhc3NlcnQobnVtYmVyIDw9IDkwMDcxOTkyNTQ3NDA5OTEsIFwib3ZlcmZsb3dcIik7XG4gICAgICAgICAgICBudW1iZXIgPSBcIlwiICsgbnVtYmVyO1xuICAgICAgICB9IGVsc2UgaWYgKG51bWJlci50b1N0cmluZykgbnVtYmVyID0gbnVtYmVyLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBudW1iZXIgPT09IFwic3RyaW5nXCIsIFwibnVtYmVyIHNob3VsZCBiZSBhbiBhY3R1YWwgbnVtYmVyIG9yIHN0cmluZzogXCIgKyAodHlwZW9mIG51bWJlciA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG51bWJlcikpKTtcbiAgICAgICAgbnVtYmVyID0gbnVtYmVyLnRyaW0oKTtcbiAgICAgICAgYXNzZXJ0KC9eWzAtOV0qXFwuP1swLTldKiQvLnRlc3QobnVtYmVyKSwgXCJJbnZhbGlkIGRlY2ltYWwgbnVtYmVyIFwiICsgbnVtYmVyKTtcblxuICAgICAgICB2YXIgX251bWJlciRzcGxpdCA9IG51bWJlci5zcGxpdChcIi5cIik7XG5cbiAgICAgICAgdmFyIF9udW1iZXIkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX251bWJlciRzcGxpdCwgMik7XG5cbiAgICAgICAgdmFyIF9udW1iZXIkc3BsaXQyJCA9IF9udW1iZXIkc3BsaXQyWzBdO1xuICAgICAgICB2YXIgd2hvbGUgPSBfbnVtYmVyJHNwbGl0MiQgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBfbnVtYmVyJHNwbGl0MiQ7XG4gICAgICAgIHZhciBfbnVtYmVyJHNwbGl0MiQyID0gX251bWJlciRzcGxpdDJbMV07XG4gICAgICAgIHZhciBkZWNpbWFsID0gX251bWJlciRzcGxpdDIkMiA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IF9udW1iZXIkc3BsaXQyJDI7XG5cblxuICAgICAgICB2YXIgcGFkZGluZyA9IHByZWNpc2lvbiAtIGRlY2ltYWwubGVuZ3RoO1xuICAgICAgICBhc3NlcnQocGFkZGluZyA+PSAwLCBcIlRvbyBtYW55IGRlY2ltYWwgZGlnaXRzIGluIFwiICsgbnVtYmVyICsgXCIgdG8gY3JlYXRlIGFuIGltcGxpZWQgZGVjaW1hbCBvZiBcIiArIHByZWNpc2lvbik7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRkaW5nOyBpKyspIHtcbiAgICAgICAgICAgIGRlY2ltYWwgKz0gXCIwXCI7XG4gICAgICAgIH13aGlsZSAod2hvbGUuY2hhckF0KDApID09PSBcIjBcIikge1xuICAgICAgICAgICAgd2hvbGUgPSB3aG9sZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1yZXR1cm4gd2hvbGUgKyBkZWNpbWFsO1xuICAgIH0sXG5cbiAgICBmcm9tSW1wbGllZERlY2ltYWw6IGZ1bmN0aW9uIGZyb21JbXBsaWVkRGVjaW1hbChudW1iZXIsIHByZWNpc2lvbikge1xuICAgICAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgYXNzZXJ0KG51bWJlciA8PSA5MDA3MTk5MjU0NzQwOTkxLCBcIm92ZXJmbG93XCIpO1xuICAgICAgICAgICAgbnVtYmVyID0gXCJcIiArIG51bWJlcjtcbiAgICAgICAgfSBlbHNlIGlmIChudW1iZXIudG9TdHJpbmcpIG51bWJlciA9IG51bWJlci50b1N0cmluZygpO1xuXG4gICAgICAgIHdoaWxlIChudW1iZXIubGVuZ3RoIDwgcHJlY2lzaW9uICsgMSkge1xuICAgICAgICAgICAgLy8gMC4xMjNcbiAgICAgICAgICAgIG51bWJlciA9IFwiMFwiICsgbnVtYmVyO1xuICAgICAgICB9IC8vIDQ0MDAwID0+IDQ0LjAwMFxuICAgICAgICB2YXIgZGVjX3N0cmluZyA9IG51bWJlci5zdWJzdHJpbmcobnVtYmVyLmxlbmd0aCAtIHByZWNpc2lvbik7XG4gICAgICAgIHJldHVybiBudW1iZXIuc3Vic3RyaW5nKDAsIG51bWJlci5sZW5ndGggLSBwcmVjaXNpb24pICsgKGRlY19zdHJpbmcgPyBcIi5cIiArIGRlY19zdHJpbmcgOiBcIlwiKTtcbiAgICB9XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9udW1iZXJVdGlscy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xudmFyIFNlcmlhbGl6ZXJJbXBsID0gcmVxdWlyZShcIi4vc2VyaWFsaXplclwiKTtcblxudmFyIGludDE2ID0gdHlwZXMuaW50MTY7XG52YXIgdWludDE2ID0gdHlwZXMudWludDE2O1xudmFyIHVpbnQzMiA9IHR5cGVzLnVpbnQzMjtcbnZhciBpbnQ2NCA9IHR5cGVzLmludDY0O1xudmFyIHVpbnQ2NCA9IHR5cGVzLnVpbnQ2NDtcbnZhciBzdHJpbmcgPSB0eXBlcy5zdHJpbmc7XG52YXIgYnl0ZXMgPSB0eXBlcy5ieXRlcztcbnZhciBib29sID0gdHlwZXMuYm9vbDtcbnZhciBhcnJheSA9IHR5cGVzLmFycmF5O1xudmFyIGZpeGVkX2FycmF5ID0gdHlwZXMuZml4ZWRfYXJyYXk7XG52YXIgb2JqZWN0X2lkX3R5cGUgPSB0eXBlcy5vYmplY3RfaWRfdHlwZTtcbnZhciB2b3RlX2lkID0gdHlwZXMudm90ZV9pZDtcbnZhciBmdXR1cmVfZXh0ZW5zaW9ucyA9IHR5cGVzLmZ1dHVyZV9leHRlbnNpb25zO1xudmFyIHN0YXRpY192YXJpYW50ID0gdHlwZXMuc3RhdGljX3ZhcmlhbnQ7XG52YXIgbWFwID0gdHlwZXMubWFwO1xudmFyIHNldCA9IHR5cGVzLnNldDtcbnZhciBwdWJsaWNfa2V5ID0gdHlwZXMucHVibGljX2tleTtcbnZhciBhZGRyZXNzID0gdHlwZXMuYWRkcmVzcztcbnZhciB0aW1lX3BvaW50X3NlYyA9IHR5cGVzLnRpbWVfcG9pbnRfc2VjO1xudmFyIG9wdGlvbmFsID0gdHlwZXMub3B0aW9uYWw7XG52YXIgYXNzZXQgPSB0eXBlcy5hc3NldDtcblxuXG5mdXR1cmVfZXh0ZW5zaW9ucyA9IHR5cGVzLnZvaWQ7XG5cbi8qXG5XaGVuIHVwZGF0aW5nIGdlbmVyYXRlZCBjb2RlXG5SZXBsYWNlOiAgb3BlcmF0aW9uID0gc3RhdGljX3ZhcmlhbnQgW1xud2l0aDogICAgIG9wZXJhdGlvbi5zdF9vcGVyYXRpb25zID0gW1xuXG5hdCB0aGUgZW5kIG9mIHRoaXMgZmlsZS5cblxuVGhlbiwgZGVsZXRlIHRoaXMgcGFydDpcbnB1YmxpY19rZXkgPSBuZXcgU2VyaWFsaXplcihcbiAgICBcInB1YmxpY19rZXlcIlxuICAgIGtleV9kYXRhOiBieXRlcyAzM1xuKVxuXG4qL1xuLy8gUGxhY2UtaG9sZGVyLCB0aGVpciBhcmUgZGVwZW5kZW5jaWVzIG9uIFwib3BlcmF0aW9uXCIgLi4gVGhlIGZpbmFsIGxpc3Qgb2Zcbi8vIG9wZXJhdGlvbnMgaXMgbm90IGF2aWFsYmxlIHVudGlsIHRoZSB2ZXJ5IGVuZCBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4vLyBTZWU6IG9wZXJhdGlvbi5zdF9vcGVyYXRpb25zID0gLi4uXG52YXIgb3BlcmF0aW9uID0gc3RhdGljX3ZhcmlhbnQoKTtcbm1vZHVsZS5leHBvcnRzW1wib3BlcmF0aW9uXCJdID0gb3BlcmF0aW9uO1xuXG4vLyBGb3IgbW9kdWxlLmV4cG9ydHNcbnZhciBTZXJpYWxpemVyID0gZnVuY3Rpb24gU2VyaWFsaXplcihvcGVyYXRpb25fbmFtZSwgc2VyaWxpemF0aW9uX3R5cGVzX29iamVjdCkge1xuICAgIHZhciBzID0gbmV3IFNlcmlhbGl6ZXJJbXBsKG9wZXJhdGlvbl9uYW1lLCBzZXJpbGl6YXRpb25fdHlwZXNfb2JqZWN0KTtcbiAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHNbb3BlcmF0aW9uX25hbWVdID0gcztcbn07XG5cbi8vIEN1c3RvbS10eXBlcyBmb2xsb3cgR2VuZXJhdGVkIGNvZGU6XG5cbi8vICMjICBHZW5lcmF0ZWQgY29kZSBmb2xsb3dzXG4vLyAjIG5wbSBpIC1nIGRlY2FmZmVpbmF0ZVxuLy8gIyBwcm9ncmFtcy9qc19vcGVyYXRpb25fc2VyaWFsaXplciA+IG9wcy5jb2ZmZWUgJiYgZGVjYWZmZWluYXRlIG9wcy5jb2ZmZWVcbi8vICMgb3BlbiBvcHMudHh0LCBjb3B5IHRvIENoYWluL0NoYWluVHlwZXMgYW5kIG9wZXJhdGlvbnMuanNcbi8vICMjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBzaWduZWRfdHJhbnNhY3Rpb24gPSBuZXcgU2VyaWFsaXplcihcInNpZ25lZF90cmFuc2FjdGlvblwiLCB7XG4gICAgcmVmX2Jsb2NrX251bTogdWludDE2LFxuICAgIHJlZl9ibG9ja19wcmVmaXg6IHVpbnQzMixcbiAgICBleHBpcmF0aW9uOiB0aW1lX3BvaW50X3NlYyxcbiAgICBvcGVyYXRpb25zOiBhcnJheShvcGVyYXRpb24pLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucyksXG4gICAgc2lnbmF0dXJlczogYXJyYXkoYnl0ZXMoNjUpKVxufSk7XG5cbnZhciBzaWduZWRfYmxvY2sgPSBuZXcgU2VyaWFsaXplcihcInNpZ25lZF9ibG9ja1wiLCB7XG4gICAgcHJldmlvdXM6IGJ5dGVzKDIwKSxcbiAgICB0aW1lc3RhbXA6IHRpbWVfcG9pbnRfc2VjLFxuICAgIHdpdG5lc3M6IHN0cmluZyxcbiAgICB0cmFuc2FjdGlvbl9tZXJrbGVfcm9vdDogYnl0ZXMoMjApLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucyksXG4gICAgd2l0bmVzc19zaWduYXR1cmU6IGJ5dGVzKDY1KSxcbiAgICB0cmFuc2FjdGlvbnM6IGFycmF5KHNpZ25lZF90cmFuc2FjdGlvbilcbn0pO1xuXG52YXIgYmxvY2tfaGVhZGVyID0gbmV3IFNlcmlhbGl6ZXIoXCJibG9ja19oZWFkZXJcIiwge1xuICAgIHByZXZpb3VzOiBieXRlcygyMCksXG4gICAgdGltZXN0YW1wOiB0aW1lX3BvaW50X3NlYyxcbiAgICB3aXRuZXNzOiBzdHJpbmcsXG4gICAgdHJhbnNhY3Rpb25fbWVya2xlX3Jvb3Q6IGJ5dGVzKDIwKSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpXG59KTtcblxudmFyIHNpZ25lZF9ibG9ja19oZWFkZXIgPSBuZXcgU2VyaWFsaXplcihcInNpZ25lZF9ibG9ja19oZWFkZXJcIiwge1xuICAgIHByZXZpb3VzOiBieXRlcygyMCksXG4gICAgdGltZXN0YW1wOiB0aW1lX3BvaW50X3NlYyxcbiAgICB3aXRuZXNzOiBzdHJpbmcsXG4gICAgdHJhbnNhY3Rpb25fbWVya2xlX3Jvb3Q6IGJ5dGVzKDIwKSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpLFxuICAgIHdpdG5lc3Nfc2lnbmF0dXJlOiBieXRlcyg2NSlcbn0pO1xuXG52YXIgdm90ZSA9IG5ldyBTZXJpYWxpemVyKFwidm90ZVwiLCB7XG4gICAgdm90ZXI6IHN0cmluZyxcbiAgICBhdXRob3I6IHN0cmluZyxcbiAgICBwZXJtbGluazogc3RyaW5nLFxuICAgIHdlaWdodDogdWludDE2XG59KTtcblxudmFyIGNvbW1lbnQgPSBuZXcgU2VyaWFsaXplcihcImNvbW1lbnRcIiwge1xuICAgIHBhcmVudF9hdXRob3I6IHN0cmluZyxcbiAgICBwYXJlbnRfcGVybWxpbms6IHN0cmluZyxcbiAgICBhdXRob3I6IHN0cmluZyxcbiAgICBwZXJtbGluazogc3RyaW5nLFxuICAgIHRpdGxlOiBzdHJpbmcsXG4gICAgYm9keTogc3RyaW5nLFxuICAgIGpzb25fbWV0YWRhdGE6IHN0cmluZ1xufSk7XG5cbi8vIGxldCBhc3NldCA9IG5ldyBTZXJpYWxpemVyKFxuLy8gICAgIFwiYXNzZXRcIix7XG4vLyAgICAgYW1vdW50OiBpbnQ2NCxcbi8vICAgICBzeW1ib2w6IHN0cmluZ1xuLy8gfVxuLy8gKTtcblxudmFyIHRyYW5zZmVyID0gbmV3IFNlcmlhbGl6ZXIoXCJ0cmFuc2ZlclwiLCB7XG4gICAgZnJvbTogc3RyaW5nLFxuICAgIHRvOiBzdHJpbmcsXG4gICAgYW1vdW50OiBhc3NldCxcbiAgICBtZW1vOiBzdHJpbmdcbn0pO1xuXG52YXIgdHJhbnNmZXJfdG9fdmVzdGluZyA9IG5ldyBTZXJpYWxpemVyKFwidHJhbnNmZXJfdG9fdmVzdGluZ1wiLCB7XG4gICAgZnJvbTogc3RyaW5nLFxuICAgIHRvOiBzdHJpbmcsXG4gICAgYW1vdW50OiBhc3NldFxufSk7XG5cbnZhciB3aXRoZHJhd192ZXN0aW5nID0gbmV3IFNlcmlhbGl6ZXIoXCJ3aXRoZHJhd192ZXN0aW5nXCIsIHtcbiAgICBhY2NvdW50OiBzdHJpbmcsXG4gICAgdmVzdGluZ19zaGFyZXM6IGFzc2V0XG59KTtcblxudmFyIGxpbWl0X29yZGVyX2NyZWF0ZSA9IG5ldyBTZXJpYWxpemVyKFwibGltaXRfb3JkZXJfY3JlYXRlXCIsIHtcbiAgICBvd25lcjogc3RyaW5nLFxuICAgIG9yZGVyaWQ6IHVpbnQzMixcbiAgICBhbW91bnRfdG9fc2VsbDogYXNzZXQsXG4gICAgbWluX3RvX3JlY2VpdmU6IGFzc2V0LFxuICAgIGZpbGxfb3Jfa2lsbDogYm9vbCxcbiAgICBleHBpcmF0aW9uOiB0aW1lX3BvaW50X3NlY1xufSk7XG5cbnZhciBsaW1pdF9vcmRlcl9jYW5jZWwgPSBuZXcgU2VyaWFsaXplcihcImxpbWl0X29yZGVyX2NhbmNlbFwiLCB7XG4gICAgb3duZXI6IHN0cmluZyxcbiAgICBvcmRlcmlkOiB1aW50MzJcbn0pO1xuXG52YXIgcHJpY2UgPSBuZXcgU2VyaWFsaXplcihcInByaWNlXCIsIHtcbiAgICBiYXNlOiBhc3NldCxcbiAgICBxdW90ZTogYXNzZXRcbn0pO1xuXG52YXIgZmVlZF9wdWJsaXNoID0gbmV3IFNlcmlhbGl6ZXIoXCJmZWVkX3B1Ymxpc2hcIiwge1xuICAgIHB1Ymxpc2hlcjogc3RyaW5nLFxuICAgIGV4Y2hhbmdlX3JhdGU6IHByaWNlXG59KTtcblxudmFyIGNvbnZlcnQgPSBuZXcgU2VyaWFsaXplcihcImNvbnZlcnRcIiwge1xuICAgIG93bmVyOiBzdHJpbmcsXG4gICAgcmVxdWVzdGlkOiB1aW50MzIsXG4gICAgYW1vdW50OiBhc3NldFxufSk7XG5cbnZhciBhdXRob3JpdHkgPSBuZXcgU2VyaWFsaXplcihcImF1dGhvcml0eVwiLCB7XG4gICAgd2VpZ2h0X3RocmVzaG9sZDogdWludDMyLFxuICAgIGFjY291bnRfYXV0aHM6IG1hcChzdHJpbmcsIHVpbnQxNiksXG4gICAga2V5X2F1dGhzOiBtYXAocHVibGljX2tleSwgdWludDE2KVxufSk7XG5cbnZhciBhY2NvdW50X2NyZWF0ZSA9IG5ldyBTZXJpYWxpemVyKFwiYWNjb3VudF9jcmVhdGVcIiwge1xuICAgIGZlZTogYXNzZXQsXG4gICAgY3JlYXRvcjogc3RyaW5nLFxuICAgIG5ld19hY2NvdW50X25hbWU6IHN0cmluZyxcbiAgICBvd25lcjogYXV0aG9yaXR5LFxuICAgIGFjdGl2ZTogYXV0aG9yaXR5LFxuICAgIHBvc3Rpbmc6IGF1dGhvcml0eSxcbiAgICBtZW1vX2tleTogcHVibGljX2tleSxcbiAgICBqc29uX21ldGFkYXRhOiBzdHJpbmdcbn0pO1xuXG52YXIgYWNjb3VudF91cGRhdGUgPSBuZXcgU2VyaWFsaXplcihcImFjY291bnRfdXBkYXRlXCIsIHtcbiAgICBhY2NvdW50OiBzdHJpbmcsXG4gICAgb3duZXI6IG9wdGlvbmFsKGF1dGhvcml0eSksXG4gICAgYWN0aXZlOiBvcHRpb25hbChhdXRob3JpdHkpLFxuICAgIHBvc3Rpbmc6IG9wdGlvbmFsKGF1dGhvcml0eSksXG4gICAgbWVtb19rZXk6IHB1YmxpY19rZXksXG4gICAganNvbl9tZXRhZGF0YTogc3RyaW5nXG59KTtcblxudmFyIGNoYWluX3Byb3BlcnRpZXMgPSBuZXcgU2VyaWFsaXplcihcImNoYWluX3Byb3BlcnRpZXNcIiwge1xuICAgIGFjY291bnRfY3JlYXRpb25fZmVlOiBhc3NldCxcbiAgICBtYXhpbXVtX2Jsb2NrX3NpemU6IHVpbnQzMixcbiAgICBzYmRfaW50ZXJlc3RfcmF0ZTogdWludDE2XG59KTtcblxudmFyIHdpdG5lc3NfdXBkYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJ3aXRuZXNzX3VwZGF0ZVwiLCB7XG4gICAgb3duZXI6IHN0cmluZyxcbiAgICB1cmw6IHN0cmluZyxcbiAgICBibG9ja19zaWduaW5nX2tleTogcHVibGljX2tleSxcbiAgICBwcm9wczogY2hhaW5fcHJvcGVydGllcyxcbiAgICBmZWU6IGFzc2V0XG59KTtcblxudmFyIGFjY291bnRfd2l0bmVzc192b3RlID0gbmV3IFNlcmlhbGl6ZXIoXCJhY2NvdW50X3dpdG5lc3Nfdm90ZVwiLCB7XG4gICAgYWNjb3VudDogc3RyaW5nLFxuICAgIHdpdG5lc3M6IHN0cmluZyxcbiAgICBhcHByb3ZlOiBib29sXG59KTtcblxudmFyIGFjY291bnRfd2l0bmVzc19wcm94eSA9IG5ldyBTZXJpYWxpemVyKFwiYWNjb3VudF93aXRuZXNzX3Byb3h5XCIsIHtcbiAgICBhY2NvdW50OiBzdHJpbmcsXG4gICAgcHJveHk6IHN0cmluZ1xufSk7XG5cbnZhciBwb3cgPSBuZXcgU2VyaWFsaXplcihcInBvd1wiLCB7XG4gICAgd29ya2VyOiBwdWJsaWNfa2V5LFxuICAgIGlucHV0OiBieXRlcygzMiksXG4gICAgc2lnbmF0dXJlOiBieXRlcyg2NSksXG4gICAgd29yazogYnl0ZXMoMzIpXG59KTtcblxudmFyIGN1c3RvbSA9IG5ldyBTZXJpYWxpemVyKFwiY3VzdG9tXCIsIHtcbiAgICByZXF1aXJlZF9hdXRoczogc2V0KHN0cmluZyksXG4gICAgaWQ6IHVpbnQxNixcbiAgICBkYXRhOiBieXRlcygpXG59KTtcblxudmFyIHJlcG9ydF9vdmVyX3Byb2R1Y3Rpb24gPSBuZXcgU2VyaWFsaXplcihcInJlcG9ydF9vdmVyX3Byb2R1Y3Rpb25cIiwge1xuICAgIHJlcG9ydGVyOiBzdHJpbmcsXG4gICAgZmlyc3RfYmxvY2s6IHNpZ25lZF9ibG9ja19oZWFkZXIsXG4gICAgc2Vjb25kX2Jsb2NrOiBzaWduZWRfYmxvY2tfaGVhZGVyXG59KTtcblxudmFyIGRlbGV0ZV9jb21tZW50ID0gbmV3IFNlcmlhbGl6ZXIoXCJkZWxldGVfY29tbWVudFwiLCB7XG4gICAgYXV0aG9yOiBzdHJpbmcsXG4gICAgcGVybWxpbms6IHN0cmluZ1xufSk7XG5cbnZhciBjdXN0b21fanNvbiA9IG5ldyBTZXJpYWxpemVyKFwiY3VzdG9tX2pzb25cIiwge1xuICAgIHJlcXVpcmVkX2F1dGhzOiBzZXQoc3RyaW5nKSxcbiAgICByZXF1aXJlZF9wb3N0aW5nX2F1dGhzOiBzZXQoc3RyaW5nKSxcbiAgICBpZDogc3RyaW5nLFxuICAgIGpzb246IHN0cmluZ1xufSk7XG5cbnZhciBjb21tZW50X29wdGlvbnMgPSBuZXcgU2VyaWFsaXplcihcImNvbW1lbnRfb3B0aW9uc1wiLCB7XG4gICAgYXV0aG9yOiBzdHJpbmcsXG4gICAgcGVybWxpbms6IHN0cmluZyxcbiAgICBtYXhfYWNjZXB0ZWRfcGF5b3V0OiBhc3NldCxcbiAgICBwZXJjZW50X3N0ZWVtX2RvbGxhcnM6IHVpbnQxNixcbiAgICBhbGxvd192b3RlczogYm9vbCxcbiAgICBhbGxvd19jdXJhdGlvbl9yZXdhcmRzOiBib29sLFxuICAgIGV4dGVuc2lvbnM6IHNldChzdGF0aWNfdmFyaWFudChbZnV0dXJlX2V4dGVuc2lvbnNdKSlcbn0pO1xuXG52YXIgc2V0X3dpdGhkcmF3X3Zlc3Rpbmdfcm91dGUgPSBuZXcgU2VyaWFsaXplcihcInNldF93aXRoZHJhd192ZXN0aW5nX3JvdXRlXCIsIHtcbiAgICBmcm9tX2FjY291bnQ6IHN0cmluZyxcbiAgICB0b19hY2NvdW50OiBzdHJpbmcsXG4gICAgcGVyY2VudDogdWludDE2LFxuICAgIGF1dG9fdmVzdDogYm9vbFxufSk7XG5cbnZhciBmaWxsX2NvbnZlcnRfcmVxdWVzdCA9IG5ldyBTZXJpYWxpemVyKFwiZmlsbF9jb252ZXJ0X3JlcXVlc3RcIiwge1xuICAgIG93bmVyOiBzdHJpbmcsXG4gICAgcmVxdWVzdGlkOiB1aW50MzIsXG4gICAgYW1vdW50X2luOiBhc3NldCxcbiAgICBhbW91bnRfb3V0OiBhc3NldFxufSk7XG5cbnZhciBjb21tZW50X3Jld2FyZCA9IG5ldyBTZXJpYWxpemVyKFwiY29tbWVudF9yZXdhcmRcIiwge1xuICAgIGF1dGhvcjogc3RyaW5nLFxuICAgIHBlcm1saW5rOiBzdHJpbmcsXG4gICAgc2JkX3BheW91dDogYXNzZXQsXG4gICAgdmVzdGluZ19wYXlvdXQ6IGFzc2V0XG59KTtcblxudmFyIGN1cmF0ZV9yZXdhcmQgPSBuZXcgU2VyaWFsaXplcihcImN1cmF0ZV9yZXdhcmRcIiwge1xuICAgIGN1cmF0b3I6IHN0cmluZyxcbiAgICByZXdhcmQ6IGFzc2V0LFxuICAgIGNvbW1lbnRfYXV0aG9yOiBzdHJpbmcsXG4gICAgY29tbWVudF9wZXJtbGluazogc3RyaW5nXG59KTtcblxudmFyIGxpcXVpZGl0eV9yZXdhcmQgPSBuZXcgU2VyaWFsaXplcihcImxpcXVpZGl0eV9yZXdhcmRcIiwge1xuICAgIG93bmVyOiBzdHJpbmcsXG4gICAgcGF5b3V0OiBhc3NldFxufSk7XG5cbnZhciBpbnRlcmVzdCA9IG5ldyBTZXJpYWxpemVyKFwiaW50ZXJlc3RcIiwge1xuICAgIG93bmVyOiBzdHJpbmcsXG4gICAgaW50ZXJlc3Q6IGFzc2V0XG59KTtcblxudmFyIGZpbGxfdmVzdGluZ193aXRoZHJhdyA9IG5ldyBTZXJpYWxpemVyKFwiZmlsbF92ZXN0aW5nX3dpdGhkcmF3XCIsIHtcbiAgICBmcm9tX2FjY291bnQ6IHN0cmluZyxcbiAgICB0b19hY2NvdW50OiBzdHJpbmcsXG4gICAgd2l0aGRyYXduOiBhc3NldCxcbiAgICBkZXBvc2l0ZWQ6IGFzc2V0XG59KTtcblxudmFyIGZpbGxfb3JkZXIgPSBuZXcgU2VyaWFsaXplcihcImZpbGxfb3JkZXJcIiwge1xuICAgIGN1cnJlbnRfb3duZXI6IHN0cmluZyxcbiAgICBjdXJyZW50X29yZGVyaWQ6IHVpbnQzMixcbiAgICBjdXJyZW50X3BheXM6IGFzc2V0LFxuICAgIG9wZW5fb3duZXI6IHN0cmluZyxcbiAgICBvcGVuX29yZGVyaWQ6IHVpbnQzMixcbiAgICBvcGVuX3BheXM6IGFzc2V0XG59KTtcblxudmFyIGNvbW1lbnRfcGF5b3V0ID0gbmV3IFNlcmlhbGl6ZXIoXCJjb21tZW50X3BheW91dFwiLCB7XG4gICAgYXV0aG9yOiBzdHJpbmcsXG4gICAgcGVybWxpbms6IHN0cmluZyxcbiAgICBwYXlvdXQ6IGFzc2V0XG59KTtcblxudmFyIGVzY3Jvd190cmFuc2ZlciA9IG5ldyBTZXJpYWxpemVyKFwiZXNjcm93X3RyYW5zZmVyXCIsIHtcbiAgICBmcm9tOiBzdHJpbmcsXG4gICAgdG86IHN0cmluZyxcbiAgICBhZ2VudDogc3RyaW5nLFxuICAgIGVzY3Jvd19pZDogdWludDMyLFxuICAgIHNiZF9hbW91bnQ6IGFzc2V0LFxuICAgIHN0ZWVtX2Ftb3VudDogYXNzZXQsXG4gICAgZmVlOiBhc3NldCxcbiAgICByYXRpZmljYXRpb25fZGVhZGxpbmU6IHRpbWVfcG9pbnRfc2VjLFxuICAgIGVzY3Jvd19leHBpcmF0aW9uOiB0aW1lX3BvaW50X3NlYyxcbiAgICBqc29uX21ldGFkYXRhOiBzdHJpbmdcbn0pO1xuXG52YXIgZXNjcm93X2FwcHJvdmUgPSBuZXcgU2VyaWFsaXplcihcImVzY3Jvd19hcHByb3ZlXCIsIHtcbiAgICBmcm9tOiBzdHJpbmcsXG4gICAgdG86IHN0cmluZyxcbiAgICBhZ2VudDogc3RyaW5nLFxuICAgIHdobzogc3RyaW5nLFxuICAgIGVzY3Jvd19pZDogdWludDMyLFxuICAgIGFwcHJvdmU6IGJvb2xcbn0pO1xuXG52YXIgZXNjcm93X2Rpc3B1dGUgPSBuZXcgU2VyaWFsaXplcihcImVzY3Jvd19kaXNwdXRlXCIsIHtcbiAgICBmcm9tOiBzdHJpbmcsXG4gICAgdG86IHN0cmluZyxcbiAgICBhZ2VudDogc3RyaW5nLFxuICAgIHdobzogc3RyaW5nLFxuICAgIGVzY3Jvd19pZDogdWludDMyXG59KTtcblxudmFyIGVzY3Jvd19yZWxlYXNlID0gbmV3IFNlcmlhbGl6ZXIoXCJlc2Nyb3dfcmVsZWFzZVwiLCB7XG4gICAgZnJvbTogc3RyaW5nLFxuICAgIHRvOiBzdHJpbmcsXG4gICAgYWdlbnQ6IHN0cmluZyxcbiAgICB3aG86IHN0cmluZyxcbiAgICByZWNlaXZlcjogc3RyaW5nLFxuICAgIGVzY3Jvd19pZDogdWludDMyLFxuICAgIHNiZF9hbW91bnQ6IGFzc2V0LFxuICAgIHN0ZWVtX2Ftb3VudDogYXNzZXRcbn0pO1xuXG5vcGVyYXRpb24uc3Rfb3BlcmF0aW9ucyA9IFt2b3RlLCBjb21tZW50LCB0cmFuc2ZlciwgdHJhbnNmZXJfdG9fdmVzdGluZywgd2l0aGRyYXdfdmVzdGluZywgbGltaXRfb3JkZXJfY3JlYXRlLCBsaW1pdF9vcmRlcl9jYW5jZWwsIGZlZWRfcHVibGlzaCwgY29udmVydCwgYWNjb3VudF9jcmVhdGUsIGFjY291bnRfdXBkYXRlLCB3aXRuZXNzX3VwZGF0ZSwgYWNjb3VudF93aXRuZXNzX3ZvdGUsIGFjY291bnRfd2l0bmVzc19wcm94eSwgcG93LCBjdXN0b20sIHJlcG9ydF9vdmVyX3Byb2R1Y3Rpb24sIGRlbGV0ZV9jb21tZW50LCBjdXN0b21fanNvbiwgY29tbWVudF9vcHRpb25zLCBzZXRfd2l0aGRyYXdfdmVzdGluZ19yb3V0ZSwgZmlsbF9jb252ZXJ0X3JlcXVlc3QsIGNvbW1lbnRfcmV3YXJkLCBjdXJhdGVfcmV3YXJkLCBsaXF1aWRpdHlfcmV3YXJkLCBpbnRlcmVzdCwgZmlsbF92ZXN0aW5nX3dpdGhkcmF3LCBmaWxsX29yZGVyLCBjb21tZW50X3BheW91dCwgZXNjcm93X3RyYW5zZmVyLCBlc2Nyb3dfYXBwcm92ZSwgZXNjcm93X2Rpc3B1dGUsIGVzY3Jvd19yZWxlYXNlXTtcblxudmFyIHRyYW5zYWN0aW9uID0gbmV3IFNlcmlhbGl6ZXIoXCJ0cmFuc2FjdGlvblwiLCB7XG4gICAgcmVmX2Jsb2NrX251bTogdWludDE2LFxuICAgIHJlZl9ibG9ja19wcmVmaXg6IHVpbnQzMixcbiAgICBleHBpcmF0aW9uOiB0aW1lX3BvaW50X3NlYyxcbiAgICBvcGVyYXRpb25zOiBhcnJheShvcGVyYXRpb24pLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucylcbn0pO1xuXG4vLyMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8jICBHZW5lcmF0ZWQgY29kZSBlbmRcbi8vIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL29wZXJhdGlvbnMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9zZXJpYWxpemVyL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ5dGVCdWZmZXIgPSByZXF1aXJlKCdieXRlYnVmZmVyJyk7XG52YXIgRUMgPSByZXF1aXJlKCcuL2Vycm9yX3dpdGhfY2F1c2UnKTtcblxudmFyIEhFWF9EVU1QID0gcHJvY2Vzcy5lbnYubnBtX2NvbmZpZ19fZ3JhcGhlbmVfc2VyaWFsaXplcl9oZXhfZHVtcDtcblxudmFyIFNlcmlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VyaWFsaXplcihvcGVyYXRpb25fbmFtZSwgdHlwZXMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlcmlhbGl6ZXIpO1xuXG4gICAgICAgIHRoaXMub3BlcmF0aW9uX25hbWUgPSBvcGVyYXRpb25fbmFtZTtcbiAgICAgICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgICAgICBpZiAodGhpcy50eXBlcykgdGhpcy5rZXlzID0gT2JqZWN0LmtleXModGhpcy50eXBlcyk7XG5cbiAgICAgICAgU2VyaWFsaXplci5wcmludERlYnVnID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU2VyaWFsaXplciwgW3tcbiAgICAgICAga2V5OiAnZnJvbUJ5dGVCdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZXJhYmxlID0gdGhpcy5rZXlzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBmaWVsZDsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlc1tmaWVsZF07XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSEVYX0RVTVApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5vcGVyYXRpb25fbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHR5cGUub3BlcmF0aW9uX25hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvMSA9IGIub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLmZyb21CeXRlQnVmZmVyKGIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbzIgPSBiLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5vZmZzZXQgPSBvMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9iLnJlc2V0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gYi5jb3B5KG8xLCBvMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkICsgJ1xcdCcsIF9iLnRvSGV4KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtmaWVsZF0gPSB0eXBlLmZyb21CeXRlQnVmZmVyKGIpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoU2VyaWFsaXplci5wcmludERlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVhZGluZyAnICsgdGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkICsgJyBpbiBkYXRhOicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIucHJpbnREZWJ1ZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgRUMudGhyb3codGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkLCBlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FwcGVuZEJ5dGVCdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXMua2V5cztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZmllbGQ7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZXNbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICB0eXBlLmFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0W2ZpZWxkXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBFQy50aHJvdyh0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQgKyBcIiA9IFwiICsgSlNPTi5zdHJpbmdpZnkob2JqZWN0W2ZpZWxkXSksIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNpcmN1bGFyIHJlZlxuICAgICAgICAgICAgICAgICAgICBFQy50aHJvdyh0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQgKyBcIiA9IFwiICsgb2JqZWN0W2ZpZWxkXSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbU9iamVjdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tT2JqZWN0KHNlcmlhbGl6ZWRfb2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLmtleXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGZpZWxkOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGVzW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VyaWFsaXplZF9vYmplY3RbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICAvL0RFQlVHIHZhbHVlID0gdmFsdWUucmVzb2x2ZSBpZiB2YWx1ZS5yZXNvbHZlXG4gICAgICAgICAgICAgICAgICAgIC8vREVCVUcgY29uc29sZS5sb2coJy4uLiB2YWx1ZScsZmllbGQsdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSB0eXBlLmZyb21PYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZmllbGRdID0gb2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgRUMudGhyb3codGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkLCBlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICAgIEBhcmcge2Jvb2xlYW59IFtkZWJ1Zy51c2VfZGVmYXVsdCA9IGZhbHNlXSAtIG1vcmUgdGVtcGxhdGUgZnJpZW5kbHlcbiAgICAgICAgICAgIEBhcmcge2Jvb2xlYW59IFtkZWJ1Zy5hbm5vdGF0ZSA9IGZhbHNlXSAtIGFkZCB1c2VyLWZyaWVuZGx5IGluZm9ybWF0aW9uXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvT2JqZWN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRfb2JqZWN0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7IHVzZV9kZWZhdWx0OiBmYWxzZSwgYW5ub3RhdGU6IGZhbHNlIH0gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50eXBlcykgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICAgICAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXMua2V5cztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZmllbGQ7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZXNbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gdHlwZS50b09iamVjdCh0eXBlb2Ygc2VyaWFsaXplZF9vYmplY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VyaWFsaXplZF9vYmplY3QgIT09IG51bGwgPyBzZXJpYWxpemVkX29iamVjdFtmaWVsZF0gOiB1bmRlZmluZWQsIGRlYnVnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkXSA9IG9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEhFWF9EVU1QKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IG5ldyBCeXRlQnVmZmVyKEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWSwgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUuYXBwZW5kQnl0ZUJ1ZmZlcihiLCB0eXBlb2Ygc2VyaWFsaXplZF9vYmplY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VyaWFsaXplZF9vYmplY3QgIT09IG51bGwgPyBzZXJpYWxpemVkX29iamVjdFtmaWVsZF0gOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGIuY29weSgwLCBiLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHRoaXMub3BlcmF0aW9uX25hbWUgKyAnLicgKyBmaWVsZCwgYi50b0hleCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgRUMudGhyb3codGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkLCBlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogU29ydCBieSB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIG9wZXJhdGlvbiAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb21wYXJlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuXG4gICAgICAgICAgICB2YXIgZmlyc3Rfa2V5ID0gdGhpcy5rZXlzWzBdO1xuICAgICAgICAgICAgdmFyIGZpcnN0X3R5cGUgPSB0aGlzLnR5cGVzW2ZpcnN0X2tleV07XG5cbiAgICAgICAgICAgIHZhciB2YWxBID0gYVtmaXJzdF9rZXldO1xuICAgICAgICAgICAgdmFyIHZhbEIgPSBiW2ZpcnN0X2tleV07XG5cbiAgICAgICAgICAgIGlmIChmaXJzdF90eXBlLmNvbXBhcmUpIHJldHVybiBmaXJzdF90eXBlLmNvbXBhcmUodmFsQSwgdmFsQik7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsQSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgdmFsQiA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHZhbEEgLSB2YWxCO1xuXG4gICAgICAgICAgICB2YXIgZW5jb2RpbmcgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbEEpICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWxCKSkge1xuICAgICAgICAgICAgICAgIC8vIEEgYmluYXJ5IHN0cmluZyBjb21wYXJlIGRvZXMgbm90IHdvcmsuICBJZiBsb2NhbGVDb21wYXJlIGlzIHdlbGwgc3VwcG9ydGVkIHRoYXQgY291bGQgcmVwbGFjZSBIRVguICBQZXJmb3JtYW5hbmNlIGlzIHZlcnkgZ29vZCBzbyBjb21wYXJpbmcgSEVYIHdvcmtzLlxuICAgICAgICAgICAgICAgIGVuY29kaW5nID0gXCJoZXhcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0ckEgPSB2YWxBLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICAgICAgICAgIHZhciBzdHJCID0gdmFsQi50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgICAgICAgICByZXR1cm4gc3RyQSA+IHN0ckIgPyAxIDogc3RyQSA8IHN0ckIgPyAtMSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyA8aGVscGVyX2Z1bmN0aW9ucz5cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbUhleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgdmFyIGIgPSBCeXRlQnVmZmVyLmZyb21IZXgoaGV4LCBCeXRlQnVmZmVyLkxJVFRMRV9FTkRJQU4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUJ5dGVCdWZmZXIoYik7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21CdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gQnl0ZUJ1ZmZlci5mcm9tQmluYXJ5KGJ1ZmZlci50b1N0cmluZyhcImJpbmFyeVwiKSwgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21CeXRlQnVmZmVyKGIpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0hleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0hleChvYmplY3QpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGlzLnRvQnVmZmVyKG9iamVjdCkudG9TdHJpbmcoXCJoZXhcIilcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy50b0J5dGVCdWZmZXIob2JqZWN0KTtcbiAgICAgICAgICAgIHJldHVybiBiLnRvSGV4KCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQnl0ZUJ1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J5dGVCdWZmZXIob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBCeXRlQnVmZmVyKEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWSwgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpO1xuICAgICAgICAgICAgcmV0dXJuIGIuY29weSgwLCBiLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQnVmZmVyKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy50b0J5dGVCdWZmZXIob2JqZWN0KS50b0JpbmFyeSgpLCAnYmluYXJ5Jyk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU2VyaWFsaXplcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXJpYWxpemVyO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9zZXJpYWxpemVyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxuLyoqIENvbnNvbGUgcHJpbnQgYW55IHRyYW5zYWN0aW9uIG9iamVjdCB3aXRoIHplcm8gZGVmYXVsdCB2YWx1ZXMuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRlbXBsYXRlKG9wKSB7XG5cbiAgICB2YXIgb2JqZWN0ID0gb3AudG9PYmplY3Qodm9pZCAwLCB7IHVzZV9kZWZhdWx0OiB0cnVlLCBhbm5vdGF0ZTogdHJ1ZSB9KTtcblxuICAgIC8vIHZpc3VhbCAod2l0aCBkZXNjcmlwdGlvbnMpXG4gICAgY29uc29sZS5lcnJvcihKU09OLnN0cmluZ2lmeShvYmplY3QsIG51bGwsIDQpKTtcblxuICAgIC8vIHVzYWJsZSBpbiBhIGNvcHktcGFzdGVcblxuICAgIG9iamVjdCA9IG9wLnRvT2JqZWN0KHZvaWQgMCwgeyB1c2VfZGVmYXVsdDogdHJ1ZSwgYW5ub3RhdGU6IGZhbHNlIH0pO1xuXG4gICAgLy8gY29weS1wYXN0ZSBvbmUtbGluZWVyXG4gICAgY29uc29sZS5lcnJvcihKU09OLnN0cmluZ2lmeShvYmplY3QpKTtcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL3RlbXBsYXRlLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbi8vIExvdy1sZXZlbCB0eXBlcyB0aGF0IG1ha2UgdXAgb3BlcmF0aW9uc1xuXG52YXIgdiA9IHJlcXVpcmUoJy4vU2VyaWFsaXplclZhbGlkYXRpb24nKTtcbnZhciBmcCA9IHJlcXVpcmUoJy4vRmFzdFBhcnNlcicpO1xuXG52YXIgQ2hhaW5UeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9jaGFpbi9zcmMvQ2hhaW5UeXBlc1wiKTtcbnZhciBPYmplY3RJZCA9IHJlcXVpcmUoXCIuLi8uLi9jaGFpbi9zcmMvT2JqZWN0SWRcIik7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi8uLi9lY2NcIik7XG5cbnZhciBQdWJsaWNLZXkgPSBfcmVxdWlyZS5QdWJsaWNLZXk7XG52YXIgQWRkcmVzcyA9IF9yZXF1aXJlLkFkZHJlc3M7XG5cbnZhciBDaGFpbkNvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jaGFpbi9zcmMvQ2hhaW5Db25maWdcIik7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi9udW1iZXJVdGlsc1wiKTtcblxudmFyIGZyb21JbXBsaWVkRGVjaW1hbCA9IF9yZXF1aXJlMi5mcm9tSW1wbGllZERlY2ltYWw7XG5cbnZhciBUeXBlcyA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBUeXBlcztcblxudmFyIEhFWF9EVU1QID0gcHJvY2Vzcy5lbnYubnBtX2NvbmZpZ19fZ3JhcGhlbmVfc2VyaWFsaXplcl9oZXhfZHVtcDtcblxuVHlwZXMuYXNzZXQgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgdmFyIGFtb3VudCA9IGIucmVhZEludDY0KCk7XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSBiLnJlYWRVaW50OCgpO1xuICAgICAgICB2YXIgYl9jb3B5ID0gYi5jb3B5KGIub2Zmc2V0LCBiLm9mZnNldCArIDcpO1xuICAgICAgICB2YXIgc3ltYm9sID0gbmV3IEJ1ZmZlcihiX2NvcHkudG9CaW5hcnkoKSwgXCJiaW5hcnlcIikudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHgwMC9nLCBcIlwiKTtcbiAgICAgICAgYi5za2lwKDcpO1xuICAgICAgICAvLyBcIjEuMDAwIFNURUVNXCIgYWx3YXlzIHdyaXR0ZW4gd2l0aCBmdWxsIHByZWNpc2lvblxuICAgICAgICB2YXIgYW1vdW50X3N0cmluZyA9IGZyb21JbXBsaWVkRGVjaW1hbChhbW91bnQsIHByZWNpc2lvbik7XG4gICAgICAgIHJldHVybiBhbW91bnRfc3RyaW5nICsgXCIgXCIgKyBzeW1ib2w7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICBvYmplY3QgPSBvYmplY3QudHJpbSgpO1xuICAgICAgICBpZiAoIS9eWzAtOV0rXFwuP1swLTldKiBbQS1aYS16MC05XSskLy50ZXN0KG9iamVjdCkpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGluZyBhbW91bnQgbGlrZSAnOTkuMDAwIFNZTUJPTCcsIGluc3RlYWQgZ290ICdcIiArIG9iamVjdCArIFwiJ1wiKTtcblxuICAgICAgICB2YXIgX29iamVjdCRzcGxpdCA9IG9iamVjdC5zcGxpdChcIiBcIik7XG5cbiAgICAgICAgdmFyIF9vYmplY3Qkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX29iamVjdCRzcGxpdCwgMik7XG5cbiAgICAgICAgdmFyIGFtb3VudCA9IF9vYmplY3Qkc3BsaXQyWzBdO1xuICAgICAgICB2YXIgc3ltYm9sID0gX29iamVjdCRzcGxpdDJbMV07XG5cbiAgICAgICAgaWYgKHN5bWJvbC5sZW5ndGggPiA2KSB0aHJvdyBuZXcgRXJyb3IoXCJTeW1ib2xzIGFyZSBub3QgbG9uZ2VyIHRoYW4gNiBjaGFyYWN0ZXJzIFwiICsgc3ltYm9sICsgXCItXCIgKyBzeW1ib2wubGVuZ3RoKTtcblxuICAgICAgICBiLndyaXRlSW50NjQodi50b19sb25nKGFtb3VudC5yZXBsYWNlKFwiLlwiLCBcIlwiKSkpO1xuICAgICAgICB2YXIgZG90ID0gYW1vdW50LmluZGV4T2YoXCIuXCIpOyAvLyAwLjAwMFxuICAgICAgICB2YXIgcHJlY2lzaW9uID0gZG90ID09PSAtMSA/IDAgOiBhbW91bnQubGVuZ3RoIC0gZG90IC0gMTtcbiAgICAgICAgYi53cml0ZVVpbnQ4KHByZWNpc2lvbik7XG4gICAgICAgIGIuYXBwZW5kKHN5bWJvbC50b1VwcGVyQ2FzZSgpLCAnYmluYXJ5Jyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNyAtIHN5bWJvbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYi53cml0ZVVpbnQ4KDApO1xuICAgICAgICB9cmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwLjAwMCBTVEVFTVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxufTtcblxuVHlwZXMudWludDggPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVhZFVpbnQ4KCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRiwgb2JqZWN0LCAndWludDggJyArIG9iamVjdCk7XG4gICAgICAgIGIud3JpdGVVaW50OChvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRiwgb2JqZWN0LCAndWludDggJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkYsIG9iamVjdCwgJ3VpbnQ4ICcgKyBvYmplY3QpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqZWN0KTtcbiAgICB9XG59O1xuXG5UeXBlcy5pbnQxNiA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkSW50MTYoKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZSgwLCAweEZGRkYsIG9iamVjdCwgJ2ludDE2ICcgKyBvYmplY3QpO1xuICAgICAgICBiLndyaXRlSW50MTYob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkZGRiwgb2JqZWN0LCAnaW50MTYgJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkZGRiwgb2JqZWN0LCAnaW50MTYgJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBwYXJzZUludChvYmplY3QpO1xuICAgIH1cbn07XG5cblR5cGVzLnVpbnQxNiA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkVWludDE2KCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoLTB4RkZGRiwgMHhGRkZGLCBvYmplY3QsICd1aW50MTYgJyArIG9iamVjdCk7XG4gICAgICAgIGIud3JpdGVVaW50MTYob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKC0weEZGRkYsIDB4RkZGRiwgb2JqZWN0LCAndWludDE2ICcgKyBvYmplY3QpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZSgtMHhGRkZGLCAweEZGRkYsIG9iamVjdCwgJ3VpbnQxNiAnICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iamVjdCk7XG4gICAgfVxufTtcblxuVHlwZXMudWludDMyID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBiLnJlYWRVaW50MzIoKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZSgwLCAweEZGRkZGRkZGLCBvYmplY3QsICd1aW50MzIgJyArIG9iamVjdCk7XG4gICAgICAgIGIud3JpdGVVaW50MzIob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkZGRkZGRkYsIG9iamVjdCwgJ3VpbnQzMiAnICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRkZGRkZGRiwgb2JqZWN0LCAndWludDMyICcgKyBvYmplY3QpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqZWN0KTtcbiAgICB9XG59O1xuXG52YXIgTUlOX1NJR05FRF8zMiA9IC0xICogTWF0aC5wb3coMiwgMzEpO1xudmFyIE1BWF9TSUdORURfMzIgPSBNYXRoLnBvdygyLCAzMSkgLSAxO1xuXG5UeXBlcy52YXJpbnQzMiA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkVmFyaW50MzIoKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZShNSU5fU0lHTkVEXzMyLCBNQVhfU0lHTkVEXzMyLCBvYmplY3QsICd1aW50MzIgJyArIG9iamVjdCk7XG4gICAgICAgIGIud3JpdGVWYXJpbnQzMihvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoTUlOX1NJR05FRF8zMiwgTUFYX1NJR05FRF8zMiwgb2JqZWN0LCAndWludDMyICcgKyBvYmplY3QpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZShNSU5fU0lHTkVEXzMyLCBNQVhfU0lHTkVEXzMyLCBvYmplY3QsICd1aW50MzIgJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBwYXJzZUludChvYmplY3QpO1xuICAgIH1cbn07XG5cblR5cGVzLmludDY0ID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBiLnJlYWRJbnQ2NCgpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBiLndyaXRlSW50NjQodi50b19sb25nKG9iamVjdCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIHJldHVybiB2LnRvX2xvbmcob2JqZWN0KTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICByZXR1cm4gdi50b19sb25nKG9iamVjdCkudG9TdHJpbmcoKTtcbiAgICB9XG59O1xuXG5UeXBlcy51aW50NjQgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVhZFVpbnQ2NCgpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgYi53cml0ZVVpbnQ2NCh2LnRvX2xvbmcodi51bnNpZ25lZChvYmplY3QpKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB2LnRvX2xvbmcodi51bnNpZ25lZChvYmplY3QpKTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYudG9fbG9uZyhvYmplY3QpLnRvU3RyaW5nKCk7XG4gICAgfVxufTtcblxuVHlwZXMuc3RyaW5nID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHZhciBiX2NvcHk7XG4gICAgICAgIHZhciBsZW4gPSBiLnJlYWRWYXJpbnQzMigpO1xuICAgICAgICBiX2NvcHkgPSBiLmNvcHkoYi5vZmZzZXQsIGIub2Zmc2V0ICsgbGVuKSwgYi5za2lwKGxlbik7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGJfY29weS50b0JpbmFyeSgpLCAnYmluYXJ5Jyk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIGIud3JpdGVWYXJpbnQzMihvYmplY3QubGVuZ3RoKTtcbiAgICAgICAgYi5hcHBlbmQob2JqZWN0LnRvU3RyaW5nKCdiaW5hcnknKSwgJ2JpbmFyeScpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKG9iamVjdCk7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdC50b1N0cmluZygpO1xuICAgIH1cbn07XG5cblR5cGVzLmJ5dGVzID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICAgICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBiX2NvcHk7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGIucmVhZFZhcmludDMyKCk7XG4gICAgICAgICAgICAgICAgYl9jb3B5ID0gYi5jb3B5KGIub2Zmc2V0LCBiLm9mZnNldCArIGxlbiksIGIuc2tpcChsZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGJfY29weS50b0JpbmFyeSgpLCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJfY29weSA9IGIuY29weShiLm9mZnNldCwgYi5vZmZzZXQgKyBzaXplKSwgYi5za2lwKHNpemUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGJfY29weS50b0JpbmFyeSgpLCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJzdHJpbmdcIikgb2JqZWN0ID0gbmV3IEJ1ZmZlcihvYmplY3QsIFwiaGV4XCIpO1xuXG4gICAgICAgICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYi53cml0ZVZhcmludDMyKG9iamVjdC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYi5hcHBlbmQob2JqZWN0LnRvU3RyaW5nKCdiaW5hcnknKSwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpKSByZXR1cm4gb2JqZWN0O1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihvYmplY3QsICdoZXgnKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciB6ZXJvcyA9IGZ1bmN0aW9uIHplcm9zKG51bSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5KG51bSkuam9pbihcIjAwXCIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9zKHNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdC50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuVHlwZXMuYm9vbCA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkVWludDgoKSA9PT0gMTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIC8vIHN1cHBvcnRzIGJvb2xlYW4gb3IgaW50ZWdlclxuICAgICAgICBiLndyaXRlVWludDgoSlNPTi5wYXJzZShvYmplY3QpID8gMSA6IDApO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShvYmplY3QpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShvYmplY3QpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbn07XG5cblR5cGVzLnZvaWQgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiKHZvaWQpIHVuZGVmaW5lZCB0eXBlXCIpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiKHZvaWQpIHVuZGVmaW5lZCB0eXBlXCIpO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiKHZvaWQpIHVuZGVmaW5lZCB0eXBlXCIpO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiKHZvaWQpIHVuZGVmaW5lZCB0eXBlXCIpO1xuICAgIH1cbn07XG5cblR5cGVzLmFycmF5ID0gZnVuY3Rpb24gKHN0X29wZXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGIucmVhZFZhcmludDMyKCk7XG4gICAgICAgICAgICBpZiAoSEVYX0RVTVApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInZhcmludDMyIHNpemUgPSBcIiArIHNpemUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyAwIDwgc2l6ZSA/IGkgPCBzaXplIDogaSA+IHNpemU7IDAgPCBzaXplID8gaSsrIDogaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Rfb3BlcmF0aW9uLmZyb21CeXRlQnVmZmVyKGIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3J0T3BlcmF0aW9uKHJlc3VsdCwgc3Rfb3BlcmF0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIG9iamVjdCA9IHNvcnRPcGVyYXRpb24ob2JqZWN0LCBzdF9vcGVyYXRpb24pO1xuICAgICAgICAgICAgYi53cml0ZVZhcmludDMyKG9iamVjdC5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvID0gb2JqZWN0W2ldO1xuICAgICAgICAgICAgICAgIHN0X29wZXJhdGlvbi5hcHBlbmRCeXRlQnVmZmVyKGIsIG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgb2JqZWN0ID0gc29ydE9wZXJhdGlvbihvYmplY3QsIHN0X29wZXJhdGlvbik7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Rfb3BlcmF0aW9uLmZyb21PYmplY3QobykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KG9iamVjdCwgZGVidWcpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIG9iamVjdCA9IHNvcnRPcGVyYXRpb24ob2JqZWN0LCBzdF9vcGVyYXRpb24pO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KG8sIGRlYnVnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblR5cGVzLnRpbWVfcG9pbnRfc2VjID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBiLnJlYWRVaW50MzIoKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBcIm51bWJlclwiKSBvYmplY3QgPSBUeXBlcy50aW1lX3BvaW50X3NlYy5mcm9tT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgICAgYi53cml0ZVVpbnQzMihvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwibnVtYmVyXCIpIHJldHVybiBvYmplY3Q7XG5cbiAgICAgICAgaWYgKG9iamVjdC5nZXRUaW1lKSByZXR1cm4gTWF0aC5mbG9vcihvYmplY3QuZ2V0VGltZSgpIC8gMTAwMCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFwic3RyaW5nXCIpIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0ZSB0eXBlOiBcIiArIG9iamVjdCk7XG5cbiAgICAgICAgLy8gaWYodHlwZW9mIG9iamVjdCA9PT0gXCJzdHJpbmdcIiAmJiAhL1okLy50ZXN0KG9iamVjdCkpXG4gICAgICAgIC8vICAgICBvYmplY3QgPSBvYmplY3QgKyBcIlpcIlxuXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG5ldyBEYXRlKG9iamVjdCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG5ldyBEYXRlKDApLnRvSVNPU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcblxuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIpIHJldHVybiBvYmplY3Q7XG5cbiAgICAgICAgaWYgKG9iamVjdC5nZXRUaW1lKSByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcblxuICAgICAgICB2YXIgaW50ID0gcGFyc2VJbnQob2JqZWN0KTtcbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkZGRkZGRkYsIGludCwgJ3VpbnQzMiAnICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGludCAqIDEwMDApLnRvSVNPU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcbiAgICB9XG59O1xuXG5UeXBlcy5zZXQgPSBmdW5jdGlvbiAoc3Rfb3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgZHVwX21hcCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBhcnJheVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgIGlmIChyZWYgPSB0eXBlb2YgbyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobyksIFsnc3RyaW5nJywgJ251bWJlciddLmluZGV4T2YocmVmKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkdXBfbWFwW29dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImR1cGxpY2F0ZSAoc2V0KVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkdXBfbWFwW29dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc29ydE9wZXJhdGlvbihhcnJheSwgc3Rfb3BlcmF0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gYi5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgICAgIGlmIChIRVhfRFVNUCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidmFyaW50MzIgc2l6ZSA9IFwiICsgc2l6ZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgMCA8IHNpemUgPyBpIDwgc2l6ZSA6IGkgPiBzaXplOyAwIDwgc2l6ZSA/IGkrKyA6IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdF9vcGVyYXRpb24uZnJvbUJ5dGVCdWZmZXIoYikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLndyaXRlVmFyaW50MzIob2JqZWN0Lmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLnZhbGlkYXRlKG9iamVjdCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbyA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICAgIHN0X29wZXJhdGlvbi5hcHBlbmRCeXRlQnVmZmVyKGIsIG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Rfb3BlcmF0aW9uLmZyb21PYmplY3QobykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KG9iamVjdCwgZGVidWcpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0X29wZXJhdGlvbi50b09iamVjdChvLCBkZWJ1ZykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4vLyBnbG9iYWxfcGFyYW1ldGVyc191cGRhdGVfb3BlcmF0aW9uIGN1cnJlbnRfZmVlc1xuVHlwZXMuZml4ZWRfYXJyYXkgPSBmdW5jdGlvbiAoY291bnQsIHN0X29wZXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICB2YXIgaSwgaiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNvdW50OyBqIDwgcmVmOyBpID0gaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHN0X29wZXJhdGlvbi5mcm9tQnl0ZUJ1ZmZlcihiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc29ydE9wZXJhdGlvbihyZXN1bHRzLCBzdF9vcGVyYXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGksIGosIHJlZjtcbiAgICAgICAgICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBzb3J0T3BlcmF0aW9uKG9iamVjdCwgc3Rfb3BlcmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBjb3VudDsgaiA8IHJlZjsgaSA9IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIHN0X29wZXJhdGlvbi5hcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgaSwgaiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNvdW50OyBqIDwgcmVmOyBpID0gaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHN0X29wZXJhdGlvbi5mcm9tT2JqZWN0KG9iamVjdFtpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0sXG4gICAgICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QsIGRlYnVnKSB7XG4gICAgICAgICAgICB2YXIgaSwgaiwgaywgcmVmLCByZWYxLCByZXN1bHRzLCByZXN1bHRzMTtcbiAgICAgICAgICAgIGlmIChkZWJ1ZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVidWcgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gY291bnQ7IGogPCByZWY7IGkgPSBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHN0X29wZXJhdGlvbi50b09iamVjdCh2b2lkIDAsIGRlYnVnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYxID0gY291bnQ7IGsgPCByZWYxOyBpID0gayArPSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0czEucHVzaChzdF9vcGVyYXRpb24udG9PYmplY3Qob2JqZWN0W2ldLCBkZWJ1ZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHMxO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qIFN1cHBvcnRzIGluc3RhbmNlIG51bWJlcnMgKDExKSBvciBvYmplY3QgdHlwZXMgKDEuMi4xMSkuICBPYmplY3QgdHlwZVxuVmFsaWRhdGlvbiBpcyBlbmZvcmNlZCB3aGVuIGFuIG9iamVjdCB0eXBlIGlzIHVzZWQuICovXG52YXIgaWRfdHlwZSA9IGZ1bmN0aW9uIGlkX3R5cGUocmVzZXJ2ZWRfc3BhY2VzLCBvYmplY3RfdHlwZSkge1xuICAgIHYucmVxdWlyZWQocmVzZXJ2ZWRfc3BhY2VzLCBcInJlc2VydmVkX3NwYWNlc1wiKTtcbiAgICB2LnJlcXVpcmVkKG9iamVjdF90eXBlLCBcIm9iamVjdF90eXBlXCIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIGlmIChvYmplY3QucmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnJlc29sdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb252ZXJ0IDEuMi5uIGludG8ganVzdCBuXG4gICAgICAgICAgICBpZiAoL15bMC05XStcXC5bMC05XStcXC5bMC05XSskLy50ZXN0KG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSB2LmdldF9pbnN0YW5jZShyZXNlcnZlZF9zcGFjZXMsIG9iamVjdF90eXBlLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYi53cml0ZVZhcmludDMyKHYudG9fbnVtYmVyKG9iamVjdCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBvYmplY3QucmVzb2x2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2LmlzX2RpZ2l0cyhvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYudG9fbnVtYmVyKG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdi5nZXRfaW5zdGFuY2UocmVzZXJ2ZWRfc3BhY2VzLCBvYmplY3RfdHlwZSwgb2JqZWN0KTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgICAgIHZhciBvYmplY3RfdHlwZV9pZCA9IENoYWluVHlwZXMub2JqZWN0X3R5cGVbb2JqZWN0X3R5cGVdO1xuICAgICAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc2VydmVkX3NwYWNlcyArICcuJyArIG9iamVjdF90eXBlX2lkICsgJy4wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIGlmIChvYmplY3QucmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnJlc29sdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoL15bMC05XStcXC5bMC05XStcXC5bMC05XSskLy50ZXN0KG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSB2LmdldF9pbnN0YW5jZShyZXNlcnZlZF9zcGFjZXMsIG9iamVjdF90eXBlLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzZXJ2ZWRfc3BhY2VzICsgJy4nICsgb2JqZWN0X3R5cGVfaWQgKyAnLicgKyBvYmplY3Q7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuVHlwZXMub2JqZWN0X2lkX3R5cGUgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdElkLmZyb21CeXRlQnVmZmVyKGIpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0LnJlc29sdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnJlc29sdmU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0SWQuZnJvbVN0cmluZyhvYmplY3QpO1xuICAgICAgICBvYmplY3QuYXBwZW5kQnl0ZUJ1ZmZlcihiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0LnJlc29sdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnJlc29sdmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdElkLmZyb21TdHJpbmcob2JqZWN0KTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwLjAuMFwiO1xuICAgICAgICB9XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5yZXNvbHZlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IE9iamVjdElkLmZyb21TdHJpbmcob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG9iamVjdC50b1N0cmluZygpO1xuICAgIH1cbn07XG5cblR5cGVzLnZvdGVfaWQgPSB7IFRZUEU6IDB4MDAwMDAwRkYsXG4gICAgSUQ6IDB4RkZGRkZGMDAsXG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYi5yZWFkVWludDMyKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB2YWx1ZSAmIHRoaXMuVFlQRSxcbiAgICAgICAgICAgIGlkOiB2YWx1ZSAmIHRoaXMuSURcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gXCJzdHJpbmdcIikgb2JqZWN0ID0gVHlwZXMudm90ZV9pZC5mcm9tT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0LmlkIDw8IDggfCBvYmplY3QudHlwZTtcbiAgICAgICAgYi53cml0ZVVpbnQzMih2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0LCBcIih0eXBlIHZvdGVfaWQpXCIpO1xuICAgICAgICBpZiAoKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iamVjdCkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdC50eXBlLCBcInR5cGVcIik7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdC5pZCwgXCJpZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgdi5yZXF1aXJlX3Rlc3QoL15bMC05XSs6WzAtOV0rJC8sIG9iamVjdCwgJ3ZvdGVfaWQgZm9ybWF0ICcgKyBvYmplY3QpO1xuXG4gICAgICAgIHZhciBfb2JqZWN0JHNwbGl0MyA9IG9iamVjdC5zcGxpdCgnOicpO1xuXG4gICAgICAgIHZhciBfb2JqZWN0JHNwbGl0NCA9IF9zbGljZWRUb0FycmF5KF9vYmplY3Qkc3BsaXQzLCAyKTtcblxuICAgICAgICB2YXIgdHlwZSA9IF9vYmplY3Qkc3BsaXQ0WzBdO1xuICAgICAgICB2YXIgaWQgPSBfb2JqZWN0JHNwbGl0NFsxXTtcblxuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhmZiwgdHlwZSwgJ3ZvdGUgdHlwZSAnICsgb2JqZWN0KTtcbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4ZmZmZmZmLCBpZCwgJ3ZvdGUgaWQgJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGlkOiBpZCB9O1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjA6MFwiO1xuICAgICAgICB9XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIpIG9iamVjdCA9IFR5cGVzLnZvdGVfaWQuZnJvbU9iamVjdChvYmplY3QpO1xuXG4gICAgICAgIHJldHVybiBvYmplY3QudHlwZSArIFwiOlwiICsgb2JqZWN0LmlkO1xuICAgIH0sXG4gICAgY29tcGFyZTogZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICAgIGlmICgodHlwZW9mIGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGEpKSAhPT0gXCJvYmplY3RcIikgYSA9IFR5cGVzLnZvdGVfaWQuZnJvbU9iamVjdChhKTtcbiAgICAgICAgaWYgKCh0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYikpICE9PSBcIm9iamVjdFwiKSBiID0gVHlwZXMudm90ZV9pZC5mcm9tT2JqZWN0KGIpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoYS5pZCkgLSBwYXJzZUludChiLmlkKTtcbiAgICB9XG59O1xuXG5UeXBlcy5vcHRpb25hbCA9IGZ1bmN0aW9uIChzdF9vcGVyYXRpb24pIHtcbiAgICB2LnJlcXVpcmVkKHN0X29wZXJhdGlvbiwgXCJzdF9vcGVyYXRpb25cIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIGlmICghKGIucmVhZFVpbnQ4KCkgPT09IDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdF9vcGVyYXRpb24uZnJvbUJ5dGVCdWZmZXIoYik7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0ICE9PSBudWxsICYmIG9iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYi53cml0ZVVpbnQ4KDEpO1xuICAgICAgICAgICAgICAgIHN0X29wZXJhdGlvbi5hcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGIud3JpdGVVaW50OCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3Rfb3BlcmF0aW9uLmZyb21PYmplY3Qob2JqZWN0KTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgICAgIC8vIHRvT2JqZWN0IGlzIG9ubHkgbnVsbCBzYXZlIGlmIHVzZV9kZWZhdWx0IGlzIHRydWVcbiAgICAgICAgICAgIHZhciByZXN1bHRfb2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KG9iamVjdCwgZGVidWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgaWYgKGRlYnVnLmFubm90YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgcmVzdWx0X29iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocmVzdWx0X29iamVjdCkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdF9vYmplY3QuX19vcHRpb25hbCA9IFwicGFyZW50IGlzIG9wdGlvbmFsXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0X29iamVjdCA9IHsgX19vcHRpb25hbDogcmVzdWx0X29iamVjdCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRfb2JqZWN0O1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblR5cGVzLnN0YXRpY192YXJpYW50ID0gZnVuY3Rpb24gKF9zdF9vcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9zb3J0OiB0cnVlLFxuICAgICAgICBzdF9vcGVyYXRpb25zOiBfc3Rfb3BlcmF0aW9ucyxcbiAgICAgICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHZhciB0eXBlX2lkID0gYi5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgICAgIHZhciBzdF9vcGVyYXRpb24gPSB0aGlzLnN0X29wZXJhdGlvbnNbdHlwZV9pZF07XG4gICAgICAgICAgICBpZiAoSEVYX0RVTVApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdzdGF0aWNfdmFyaWFudCBpZCAweCcgKyB0eXBlX2lkLnRvU3RyaW5nKDE2KSArICcgKCcgKyB0eXBlX2lkICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHYucmVxdWlyZWQoc3Rfb3BlcmF0aW9uLCAnb3BlcmF0aW9uICcgKyB0eXBlX2lkKTtcbiAgICAgICAgICAgIHJldHVybiBbdHlwZV9pZCwgc3Rfb3BlcmF0aW9uLmZyb21CeXRlQnVmZmVyKGIpXTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIHZhciB0eXBlX2lkID0gb2JqZWN0WzBdO1xuICAgICAgICAgICAgdmFyIHN0X29wZXJhdGlvbiA9IHRoaXMuc3Rfb3BlcmF0aW9uc1t0eXBlX2lkXTtcbiAgICAgICAgICAgIHYucmVxdWlyZWQoc3Rfb3BlcmF0aW9uLCAnb3BlcmF0aW9uICcgKyB0eXBlX2lkKTtcbiAgICAgICAgICAgIGIud3JpdGVWYXJpbnQzMih0eXBlX2lkKTtcbiAgICAgICAgICAgIHN0X29wZXJhdGlvbi5hcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICB2YXIgdHlwZV9pZCA9IG9iamVjdFswXTtcbiAgICAgICAgICAgIHZhciBzdF9vcGVyYXRpb24gPSB0aGlzLnN0X29wZXJhdGlvbnNbdHlwZV9pZF07XG4gICAgICAgICAgICB2LnJlcXVpcmVkKHN0X29wZXJhdGlvbiwgJ29wZXJhdGlvbiAnICsgdHlwZV9pZCk7XG4gICAgICAgICAgICByZXR1cm4gW3R5cGVfaWQsIHN0X29wZXJhdGlvbi5mcm9tT2JqZWN0KG9iamVjdFsxXSldO1xuICAgICAgICB9LFxuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFswLCB0aGlzLnN0X29wZXJhdGlvbnNbMF0udG9PYmplY3QodW5kZWZpbmVkLCBkZWJ1ZyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgdmFyIHR5cGVfaWQgPSBvYmplY3RbMF07XG4gICAgICAgICAgICB2YXIgc3Rfb3BlcmF0aW9uID0gdGhpcy5zdF9vcGVyYXRpb25zW3R5cGVfaWRdO1xuICAgICAgICAgICAgdi5yZXF1aXJlZChzdF9vcGVyYXRpb24sICdvcGVyYXRpb24gJyArIHR5cGVfaWQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0eXBlX2lkLCBzdF9vcGVyYXRpb24udG9PYmplY3Qob2JqZWN0WzFdLCBkZWJ1ZyldO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblR5cGVzLm1hcCA9IGZ1bmN0aW9uIChrZXlfc3Rfb3BlcmF0aW9uLCB2YWx1ZV9zdF9vcGVyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoYXJyYXkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RpbmcgYXJyYXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZHVwX21hcCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBhcnJheVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgIGlmICghKG8ubGVuZ3RoID09PSAyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RpbmcgdHdvIGVsZW1lbnRzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVmID0gX3R5cGVvZihvWzBdKSwgWydudW1iZXInLCAnc3RyaW5nJ10uaW5kZXhPZihyZWYpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR1cF9tYXBbb1swXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZHVwbGljYXRlIChtYXApXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGR1cF9tYXBbb1swXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3J0T3BlcmF0aW9uKGFycmF5LCBrZXlfc3Rfb3BlcmF0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBiLnJlYWRWYXJpbnQzMigpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IDAgPCBlbmQgPyBpIDwgZW5kIDogaSA+IGVuZDsgMCA8IGVuZCA/IGkrKyA6IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtrZXlfc3Rfb3BlcmF0aW9uLmZyb21CeXRlQnVmZmVyKGIpLCB2YWx1ZV9zdF9vcGVyYXRpb24uZnJvbUJ5dGVCdWZmZXIoYildKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKHJlc3VsdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlKG9iamVjdCk7XG4gICAgICAgICAgICBiLndyaXRlVmFyaW50MzIob2JqZWN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgICAgICAgICAga2V5X3N0X29wZXJhdGlvbi5hcHBlbmRCeXRlQnVmZmVyKGIsIG9bMF0pO1xuICAgICAgICAgICAgICAgIHZhbHVlX3N0X29wZXJhdGlvbi5hcHBlbmRCeXRlQnVmZmVyKGIsIG9bMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvID0gb2JqZWN0W2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtrZXlfc3Rfb3BlcmF0aW9uLmZyb21PYmplY3Qob1swXSksIHZhbHVlX3N0X29wZXJhdGlvbi5mcm9tT2JqZWN0KG9bMV0pXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZShyZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtba2V5X3N0X29wZXJhdGlvbi50b09iamVjdCh1bmRlZmluZWQsIGRlYnVnKSwgdmFsdWVfc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KHVuZGVmaW5lZCwgZGVidWcpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICBvYmplY3QgPSB0aGlzLnZhbGlkYXRlKG9iamVjdCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goW2tleV9zdF9vcGVyYXRpb24udG9PYmplY3Qob1swXSwgZGVidWcpLCB2YWx1ZV9zdF9vcGVyYXRpb24udG9PYmplY3Qob1sxXSwgZGVidWcpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblR5cGVzLnB1YmxpY19rZXkgPSB7XG4gICAgdG9QdWJsaWM6IGZ1bmN0aW9uIHRvUHVibGljKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0LnJlc29sdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnJlc29sdmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0LlEgPyBvYmplY3QgOiBQdWJsaWNLZXkuZnJvbVN0cmluZ09yVGhyb3cob2JqZWN0KTtcbiAgICB9LFxuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBmcC5wdWJsaWNfa2V5KGIpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBmcC5wdWJsaWNfa2V5KGIsIFR5cGVzLnB1YmxpY19rZXkudG9QdWJsaWMob2JqZWN0KSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5RKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUeXBlcy5wdWJsaWNfa2V5LnRvUHVibGljKG9iamVjdCk7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIENoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4ICsgXCI4NTlneGZuWHlVcmlNZ1VlVGhoMWZXdjNvcWNwTEZ5SGEzVGZGWUM0UEsySHFoVG9WTVwiO1xuICAgICAgICB9XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG9iamVjdC50b1N0cmluZygpO1xuICAgIH0sXG4gICAgY29tcGFyZTogZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBzdHJDbXAoYS50b1N0cmluZygpLCBiLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5cblR5cGVzLmFkZHJlc3MgPSB7XG4gICAgX3RvX2FkZHJlc3M6IGZ1bmN0aW9uIF90b19hZGRyZXNzKG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QuYWRkeSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQWRkcmVzcy5mcm9tU3RyaW5nKG9iamVjdCk7XG4gICAgfSxcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoZnAucmlwZW1kMTYwKGIpKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIGZwLnJpcGVtZDE2MChiLCBUeXBlcy5hZGRyZXNzLl90b19hZGRyZXNzKG9iamVjdCkudG9CdWZmZXIoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBUeXBlcy5hZGRyZXNzLl90b19hZGRyZXNzKG9iamVjdCk7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIENoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4ICsgXCI2NjRLbUh4U3VReURzZndvNFdFSnZXcHpnMVFLZGc2N1NcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHlwZXMuYWRkcmVzcy5fdG9fYWRkcmVzcyhvYmplY3QpLnRvU3RyaW5nKCk7XG4gICAgfSxcbiAgICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHN0ckNtcChhLnRvU3RyaW5nKCksIGIudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcblxudmFyIHN0ckNtcCA9IGZ1bmN0aW9uIHN0ckNtcChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xufTtcbnZhciBmaXJzdEVsID0gZnVuY3Rpb24gZmlyc3RFbChlbCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGVsKSA/IGVsWzBdIDogZWw7XG59O1xudmFyIHNvcnRPcGVyYXRpb24gPSBmdW5jdGlvbiBzb3J0T3BlcmF0aW9uKGFycmF5LCBzdF9vcGVyYXRpb24pIHtcbiAgICByZXR1cm4gc3Rfb3BlcmF0aW9uLm5vc29ydCA/IGFycmF5IDogc3Rfb3BlcmF0aW9uLmNvbXBhcmUgPyBhcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBzdF9vcGVyYXRpb24uY29tcGFyZShmaXJzdEVsKGEpLCBmaXJzdEVsKGIpKTtcbiAgICB9KSA6IC8vIGN1c3RvbSBjb21wYXJlIG9wZXJhdGlvblxuICAgIGFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmaXJzdEVsKGEpID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBmaXJzdEVsKGIpID09PSBcIm51bWJlclwiID8gZmlyc3RFbChhKSAtIGZpcnN0RWwoYikgOlxuICAgICAgICAvLyBBIGJpbmFyeSBzdHJpbmcgY29tcGFyZSBkb2VzIG5vdCB3b3JrLiBQZXJmb3JtYW5hbmNlIGlzIHZlcnkgZ29vZCBzbyBIRVggaXMgdXNlZC4uICBsb2NhbGVDb21wYXJlIGlzIGFub3RoZXIgb3B0aW9uLlxuICAgICAgICBCdWZmZXIuaXNCdWZmZXIoZmlyc3RFbChhKSkgJiYgQnVmZmVyLmlzQnVmZmVyKGZpcnN0RWwoYikpID8gc3RyQ21wKGZpcnN0RWwoYSkudG9TdHJpbmcoXCJoZXhcIiksIGZpcnN0RWwoYikudG9TdHJpbmcoXCJoZXhcIikpIDogc3RyQ21wKGZpcnN0RWwoYSkudG9TdHJpbmcoKSwgZmlyc3RFbChiKS50b1N0cmluZygpKTtcbiAgICB9KTtcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL3R5cGVzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL2Rpc3Qvc2VyaWFsaXplci9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuL2xpYi9rZXlzLmpzJyk7XG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2xpYi9pc19hcmd1bWVudHMuanMnKTtcblxudmFyIGRlZXBFcXVhbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCB8fCB0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcHRzLnN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAoeCkge1xuICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnIHx8IHR5cGVvZiB4Lmxlbmd0aCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB4LmNvcHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHguc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHgubGVuZ3RoID4gMCAmJiB0eXBlb2YgeFswXSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIG9wdHMpIHtcbiAgdmFyIGksIGtleTtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCBvcHRzKTtcbiAgfVxuICBpZiAoaXNCdWZmZXIoYSkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYik7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgb3B0cykpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbWpzLWxpYi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID0gKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKVxufSkoKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA/IHN1cHBvcnRlZCA6IHVuc3VwcG9ydGVkO1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIHN1cHBvcnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuZXhwb3J0cy51bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWQob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdjYWxsZWUnKSAmJlxuICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAnY2FsbGVlJykgfHxcbiAgICBmYWxzZTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtanMtbGliL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9pc19hcmd1bWVudHMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nXG4gID8gT2JqZWN0LmtleXMgOiBzaGltO1xuXG5leHBvcnRzLnNoaW0gPSBzaGltO1xuZnVuY3Rpb24gc2hpbSAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2tleXMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW1qcy1saWIvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vcmVhZGFibGUuanMnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vd3JpdGFibGUuanMnKTtcblxuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbkR1cGxleC5wcm90b3R5cGUud3JpdGUgPSBXcml0YWJsZS5wcm90b3R5cGUud3JpdGU7XG5EdXBsZXgucHJvdG90eXBlLmVuZCA9IFdyaXRhYmxlLnByb3RvdHlwZS5lbmQ7XG5EdXBsZXgucHJvdG90eXBlLl93cml0ZSA9IFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGU7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5lbmQoKTtcbiAgfSk7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2R1cGxleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeVwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCcuL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCcuL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgnLi9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi90cmFuc2Zvcm0uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9wYXNzdGhyb3VnaC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeVwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiAxNiAqIDEwMjQ7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBmYWxzZTtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gSW4gc3RyZWFtcyB0aGF0IG5ldmVyIGhhdmUgYW55IGRhdGEsIGFuZCBkbyBwdXNoKG51bGwpIHJpZ2h0IGF3YXksXG4gIC8vIHRoZSBjb25zdW1lciBjYW4gbWlzcyB0aGUgJ2VuZCcgZXZlbnQgaWYgdGhleSBkbyBzb21lIEkvTyBiZWZvcmVcbiAgLy8gY29uc3VtaW5nIHRoZSBzdHJlYW0uICBTbywgd2UgZG9uJ3QgZW1pdCgnZW5kJykgdW50aWwgc29tZSByZWFkaW5nXG4gIC8vIGhhcHBlbnMuXG4gIHRoaXMuY2FsbGVkUmVhZCA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG5cblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZClcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxMjhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIHJvdW5kVXBUb05leHRQb3dlck9mMihuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIGZvciAodmFyIHAgPSAxOyBwIDwgMzI7IHAgPDw9IDEpIG4gfD0gbiA+PiBwO1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgIHJldHVybiAwO1xuXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKVxuICAgIHJldHVybiBuID09PSAwID8gMCA6IDE7XG5cbiAgaWYgKGlzTmFOKG4pIHx8IG4gPT09IG51bGwpIHtcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5jYWxsZWRSZWFkID0gdHJ1ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPiAwKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiZcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSAmJlxuICAgICAgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggLSBuIDw9IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgZG9SZWFkID0gdHJ1ZTtcblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKVxuICAgIGRvUmVhZCA9IGZhbHNlO1xuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIGNhbGxlZCBpdHMgY2FsbGJhY2sgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2BcbiAgLy8gd2lsbCBiZSBmYWxzZSwgYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZVxuICAvLyBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIGhhcHBlbmVkIHRvIHJlYWQoKSBleGFjdGx5IHRoZSByZW1haW5pbmcgYW1vdW50IGluIHRoZVxuICAvLyBidWZmZXIsIGFuZCB0aGUgRU9GIGhhcyBiZWVuIHNlZW4gYXQgdGhpcyBwb2ludCwgdGhlbiBtYWtlIHN1cmVcbiAgLy8gdGhhdCB3ZSBlbWl0ICdlbmQnIG9uIHRoZSB2ZXJ5IG5leHQgdGljay5cbiAgaWYgKHN0YXRlLmVuZGVkICYmICFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgIWVyKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkIGFuZCB3ZSBoYXZlIHNvbWUgZGF0YSBsZWZ0LCB0aGVuIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgZWxzZVxuICAgIGVuZFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmIChzdGF0ZS5lbWl0dGVkUmVhZGFibGUpXG4gICAgcmV0dXJuO1xuXG4gIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gIGlmIChzdGF0ZS5zeW5jKVxuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9KTtcbiAgZWxzZVxuICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG59XG5cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHNldEltbWVkaWF0ZShlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBpZiAocmVhZGFibGUgIT09IHNyYykgcmV0dXJuO1xuICAgIGNsZWFudXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgLy8gY2hlY2sgZm9yIGxpc3RlbmVycyBiZWZvcmUgZW1pdCByZW1vdmVzIG9uZS10aW1lIGxpc3RlbmVycy5cbiAgdmFyIGVyckxpc3RlbmVycyA9IEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJyk7XG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICB1bnBpcGUoKTtcbiAgICBpZiAoZXJyTGlzdGVuZXJzID09PSAwICYmIEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIGRlc3Qub25jZSgnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgLy8gdGhlIGhhbmRsZXIgdGhhdCB3YWl0cyBmb3IgcmVhZGFibGUgZXZlbnRzIGFmdGVyIGFsbFxuICAgIC8vIHRoZSBkYXRhIGdldHMgc3Vja2VkIG91dCBpbiBmbG93LlxuICAgIC8vIFRoaXMgd291bGQgYmUgZWFzaWVyIHRvIGZvbGxvdyB3aXRoIGEgLm9uY2UoKSBoYW5kbGVyXG4gICAgLy8gaW4gZmxvdygpLCBidXQgdGhhdCBpcyB0b28gc2xvdy5cbiAgICB0aGlzLm9uKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcblxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVzdCA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMClcbiAgICAgIGZsb3coc3JjKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvdyhzcmMpIHtcbiAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgY2h1bms7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuXG4gIGZ1bmN0aW9uIHdyaXRlKGRlc3QsIGksIGxpc3QpIHtcbiAgICB2YXIgd3JpdHRlbiA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gd3JpdHRlbikge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5waXBlc0NvdW50ICYmIG51bGwgIT09IChjaHVuayA9IHNyYy5yZWFkKCkpKSB7XG5cbiAgICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICAgIHdyaXRlKHN0YXRlLnBpcGVzLCAwLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICBmb3JFYWNoKHN0YXRlLnBpcGVzLCB3cml0ZSk7XG5cbiAgICBzcmMuZW1pdCgnZGF0YScsIGNodW5rKTtcblxuICAgIC8vIGlmIGFueW9uZSBuZWVkcyBhIGRyYWluLCB0aGVuIHdlIGhhdmUgdG8gd2FpdCBmb3IgdGhhdC5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA+IDApXG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBpZiBldmVyeSBkZXN0aW5hdGlvbiB3YXMgdW5waXBlZCwgZWl0aGVyIGJlZm9yZSBlbnRlcmluZyB0aGlzXG4gIC8vIGZ1bmN0aW9uLCBvciBpbiB0aGUgd2hpbGUgbG9vcCwgdGhlbiBzdG9wIGZsb3dpbmcuXG4gIC8vXG4gIC8vIE5COiBUaGlzIGlzIGEgcHJldHR5IHJhcmUgZWRnZSBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkge1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIC8vIGlmIHRoZXJlIHdlcmUgZGF0YSBldmVudCBsaXN0ZW5lcnMgYWRkZWQsIHRoZW4gc3dpdGNoIHRvIG9sZCBtb2RlLlxuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSA+IDApXG4gICAgICBlbWl0RGF0YUV2ZW50cyhzcmMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIG5vIG9uZSBuZWVkZWQgYSBkcmFpbiwgc28gd2UganVzdCByYW4gb3V0IG9mIGRhdGFcbiAgLy8gb24gdGhlIG5leHQgcmVhZGFibGUgZXZlbnQsIHN0YXJ0IGl0IG92ZXIgYWdhaW4uXG4gIHN0YXRlLnJhbk91dCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHBpcGVPblJlYWRhYmxlKCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5yYW5PdXQpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJhbk91dCA9IGZhbHNlO1xuICAgIGZsb3codGhpcyk7XG4gIH1cbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKVxuICAgIGVtaXREYXRhRXZlbnRzKHRoaXMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdGhpcy5yZWFkKDApO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICBlbWl0RGF0YUV2ZW50cyh0aGlzKTtcbiAgdGhpcy5yZWFkKDApO1xuICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGVtaXREYXRhRXZlbnRzKHRoaXMsIHRydWUpO1xuICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG59O1xuXG5mdW5jdGlvbiBlbWl0RGF0YUV2ZW50cyhzdHJlYW0sIHN0YXJ0UGF1c2VkKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3MvcmVhZGFibGUtc3RyZWFtL2lzc3Vlcy8xNlxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3aXRjaCB0byBvbGQgbW9kZSBub3cuJyk7XG4gIH1cblxuICB2YXIgcGF1c2VkID0gc3RhcnRQYXVzZWQgfHwgZmFsc2U7XG4gIHZhciByZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGNvbnZlcnQgdG8gYW4gb2xkLXN0eWxlIHN0cmVhbS5cbiAgc3RyZWFtLnJlYWRhYmxlID0gdHJ1ZTtcbiAgc3RyZWFtLnBpcGUgPSBTdHJlYW0ucHJvdG90eXBlLnBpcGU7XG4gIHN0cmVhbS5vbiA9IHN0cmVhbS5hZGRMaXN0ZW5lciA9IFN0cmVhbS5wcm90b3R5cGUub247XG5cbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uKCkge1xuICAgIHJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIHZhciBjO1xuICAgIHdoaWxlICghcGF1c2VkICYmIChudWxsICE9PSAoYyA9IHN0cmVhbS5yZWFkKCkpKSlcbiAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgYyk7XG5cbiAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgc3RyZWFtLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH07XG5cbiAgc3RyZWFtLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGlmIChyZWFkYWJsZSlcbiAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnJlYWQoMCk7XG4gICAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbiAgfTtcblxuICAvLyBub3cgbWFrZSBpdCBzdGFydCwganVzdCBpbiBjYXNlIGl0IGhhZG4ndCBhbHJlYWR5LlxuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcilcbiAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgaWYgKCFjaHVuayB8fCAhc3RhdGUub2JqZWN0TW9kZSAmJiAhY2h1bmsubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHRoaXNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH19KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHNlbGYuZW1pdC5hcHBseShzZWxmLCBldiwgeCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5jYWxsZWRSZWFkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L3JlYWRhYmxlLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL2R1cGxleC5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKVxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGlmIChjYilcbiAgICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKVxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB0aGlzLl9mbHVzaClcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XG4gICAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fFxuICAgICAgICBycy5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcbiAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gIGlmIChlcilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvdHJhbnNmb3JtLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbnZhciBpc1VpbnQ4QXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCdcbiAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfVxuICA6IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHggJiYgeC5jb25zdHJ1Y3RvciAmJiB4LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5J1xuICB9XG47XG52YXIgaXNBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCdcbiAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIH1cbiAgOiBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4ICYmIHguY29uc3RydWN0b3IgJiYgeC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInXG4gIH1cbjtcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XG52YXIgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogMTYgKiAxMDI0O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgU3RyZWFtLkR1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XG59O1xuXG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgY2IoZXIpO1xuICB9KTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgaXNVaW50OEFycmF5KGNodW5rKSlcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmspO1xuICBpZiAoaXNBcnJheUJ1ZmZlcihjaHVuaykgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShjaHVuaykpO1xuICBcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgZWxzZSBpZiAoIWVuY29kaW5nKVxuICAgIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgY2IgPSBmdW5jdGlvbigpIHt9O1xuXG4gIGlmIChzdGF0ZS5lbmRlZClcbiAgICB3cml0ZUFmdGVyRW5kKHRoaXMsIHN0YXRlLCBjYik7XG4gIGVsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpXG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmXG4gICAgICBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgc3RhdGUubmVlZERyYWluID0gIXJldDtcblxuICBpZiAoc3RhdGUud3JpdGluZylcbiAgICBzdGF0ZS5idWZmZXIucHVzaChuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikpO1xuICBlbHNlXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgaWYgKHN5bmMpXG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICBlbHNlXG4gICAgY2IoZXIpO1xuXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpXG4gICAgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7XG4gIGVsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZClcbiAgICBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIGNiKCk7XG4gIGlmIChmaW5pc2hlZClcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG5cbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspIHtcbiAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XG4gICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgYysrO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuICBpZiAoYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgc3RhdGUuYnVmZmVyID0gc3RhdGUuYnVmZmVyLnNsaWNlKGMpO1xuICBlbHNlXG4gICAgc3RhdGUuYnVmZmVyLmxlbmd0aCA9IDA7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3VuZGVmaW5lZCcgJiYgY2h1bmsgIT09IG51bGwpXG4gICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKVxuICAgIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICByZXR1cm4gKHN0YXRlLmVuZGluZyAmJlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAgICFzdGF0ZS53cml0aW5nKTtcbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZClcbiAgICAgIHNldEltbWVkaWF0ZShjYik7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L3dyaXRhYmxlLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3V0aWwvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvdXRpbC9ub2RlX21vZHVsZXMvaW5oZXJpdHNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3V0aWxcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5yZXF1aXJlKCcuL3Bvc3RzJylcbi8vcmVxdWlyZSgnc3RlZW1qcy1saWInKVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2Zha2VfZDJlY2NjMGMuanNcIixcIi9cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHApIHtcblx0YXBwLmNvbnN0YW50KCdBUElfRU5EX1BPSU5UJywnaHR0cDovL2FwaS5lc3RlZW0ud3M6ODA4MCcpO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL3Bvc3RzL2NvbmZpZy5qc1wiLFwiL3Bvc3RzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXBwKSB7XG4vL2FuZ3VsYXIubW9kdWxlKCdzdGVlbS5jb250cm9sbGVycycsIFtdKVxuXG5hcHAuY29udHJvbGxlcignQXBwQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJGlvbmljTW9kYWwsICR0aW1lb3V0LCAkcm9vdFNjb3BlLCAkc3RhdGUsICRpb25pY0hpc3RvcnksICRjb3Jkb3ZhU29jaWFsU2hhcmluZywgSW1hZ2VVcGxvYWRTZXJ2aWNlLCAkY29yZG92YUNhbWVyYSwgJGlvbmljU2lkZU1lbnVEZWxlZ2F0ZSwgJGlvbmljUGxhdGZvcm0sICRmaWx0ZXIsIEFQSXMsICR3aW5kb3csICRpb25pY1BvcG92ZXIpIHtcblxuICAkc2NvcGUubG9naW5EYXRhID0ge307XG5cbiAgJGlvbmljTW9kYWwuZnJvbVRlbXBsYXRlVXJsKCd0ZW1wbGF0ZXMvbG9naW4uaHRtbCcsIHtcbiAgICBzY29wZTogJHNjb3BlICB9KS50aGVuKGZ1bmN0aW9uKG1vZGFsKSB7XG4gICAgJHNjb3BlLmxvZ2luTW9kYWwgPSBtb2RhbDtcbiAgfSk7XG5cblxuICAkaW9uaWNQb3BvdmVyLmZyb21UZW1wbGF0ZVVybCgndGVtcGxhdGVzL3BvcG92ZXIuaHRtbCcsIHtcbiAgICBzY29wZTogJHNjb3BlLFxuICB9KS50aGVuKGZ1bmN0aW9uKHBvcG92ZXIpIHtcbiAgICAkc2NvcGUubWVudXBvcG92ZXIgPSBwb3BvdmVyO1xuICB9KTtcblxuICAkc2NvcGUub3Blbk1lbnVQb3BvdmVyID0gZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgJHNjb3BlLm1lbnVwb3BvdmVyLnNob3coJGV2ZW50KTtcbiAgfTtcbiAgJHNjb3BlLmNsb3NlTWVudVBvcG92ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUubWVudXBvcG92ZXIuaGlkZSgpO1xuICB9O1xuXG4gICRyb290U2NvcGUuJG9uKCdjbG9zZTpwb3BvdmVyJywgZnVuY3Rpb24oKXtcbiAgICBjb25zb2xlLmxvZygnY2xvc2U6cG9wb3ZlcicpO1xuICAgICRzY29wZS5tZW51cG9wb3Zlci5oaWRlKCk7XG5cbiAgICAkaW9uaWNIaXN0b3J5Lm5leHRWaWV3T3B0aW9ucyh7XG4gICAgICBkaXNhYmxlQmFjazogdHJ1ZVxuICAgIH0pO1xuICAgIC8vJHNjb3BlLmNsb3NlTWVudVBvcG92ZXIoKTtcbiAgICAvLyRzY29wZS5mZXRjaFBvc3RzKCk7XG4gIH0pO1xuXG4gICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLm1lbnVwb3BvdmVyLnJlbW92ZSgpO1xuICB9KTtcblxuICAkc2NvcGUuY2hhbmdlVXNlcm5hbWUgPSBmdW5jdGlvbigpe1xuICAgICRzY29wZS5sb2dpbkRhdGEudXNlcm5hbWUgPSBhbmd1bGFyLmxvd2VyY2FzZSgkc2NvcGUubG9naW5EYXRhLnVzZXJuYW1lKTtcbiAgfVxuICAkc2NvcGUub3BlbiA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICBpdGVtLmpzb25fbWV0YWRhdGEgPSBhbmd1bGFyLmZyb21Kc29uKGl0ZW0uanNvbl9tZXRhZGF0YSk7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbSA9IGl0ZW07XG4gICAgLy9jb25zb2xlLmxvZyhpdGVtKTtcblxuICAgIC8vJHN0YXRlLmdvKCdhcHAuc2luZ2xlJyk7Ki9cbiAgICAkc3RhdGUuZ28oJ2FwcC5wb3N0Jywge2NhdGVnb3J5OiBpdGVtLmNhdGVnb3J5LCBhdXRob3I6IGl0ZW0uYXV0aG9yLCBwZXJtbGluazogaXRlbS5wZXJtbGlua30pO1xuICB9O1xuICAkc2NvcGUuYWR2YW5jZWRDaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAkcm9vdFNjb3BlLmxvZyhhbmd1bGFyLnRvSnNvbigkc2NvcGUubG9naW5EYXRhLmFkdmFuY2VkKSk7XG4gICAgaWYgKCRzY29wZS5sb2dpbkRhdGEuYWR2YW5jZWQpIHtcbiAgICAgICRzY29wZS5sb2dpbkRhdGEucGFzc3dvcmQgPSBudWxsO1xuICAgIH1cbiAgfVxuICAkc2NvcGUuY2xvc2VMb2dpbiA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS5sb2dpbk1vZGFsLmhpZGUoKTtcbiAgfTtcbiAgXG4gICRzY29wZS5vcGVuU2lnblVQID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLmNoYWludXJsID0gJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbj09J3N0ZWVtJz8naHR0cHM6Ly9zdGVlbWl0LmNvbS9jcmVhdGVfYWNjb3VudCc6J2h0dHBzOi8vZ29sb3MuaW8vY3JlYXRlX2FjY291bnQnO1xuICAgIHdpbmRvdy5vcGVuKCRzY29wZS5jaGFpbnVybCwgJ19ibGFuaycsICdsb2NhdGlvbj15ZXMnKTtcbiAgICByZXR1cm4gZmFsc2U7ICBcbiAgfVxuICAkc2NvcGUub3BlbkxvZ2luID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UubGFuZ3VhZ2UgPT0gJ3J1LVJVJykge1xuICAgICAgJHNjb3BlLmxvZ2luRGF0YS5jaGFpbiA9IFwiZ29sb3NcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjb3BlLmxvZ2luRGF0YS5jaGFpbiA9IFwic3RlZW1cIjtcbiAgICB9XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS5sb2dpbk1vZGFsLnNob3coKTtcbiAgICB9LCAxKTtcbiAgfTtcbiAgJHNjb3BlLmdvUHJvZmlsZSA9IGZ1bmN0aW9uKCkge1xuICAgICRzdGF0ZS5nbyhcImFwcC5wcm9maWxlXCIsIHt1c2VybmFtZTokcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWV9KTtcbiAgICAvLyRpb25pY1NpZGVNZW51RGVsZWdhdGUudG9nZ2xlTGVmdCgpO1xuICB9XG4gICRzY29wZS5zaGFyZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBob3N0ID0gXCJcIjtcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbiA9PSAnc3RlZW0nKSB7XG4gICAgICBob3N0ID0gXCJodHRwczovL3N0ZWVtaXQuY29tL1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBob3N0ID0gXCJodHRwczovL2dvbG9zLmlvL1wiO1xuICAgIH1cbiAgICB2YXIgbGluayA9IGhvc3QrJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbS5jYXRlZ29yeStcIi9AXCIrJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbS5hdXRob3IrXCIvXCIrJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbS5wZXJtbGluaztcbiAgICB2YXIgbWVzc2FnZSA9IFwiSGV5ISBDaGVja291dCBibG9nIHBvc3Qgb24gU3RlZW0gXCIrbGluaztcbiAgICB2YXIgc3ViamVjdCA9IFwiVmlhIGVTdGVlbSBNb2JpbGVcIjtcbiAgICB2YXIgZmlsZSA9IG51bGw7XG4gICAgJGNvcmRvdmFTb2NpYWxTaGFyaW5nLnNoYXJlKG1lc3NhZ2UsIHN1YmplY3QsIGZpbGUsIGxpbmspIC8vIFNoYXJlIHZpYSBuYXRpdmUgc2hhcmUgc2hlZXRcbiAgICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIC8vIFN1Y2Nlc3MhXG4gICAgICAkcm9vdFNjb3BlLmxvZyhcInNoYXJlZFwiKTtcbiAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIC8vIEFuIGVycm9yIG9jY3VyZWQuIFNob3cgYSBtZXNzYWdlIHRvIHRoZSB1c2VyXG4gICAgICAkcm9vdFNjb3BlLmxvZyhcIm5vdCBzaGFyZWRcIik7XG4gICAgfSk7XG4gIH1cblxuXG4gICRzY29wZS5sb2dpbkNoYWluID0gZnVuY3Rpb24oeCl7XG4gICAgY29uc29sZS5sb2coeCk7XG4gICAgJHNjb3BlLmxvZ2luRGF0YS5jaGFpbiA9IHg7XG4gIH1cbiAgXG4gICRzY29wZS5kb0xvZ2luID0gZnVuY3Rpb24oKSB7XG4gICAgJHJvb3RTY29wZS5sb2coJ0RvaW5nIGxvZ2luJyk7XG4gICAgaWYgKCRzY29wZS5sb2dpbkRhdGEucGFzc3dvcmQgfHwgJHNjb3BlLmxvZ2luRGF0YS5wcml2YXRlUG9zdGluZ0tleSkge1xuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICAgICRzY29wZS5sb2dpbkRhdGEudXNlcm5hbWUgPSAkc2NvcGUubG9naW5EYXRhLnVzZXJuYW1lLnRyaW0oKTtcbiAgICAgIGNvbnNvbGUubG9nKCdkb0xvZ2luJyskc2NvcGUubG9naW5EYXRhLnVzZXJuYW1lKyRzY29wZS5sb2dpbkRhdGEucGFzc3dvcmQpO1xuICAgICAgd2luZG93LkFwaS5jbG9zZSgpO1xuICAgICAgd2luZG93LkFwaSA9IG51bGw7XG4gICAgICB3aW5kb3cuc3RlZW1SUEMuQ2xpZW50LmNsb3NlKCk7XG4gICAgICBcbiAgICAgIHZhciBzb2NrZXRVcmwgPSAkcm9vdFNjb3BlLiRzdG9yYWdlW1wic29ja2V0XCIrJHNjb3BlLmxvZ2luRGF0YS5jaGFpbl07XG4gICAgICBjb25zb2xlLmxvZyhzb2NrZXRVcmwpO1xuXG4gICAgICB3aW5kb3cuQXBpID0gd2luZG93LnN0ZWVtUlBDLkNsaWVudC5nZXQoe3VybDpzb2NrZXRVcmx9LCB0cnVlKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9hY2NvdW50c1wiLCBbWyRzY29wZS5sb2dpbkRhdGEudXNlcm5hbWVdXSkudGhlbihmdW5jdGlvbihkZCl7XG4gICAgICAgICAgICBkZCA9IGRkWzBdO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGQpO1xuICAgICAgICAgICAgJHNjb3BlLmxvZ2luRGF0YS5pZCA9IGRkLmlkO1xuICAgICAgICAgICAgJHNjb3BlLmxvZ2luRGF0YS5vd25lciA9IGRkLm93bmVyO1xuICAgICAgICAgICAgJHNjb3BlLmxvZ2luRGF0YS5hY3RpdmUgPSBkZC5hY3RpdmU7XG4gICAgICAgICAgICAkc2NvcGUubG9naW5EYXRhLnJlcHV0YXRpb24gPSBkZC5yZXB1dGF0aW9uO1xuICAgICAgICAgICAgJHNjb3BlLmxvZ2luRGF0YS5wb3N0aW5nID0gZGQucG9zdGluZztcbiAgICAgICAgICAgICRzY29wZS5sb2dpbkRhdGEubWVtb19rZXkgPSBkZC5tZW1vX2tleTtcbiAgICAgICAgICAgICRzY29wZS5sb2dpbkRhdGEucG9zdF9jb3VudCA9IGRkLnBvc3RfY291bnQ7XG4gICAgICAgICAgICAkc2NvcGUubG9naW5EYXRhLnZvdGluZ19wb3dlciA9IGRkLnZvdGluZ19wb3dlcjtcbiAgICAgICAgICAgICRzY29wZS5sb2dpbkRhdGEud2l0bmVzc192b3RlcyA9IGRkLndpdG5lc3Nfdm90ZXM7XG4gICAgICAgICAgICAkc2NvcGUubG9naW4gPSBuZXcgd2luZG93WyRzY29wZS5sb2dpbkRhdGEuY2hhaW4rXCJKU1wiXS5Mb2dpbigpO1xuICAgICAgICAgICAgJHNjb3BlLmxvZ2luLnNldFJvbGVzKFtcInBvc3RpbmdcIl0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLmxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRzY29wZS5sb2dpbkRhdGEudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRzY29wZS5sb2dpbkRhdGEucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICAgICAgICBwb3N0aW5nOiBkZC5wb3N0aW5nLmtleV9hdXRoc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHNjb3BlLmxvZ2luRGF0YS5wcml2YXRlUG9zdGluZ0tleSB8fCBudWxsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmICghbG9naW5TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUEFTU1dPUkRfSU5DT1JSRUNUJykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyID0gJHNjb3BlLmxvZ2luRGF0YTtcblxuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXJzLnB1c2goJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKTtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5teWxvZ2luID0gJHNjb3BlLmxvZ2luO1xuICAgICAgICAgICAgICBBUElzLnVwZGF0ZVN1YnNjcmlwdGlvbigkcm9vdFNjb3BlLiRzdG9yYWdlLmRldmljZWlkLCAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsIHtkZXZpY2U6IGlvbmljLlBsYXRmb3JtLnBsYXRmb3JtKCksIHRpbWVzdGFtcDogJGZpbHRlcignZGF0ZScpKG5ldyBEYXRlKCksICdtZWRpdW0nKSwgYXBwdmVyc2lvbjogJHJvb3RTY29wZS4kc3RvcmFnZS5hcHB2ZXJzaW9ufSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgLy8kc3RhdGUuZ28oJHN0YXRlLmN1cnJlbnQsIHt9LCB7cmVsb2FkOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgLy8kc3RhdGUuZ28oJ2FwcC5wb3N0cycsIHt9LCB7IHJlbG9hZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAvLyRzY29wZS5jbG9zZUxvZ2luKCk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmxvZ2luTW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgIC8vJGlvbmljSGlzdG9yeS5jbGVhckNhY2hlKCk7XG4gICAgICAgICAgICAgICAgLy8kaW9uaWNIaXN0b3J5LmNsZWFySGlzdG9yeSgpO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgncmVmcmVzaExvY2FsVXNlckRhdGEnKTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vd2luZG93LkFwaS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIC8vdmFyIHN0ZWVtUlBDID0gcmVxdWlyZShcInN0ZWVtLXJwY1wiKTtcbiAgICAgICAgICAgICAgICAvL3dpbmRvdy5BcGkgPSBzdGVlbVJQQy5DbGllbnQuZ2V0KHt1cmw6bG9jYWxTdG9yYWdlLnNvY2tldFVybH0sIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgLy93aW5kb3cuQXBpID0gc3RlZW1SUEMuQ2xpZW50LmdldCh7dXJsOmxvY2FsU3RvcmFnZS5zb2NrZXRVcmx9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluID0gJHNjb3BlLmxvZ2luRGF0YS5jaGFpbjtcblxuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2hhbmdlZENoYWluJyk7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjaGFuZ2VkQ3VycmVuY3knLCB7Y3VycmVuY3k6ICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3ksIGVuZm9yY2U6IHRydWV9KTtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAkd2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmV0Y2hQb3N0cycpO1xuICAgICAgICAgICAgICAgIH0sIDIwMDApO1xuXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyppZighJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgfSovXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgMTAwMCk7XG4gICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjb3BlLmxvZ2luTW9kYWwuaGlkZSgpO1xuICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUwnKSk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5zZWxlY3RBY2NvdW50ID0gZnVuY3Rpb24odXNlcikge1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2UudXNlciA9IHVzZXI7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbiA9IHVzZXIuY2hhaW47XG5cbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2NoYW5nZWRDaGFpbicpO1xuXG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjaGFuZ2VkQ3VycmVuY3knLCB7Y3VycmVuY3k6ICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3ksIGVuZm9yY2U6IHRydWV9KTtcbiAgICBcbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3JlZnJlc2hMb2NhbFVzZXJEYXRhJyk7XG4gICAgXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICR3aW5kb3cubG9jYXRpb24ucmVsb2FkKHRydWUpO1xuICAgIH0sIDIwMDApO1xuICB9XG5cbiAgJHJvb3RTY29wZS4kb24oJ3JlZnJlc2hMb2NhbFVzZXJEYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgJHJvb3RTY29wZS5sb2coJ3JlZnJlc2hMb2NhbFVzZXJEYXRhJyk7XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlciAmJiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgJiYgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmNoYWluID09ICRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4pIHtcbiAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfYWNjb3VudHNcIiwgWyBbICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSBdIF0pLnRoZW4oZnVuY3Rpb24oZGQpe1xuICAgICAgICAgICAgZGQgPSBkZFswXTtcbiAgICAgICAgICAgIGlmIChkZCAmJiBkZC5qc29uX21ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIGRkLmpzb25fbWV0YWRhdGEgPSBhbmd1bGFyLmZyb21Kc29uKGRkLmpzb25fbWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5ndWxhci5tZXJnZSgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIsIGRkKTtcbiAgICAgICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHNjb3BlLm1jc3MgPSAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEgJiYgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZSAmJiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmNvdmVyX2ltYWdlKSA/IHsnYmFja2dyb3VuZCc6ICd1cmwoJyskcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmNvdmVyX2ltYWdlKycpJywgJ2JhY2tncm91bmQtc2l6ZSc6ICdjb3ZlcicsICdiYWNrZ3JvdW5kLXBvc2l0aW9uJzonZml4ZWQnfSA6IG51bGw7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSlcblxuICAkc2NvcGUub3BlblBvc3RNb2RhbCA9IGZ1bmN0aW9uKCkge1xuICAgICRzdGF0ZS5nbygnYXBwLnBvc3RzJyk7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdvcGVuUG9zdE1vZGFsJyk7XG4gIH1cblxuICAkc2NvcGUuY2hhbmdlVmlldyA9IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnZpZXcgPSB2aWV3O1xuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2hhbmdlVmlldycpO1xuICB9XG5cbiAgJHNjb3BlLiRvbihcIiRpb25pY1ZpZXcuZW50ZXJcIiwgZnVuY3Rpb24oKXtcbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3JlZnJlc2hMb2NhbFVzZXJEYXRhJyk7XG4gIH0pO1xuXG4gIC8vIGdldCBhcHAgdmVyc2lvblxuICAkaW9uaWNQbGF0Zm9ybS5yZWFkeShmdW5jdGlvbigpe1xuICAgIGlmICh3aW5kb3cuY29yZG92YSkge1xuICAgICAgY29yZG92YS5nZXRBcHBWZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5hcHB2ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmFwcHZlcnNpb24gPSAnZGVidWcnO1xuICAgIH1cbiAgfSk7XG5cbiAgJHNjb3BlLmxvZ291dCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXJzLmxlbmd0aD4xKSB7XG4gICAgICBhbmd1bGFyLmZvckVhY2goJHJvb3RTY29wZS4kc3RvcmFnZS51c2VycywgZnVuY3Rpb24odixrKXtcbiAgICAgICAgaWYgKHYuY2hhaW4gPT0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmNoYWluICYmIHYudXNlcm5hbWUgPT0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS51c2Vycy5zcGxpY2UoaywxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXJzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgPSB1bmRlZmluZWQ7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgPSBudWxsO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5teWxvZ2luID0gdW5kZWZpbmVkO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5teWxvZ2luID0gbnVsbDtcbiAgICB9XG4gICAgLy9tYWtlIHN1cmUgdXNlciBjcmVkZW50aWFscyBjbGVhcmVkLlxuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmRldmljZWlkKSB7XG4gICAgICBBUElzLmRlbGV0ZVN1YnNjcmlwdGlvbigkcm9vdFNjb3BlLiRzdG9yYWdlLmRldmljZWlkKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICRpb25pY1NpZGVNZW51RGVsZWdhdGUudG9nZ2xlTGVmdCgpO1xuICAgICAgICAkd2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAkaW9uaWNTaWRlTWVudURlbGVnYXRlLnRvZ2dsZUxlZnQoKTtcbiAgICAgICR3aW5kb3cubG9jYXRpb24ucmVsb2FkKHRydWUpO1xuICAgIH1cbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9IHVuZGVmaW5lZDtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnRhZyA9IHVuZGVmaW5lZDtcblxuICAgICRpb25pY0hpc3RvcnkuY2xlYXJDYWNoZSgpO1xuICAgICRpb25pY0hpc3RvcnkuY2xlYXJIaXN0b3J5KCk7XG4gIH07XG4gICRzY29wZS5kYXRhID0ge307XG4gICRpb25pY01vZGFsLmZyb21UZW1wbGF0ZVVybCgndGVtcGxhdGVzL3NlYXJjaC5odG1sJywge1xuICAgIHNjb3BlOiAkc2NvcGUsXG4gICAgYW5pbWF0aW9uOiAnc2xpZGUtaW4tZG93bidcbiAgfSkudGhlbihmdW5jdGlvbihtb2RhbCkge1xuICAgICRzY29wZS5zbW9kYWwgPSBtb2RhbDtcbiAgfSk7XG5cbiAgLy8gVHJpZ2dlcmVkIGluIHRoZSBsb2dpbiBtb2RhbCB0byBjbG9zZSBpdFxuICAkc2NvcGUuY2xvc2VTbW9kYWwgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUuc21vZGFsLmhpZGUoKTtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIE9wZW4gdGhlIGxvZ2luIG1vZGFsXG4gICRzY29wZS5vcGVuU21vZGFsID0gZnVuY3Rpb24oKSB7XG4gICAgLy9pZighJHNjb3BlLnNtb2RhbCkgcmV0dXJuO1xuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2xvc2U6cG9wb3ZlcicpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUuZGF0YS50eXBlPVwidGFnXCI7XG4gICAgICAkc2NvcGUuZGF0YS5zZWFyY2hSZXN1bHQgPSBbXTtcbiAgICAgICRzY29wZS5zbW9kYWwuc2hvdygpO1xuICAgIH0sIDUpO1xuICB9O1xuICAkc2NvcGUuY2xlYXJTZWFyY2ggPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS50YWcpIHtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UudGFnID0gdW5kZWZpbmVkO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS50YWdsaW1pdHMgPSB1bmRlZmluZWQ7XG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2Nsb3NlOnBvcG92ZXInKTtcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmV0Y2hQb3N0cycpO1xuICAgIH1cbiAgfTtcbiAgJHNjb3BlLnNob3dNZUV4dHJhID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCRzY29wZS5zaG93RXh0cmEpIHtcbiAgICAgICRzY29wZS5zaG93RXh0cmEgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjb3BlLnNob3dFeHRyYSA9IHRydWU7XG4gICAgfVxuICB9XG4gICRzY29wZS5zZWFyY2ggPSBmdW5jdGlvbigpIHtcbiAgICAkcm9vdFNjb3BlLmxvZygnRG9pbmcgc2VhcmNoICcrJHNjb3BlLmRhdGEuc2VhcmNoKTtcbiAgICAkc2NvcGUuZGF0YS5zZWFyY2ggPSBhbmd1bGFyLmxvd2VyY2FzZSgkc2NvcGUuZGF0YS5zZWFyY2gpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoJHNjb3BlLmRhdGEuc2VhcmNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaWYgKCRzY29wZS5kYXRhLnR5cGUgPT0gXCJ0YWdcIil7XG4gICAgICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfdHJlbmRpbmdfdGFnc1wiLCBbJHNjb3BlLmRhdGEuc2VhcmNoLCAxNV0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgICAgICAgdmFyIGVlID0gW107XG4gICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgICAgICAgICAgLyppZiAocmVzdWx0KXtcbiAgICAgICAgICAgICAgICB2YXIgbGwgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBsbCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0W2ldLm5hbWUuaW5kZXhPZigkc2NvcGUuZGF0YS5zZWFyY2gpID4gLTEpe1xuICAgICAgICAgICAgICAgICAgICBlZS5wdXNoKHJlc3VsdFtpXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLnNlYXJjaFJlc3VsdCA9IGVlO1xuICAgICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuc2VhcmNoUmVzdWx0ID0gcmVzdWx0O1xuXG4gICAgICAgICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkc2NvcGUuZGF0YS50eXBlID09IFwidXNlclwiKXtcbiAgICAgICAgICB2YXIgZWUgPSBbXTtcbiAgICAgICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImxvb2t1cF9hY2NvdW50c1wiLCBbJHNjb3BlLmRhdGEuc2VhcmNoLCAxNV0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCl7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuc2VhcmNoUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH0sIDUpO1xuXG4gIH07XG4gICRzY29wZS50eXBlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLmRhdGEuc2VhcmNoUmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gICAgJHJvb3RTY29wZS5sb2coXCJjaGFuZ2luZyBzZWFyY2ggdHlwZVwiKTtcbiAgfVxuICAkc2NvcGUub3BlblRhZyA9IGZ1bmN0aW9uKHh4LCB5eSkge1xuICAgICRyb290U2NvcGUubG9nKFwib3BlbmluZyB0YWcgXCIreHgpO1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2UudGFnID0geHg7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS50YWdsaW1pdHMgPSB5eTtcbiAgICBpZiAoJHNjb3BlLnNtb2RhbC5pc1Nob3duKCkpe1xuICAgICAgJHNjb3BlLmNsb3NlU21vZGFsKCk7XG4gICAgfVxuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2xvc2U6cG9wb3ZlcicpO1xuICAgICRzdGF0ZS5nbyhcImFwcC5wb3N0c1wiLCB7dGFnczogeHh9KTtcbiAgfTtcbiAgJHNjb3BlLm9wZW5Vc2VyID0gZnVuY3Rpb24oeHkpIHtcbiAgICAkcm9vdFNjb3BlLmxvZyhcIm9wZW5pbmcgdXNlciBcIit4eSk7XG4gICAgJHNjb3BlLmNsb3NlU21vZGFsKCk7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjbG9zZTpwb3BvdmVyJyk7XG4gICAgJHN0YXRlLmdvKFwiYXBwLnByb2ZpbGVcIiwge3VzZXJuYW1lOiB4eX0pO1xuICB9O1xuICAkc2NvcGUudGVzdGZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfYWNjb3VudF9oaXN0b3J5XCIsIFskcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsIC0xLCAyNV0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xuICAgICAgICAkcm9vdFNjb3BlLmxvZyhhbmd1bGFyLnRvSnNvbihyZXNwb25zZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxufSlcblxuYXBwLmNvbnRyb2xsZXIoJ1NlbmRDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkcm9vdFNjb3BlLCAkc3RhdGUsICRpb25pY1BvcHVwLCAkaW9uaWNQb3BvdmVyLCAkaW50ZXJ2YWwsICRmaWx0ZXIsICRxLCAkdGltZW91dCwgJGNvcmRvdmFCYXJjb2RlU2Nhbm5lciwgJGlvbmljUGxhdGZvcm0pIHtcblxuICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbiA9PSBcInN0ZWVtXCIpIHtcbiAgICAkc2NvcGUuZGF0YSA9IHt0eXBlczogW3t0eXBlOiBcInN0ZWVtXCIsIG5hbWU6XCJTdGVlbVwiLCBpZDoxfSx7dHlwZTogXCJzYmRcIiwgbmFtZTpcIlN0ZWVtIERvbGxhclwiLCBpZDoyfSwge3R5cGU6IFwic3BcIiwgbmFtZTpcIlN0ZWVtIFBvd2VyXCIsIGlkOjN9XSwgdHlwZTogXCJzdGVlbVwiLCBhbW91bnQ6IDAuMDAxfTtcbiAgfSBlbHNlIHtcbiAgICAkc2NvcGUuZGF0YSA9IHt0eXBlczogW3t0eXBlOiBcImdvbG9zXCIsIG5hbWU6IFwi0JPQntCb0J7QoVwiLCBpZDoxfSx7dHlwZTogXCJnYmdcIiwgbmFtZTpcItCX0J7Qm9Ce0KLQntCZXCIsIGlkOjJ9LCB7dHlwZTogXCJnb2xvc3BcIiwgbmFtZTpcItCh0JjQm9CQINCT0J7Qm9Ce0KHQkFwiLCBpZDozfV0sIHR5cGU6IFwiZ29sb3NcIiwgYW1vdW50OiAwLjAwMX07XG4gIH1cbiAgJHNjb3BlLmNoYW5nZVVzZXJuYW1lID0gZnVuY3Rpb24odHlwZWQpIHtcbiAgICAkcm9vdFNjb3BlLmxvZygnc2VhcmNoaW5nJyk7XG4gICAgJHNjb3BlLmRhdGEudXNlcm5hbWUgPSBhbmd1bGFyLmxvd2VyY2FzZSgkc2NvcGUuZGF0YS51c2VybmFtZSk7XG4gICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJsb29rdXBfYWNjb3VudF9uYW1lc1wiLCBbWyRzY29wZS5kYXRhLnVzZXJuYW1lXV0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xuICAgICAgICAkc2NvcGUudXNlcnMgPSByZXNwb25zZVswXTtcbiAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgJHNjb3BlLnFyU2NhbiA9IGZ1bmN0aW9uKCkge1xuICAgICRpb25pY1BsYXRmb3JtLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgJGNvcmRvdmFCYXJjb2RlU2Nhbm5lci5zY2FuKHtcbiAgICAgICAgICBcInByZWZlckZyb250Q2FtZXJhXCIgOiBmYWxzZSwgLy8gaU9TIGFuZCBBbmRyb2lkXG4gICAgICAgICAgXCJzaG93RmxpcENhbWVyYUJ1dHRvblwiIDogZmFsc2UsIC8vIGlPUyBhbmQgQW5kcm9pZFxuICAgICAgICAgIFwicHJvbXB0XCIgOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUVJfVEVYVCcpLCAvLyBzdXBwb3J0ZWQgb24gQW5kcm9pZCBvbmx5XG4gICAgICAgICAgXCJmb3JtYXRzXCIgOiBcIlFSX0NPREVcIiAvLyBkZWZhdWx0OiBhbGwgYnV0IFBERl80MTcgYW5kIFJTU19FWFBBTkRFRFxuICAgICAgICAgIC8vXCJvcmllbnRhdGlvblwiIDogXCJsYW5kc2NhcGVcIiAvLyBBbmRyb2lkIG9ubHkgKHBvcnRyYWl0fGxhbmRzY2FwZSksIGRlZmF1bHQgdW5zZXQgc28gaXQgcm90YXRlcyB3aXRoIHRoZSBkZXZpY2VcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihiYXJjb2RlRGF0YSkge1xuICAgICAgICAvL2FsZXJ0KGJhcmNvZGVEYXRhKTtcbiAgICAgICAgaWYgKGJhcmNvZGVEYXRhLnRleHQuaW5kZXhPZignP2Ftb3VudCcpPi0xKSB7XG4gICAgICAgICAgLy9zdGVlbSBkb2xsYXI6YmxvY2t0cmFkZXM/YW1vdW50PTEyLjA4MFxuXG4gICAgICAgICAgJHNjb3BlLmRhdGEudXNlcm5hbWUgPSBiYXJjb2RlRGF0YS50ZXh0LnNwbGl0KCc6JylbMV0uc3BsaXQoJz8nKVswXS50cmltKCk7XG4gICAgICAgICAgJHNjb3BlLmRhdGEuYW1vdW50ID0gTnVtYmVyKGJhcmNvZGVEYXRhLnRleHQuc3BsaXQoJz0nKVsxXSk7XG4gICAgICAgICAgaWYgKGJhcmNvZGVEYXRhLnRleHQuc3BsaXQoJzonKVswXT09PSdzdGVlbSBkb2xsYXInKSB7XG4gICAgICAgICAgICAkc2NvcGUuZGF0YS50eXBlID0gJ3NiZCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiYXJjb2RlRGF0YS50ZXh0LnNwbGl0KCc6JylbMF09PT0nc3RlZW0nKSB7XG4gICAgICAgICAgICAkc2NvcGUuZGF0YS50eXBlID0gJ3N0ZWVtJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJhcmNvZGVEYXRhLnRleHQuc3BsaXQoJzonKVswXT09PSdzdGVlbSBwb3dlcicpIHtcbiAgICAgICAgICAgICRzY29wZS5kYXRhLnR5cGUgPSAnc3AnO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRzY29wZS5kYXRhLnVzZXJuYW1lID0gYmFyY29kZURhdGEudGV4dDtcbiAgICAgICAgfVxuICAgICAgICAkc2NvcGUuY2hhbmdlVXNlcm5hbWUoKTtcbiAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJ0Vycm9yJyxhbmd1bGFyLnRvSnNvbihlcnJvcikpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gICRzY29wZS50cmFuc2ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCAmJiAhJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVBY3RpdmVLZXkpIHtcbiAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0FDVElWRV9LRVlfUkVRVUlSRURfVEVYVCcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgkc2NvcGUuZGF0YS50eXBlID09PSAnc2JkJyB8fCAkc2NvcGUuZGF0YS50eXBlID09PSAnZ2JnJykge1xuICAgICAgICAgIGlmICgkc2NvcGUuZGF0YS5hbW91bnQgPiBOdW1iZXIoJHNjb3BlLmJhbGFuY2Uuc2JkX2JhbGFuY2Uuc3BsaXQoXCIgXCIpWzBdKSkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0JBTEFOQ0VfVEVYVCcpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLm9rYmFsYW5jZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgkc2NvcGUuZGF0YS50eXBlID09PSAnc3AnIHx8ICRzY29wZS5kYXRhLnR5cGUgPT09ICdzdGVlbScgfHwgJHNjb3BlLmRhdGEudHlwZSA9PT0gJ2dvbG9zJyB8fCAkc2NvcGUuZGF0YS50eXBlID09PSAnZ29sb3NwJykge1xuICAgICAgICAgIGlmICgkc2NvcGUuZGF0YS5hbW91bnQgPiBOdW1iZXIoJHNjb3BlLmJhbGFuY2UuYmFsYW5jZS5zcGxpdChcIiBcIilbMF0pKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQkFMQU5DRV9URVhUJykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2NvcGUub2tiYWxhbmNlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkc2NvcGUudXNlcnMgfHwgJHNjb3BlLnVzZXJzLm5hbWUgIT09ICRzY29wZS5kYXRhLnVzZXJuYW1lKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ05PTkVYSVNUX1VTRVInKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHNjb3BlLm9rdXNlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRzY29wZS5va2JhbGFuY2UgJiYgJHNjb3BlLm9rdXNlcikge1xuICAgICAgICAgIHZhciBjb25maXJtUG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgICAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ09ORklSTUFUSU9OJyksXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ1RSQU5TRkVSX1RFWFQnKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uZmlybVBvcHVwLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICBpZihyZXMpIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgc3VyZScpO1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbiA9IG5ldyB3aW5kb3dbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIkpTXCJdLkxvZ2luKCk7XG4gICAgICAgICAgICAgICRzY29wZS5teWxvZ2luLnNldFJvbGVzKFtcImFjdGl2ZVwiXSk7XG4gICAgICAgICAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSAkc2NvcGUubXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmFjdGl2ZS5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSB8fCBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyID0gbmV3IHdpbmRvd1skcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluK1wiSlNcIl0uVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKCRzY29wZS5kYXRhLnR5cGUgIT09ICdzcCcgJiYgJHNjb3BlLmRhdGEudHlwZSAhPT0gJ2dvbG9zcCcpIHtcblxuICAgICAgICAgICAgICAgICAgdmFyIHR0ID0gJGZpbHRlcignbnVtYmVyJykoJHNjb3BlLmRhdGEuYW1vdW50KSArXCIgXCIrYW5ndWxhci51cHBlcmNhc2UoJHNjb3BlLmRhdGEudHlwZSk7XG4gICAgICAgICAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJ0cmFuc2ZlclwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdG86ICRzY29wZS5kYXRhLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IHR0LFxuICAgICAgICAgICAgICAgICAgICBtZW1vOiAkc2NvcGUuZGF0YS5tZW1vIHx8IFwiXCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcbiAgICAgICAgICAgICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24oJHNjb3BlLm15bG9naW4sIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5lcnJvciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdJTkZPJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdUWF9CUk9BRENBU1RFRCcpKS50aGVuKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS50eXBlPSRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW47XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5hbW91bnQ9IDAuMDAxO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHR0ID0gJGZpbHRlcignbnVtYmVyJykoJHNjb3BlLmRhdGEuYW1vdW50KSArIFwiIFwiKyRmaWx0ZXIoJ3VwcGVyY2FzZScpKCRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4pO1xuICAgICAgICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwidHJhbnNmZXJfdG9fdmVzdGluZ1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdG86ICRzY29wZS5kYXRhLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IHR0XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnSU5GTycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVFhfQlJPQURDQVNURUQnKSkudGhlbihmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEudHlwZT0kcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuYW1vdW50PSAwLjAwMTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSwgMzAwMCk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUxfQScpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBub3Qgc3VyZScpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX1RPX1gnKSk7XG4gICAgfVxuICB9O1xuICAkc2NvcGUucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfYWNjb3VudHNcIiwgWyBbICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSBdIF0pLnRoZW4oZnVuY3Rpb24oZGQpe1xuICAgICAgICAkc2NvcGUuYmFsYW5jZSA9IGRkWzBdO1xuICAgICAgICBjb25zb2xlLmxvZygkc2NvcGUuYmFsYW5jZSk7XG4gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgfVxuICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmJlZm9yZUVudGVyJywgZnVuY3Rpb24oKXtcbiAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9hY2NvdW50c1wiLCBbIFsgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lIF0gXSkudGhlbihmdW5jdGlvbihkZCl7XG4gICAgICAgICRzY29wZS5iYWxhbmNlID0gZGRbMF07XG4gICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG59KTtcbmFwcC5jb250cm9sbGVyKCdQb3N0c0N0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRyb290U2NvcGUsICRzdGF0ZSwgJGlvbmljUG9wdXAsICRpb25pY1BvcG92ZXIsICRpbnRlcnZhbCwgJGlvbmljU2Nyb2xsRGVsZWdhdGUsICRpb25pY01vZGFsLCAkZmlsdGVyLCAkc3RhdGVQYXJhbXMsICRpb25pY1NsaWRlQm94RGVsZWdhdGUsICRpb25pY0FjdGlvblNoZWV0LCAkaW9uaWNQbGF0Zm9ybSwgJGNvcmRvdmFDYW1lcmEsIEltYWdlVXBsb2FkU2VydmljZSwgJGZpbHRlciwgJGlvbmljSGlzdG9yeSwgJHRpbWVvdXQsIEFQSXMsICR0cmFuc2xhdGUpIHtcblxuICB2YXIgZm9ybWF0VG9QZXJjZW50YWdlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJyUnO1xuICB9O1xuXG4gICRzY29wZS5wc2xpZGVyID0ge1xuICAgIHZhbHVlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQvMTAwLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGZsb29yOiAxLFxuICAgICAgY2VpbDogMTAwLFxuICAgICAgdHJhbnNsYXRlOiBmb3JtYXRUb1BlcmNlbnRhZ2UsXG4gICAgICBzaG93U2VsZWN0aW9uQmFyOiB0cnVlXG4gICAgfVxuICB9O1xuICBcbiAgJGlvbmljUG9wb3Zlci5mcm9tVGVtcGxhdGVVcmwoJ3BvcG92ZXJTbGlkZXIuaHRtbCcsIHtcbiAgICAgIHNjb3BlOiAkc2NvcGVcbiAgfSkudGhlbihmdW5jdGlvbihwb3BvdmVyKSB7XG4gICAgICAkc2NvcGUudG9vbHRpcFNsaWRlciA9IHBvcG92ZXI7XG4gIH0pO1xuICBcbiAgJHNjb3BlLm9wZW5TbGlkZXIgPSBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAkc2NvcGUucHNsaWRlciA9IHtcbiAgICAgIHZhbHVlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQvMTAwLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBmbG9vcjogMSxcbiAgICAgICAgY2VpbDogMTAwLFxuICAgICAgICB0cmFuc2xhdGU6IGZvcm1hdFRvUGVyY2VudGFnZSxcbiAgICAgICAgc2hvd1NlbGVjdGlvbkJhcjogdHJ1ZVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgICAkc2NvcGUudG9vbHRpcFNsaWRlci5zaG93KCRldmVudCk7XG4gIH07XG5cbiAgJHNjb3BlLmNsb3NlU2xpZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLnRvb2x0aXBTbGlkZXIuaGlkZSgpO1xuICB9O1xuXG4gICRzY29wZS4kd2F0Y2goJ3BzbGlkZXInLCBmdW5jdGlvbihuZXdWYWx1ZSwgb2xkVmFsdWUpe1xuICAgIC8vY29uc29sZS5sb2cobmV3VmFsdWUudmFsdWUpO1xuICAgIGlmIChuZXdWYWx1ZS52YWx1ZSkge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS52b3RlV2VpZ2h0ID0gbmV3VmFsdWUudmFsdWUqMTAwO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG5cblxuICAkc2NvcGUub3B0aW9ucyA9IHtcbiAgICBsb29wOiBmYWxzZSxcbiAgICBzcGVlZDogNTAwLFxuICAgIC8qcGFnaW5hdGlvbjogZmFsc2UsKi9cbiAgICBzaG93UGFnZXI6IGZhbHNlLFxuICAgIHNsaWRlc1BlclZpZXc6IDMsXG4gICAgc3BhY2VCZXR3ZWVuOiAyMCxcbiAgICBicmVha3BvaW50czoge1xuICAgICAgMTAyNDoge1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDUsXG4gICAgICAgICAgc3BhY2VCZXR3ZWVuOiAxNVxuICAgICAgfSxcbiAgICAgIDc2ODoge1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDQsXG4gICAgICAgICAgc3BhY2VCZXR3ZWVuOiAxMFxuICAgICAgfSxcbiAgICAgIDY0MDoge1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDMsXG4gICAgICAgICAgc3BhY2VCZXR3ZWVuOiA1XG4gICAgICB9LFxuICAgICAgMzIwOiB7XG4gICAgICAgICAgc2xpZGVzUGVyVmlldzogMyxcbiAgICAgICAgICBzcGFjZUJldHdlZW46IDNcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gICRyb290U2NvcGUuJG9uKCdmaWx0ZXI6Y2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgLy8kcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgICRyb290U2NvcGUubG9nKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyKTtcbiAgICB2YXIgdHlwZSA9ICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyIHx8IFwidHJlbmRpbmdcIjtcbiAgICB2YXIgdGFnID0gJHJvb3RTY29wZS4kc3RvcmFnZS50YWcgfHwgXCJcIjtcbiAgICBjb25zb2xlLmxvZyh0eXBlLCAkc2NvcGUubGltaXQsIHRhZyk7XG4gICAgJHNjb3BlLmZldGNoUG9zdHModHlwZSwgJHNjb3BlLmxpbWl0LCB0YWcpO1xuICB9KTtcblxuICAkc2NvcGUuZmlsdGVyQ2hhbmdlZCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZmlsID0gJHNjb3BlLm15bWVudVt0XS5jdXN0b207XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSBmaWw7XG4gICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS5teW1lbnUsIGZ1bmN0aW9uKHYsayl7XG4gICAgICBpZiAodi5jdXN0b20gPT0gZmlsKSB7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyTmFtZSA9IHYudGV4dDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAkc2NvcGUuZGF0YSA9IFtdO1xuICAgICRzY29wZS5lcnJvciA9IGZhbHNlO1xuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICB9XG4gICRzY29wZS5zaG93RmlsdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZpbHRlclNoZWV0ID0gJGlvbmljQWN0aW9uU2hlZXQuc2hvdyh7XG4gICAgIGJ1dHRvbnM6ICRzY29wZS5teW1lbnUsXG4gICAgIHRpdGxlVGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1NPUlRfUE9TVF9CWScpLFxuICAgICBjYW5jZWxUZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FOQ0VMJyksXG4gICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGFkZCBjYW5jZWwgY29kZS4uXG4gICAgICB9LFxuICAgICBidXR0b25DbGlja2VkOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAkc2NvcGUuZmlsdGVyQ2hhbmdlZChpbmRleCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAkaW9uaWNQb3BvdmVyLmZyb21UZW1wbGF0ZVVybCgncG9wb3ZlclQuaHRtbCcsIHtcbiAgICAgIHNjb3BlOiAkc2NvcGVcbiAgfSkudGhlbihmdW5jdGlvbihwb3BvdmVyKSB7XG4gICAgJHNjb3BlLnRvb2x0aXAgPSBwb3BvdmVyO1xuICB9KTtcblxuICAkc2NvcGUub3BlblRvb2x0aXAgPSBmdW5jdGlvbigkZXZlbnQsIGQpIHtcbiAgICB2YXIgdHBwdiA9IE51bWJlcihkLnRvdGFsX3BlbmRpbmdfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgIHZhciBwID0gTnVtYmVyKGQucHJvbW90ZWQuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgdmFyIHRwdiA9IE51bWJlcihkLnRvdGFsX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICB2YXIgYXIgPSBOdW1iZXIoZC50b3RhbF9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXS1kLmN1cmF0b3JfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgIHZhciBjcnAgPSBOdW1iZXIoZC5jdXJhdG9yX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICB2YXIgdGV4dGggPSBcIjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUEFZT1VUX0NZQ0xFJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIitkLm1vZGUucmVwbGFjZSgnXycsJyAnKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUE9URU5USUFMX1BBWU9VVCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcignZ2V0Q3VycmVuY3lTeW1ib2wnKSgkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5KSskZmlsdGVyKCdudW1iZXInKSh0cHB2LCAzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUFJPTU9URUQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykocCwzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUEFTVF9QQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykodHB2LDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBVVRIT1JfUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCdnZXRDdXJyZW5jeVN5bWJvbCcpKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kpKyRmaWx0ZXIoJ251bWJlcicpKGFyLDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDVVJBVElPTl9QQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykoY3JwLDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ3RpbWVhZ28nKShkLmNhc2hvdXRfdGltZSwgdHJ1ZSkrXCI8L2Rpdj48L2Rpdj5cIjtcbiAgICAkc2NvcGUudG9vbHRpcFRleHQgPSB0ZXh0aDtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICAgICRzY29wZS50b29sdGlwLnNob3coJGV2ZW50KTtcbiAgfTtcblxuICAkc2NvcGUuY2xvc2VUb29sdGlwID0gZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUudG9vbHRpcC5oaWRlKCk7XG4gIH07XG5cbiAgIC8vQ2xlYW51cCB0aGUgcG9wb3ZlciB3aGVuIHdlJ3JlIGRvbmUgd2l0aCBpdCFcbiAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUudG9vbHRpcC5yZW1vdmUoKTtcbiAgIH0pO1xuXG4gICAvLyBFeGVjdXRlIGFjdGlvbiBvbiBoaWRlIHBvcG92ZXJcbiAgICRzY29wZS4kb24oJ3BvcG92ZXIuaGlkZGVuJywgZnVuY3Rpb24oKSB7XG4gICAgICAvLyBFeGVjdXRlIGFjdGlvblxuICAgICAgJHNjb3BlLnRvb2x0aXBUZXh0ID0gdW5kZWZpbmVkO1xuICAgfSk7XG5cbiAgIC8vIEV4ZWN1dGUgYWN0aW9uIG9uIHJlbW92ZSBwb3BvdmVyXG4gICAkc2NvcGUuJG9uKCdwb3BvdmVyLnJlbW92ZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIC8vIEV4ZWN1dGUgYWN0aW9uXG4gICB9KTtcblxuICAkaW9uaWNNb2RhbC5mcm9tVGVtcGxhdGVVcmwoJ3RlbXBsYXRlcy9zdG9yeS5odG1sJywgeyBzY29wZTogJHNjb3BlICB9KS50aGVuKGZ1bmN0aW9uKG1vZGFsKSB7XG4gICAgICAkc2NvcGUubW9kYWxwID0gbW9kYWw7XG4gIH0pO1xuICAkc2NvcGUubGFzdEZvY3VzZWQ7XG5cbiAgJHJvb3RTY29wZS4kb24oJ29wZW5Qb3N0TW9kYWwnLCBmdW5jdGlvbigpIHtcblxuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2xvc2U6cG9wb3ZlcicpO1xuXG4gICAgJHNjb3BlLnNwb3N0ID0gJHJvb3RTY29wZS4kc3RvcmFnZS5zcG9zdCB8fCAkc2NvcGUuc3Bvc3Q7XG5cbiAgICBcblxuICAgICR0aW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBpZiAoISRzY29wZS5zcG9zdC5vcGVyYXRpb25fdHlwZSkge1xuICAgICAgICAkc2NvcGUuc3Bvc3Qub3BlcmF0aW9uX3R5cGUgPSAnZGVmYXVsdCc7XG4gICAgICB9XG4gICAgICAkc2NvcGUudGFnc0NoYW5nZSgpO1xuXG4gICAgICAkc2NvcGUubW9kYWxwLnNob3coKTtcbiAgICAgIC8qYW5ndWxhci5lbGVtZW50KFwidGV4dGFyZWFcIikuZm9jdXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5sYXN0Rm9jdXNlZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIC8vY29uc29sZS5sb2coZG9jdW1lbnQpO1xuICAgICAgfSk7Ki9cbiAgICB9LCAxMCk7XG4gICAgLy8kc2NvcGUubW9kYWxwLnNob3coKTtcbiAgfSk7XG5cbiAgJHJvb3RTY29wZS4kb24oJ2Nsb3NlUG9zdE1vZGFsJywgZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLm1vZGFscC5oaWRlKCk7XG4gIH0pO1xuXG4gICRzY29wZS5jbG9zZVBvc3RNb2RhbCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vJHNjb3BlLiRicm9hZGNhc3QoJ2Nsb3NlOnBvcG92ZXInKTtcbiAgICAkc2NvcGUubW9kYWxwLmhpZGUoKTtcbiAgfTtcblxuXG4gICRzY29wZS5jZm9jdXMgPSBmdW5jdGlvbigpe1xuICAgICRzY29wZS5sYXN0Rm9jdXNlZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIH1cbiAgLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNjQwODkvaW5zZXJ0aW5nLWEtdGV4dC13aGVyZS1jdXJzb3ItaXMtdXNpbmctamF2YXNjcmlwdC1qcXVlcnlcbiAgJHNjb3BlLmluc2VydFRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIGlucHV0ID0gJHNjb3BlLmxhc3RGb2N1c2VkO1xuICAgIC8vY29uc29sZS5sb2coaW5wdXQpO1xuICAgIGlmIChpbnB1dCA9PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHNjcm9sbFBvcyA9IGlucHV0LnNjcm9sbFRvcDtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgYnJvd3NlciA9ICgoaW5wdXQuc2VsZWN0aW9uU3RhcnQgfHwgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPT0gXCIwXCIpID9cbiAgICAgICAgICAgICAgICAgICBcImZmXCIgOiAoZG9jdW1lbnQuc2VsZWN0aW9uID8gXCJpZVwiIDogZmFsc2UgKSApO1xuICAgIGlmIChicm93c2VyID09IFwiaWVcIikge1xuICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgcmFuZ2UubW92ZVN0YXJ0IChcImNoYXJhY3RlclwiLCAtaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICAgIHBvcyA9IHJhbmdlLnRleHQubGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIGlmIChicm93c2VyID09IFwiZmZcIikgeyBwb3MgPSBpbnB1dC5zZWxlY3Rpb25TdGFydCB9O1xuXG4gICAgdmFyIGZyb250ID0gKGlucHV0LnZhbHVlKS5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICB2YXIgYmFjayA9IChpbnB1dC52YWx1ZSkuc3Vic3RyaW5nKHBvcywgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICBpbnB1dC52YWx1ZSA9IGZyb250K3RleHQrYmFjaztcbiAgICBwb3MgPSBwb3MgKyB0ZXh0Lmxlbmd0aDtcbiAgICBpZiAoYnJvd3NlciA9PSBcImllXCIpIHtcbiAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCAoXCJjaGFyYWN0ZXJcIiwgLWlucHV0LnZhbHVlLmxlbmd0aCk7XG4gICAgICByYW5nZS5tb3ZlU3RhcnQgKFwiY2hhcmFjdGVyXCIsIHBvcyk7XG4gICAgICByYW5nZS5tb3ZlRW5kIChcImNoYXJhY3RlclwiLCAwKTtcbiAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChicm93c2VyID09IFwiZmZcIikge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBwb3M7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBwb3M7XG4gICAgICBpbnB1dC5mb2N1cygpO1xuICAgIH1cbiAgICBpbnB1dC5zY3JvbGxUb3AgPSBzY3JvbGxQb3M7XG4gICAgLy9jb25zb2xlLmxvZyhhbmd1bGFyLmVsZW1lbnQoaW5wdXQpLnZhbCgpKTtcbiAgICBhbmd1bGFyLmVsZW1lbnQoaW5wdXQpLnRyaWdnZXIoJ2lucHV0Jyk7XG4gIH1cblxuXG4gICRzY29wZS5zaG93SW1nID0gZnVuY3Rpb24oKSB7XG4gICB2YXIgaGlkZVNoZWV0ID0gJGlvbmljQWN0aW9uU2hlZXQuc2hvdyh7XG4gICAgIGJ1dHRvbnM6IFtcbiAgICAgICB7IHRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDQVBUVVJFX1BJQ1RVUkUnKSB9LFxuICAgICAgIHsgdGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFTEVDVF9QSUNUVVJFJykgfSxcbiAgICAgICB7IHRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRfQ1VTVE9NX1VSTCcpIH0sXG4gICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnR0FMTEVSWScpIH1cbiAgICAgXSxcbiAgICAgdGl0bGVUZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnSU5TRVJUX1BJQ1RVUkUnKSxcbiAgICAgY2FuY2VsVGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0NBTkNFTCcpLFxuICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBhZGQgY2FuY2VsIGNvZGUuLlxuICAgICAgfSxcbiAgICAgYnV0dG9uQ2xpY2tlZDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgJHNjb3BlLmluc2VydEltYWdlKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgIH1cbiAgIH0pO1xuICB9O1xuICAkc2NvcGUuaW5zZXJ0SW1hZ2UgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAgIGlmICh0eXBlID09IDAgfHwgdHlwZSA9PSAxKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBxdWFsaXR5OiA1MCxcbiAgICAgICAgZGVzdGluYXRpb25UeXBlOiBDYW1lcmEuRGVzdGluYXRpb25UeXBlLkZJTEVfVVJJLFxuICAgICAgICBzb3VyY2VUeXBlOiAodHlwZT09PTApP0NhbWVyYS5QaWN0dXJlU291cmNlVHlwZS5DQU1FUkE6Q2FtZXJhLlBpY3R1cmVTb3VyY2VUeXBlLlBIT1RPTElCUkFSWSxcbiAgICAgICAgYWxsb3dFZGl0OiAodHlwZT09PTApP3RydWU6ZmFsc2UsXG4gICAgICAgIGVuY29kaW5nVHlwZTogQ2FtZXJhLkVuY29kaW5nVHlwZS5KUEVHLFxuICAgICAgICBwb3BvdmVyT3B0aW9uczogQ2FtZXJhUG9wb3Zlck9wdGlvbnMsXG4gICAgICAgIHNhdmVUb1Bob3RvQWxidW06IGZhbHNlXG4gICAgICAgIC8vY29ycmVjdE9yaWVudGF0aW9uOnRydWVcbiAgICAgIH07XG4gICAgICAkY29yZG92YUNhbWVyYS5nZXRQaWN0dXJlKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgSW1hZ2VVcGxvYWRTZXJ2aWNlLnVwbG9hZEltYWdlKGltYWdlRGF0YSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIC8vdmFyIHVybCA9IHJlc3VsdC5zZWN1cmVfdXJsIHx8ICcnO1xuICAgICAgICAgICAgdmFyIHVybCA9IHJlc3VsdC5pbWFnZVVybCB8fCAnJztcbiAgICAgICAgICAgIHZhciBmaW5hbCA9IFwiICFbaW1hZ2VdKFwiICsgdXJsICsgXCIpXCI7XG4gICAgICAgICAgICAvKmlmICgkc2NvcGUuc3Bvc3QuYm9keSkge1xuICAgICAgICAgICAgICAkc2NvcGUuc3Bvc3QuYm9keSArPSBmaW5hbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRzY29wZS5zcG9zdC5ib2R5ID0gZmluYWw7XG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgICRzY29wZS5pbnNlcnRUZXh0KGZpbmFsKTtcbiAgICAgICAgICAgIGlmICghaW9uaWMuUGxhdGZvcm0uaXNBbmRyb2lkKCkgfHwgIWlvbmljLlBsYXRmb3JtLmlzV2luZG93c1Bob25lKCkpIHtcbiAgICAgICAgICAgICAgJGNvcmRvdmFDYW1lcmEuY2xlYW51cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1VQTE9BRF9FUlJPUicpKTtcbiAgICAgICAgICAgIGlmICghaW9uaWMuUGxhdGZvcm0uaXNBbmRyb2lkKCkgfHwgIWlvbmljLlBsYXRmb3JtLmlzV2luZG93c1Bob25lKCkpIHtcbiAgICAgICAgICAgICAgJGNvcmRvdmFDYW1lcmEuY2xlYW51cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAxMCk7XG4gICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDQU1FUkFfQ0FOQ0VMTEVEJykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IDIpe1xuICAgICAgJGlvbmljUG9wdXAucHJvbXB0KHtcbiAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRfVVJMJyksXG4gICAgICAgIHRlbXBsYXRlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRElSRUNUX0xJTktfUElDVFVSRScpLFxuICAgICAgICBpbnB1dFR5cGU6ICd0ZXh0JyxcbiAgICAgICAgaW5wdXRQbGFjZWhvbGRlcjogJ2h0dHA6Ly9leGFtcGxlLmNvbS9pbWFnZS5qcGcnXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91ciB1cmwgaXMnICsgcmVzKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHZhciB1cmwgPSByZXMudHJpbSgpO1xuICAgICAgICAgIHZhciBmaW5hbCA9IFwiICFbaW1hZ2VdKFwiICsgdXJsICsgXCIpXCI7XG4gICAgICAgICAgLyppZiAoJHNjb3BlLnNwb3N0LmJvZHkpIHtcbiAgICAgICAgICAgICRzY29wZS5zcG9zdC5ib2R5ICs9IGZpbmFsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2NvcGUuc3Bvc3QuYm9keSA9IGZpbmFsO1xuICAgICAgICAgIH0qL1xuICAgICAgICAgICRzY29wZS5pbnNlcnRUZXh0KGZpbmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzY29wZS5nYWxsZXJ5ID0gW107XG4gICAgICBBUElzLmZldGNoSW1hZ2VzKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICB2YXIgaW1ncyA9IHJlcy5kYXRhO1xuICAgICAgICBpZiAoaW1ncy5sZW5ndGg+MCl7XG4gICAgICAgICAgJHNjb3BlLnNob3dnYWxsZXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAkc2NvcGUuZ2FsbGVyeS5pbWFnZXMgPSBpbWdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRzY29wZS5zaG93Z2FsbGVyeSA9IGZhbHNlO1xuICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ05PX0lNQUdFJykpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdubyBpbWFnZXMgYXZhaWxhYmxlJylcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAkc2NvcGUuY2xvc2VHYWxsZXJ5ID0gZnVuY3Rpb24oKXtcbiAgICAkc2NvcGUuc2hvd2dhbGxlcnkgPSBmYWxzZTtcbiAgfVxuICAkc2NvcGUubWFuYWdlR2FsbGVyeSA9IGZ1bmN0aW9uKCl7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjbG9zZVBvc3RNb2RhbCcpO1xuICAgICRzdGF0ZS5nbygnYXBwLmltYWdlcycpO1xuICB9XG4gIGZ1bmN0aW9uIHNsdWcodGV4dCkge1xuICAgIHJldHVybiBnZXRTbHVnKHRleHQsIHt0cnVuY2F0ZTogMTI4fSk7XG4gIH07XG4gIGZ1bmN0aW9uIGNyZWF0ZVBlcm1saW5rKHRpdGxlKSB7XG4gICAgdmFyIHBlcm1saW5rO1xuICAgIHZhciB0ID0gbmV3IERhdGUoKTtcbiAgICB2YXIgdGltZWZvcm1hdCA9IHQuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpKyh0LmdldE1vbnRoKCkrMSkudG9TdHJpbmcoKSt0LmdldERhdGUoKS50b1N0cmluZygpK1widFwiK3QuZ2V0SG91cnMoKS50b1N0cmluZygpK3QuZ2V0TWludXRlcygpLnRvU3RyaW5nKCkrdC5nZXRTZWNvbmRzKCkudG9TdHJpbmcoKSt0LmdldE1pbGxpc2Vjb25kcygpLnRvU3RyaW5nKCkrXCJ6XCI7XG4gICAgaWYgKHRpdGxlICYmIHRpdGxlLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgIHZhciBzID0gc2x1Zyh0aXRsZSk7XG4gICAgICBwZXJtbGluayA9IHMudG9TdHJpbmcoKStcIi1cIit0aW1lZm9ybWF0O1xuICAgICAgaWYocGVybWxpbmsubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgIC8vIFNURUVNSVRfTUFYX1BFUk1MSU5LX0xFTkdUSFxuICAgICAgICBwZXJtbGluayA9IHBlcm1saW5rLnN1YnN0cmluZyhwZXJtbGluay5sZW5ndGggLSAyNTUsIHBlcm1saW5rLmxlbmd0aClcbiAgICAgIH1cbiAgICAgIC8vIG9ubHkgbGV0dGVycyBudW1iZXJzIGFuZCBkYXNoZXMgc2hhbGwgc3Vydml2ZVxuICAgICAgcGVybWxpbmsgPSBwZXJtbGluay50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teYS16MC05LV0rL2csICcnKVxuICAgICAgcmV0dXJuIHBlcm1saW5rO1xuICAgIH1cbiAgfTtcbiAgLy8kc2NvcGUub3BlcmF0aW9uX3R5cGUgPSAnZGVmYXVsdCc7XG4gICRzY29wZS5zcG9zdCA9IHt9O1xuICAkc2NvcGUudGFnc0NoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICRyb290U2NvcGUubG9nKFwidGFnc0NoYW5nZVwiKTtcbiAgICAkc2NvcGUuc3Bvc3QudGFncyA9ICRmaWx0ZXIoJ2xvd2VyY2FzZScpKCRzY29wZS5zcG9zdC50YWdzKTtcbiAgICAkc2NvcGUuc3Bvc3QuY2F0ZWdvcnkgPSAkc2NvcGUuc3Bvc3QudGFncz8kc2NvcGUuc3Bvc3QudGFncy5zcGxpdChcIiBcIik6W107XG4gICAgaWYgKCRzY29wZS5zcG9zdC5jYXRlZ29yeS5sZW5ndGggPiA1KSB7XG4gICAgICAkc2NvcGUuZGlzYWJsZUJ0biA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzY29wZS5kaXNhYmxlQnRuID0gZmFsc2U7XG4gICAgfVxuICB9XG4gICRzY29wZS5jb250ZW50Q2hhbmdlZCA9IGZ1bmN0aW9uIChlZGl0b3IsIGh0bWwsIHRleHQpIHtcbiAgICAvL2NvbnNvbGUubG9nKCRzY29wZS5zcG9zdC5ib2R5KTtcbiAgICAvL2NvbnNvbGUubG9nKCdlZGl0b3I6ICcsIGVkaXRvciwgJ2h0bWw6ICcsIGh0bWwsICd0ZXh0OicsIHRleHQpO1xuICB9O1xuXG4gICRzY29wZS5zdWJtaXRTdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vY29uc29sZS5sb2coJHNjb3BlLnNwb3N0LmJvZHkpO1xuICAgICRzY29wZS50YWdzQ2hhbmdlKCk7XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93WyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4rXCJKU1wiXS5Mb2dpbigpO1xuICAgICAgJHNjb3BlLm15bG9naW4uc2V0Um9sZXMoW1wicG9zdGluZ1wiXSk7XG4gICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlUG9zdGluZ0tleSB8fCBudWxsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3dbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIkpTXCJdLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICB2YXIgcGVybWxpbmsgPSBjcmVhdGVQZXJtbGluaygkc2NvcGUuc3Bvc3QudGl0bGUpO1xuICAgICAgICB2YXIganNvbiA9ICRmaWx0ZXIoXCJtZXRhZGF0YVwiKSgkc2NvcGUuc3Bvc3QuYm9keSk7XG4gICAgICAgIGFuZ3VsYXIubWVyZ2UoanNvbiwge3RhZ3M6ICRzY29wZS5zcG9zdC5jYXRlZ29yeSwgYXBwOiAnZXN0ZWVtLycrJHJvb3RTY29wZS4kc3RvcmFnZS5hcHB2ZXJzaW9uLCBmb3JtYXQ6ICdtYXJrZG93bitodG1sJyB9KTtcblxuICAgICAgICBpZiAoISRzY29wZS5zcG9zdC5vcGVyYXRpb25fdHlwZSkge1xuICAgICAgICAgICRzY29wZS5zcG9zdC5vcGVyYXRpb25fdHlwZSA9ICdkZWZhdWx0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoJHNjb3BlLnNwb3N0Lm9wZXJhdGlvbl90eXBlICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCdOT1QgRGVmYXVsdCcpO1xuICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImNvbW1lbnRcIiwge1xuICAgICAgICAgICAgcGFyZW50X2F1dGhvcjogXCJcIixcbiAgICAgICAgICAgIHBhcmVudF9wZXJtbGluazogJHNjb3BlLnNwb3N0LmNhdGVnb3J5WzBdLFxuICAgICAgICAgICAgYXV0aG9yOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICBwZXJtbGluazogcGVybWxpbmssXG4gICAgICAgICAgICB0aXRsZTogJHNjb3BlLnNwb3N0LnRpdGxlLFxuICAgICAgICAgICAgYm9keTogJHNjb3BlLnNwb3N0LmJvZHksXG4gICAgICAgICAgICBqc29uX21ldGFkYXRhOiBhbmd1bGFyLnRvSnNvbihqc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImNvbW1lbnRfb3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBhbGxvd19jdXJhdGlvbl9yZXdhcmRzOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dfdm90ZXM6IHRydWUsXG4gICAgICAgICAgICBhdXRob3I6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgIHBlcm1saW5rOiBwZXJtbGluayxcbiAgICAgICAgICAgIG1heF9hY2NlcHRlZF9wYXlvdXQ6ICRzY29wZS5zcG9zdC5vcGVyYXRpb25fdHlwZT09PSdzcCc/XCIxMDAwMDAwLjAwMCBcIiskcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZHVuaXQ6XCIwLjAwMCBcIiskcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZHVuaXQsXG4gICAgICAgICAgICBwZXJjZW50X3N0ZWVtX2RvbGxhcnM6ICRzY29wZS5zcG9zdC5vcGVyYXRpb25fdHlwZT09PSdzcCc/MDoxMDAwMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RlZmF1bHQnKTtcbiAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJjb21tZW50XCIsIHtcbiAgICAgICAgICAgIHBhcmVudF9hdXRob3I6IFwiXCIsXG4gICAgICAgICAgICBwYXJlbnRfcGVybWxpbms6ICRzY29wZS5zcG9zdC5jYXRlZ29yeVswXSxcbiAgICAgICAgICAgIGF1dGhvcjogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgcGVybWxpbms6IHBlcm1saW5rLFxuICAgICAgICAgICAgdGl0bGU6ICRzY29wZS5zcG9zdC50aXRsZSxcbiAgICAgICAgICAgIGJvZHk6ICRzY29wZS5zcG9zdC5ib2R5LFxuICAgICAgICAgICAganNvbl9tZXRhZGF0YTogYW5ndWxhci50b0pzb24oanNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24oJHNjb3BlLm15bG9naW4sIG51bGwsIHRydWUpO1xuICAgICAgICAkc2NvcGUucmVwbHlpbmcgPSBmYWxzZTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyRzY29wZS5jbG9zZVBvc3RNb2RhbCgpO1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjbG9zZVBvc3RNb2RhbCcpO1xuXG4gICAgICAgICAgICAvLyRzY29wZS5tZW51cG9wb3Zlci5oaWRlKCk7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2Nsb3NlOnBvcG92ZXInKTtcbiAgICAgICAgICAgICRzY29wZS5zcG9zdCA9IHt9O1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUE9TVF9TVUJNSVRURUQnKSk7XG4gICAgICAgICAgICAvLyRzY29wZS5jbG9zZU1lbnVQb3BvdmVyKCk7XG4gICAgICAgICAgICAkc3RhdGUuZ28oXCJhcHAucHJvZmlsZVwiLCB7dXNlcm5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMzAwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTCcpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9UT19YJykpO1xuICAgIH1cbiAgfVxuICAkc2NvcGUuc2F2ZVBvc3QgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLmxvZygkc2NvcGUubW9kYWxwKTtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnNwb3N0ID0gJHNjb3BlLnNwb3N0O1xuICAgIC8vYWRkZHJhZnRcbiAgICB2YXIgZHIgPSB7dGl0bGU6JHNjb3BlLnNwb3N0LnRpdGxlLCBib2R5OiAkc2NvcGUuc3Bvc3QuYm9keSwgdGFnczogJHNjb3BlLnNwb3N0LnRhZ3MsIHBvc3RfdHlwZTogJHNjb3BlLnNwb3N0Lm9wZXJhdGlvbl90eXBlfTtcbiAgICBBUElzLmFkZERyYWZ0KCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSwgZHIpLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgIGNvbnNvbGUubG9nKHJlcy5kYXRhKTtcbiAgICAgIC8vJHNjb3BlLmRyYWZ0cyA9IHJlcy5kYXRhO1xuICAgIH0pO1xuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2xvc2VQb3N0TW9kYWwnKTtcbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2Nsb3NlOnBvcG92ZXInKTtcbiAgICAkc2NvcGUubW9kYWxwLmhpZGUoKTtcbiAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTQVZFRCcpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUE9TVF9MQVRFUicpKTtcbiAgfVxuICAkc2NvcGUuY2xlYXJQb3N0ID0gZnVuY3Rpb24oKSB7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5zcG9zdCA9IHt9O1xuICAgICRzY29wZS5zcG9zdCA9IHt9O1xuICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0NMRUFSRUQnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1BPU1QnKSk7XG4gIH1cblxuXG4gICRyb290U2NvcGUuJG9uKCdmZXRjaFBvc3RzJywgZnVuY3Rpb24oKXtcbiAgICAkc2NvcGUuZmV0Y2hQb3N0cygpO1xuICB9KTtcblxuICAkcm9vdFNjb3BlLiRvbignZmV0Y2hDb250ZW50JywgZnVuY3Rpb24oZXZlbnQsIGFyZ3MpIHtcbiAgICB2YXIgcG9zdCA9IGFyZ3MuYW55O1xuICAgIC8vY29uc29sZS5sb2cocG9zdCk7XG4gICAgJHNjb3BlLmZldGNoQ29udGVudChwb3N0LmF1dGhvciwgcG9zdC5wZXJtbGluayk7XG4gIH0pO1xuXG4gICRzY29wZS52b3RlUG9zdCA9IGZ1bmN0aW9uKHBvc3QpIHtcbiAgICAkcm9vdFNjb3BlLnZvdGVQb3N0KHBvc3QsICd1cHZvdGUnLCAnZmV0Y2hDb250ZW50Jyk7XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuZG93bnZvdGVQb3N0ID0gZnVuY3Rpb24ocG9zdCkge1xuXG4gICAgdmFyIGNvbmZpcm1Qb3B1cCA9ICRpb25pY1BvcHVwLmNvbmZpcm0oe1xuICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBUkVfWU9VX1NVUkUnKSxcbiAgICAgIHRlbXBsYXRlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRkxBR0dJTkdfVEVYVCcpXG4gICAgfSk7XG4gICAgY29uZmlybVBvcHVwLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICBpZihyZXMpIHtcbiAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgc3VyZScpO1xuICAgICAgICAkcm9vdFNjb3BlLnZvdGVQb3N0KHBvc3QsICdkb3dudm90ZScsICdmZXRjaENvbnRlbnQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIG5vdCBzdXJlJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfTtcblxuICAkc2NvcGUudW52b3RlUG9zdCA9IGZ1bmN0aW9uKHBvc3QpIHtcbiAgICAkcm9vdFNjb3BlLnZvdGVQb3N0KHBvc3QsICd1bnZvdGUnLCAnZmV0Y2hDb250ZW50Jyk7XG4gIH07XG5cblxuICAkcm9vdFNjb3BlLiRvbihcInVzZXI6bG9nb3V0XCIsIGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLmZldGNoUG9zdHMoKTtcbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgfSk7XG5cbiAgJHNjb3BlLmxvYWRNb3JlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8kcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgICRzY29wZS5saW1pdCArPSA1O1xuICAgIC8vaWYgKCEkc2NvcGUuZXJyb3IpIHtcbiAgICAkc2NvcGUuZmV0Y2hQb3N0cyhudWxsLCAkc2NvcGUubGltaXQsIG51bGwpO1xuICAgIC8vfVxuICB9O1xuICAkc2NvcGUucmVmcmVzaCA9IGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLmxpbWl0ID0gMTA7XG4gICAgLy9pZiAoISRzY29wZS5lcnJvcikge1xuICAgICRzY29wZS5mZXRjaFBvc3RzKG51bGwsICRzY29wZS5saW1pdCwgbnVsbCk7XG4gICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5yZWZyZXNoQ29tcGxldGUnKTtcbiAgfVxuXG4gICRzY29wZS4kb24oJyRzdGF0ZUNoYW5nZVN1Y2Nlc3MnLCBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUubG9hZE1vcmUoKTtcbiAgfSk7XG5cbiAgJHNjb3BlLm1vcmVEYXRhQ2FuQmVMb2FkZWQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiAhJHNjb3BlLmVycm9yO1xuICB9XG5cbiAgJHJvb3RTY29wZS4kb24oJ2NoYW5nZVZpZXcnLCBmdW5jdGlvbigpe1xuICAgIC8vJHNjb3BlLm1lbnVwb3BvdmVyLmhpZGUoKTtcbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2Nsb3NlOnBvcG92ZXInKTtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudmlldyA9PT0gJ2NhcmQnKSB7XG4gICAgICBhbmd1bGFyLmZvckVhY2goJHNjb3BlLmRhdGEsIGZ1bmN0aW9uKHYsayl7XG4gICAgICAgIHYuanNvbl9tZXRhZGF0YSA9IGFuZ3VsYXIuZnJvbUpzb24odi5qc29uX21ldGFkYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gYXJyYXlPYmplY3RJbmRleE9mKG15QXJyYXksIHNlYXJjaFRlcm0sIHByb3BlcnR5KSB7XG4gICAgdmFyIGxsZW4gPSBteUFycmF5Lmxlbmd0aDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChteUFycmF5W2ldW3Byb3BlcnR5XSA9PT0gc2VhcmNoVGVybSkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICAkc2NvcGUuZGF0YSA9IFtdO1xuICAkc2NvcGUudGVtcERhdGEgPSBbXTtcblxuICAkc2NvcGUuZGF0YUNoYW5nZWQgPSBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgdmFyIGxlbm4gPSBuZXdWYWx1ZS5sZW5ndGg7XG4gICAgICB2YXIgdXNlciA9ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlciB8fCBudWxsO1xuICAgICAgdmFyIHZpZXcgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnZpZXc7XG5cbiAgICAgIGlmICh1c2VyKXtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5uOyBpKyspIHtcbiAgICAgICAgICBpZiAobmV3VmFsdWVbaV0gJiYgbmV3VmFsdWVbaV0uYWN0aXZlX3ZvdGVzKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gbmV3VmFsdWVbaV0uYWN0aXZlX3ZvdGVzLmxlbmd0aC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlW2ldLmFjdGl2ZV92b3Rlc1tqXS52b3RlciA9PT0gdXNlci51c2VybmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZVtpXS5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlW2ldLnVwdm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3VmFsdWVbaV0uYWN0aXZlX3ZvdGVzW2pdLnBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBuZXdWYWx1ZVtpXS5kb3dudm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBuZXdWYWx1ZVtpXS5kb3dudm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlW2ldLnVwdm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZpZXcgPT09ICdjYXJkJykge1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlW2ldLmpzb25fbWV0YWRhdGEpe1xuICAgICAgICAgICAgICBuZXdWYWx1ZVtpXS5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbihuZXdWYWx1ZVtpXS5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2aWV3ID09PSAnY2FyZCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbm47IGkrKykge1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlW2ldLmpzb25fbWV0YWRhdGEpe1xuICAgICAgICAgICAgICBuZXdWYWx1ZVtpXS5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbihuZXdWYWx1ZVtpXS5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cblxuICAkc2NvcGUuZmV0Y2hDb250ZW50ID0gZnVuY3Rpb24oYXV0aG9yLCBwZXJtbGluaykge1xuICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2NvbnRlbnRcIiwgW2F1dGhvciwgcGVybWxpbmtdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAgIHZhciBsZW4gPSByZXN1bHQuYWN0aXZlX3ZvdGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHVzZXIgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXI7XG4gICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IGxlbiAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmFjdGl2ZV92b3Rlc1tqXS52b3RlciA9PT0gdXNlci51c2VybmFtZSkge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0LmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC51cHZvdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuYWN0aXZlX3ZvdGVzW2pdLnBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRvd252b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRvd252b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC51cHZvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lmpzb25fbWV0YWRhdGEgPSBhbmd1bGFyLmZyb21Kc29uKHJlc3VsdC5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzY29wZS5kYXRhLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgaWYgKHZhbHVlLnBlcm1saW5rID09PSByZXN1bHQucGVybWxpbmspIHtcbiAgICAgICAgICAgICRzY29wZS5kYXRhW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgJHNjb3BlLmlmRXhpc3RzID0gZnVuY3Rpb24oeHgpe1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHNjb3BlLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgkc2NvcGUuZGF0YVtpXS5wZXJtbGluayA9PT0geHgpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gICRzY29wZS5mZXRjaFBvc3RzID0gZnVuY3Rpb24odHlwZSwgbGltaXQsIHRhZykge1xuICAgIHR5cGUgPSB0eXBlIHx8ICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyIHx8IFwidHJlbmRpbmdcIjtcbiAgICB0YWcgPSB0YWcgfHwgJHJvb3RTY29wZS4kc3RvcmFnZS50YWcgfHwgXCJcIjtcbiAgICBsaW1pdCA9IDEwOy8vbGltaXQgfHwgJHNjb3BlLmxpbWl0IHx8IDEwO1xuXG4gICAgdmFyIHBhcmFtcyA9IHt9O1xuXG4gICAgaWYgKHR5cGUgPT09IFwiZmVlZFwiICYmICRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgcGFyYW1zID0ge3RhZzogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCBsaW1pdDogbGltaXQsIGZpbHRlcl90YWdzOiBbXX07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gXCJmZWVkXCIpIHtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSBcInRyZW5kaW5nXCI7XG4gICAgICAgIHR5cGUgPSBcInRyZW5kaW5nXCI7XG4gICAgICB9XG4gICAgICBwYXJhbXMgPSB7dGFnOiB0YWcsIGxpbWl0OiBsaW1pdCwgZmlsdGVyX3RhZ3M6IFtdfTtcbiAgICB9XG4gICAgaWYgKCRzY29wZS5kYXRhICYmICRzY29wZS5kYXRhLmxlbmd0aD4wKSB7XG4gICAgICBwYXJhbXMuc3RhcnRfYXV0aG9yID0gJHNjb3BlLmRhdGFbJHNjb3BlLmRhdGEubGVuZ3RoLTFdLmF1dGhvcjtcbiAgICAgIHBhcmFtcy5zdGFydF9wZXJtbGluayA9ICRzY29wZS5kYXRhWyRzY29wZS5kYXRhLmxlbmd0aC0xXS5wZXJtbGluaztcbiAgICB9XG4gICAgaWYgKCRzY29wZS5lcnJvcikge1xuICAgICAgLy8kcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1JFUVVFU1RfTElNSVRfVEVYVCcpKTtcbiAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwuaW5maW5pdGVTY3JvbGxDb21wbGV0ZScpO1xuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICRyb290U2NvcGUubG9nKFwiZmV0Y2hpbmcuLi5cIit0eXBlK1wiIFwiK2xpbWl0K1wiIFwiK3RhZyk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LkFwaS5kYXRhYmFzZV9hcGkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIC8qd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X3N0YXRlXCIsIFtcIi9cIit0eXBlXSkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAgfSk7Ki9cbiAgICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfZGlzY3Vzc2lvbnNfYnlfXCIrdHlwZSwgW3BhcmFtc10pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICRzY29wZS5lcnJvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNwb25zZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlW2ldLmpzb25fbWV0YWRhdGEgPSByZXNwb25zZVtpXS5qc29uX21ldGFkYXRhP2FuZ3VsYXIuZnJvbUpzb24ocmVzcG9uc2VbaV0uanNvbl9tZXRhZGF0YSk6cmVzcG9uc2VbaV0uanNvbl9tZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgcGVybWxpbmsgPSByZXNwb25zZVtpXS5wZXJtbGluaztcbiAgICAgICAgICAgICAgICBpZiAoISRzY29wZS5pZkV4aXN0cyhwZXJtbGluaykpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB1c2VyID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2V4aXN0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVtpXSAmJiByZXNwb25zZVtpXS5hY3RpdmVfdm90ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcmVzcG9uc2VbaV0uYWN0aXZlX3ZvdGVzLmxlbmd0aC0xO1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVtpXS5hY3RpdmVfdm90ZXNbal0udm90ZXIgPT09IHVzZXIudXNlcm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlW2ldLmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlW2ldLnVwdm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlW2ldLmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlW2ldLmRvd252b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VbaV0uZG93bnZvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VbaV0udXB2b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5wdXNoKHJlc3BvbnNlW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCRzY29wZS5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLmluZmluaXRlU2Nyb2xsQ29tcGxldGUnKTtcbiAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmxvYWRlZCcsIGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLmxpbWl0ID0gMTA7XG4gICAgLy8kcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZVtcInNvY2tldFwiKyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW5dKSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlW1wic29ja2V0XCIrJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbl0gPSBsb2NhbFN0b3JhZ2Uuc29ja2V0VXJsO1xuICAgIH1cbiAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2Uudmlldykge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS52aWV3ID0gJ2NhcmQnO1xuICAgIH1cbiAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyKSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9IFwidHJlbmRpbmdcIjtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5BcGkpIHtcbiAgICAgIC8qaWYgKCFhbmd1bGFyLmlzRGVmaW5lZCgkcm9vdFNjb3BlLnRpbWVpbnQpKSB7XG4gICAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICRyb290U2NvcGUubG9nKFwiQXBpIHJlYWR5OlwiICsgYW5ndWxhci50b0pzb24ocmVzcG9uc2UpKTtcbiAgICAgICAgICAkcm9vdFNjb3BlLnRpbWVpbnQgPSAkaW50ZXJ2YWwoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9keW5hbWljX2dsb2JhbF9wcm9wZXJ0aWVzXCIsIFtdKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJnZXRfZHluYW1pY19nbG9iYWxfcHJvcGVydGllcyBcIisgcmVzcG9uc2UuaGVhZF9ibG9ja19udW1iZXIpO1xuICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93WyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4rXCJKU1wiXS5Mb2dpbigpO1xuICAgICAgICAgICAgICAgICRzY29wZS5teWxvZ2luLnNldFJvbGVzKFtcInBvc3RpbmdcIl0pO1xuICAgICAgICAgICAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSAkc2NvcGUubXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVQb3N0aW5nS2V5IHx8IG51bGxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKFwibG9naW4gXCIrbG9naW5TdWNjZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgMTUwMDApO1xuICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmV0Y2hQb3N0cycpO1xuICAgICAgICB9KTtcbiAgICAgIH0qL1xuICAgIH1cblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAkaW9uaWNTY3JvbGxEZWxlZ2F0ZS4kZ2V0QnlIYW5kbGUoJ21haW5TY3JvbGwnKS5zY3JvbGxUb3AoKTtcbiAgICB9LCAxMCk7XG4gIH0pO1xuXG4gICRzY29wZS4kb24oJyRpb25pY1ZpZXcuYmVmb3JlRW50ZXInLCBmdW5jdGlvbigpe1xuICAgIGlmICgkc3RhdGVQYXJhbXMudGFncykge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS50YWcgPSAkc3RhdGVQYXJhbXMudGFncztcbiAgICB9XG4gICAgaWYgKCFhbmd1bGFyLmlzRGVmaW5lZCgkcm9vdFNjb3BlLiRzdG9yYWdlLmxhbmd1YWdlKSkge1xuICAgICAgaWYodHlwZW9mIG5hdmlnYXRvci5nbG9iYWxpemF0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgbmF2aWdhdG9yLmdsb2JhbGl6YXRpb24uZ2V0UHJlZmVycmVkTGFuZ3VhZ2UoZnVuY3Rpb24obGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgJHRyYW5zbGF0ZS51c2UoKGxhbmd1YWdlLnZhbHVlKS5zcGxpdChcIi1cIilbMF0pLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTVUNDRVNTIC0+IFwiICsgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmxhbmd1YWdlID0gbGFuZ3VhZ2UudmFsdWUuc3BsaXQoJy0nKVswXTtcbiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1IgLT4gXCIgKyBlcnJvcik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5sYW5ndWFnZSA9ICdlbic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICR0cmFuc2xhdGUudXNlKCRyb290U2NvcGUuJHN0b3JhZ2UubGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgICRzY29wZS5hY3RpdmVNZW51ID0gJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgfHwgXCJ0cmVuZGluZ1wiO1xuICAgICRzY29wZS5teW1lbnUgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgPyBbe3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdGRUVEJyksIGN1c3RvbTonZmVlZCd9LCB7dGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1RSRU5ESU5HJyksIGN1c3RvbTondHJlbmRpbmcnfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdIT1QnKSwgY3VzdG9tOidob3QnfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdORVcnKSwgY3VzdG9tOidjcmVhdGVkJ30sIHt0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQUNUSVZFJyksIGN1c3RvbTonYWN0aXZlJ30sIHt0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUFJPTU9URUQnKSwgY3VzdG9tOiAncHJvbW90ZWQnfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdUUkVORElOR18zMCcpLCBjdXN0b206J3RyZW5kaW5nMzAnfSwge3RleHQ6JGZpbHRlcigndHJhbnNsYXRlJykoJ1ZPVEVTJyksIGN1c3RvbTondm90ZXMnfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDT01NRU5UUycpLCBjdXN0b206J2NoaWxkcmVuJ30sIHt0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUEFZT1VUJyksIGN1c3RvbTogJ2Nhc2hvdXQnfV0gOiBbIHt0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVFJFTkRJTkcnKSwgY3VzdG9tOid0cmVuZGluZyd9LCB7dGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0hPVCcpLCBjdXN0b206J2hvdCd9LCB7dGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ05FVycpLCBjdXN0b206J2NyZWF0ZWQnfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBQ1RJVkUnKSwgY3VzdG9tOidhY3RpdmUnfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQUk9NT1RFRCcpLCBjdXN0b206ICdwcm9tb3RlZCd9LCB7dGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1RSRU5ESU5HXzMwJyksIGN1c3RvbTondHJlbmRpbmczMCd9LCB7dGV4dDokZmlsdGVyKCd0cmFuc2xhdGUnKSgnVk9URVMnKSwgY3VzdG9tOid2b3Rlcyd9LCB7dGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0NPTU1FTlRTJyksIGN1c3RvbTonY2hpbGRyZW4nfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQQVlPVVQnKSwgY3VzdG9tOiAnY2FzaG91dCd9XTtcblxuICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUubXltZW51LCBmdW5jdGlvbih2LGspe1xuICAgICAgaWYgKHYuY3VzdG9tID09PSAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlcikge1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlck5hbWUgPSB2LnRleHQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfSk7XG5cbn0pXG5cbmFwcC5jb250cm9sbGVyKCdQb3N0Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkcm9vdFNjb3BlLCAkaW50ZXJ2YWwsICRpb25pY1Njcm9sbERlbGVnYXRlLCAkaW9uaWNNb2RhbCwgJGZpbHRlciwgJGlvbmljQWN0aW9uU2hlZXQsICRjb3Jkb3ZhQ2FtZXJhLCAkaW9uaWNQb3B1cCwgSW1hZ2VVcGxvYWRTZXJ2aWNlLCAkaW9uaWNQbGF0Zm9ybSwgJGlvbmljU2xpZGVCb3hEZWxlZ2F0ZSwgJGlvbmljUG9wb3ZlciwgJGZpbHRlciwgJHN0YXRlLCBBUElzKSB7XG4gICRzY29wZS5wb3N0ID0gJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbTtcbiAgJHNjb3BlLmRhdGEgPSB7fTtcbiAgJHNjb3BlLnNwb3N0ID0ge307XG4gICRzY29wZS5yZXBseWluZyA9IGZhbHNlO1xuXG4gIHZhciBmb3JtYXRUb1BlcmNlbnRhZ2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAnJSc7XG4gIH07XG5cbiAgJHNjb3BlLnBzbGlkZXIgPSB7XG4gICAgdmFsdWU6ICRyb290U2NvcGUuJHN0b3JhZ2Uudm90ZVdlaWdodC8xMDAsXG4gICAgb3B0aW9uczoge1xuICAgICAgZmxvb3I6IDEsXG4gICAgICBjZWlsOiAxMDAsXG4gICAgICB0cmFuc2xhdGU6IGZvcm1hdFRvUGVyY2VudGFnZSxcbiAgICAgIHNob3dTZWxlY3Rpb25CYXI6IHRydWVcbiAgICB9XG4gIH07XG5cbiAgJGlvbmljUG9wb3Zlci5mcm9tVGVtcGxhdGVVcmwoJ3BvcG92ZXJTbGlkZXJyLmh0bWwnLCB7XG4gICAgICBzY29wZTogJHNjb3BlXG4gIH0pLnRoZW4oZnVuY3Rpb24ocG9wb3Zlcikge1xuICAgICAgJHNjb3BlLnRvb2x0aXBTbGlkZXJyID0gcG9wb3ZlcjtcbiAgfSk7XG4gIFxuICAkc2NvcGUub3BlblNsaWRlcnIgPSBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAkc2NvcGUucHNsaWRlciA9IHtcbiAgICAgIHZhbHVlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQvMTAwLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBmbG9vcjogMSxcbiAgICAgICAgY2VpbDogMTAwLFxuICAgICAgICB0cmFuc2xhdGU6IGZvcm1hdFRvUGVyY2VudGFnZSxcbiAgICAgICAgc2hvd1NlbGVjdGlvbkJhcjogdHJ1ZVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgICAkc2NvcGUudG9vbHRpcFNsaWRlcnIuc2hvdygkZXZlbnQpO1xuICB9O1xuXG4gICRzY29wZS5jbG9zZVNsaWRlcnIgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUudG9vbHRpcFNsaWRlcnIuaGlkZSgpO1xuICB9O1xuXG4gICRzY29wZS4kd2F0Y2goJ3BzbGlkZXInLCBmdW5jdGlvbihuZXdWYWx1ZSwgb2xkVmFsdWUpe1xuICAgIC8vY29uc29sZS5sb2cobmV3VmFsdWUudmFsdWUpO1xuICAgIGlmIChuZXdWYWx1ZS52YWx1ZSkge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS52b3RlV2VpZ2h0ID0gbmV3VmFsdWUudmFsdWUqMTAwO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG5cblxuICAkc2NvcGUuaXNCb29rbWFya2VkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJvb2ttID0gJHJvb3RTY29wZS4kc3RvcmFnZS5ib29rbWFyayB8fCB1bmRlZmluZWQ7XG4gICAgaWYgKGJvb2ttKSB7XG4gICAgICB2YXIgbGVuID0gYm9va20ubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoYm9va21baV0gJiYgYm9va21baV0ucGVybWxpbmsgPT09ICRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0ucGVybWxpbmspIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuICAkc2NvcGUub3B0aW9ucyA9IHtcbiAgICBsb29wOiBmYWxzZSxcbiAgICBzcGVlZDogNTAwLFxuICAgIC8qcGFnaW5hdGlvbjogZmFsc2UsKi9cbiAgICBzaG93UGFnZXI6IGZhbHNlLFxuICAgIHNsaWRlc1BlclZpZXc6IDMsXG4gICAgc3BhY2VCZXR3ZWVuOiAyMCxcbiAgICBicmVha3BvaW50czoge1xuICAgICAgMTAyNDoge1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDUsXG4gICAgICAgICAgc3BhY2VCZXR3ZWVuOiAxNVxuICAgICAgfSxcbiAgICAgIDc2ODoge1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDQsXG4gICAgICAgICAgc3BhY2VCZXR3ZWVuOiAxMFxuICAgICAgfSxcbiAgICAgIDY0MDoge1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDMsXG4gICAgICAgICAgc3BhY2VCZXR3ZWVuOiA1XG4gICAgICB9LFxuICAgICAgMzIwOiB7XG4gICAgICAgICAgc2xpZGVzUGVyVmlldzogMyxcbiAgICAgICAgICBzcGFjZUJldHdlZW46IDNcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgJHNjb3BlLmJvb2ttYXJrID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJvb2sgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLmJvb2ttYXJrO1xuICAgIGlmICgkc2NvcGUuaXNCb29rbWFya2VkKCkpIHtcbiAgICAgIHZhciBsZW4gPSBib29rLmxlbmd0aDtcbiAgICAgIHZhciBpZCA9IHVuZGVmaW5lZDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGJvb2tbaV0ucGVybWxpbmsgPT09ICRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0ucGVybWxpbmspIHtcbiAgICAgICAgICBpZCA9IGJvb2tbaV0uX2lkO1xuICAgICAgICAgIGJvb2suc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaWQpe1xuICAgICAgICBBUElzLnJlbW92ZUJvb2ttYXJrKGlkLCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuYm9va21hcmsgPSBib29rO1xuICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1BPU1RfSVNfVU5CT09LTUFSSycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChib29rKSB7XG4gICAgICAgIHZhciBvbyA9IHsgYXV0aG9yOiRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yLHBlcm1saW5rOiRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0ucGVybWxpbmt9O1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmJvb2ttYXJrLnB1c2gob28pO1xuICAgICAgICBBUElzLmFkZEJvb2ttYXJrKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSwgb28gKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUE9TVF9JU19CT09LTUFSSycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb28gPSB7IGF1dGhvcjokcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLmF1dGhvcixwZXJtbGluazokcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLnBlcm1saW5rfTtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5ib29rbWFyayA9IFtvb107XG5cbiAgICAgICAgQVBJcy5hZGRCb29rbWFyaygkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsIG9vICkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1BPU1RfSVNfQk9PS01BUksnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8kcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQT1NUX0lTX0JPT0tNQVJLJykpO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUubGFzdEZvY3VzZWQ7XG5cblxuICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA2NDA4OS9pbnNlcnRpbmctYS10ZXh0LXdoZXJlLWN1cnNvci1pcy11c2luZy1qYXZhc2NyaXB0LWpxdWVyeVxuICAkc2NvcGUuaW5zZXJ0VGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgaW5wdXQgPSAkc2NvcGUubGFzdEZvY3VzZWQ7XG4gICAgLy9jb25zb2xlLmxvZyhpbnB1dCk7XG4gICAgaWYgKGlucHV0ID09IHVuZGVmaW5lZCkgeyByZXR1cm47IH1cbiAgICB2YXIgc2Nyb2xsUG9zID0gaW5wdXQuc2Nyb2xsVG9wO1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciBicm93c2VyID0gKChpbnB1dC5zZWxlY3Rpb25TdGFydCB8fCBpbnB1dC5zZWxlY3Rpb25TdGFydCA9PSBcIjBcIikgP1xuICAgICAgICAgICAgICAgICAgIFwiZmZcIiA6IChkb2N1bWVudC5zZWxlY3Rpb24gPyBcImllXCIgOiBmYWxzZSApICk7XG4gICAgaWYgKGJyb3dzZXIgPT0gXCJpZVwiKSB7XG4gICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICByYW5nZS5tb3ZlU3RhcnQgKFwiY2hhcmFjdGVyXCIsIC1pbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgICAgcG9zID0gcmFuZ2UudGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJyb3dzZXIgPT0gXCJmZlwiKSB7IHBvcyA9IGlucHV0LnNlbGVjdGlvblN0YXJ0IH07XG5cbiAgICB2YXIgZnJvbnQgPSAoaW5wdXQudmFsdWUpLnN1YnN0cmluZygwLCBwb3MpO1xuICAgIHZhciBiYWNrID0gKGlucHV0LnZhbHVlKS5zdWJzdHJpbmcocG9zLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgIGlucHV0LnZhbHVlID0gZnJvbnQrdGV4dCtiYWNrO1xuICAgIHBvcyA9IHBvcyArIHRleHQubGVuZ3RoO1xuICAgIGlmIChicm93c2VyID09IFwiaWVcIikge1xuICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgcmFuZ2UubW92ZVN0YXJ0IChcImNoYXJhY3RlclwiLCAtaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCAoXCJjaGFyYWN0ZXJcIiwgcG9zKTtcbiAgICAgIHJhbmdlLm1vdmVFbmQgKFwiY2hhcmFjdGVyXCIsIDApO1xuICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJyb3dzZXIgPT0gXCJmZlwiKSB7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHBvcztcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IHBvcztcbiAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgfVxuICAgIGlucHV0LnNjcm9sbFRvcCA9IHNjcm9sbFBvcztcbiAgICBjb25zb2xlLmxvZyhhbmd1bGFyLmVsZW1lbnQoaW5wdXQpLnZhbCgpKTtcbiAgICBhbmd1bGFyLmVsZW1lbnQoaW5wdXQpLnRyaWdnZXIoJ2lucHV0Jyk7XG4gIH1cblxuICAkaW9uaWNQb3BvdmVyLmZyb21UZW1wbGF0ZVVybCgncG9wb3ZlclRyLmh0bWwnLCB7XG4gICAgICBzY29wZTogJHNjb3BlXG4gICB9KS50aGVuKGZ1bmN0aW9uKHBvcG92ZXIpIHtcbiAgICAgICRzY29wZS50b29sdGlwID0gcG9wb3ZlcjtcbiAgIH0pO1xuXG4gICAkc2NvcGUub3BlblRvb2x0aXAgPSBmdW5jdGlvbigkZXZlbnQsIGQpIHtcbiAgICB2YXIgdHBwdiA9IE51bWJlcihkLnRvdGFsX3BlbmRpbmdfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgIHZhciBwID0gTnVtYmVyKGQucHJvbW90ZWQuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgdmFyIHRwdiA9IE51bWJlcihkLnRvdGFsX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICB2YXIgYXIgPSBOdW1iZXIoZC50b3RhbF9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXS1kLmN1cmF0b3JfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgIHZhciBjcnAgPSBOdW1iZXIoZC5jdXJhdG9yX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICB2YXIgdGV4dGggPSBcIjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUEFZT1VUX0NZQ0xFJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIitkLm1vZGUucmVwbGFjZSgnXycsJyAnKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUE9URU5USUFMX1BBWU9VVCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcignZ2V0Q3VycmVuY3lTeW1ib2wnKSgkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5KSskZmlsdGVyKCdudW1iZXInKSh0cHB2LCAzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUFJPTU9URUQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykocCwzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUEFTVF9QQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykodHB2LDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBVVRIT1JfUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCdnZXRDdXJyZW5jeVN5bWJvbCcpKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kpKyRmaWx0ZXIoJ251bWJlcicpKGFyLDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDVVJBVElPTl9QQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykoY3JwLDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ3RpbWVhZ28nKShkLmNhc2hvdXRfdGltZSwgdHJ1ZSkrXCI8L2Rpdj48L2Rpdj5cIjtcbiAgICAkc2NvcGUudG9vbHRpcFRleHQgPSB0ZXh0aDtcbiAgICAkc2NvcGUudG9vbHRpcC5zaG93KCRldmVudCk7XG4gICB9O1xuXG4gICAkc2NvcGUuY2xvc2VUb29sdGlwID0gZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUudG9vbHRpcC5oaWRlKCk7XG4gICB9O1xuXG4gICAvL0NsZWFudXAgdGhlIHBvcG92ZXIgd2hlbiB3ZSdyZSBkb25lIHdpdGggaXQhXG4gICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLnRvb2x0aXAucmVtb3ZlKCk7XG4gICB9KTtcblxuICAgLy8gRXhlY3V0ZSBhY3Rpb24gb24gaGlkZSBwb3BvdmVyXG4gICAkc2NvcGUuJG9uKCdwb3BvdmVyLmhpZGRlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRXhlY3V0ZSBhY3Rpb25cbiAgIH0pO1xuXG4gICAvLyBFeGVjdXRlIGFjdGlvbiBvbiByZW1vdmUgcG9wb3ZlclxuICAgJHNjb3BlLiRvbigncG9wb3Zlci5yZW1vdmVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAvLyBFeGVjdXRlIGFjdGlvblxuICAgfSk7XG5cblxuICAkc2NvcGUuaXNJbWFnZXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbSkge1xuICAgICAgdmFyIGxlbiA9ICRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0uanNvbl9tZXRhZGF0YS5pbWFnZT8kcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLmpzb25fbWV0YWRhdGEuaW1hZ2UubGVuZ3RoOjA7XG4gICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAkc2NvcGUuaW1hZ2VzID0gJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbS5qc29uX21ldGFkYXRhLmltYWdlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgJHNjb3BlLnpvb21NaW4gPSAxO1xuICAkc2NvcGUuc2hvd0ltYWdlcyA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgJHNjb3BlLmFjdGl2ZVNsaWRlID0gaW5kZXg7XG4gICAgJHJvb3RTY29wZS5sb2coYW5ndWxhci50b0pzb24oJHNjb3BlLmltYWdlc1tpbmRleF0pKTtcbiAgICAkc2NvcGUuc2hvd0dhbGxlcnlNb2RhbCgndGVtcGxhdGVzL2dhbGxlcnlfaW1hZ2VzLmh0bWwnKTtcbiAgfTtcblxuICAkc2NvcGUuc2hvd0dhbGxlcnlNb2RhbCA9IGZ1bmN0aW9uKHRlbXBsYXRlVXJsKSB7XG4gICAgJGlvbmljTW9kYWwuZnJvbVRlbXBsYXRlVXJsKHRlbXBsYXRlVXJsLCB7XG4gICAgICBzY29wZTogJHNjb3BlXG4gICAgfSkudGhlbihmdW5jdGlvbihtb2RhbCkge1xuICAgICAgJHNjb3BlLm1vZGFsZyA9IG1vZGFsO1xuICAgICAgJHNjb3BlLm1vZGFsZy5zaG93KCk7XG4gICAgfSk7XG4gIH1cblxuICAkc2NvcGUuY2xvc2VHYWxsZXJ5TW9kYWwgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUubW9kYWxnLmhpZGUoKTtcbiAgICAkc2NvcGUubW9kYWxnLnJlbW92ZSgpXG4gIH07XG5cbiAgJHNjb3BlLnVwZGF0ZVNsaWRlU3RhdHVzID0gZnVuY3Rpb24oc2xpZGUpIHtcbiAgICB2YXIgem9vbUZhY3RvciA9ICRpb25pY1Njcm9sbERlbGVnYXRlLiRnZXRCeUhhbmRsZSgnc2Nyb2xsSGFuZGxlJyArIHNsaWRlKS5nZXRTY3JvbGxQb3NpdGlvbigpLnpvb207XG4gICAgaWYgKHpvb21GYWN0b3IgPT0gJHNjb3BlLnpvb21NaW4pIHtcbiAgICAgICRpb25pY1NsaWRlQm94RGVsZWdhdGUuZW5hYmxlU2xpZGUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRpb25pY1NsaWRlQm94RGVsZWdhdGUuZW5hYmxlU2xpZGUoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuc2hvd0ltZyA9IGZ1bmN0aW9uKCkge1xuICAgdmFyIGhpZGVTaGVldCA9ICRpb25pY0FjdGlvblNoZWV0LnNob3coe1xuICAgICBidXR0b25zOiBbXG4gICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FQVFVSRV9QSUNUVVJFJykgfSxcbiAgICAgICB7IHRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRUxFQ1RfUElDVFVSRScpIH0sXG4gICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VUX0NVU1RPTV9VUkwnKSB9LFxuICAgICAgIHsgdGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0dBTExFUlknKSB9XG4gICAgIF0sXG4gICAgIHRpdGxlVGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0lOU0VSVF9QSUNUVVJFJyksXG4gICAgIGNhbmNlbFRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDQU5DRUwnKSxcbiAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYWRkIGNhbmNlbCBjb2RlLi5cbiAgICAgIH0sXG4gICAgIGJ1dHRvbkNsaWNrZWQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICRzY29wZS5pbnNlcnRJbWFnZShpbmRleCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICB9XG4gICB9KTtcbiAgfTtcbiAgJHNjb3BlLmluc2VydEltYWdlID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgaWYgKCRzY29wZS5lZGl0KSB7XG4gICAgICBpZiAodHlwZSA9PSAwIHx8IHR5cGUgPT0gMSkge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIHF1YWxpdHk6IDUwLFxuICAgICAgICAgIGRlc3RpbmF0aW9uVHlwZTogQ2FtZXJhLkRlc3RpbmF0aW9uVHlwZS5GSUxFX1VSSSxcbiAgICAgICAgICBzb3VyY2VUeXBlOiAodHlwZT09PTApP0NhbWVyYS5QaWN0dXJlU291cmNlVHlwZS5DQU1FUkE6Q2FtZXJhLlBpY3R1cmVTb3VyY2VUeXBlLlBIT1RPTElCUkFSWSxcbiAgICAgICAgICBhbGxvd0VkaXQ6ICh0eXBlPT09MCk/dHJ1ZTpmYWxzZSxcbiAgICAgICAgICBlbmNvZGluZ1R5cGU6IENhbWVyYS5FbmNvZGluZ1R5cGUuSlBFRyxcbiAgICAgICAgICBwb3BvdmVyT3B0aW9uczogQ2FtZXJhUG9wb3Zlck9wdGlvbnMsXG4gICAgICAgICAgc2F2ZVRvUGhvdG9BbGJ1bTogZmFsc2VcbiAgICAgICAgICAvL2NvcnJlY3RPcmllbnRhdGlvbjp0cnVlXG4gICAgICAgIH07XG4gICAgICAgICRjb3Jkb3ZhQ2FtZXJhLmdldFBpY3R1cmUob3B0aW9ucykudGhlbihmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgSW1hZ2VVcGxvYWRTZXJ2aWNlLnVwbG9hZEltYWdlKGltYWdlRGF0YSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgLy92YXIgdXJsID0gcmVzdWx0LnNlY3VyZV91cmwgfHwgJyc7XG4gICAgICAgICAgICAgIHZhciB1cmwgPSByZXN1bHQuaW1hZ2VVcmwgfHwgJyc7XG4gICAgICAgICAgICAgIHZhciBmaW5hbCA9IFwiICFbaW1hZ2VdKFwiICsgdXJsICsgXCIpXCI7XG4gICAgICAgICAgICAgICRyb290U2NvcGUubG9nKGZpbmFsKTtcbiAgICAgICAgICAgICAgLyppZiAoJHNjb3BlLnNwb3N0LmJvZHkpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc3Bvc3QuYm9keSArPSBmaW5hbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc3Bvc3QuYm9keSA9IGZpbmFsO1xuICAgICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgICAgJHNjb3BlLmluc2VydFRleHQoZmluYWwpO1xuICAgICAgICAgICAgICBpZiAoIWlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpIHx8ICFpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgJGNvcmRvdmFDYW1lcmEuY2xlYW51cCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVVBMT0FEX0VSUk9SJykpO1xuICAgICAgICAgICAgICBpZiAoIWlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpIHx8ICFpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgJGNvcmRvdmFDYW1lcmEuY2xlYW51cCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FNRVJBX0NBTkNFTExFRCcpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gMil7XG4gICAgICAgICRpb25pY1BvcHVwLnByb21wdCh7XG4gICAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRfVVJMJyksXG4gICAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdESVJFQ1RfTElOS19QSUNUVVJFJyksXG4gICAgICAgICAgaW5wdXRUeXBlOiAndGV4dCcsXG4gICAgICAgICAgaW5wdXRQbGFjZWhvbGRlcjogJ2h0dHA6Ly9leGFtcGxlLmNvbS9pbWFnZS5qcGcnXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdXIgdXJsIGlzJyArIHJlcyk7XG4gICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgdmFyIHVybCA9IHJlcy50cmltKCk7XG4gICAgICAgICAgICB2YXIgZmluYWwgPSBcIiAhW2ltYWdlXShcIiArIHVybCArIFwiKVwiO1xuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coZmluYWwpO1xuICAgICAgICAgICAgLyppZiAoJHNjb3BlLnNwb3N0LmJvZHkpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLnNwb3N0LmJvZHkgKz0gZmluYWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkc2NvcGUuc3Bvc3QuYm9keSA9IGZpbmFsO1xuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAkc2NvcGUuaW5zZXJ0VGV4dChmaW5hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRzY29wZS5nYWxsZXJ5ID0gW107XG4gICAgICAgIEFQSXMuZmV0Y2hJbWFnZXMoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgdmFyIGltZ3MgPSByZXMuZGF0YTtcbiAgICAgICAgICBpZiAoaW1ncy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAkc2NvcGUuc2hvd2dhbGxlcnkgPSB0cnVlO1xuICAgICAgICAgICAgJHNjb3BlLmdhbGxlcnkuaW1hZ2VzID0gaW1ncztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLnNob3dnYWxsZXJ5ID0gZmFsc2U7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdOT19JTUFHRScpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdubyBpbWFnZXMgYXZhaWxhYmxlJylcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSA9PSAwIHx8IHR5cGUgPT0gMSkge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIHF1YWxpdHk6IDUwLFxuICAgICAgICAgIGRlc3RpbmF0aW9uVHlwZTogQ2FtZXJhLkRlc3RpbmF0aW9uVHlwZS5GSUxFX1VSSSxcbiAgICAgICAgICBzb3VyY2VUeXBlOiAodHlwZT09PTApP0NhbWVyYS5QaWN0dXJlU291cmNlVHlwZS5DQU1FUkE6Q2FtZXJhLlBpY3R1cmVTb3VyY2VUeXBlLlBIT1RPTElCUkFSWSxcbiAgICAgICAgICBhbGxvd0VkaXQ6ICh0eXBlPT09MCk/dHJ1ZTpmYWxzZSxcbiAgICAgICAgICBlbmNvZGluZ1R5cGU6IENhbWVyYS5FbmNvZGluZ1R5cGUuSlBFRyxcbiAgICAgICAgICBwb3BvdmVyT3B0aW9uczogQ2FtZXJhUG9wb3Zlck9wdGlvbnMsXG4gICAgICAgICAgc2F2ZVRvUGhvdG9BbGJ1bTogZmFsc2VcbiAgICAgICAgICAvL2NvcnJlY3RPcmllbnRhdGlvbjp0cnVlXG4gICAgICAgIH07XG4gICAgICAgICRjb3Jkb3ZhQ2FtZXJhLmdldFBpY3R1cmUob3B0aW9ucykudGhlbihmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgSW1hZ2VVcGxvYWRTZXJ2aWNlLnVwbG9hZEltYWdlKGltYWdlRGF0YSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgLy92YXIgdXJsID0gcmVzdWx0LnNlY3VyZV91cmwgfHwgJyc7XG4gICAgICAgICAgICAgIHZhciB1cmwgPSByZXN1bHQuaW1hZ2VVcmwgfHwgJyc7XG4gICAgICAgICAgICAgIHZhciBmaW5hbCA9IFwiICFbaW1hZ2VdKFwiICsgdXJsICsgXCIpXCI7XG4gICAgICAgICAgICAgICRyb290U2NvcGUubG9nKGZpbmFsKTtcbiAgICAgICAgICAgICAgLyppZiAoJHNjb3BlLmRhdGEuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLmNvbW1lbnQgKz0gZmluYWw7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuY29tbWVudCA9IGZpbmFsO1xuICAgICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgICAgJHNjb3BlLmluc2VydFRleHQoZmluYWwpO1xuICAgICAgICAgICAgICBpZiAoIWlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpIHx8ICFpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgJGNvcmRvdmFDYW1lcmEuY2xlYW51cCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVVBMT0FEX0VSUk9SJykpO1xuICAgICAgICAgICAgICBpZiAoIWlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpIHx8ICFpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgJGNvcmRvdmFDYW1lcmEuY2xlYW51cCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FNRVJBX0NBTkNFTExFRCcpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gMil7XG4gICAgICAgICRpb25pY1BvcHVwLnByb21wdCh7XG4gICAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRfVVJMJyksXG4gICAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdESVJFQ1RfTElOS19QSUNUVVJFJyksXG4gICAgICAgICAgaW5wdXRUeXBlOiAndGV4dCcsXG4gICAgICAgICAgaW5wdXRQbGFjZWhvbGRlcjogJ2h0dHA6Ly9leGFtcGxlLmNvbS9pbWFnZS5qcGcnXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdXIgdXJsIGlzJyArIHJlcyk7XG4gICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgdmFyIHVybCA9IHJlcy50cmltKCk7XG4gICAgICAgICAgICB2YXIgZmluYWwgPSBcIiAhW2ltYWdlXShcIiArIHVybCArIFwiKVwiO1xuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coZmluYWwpO1xuICAgICAgICAgICAgLyppZiAoJHNjb3BlLmRhdGEuY29tbWVudCkge1xuICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5jb21tZW50ICs9IGZpbmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuY29tbWVudCA9IGZpbmFsO1xuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAkc2NvcGUuaW5zZXJ0VGV4dChmaW5hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRzY29wZS5nYWxsZXJ5ID0gW107XG4gICAgICAgIEFQSXMuZmV0Y2hJbWFnZXMoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgdmFyIGltZ3MgPSByZXMuZGF0YTtcbiAgICAgICAgICBpZiAoaW1ncy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAkc2NvcGUuc2hvd2dhbGxlcnkgPSB0cnVlO1xuICAgICAgICAgICAgJHNjb3BlLmdhbGxlcnkuaW1hZ2VzID0gaW1ncztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLnNob3dnYWxsZXJ5ID0gZmFsc2U7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdOT19JTUFHRScpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdubyBpbWFnZXMgYXZhaWxhYmxlJylcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAkaW9uaWNNb2RhbC5mcm9tVGVtcGxhdGVVcmwoJ3RlbXBsYXRlcy9zdG9yeS5odG1sJywge1xuICAgIHNjb3BlOiAkc2NvcGUgIH0pLnRoZW4oZnVuY3Rpb24obW9kYWwpIHtcbiAgICAkc2NvcGUucG1vZGFsID0gbW9kYWw7XG4gIH0pO1xuICAkc2NvcGUub3BlblBvc3RNb2RhbCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vaWYoISRzY29wZS5wbW9kYWwpIHJldHVybjtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLnBtb2RhbC5zaG93KCk7XG4gICAgICAvKmFuZ3VsYXIuZWxlbWVudChcInRleHRhcmVhXCIpLmZvY3VzKGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUubGFzdEZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBjb25zb2xlLmxvZyhkb2N1bWVudCk7XG4gICAgICB9KTsqL1xuICAgIH0sIDEwKTtcbiAgfTtcblxuICAkcm9vdFNjb3BlLiRvbignY2xvc2VQb3N0TW9kYWwnLCBmdW5jdGlvbigpe1xuICAgICRzY29wZS5wbW9kYWwuaGlkZSgpO1xuICB9KTtcblxuICAkc2NvcGUuY2xvc2VHYWxsZXJ5ID0gZnVuY3Rpb24oKXtcbiAgICAkc2NvcGUuc2hvd2dhbGxlcnkgPSBmYWxzZTtcbiAgfVxuICAkc2NvcGUubWFuYWdlR2FsbGVyeSA9IGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLm1vZGFsLmhpZGUoKTtcbiAgICAkc3RhdGUuZ28oJ2FwcC5pbWFnZXMnKTtcbiAgfVxuICB2YXIgZG1wID0gbmV3IHdpbmRvdy5kaWZmX21hdGNoX3BhdGNoKCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlUGF0Y2godGV4dDEsIHRleHQyKSB7XG4gICAgICBpZiAoIXRleHQxICYmIHRleHQxID09PSAnJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciBwYXRjaGVzID0gZG1wLnBhdGNoX21ha2UodGV4dDEsIHRleHQyKTtcbiAgICAgIHZhciBwYXRjaCA9IGRtcC5wYXRjaF90b1RleHQocGF0Y2hlcyk7XG4gICAgICByZXR1cm4gcGF0Y2g7XG4gIH1cbiAgJHNjb3BlLmNmb2N1cyA9IGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLmxhc3RGb2N1c2VkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgfVxuICAkc2NvcGUuZGVsZXRlUG9zdCA9IGZ1bmN0aW9uKHh4KSB7XG4gICAgJHJvb3RTY29wZS5sb2coJ2RlbGV0ZSBwb3N0ICcrIGFuZ3VsYXIudG9Kc29uKHh4KSk7XG4gICAgdmFyIGNvbmZpcm1Qb3B1cCA9ICRpb25pY1BvcHVwLmNvbmZpcm0oe1xuICAgICAgICB0aXRsZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FSRV9ZT1VfU1VSRScpLFxuICAgICAgICB0ZW1wbGF0ZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0RFTEVURV9DT01NRU5UJylcbiAgICB9KTtcbiAgICBjb25maXJtUG9wdXAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgaWYocmVzKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBzdXJlJyk7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbiA9IG5ldyB3aW5kb3dbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIkpTXCJdLkxvZ2luKCk7XG4gICAgICAgICAgICAgICRzY29wZS5teWxvZ2luLnNldFJvbGVzKFtcInBvc3RpbmdcIl0pO1xuICAgICAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICAgICAgICAgIHBvc3Rpbmc6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wb3N0aW5nLmtleV9hdXRoc1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlUG9zdGluZ0tleSB8fCBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyID0gbmV3IHdpbmRvd1skcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluK1wiSlNcIl0uVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG5cbiAgICAgICAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJkZWxldGVfY29tbWVudFwiLCB7XG4gICAgICAgICAgICAgICAgICBhdXRob3I6IHh4LmF1dGhvcixcbiAgICAgICAgICAgICAgICAgIHBlcm1saW5rOiB4eC5wZXJtbGlua1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vJHJvb3RTY29wZS5sb2cobXlfcHVia2V5cyk7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcbiAgICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnREVMRVRFRF9DT01NRU5UJykpO1xuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ2FwcC5wb3N0cycpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBub3Qgc3VyZScpO1xuICAgICAgICB9XG4gICAgfSk7XG4gIH1cbiAgJHNjb3BlLmVkaXQgPSBmYWxzZTtcbiAgJHNjb3BlLmVkaXRQb3N0ID0gZnVuY3Rpb24oeHgpIHtcbiAgICAkc2NvcGUuZWRpdCA9IHRydWU7XG4gICAgJHNjb3BlLm9wZW5Qb3N0TW9kYWwoKTtcbiAgICBhbmd1bGFyLmVsZW1lbnQoXCJ0ZXh0YXJlYVwiKS5mb2N1cyhmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS5sYXN0Rm9jdXNlZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICBjb25zb2xlLmxvZyhkb2N1bWVudCk7XG4gICAgfSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGlmICghJHNjb3BlLnNwb3N0LmJvZHkpIHtcbiAgICAgICAgJHNjb3BlLnNwb3N0ID0geHg7XG4gICAgICAgICRzY29wZS5wYXRjaGJvZHkgPSB4eC5ib2R5O1xuICAgICAgfVxuICAgICAgJHNjb3BlLnNwb3N0LnRhZ3MgPSBhbmd1bGFyLmZyb21Kc29uKHh4Lmpzb25fbWV0YWRhdGEpLnRhZ3Muam9pbigpLnJlcGxhY2UoL1xcLC9nLCcgJyk7XG4gICAgfSwgMTApO1xuICB9XG5cbiAgJHNjb3BlLnN1Ym1pdFN0b3J5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgaWYgKCRzY29wZS5lZGl0KSB7XG4gICAgICB2YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaCgkc2NvcGUucGF0Y2hib2R5LCAkc2NvcGUuc3Bvc3QuYm9keSlcbiAgICAgIC8vIFB1dHRpbmcgYm9keSBpbnRvIGJ1ZmZlciB3aWxsIGV4cGFuZCBVbmljb2RlIGNoYXJhY3RlcnMgaW50byB0aGVpciB0cnVlIGxlbmd0aFxuICAgICAgaWYgKHBhdGNoICYmIHBhdGNoLmxlbmd0aCA8IG5ldyBCdWZmZXIoJHNjb3BlLnNwb3N0LmJvZHksICd1dGYtOCcpLmxlbmd0aCkge1xuICAgICAgICAkc2NvcGUuc3Bvc3QuYm9keTIgPSBwYXRjaDtcbiAgICAgIH1cbiAgICAgIC8vJHJvb3RTY29wZS5sb2cocGF0Y2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2NvcGUuc3Bvc3QuYm9keTIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93WyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4rXCJKU1wiXS5Mb2dpbigpO1xuICAgICAgJHNjb3BlLm15bG9naW4uc2V0Um9sZXMoW1wicG9zdGluZ1wiXSk7XG4gICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlUG9zdGluZ0tleSB8fCBudWxsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3dbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIkpTXCJdLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICB2YXIgcGVybWxpbmsgPSAkc2NvcGUuc3Bvc3QucGVybWxpbms7XG4gICAgICAgIHZhciBqanNvbiA9ICRmaWx0ZXIoXCJtZXRhZGF0YVwiKSgkc2NvcGUuc3Bvc3QuYm9keSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coampzb24pO1xuICAgICAgICAvLyRzY29wZS5zcG9zdC50YWdzID0gJGZpbHRlcignbG93ZXJjYXNlJykoJHNjb3BlLnNwb3N0LnRhZ3MpO1xuICAgICAgICB2YXIganNvbiA9IGFuZ3VsYXIubWVyZ2Uoampzb24sIHt0YWdzOiAkc2NvcGUuc3Bvc3QudGFncy5zcGxpdChcIiBcIiksIGFwcDogJ2VzdGVlbS8nKyRyb290U2NvcGUuJHN0b3JhZ2UuYXBwdmVyc2lvbiwgZm9ybWF0OiAnbWFya2Rvd24raHRtbCcgfSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coanNvbik7XG4gICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImNvbW1lbnRcIiwge1xuICAgICAgICAgIHBhcmVudF9hdXRob3I6IFwiXCIsXG4gICAgICAgICAgcGFyZW50X3Blcm1saW5rOiAkc2NvcGUuc3Bvc3QucGFyZW50X3Blcm1saW5rLFxuICAgICAgICAgIGF1dGhvcjogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgIHBlcm1saW5rOiAkc2NvcGUuc3Bvc3QucGVybWxpbmssXG4gICAgICAgICAgdGl0bGU6ICRzY29wZS5zcG9zdC50aXRsZSxcbiAgICAgICAgICBib2R5OiAkc2NvcGUuc3Bvc3QuYm9keTIgfHwgJHNjb3BlLnNwb3N0LmJvZHksXG4gICAgICAgICAganNvbl9tZXRhZGF0YTogYW5ndWxhci50b0pzb24oanNvbilcbiAgICAgICAgfSk7XG4gICAgICAgIC8vJHJvb3RTY29wZS5sb2cobXlfcHVia2V5cyk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24oJHNjb3BlLm15bG9naW4sIG51bGwsIHRydWUpO1xuICAgICAgICAkc2NvcGUucmVwbHlpbmcgPSBmYWxzZTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyRzY29wZS5jbG9zZVBvc3RNb2RhbCgpO1xuXG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2Nsb3NlUG9zdE1vZGFsJyk7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICRzY29wZS5zcG9zdCA9IHt9O1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQT1NUX1NVQk1JVFRFRCcpKTtcbiAgICAgICAgICAgIC8vJHNjb3BlLmNsb3NlUG9zdFBvcG92ZXIoKTtcbiAgICAgICAgICAgICAgJHN0YXRlLmdvKFwiYXBwLnByb2ZpbGVcIiwge3VzZXJuYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWV9KTtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMzAwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTCcpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9UT19YJykpO1xuICAgIH1cbiAgfVxuICAkc2NvcGUuYWRkSW1hZ2UgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAkc2NvcGUuZGF0YS5jb21tZW50ICs9ICcgIVtpbWFnZV0oJyt1cmwrJykgJztcbiAgfVxuICAkc2NvcGUucmVwbHkgPSBmdW5jdGlvbiAoeHgpIHtcbiAgICAvLyRyb290U2NvcGUubG9nKHh4KTtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAkc2NvcGUubXlsb2dpbiA9IG5ldyB3aW5kb3dbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIkpTXCJdLkxvZ2luKCk7XG4gICAgICAkc2NvcGUubXlsb2dpbi5zZXRSb2xlcyhbXCJwb3N0aW5nXCJdKTtcbiAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSAkc2NvcGUubXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgIHBvc3Rpbmc6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wb3N0aW5nLmtleV9hdXRoc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJpdmF0ZUtleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVQb3N0aW5nS2V5IHx8IG51bGxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGlmIChsb2dpblN1Y2Nlc3MpIHtcbiAgICAgICAgdmFyIHRyID0gbmV3IHdpbmRvd1skcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluK1wiSlNcIl0uVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG4gICAgICAgIHZhciB0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgdmFyIHRpbWVmb3JtYXQgPSB0LmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSsodC5nZXRNb250aCgpKzEpLnRvU3RyaW5nKCkrdC5nZXREYXRlKCkudG9TdHJpbmcoKStcInRcIit0LmdldEhvdXJzKCkudG9TdHJpbmcoKSt0LmdldE1pbnV0ZXMoKS50b1N0cmluZygpK3QuZ2V0U2Vjb25kcygpLnRvU3RyaW5nKCkrdC5nZXRNaWxsaXNlY29uZHMoKS50b1N0cmluZygpK1wielwiO1xuICAgICAgICB2YXIganNvbiA9IHt0YWdzOiBhbmd1bGFyLmZyb21Kc29uKCRzY29wZS5wb3N0Lmpzb25fbWV0YWRhdGEpLnRhZ3NbMF0gfHwgW1wiZXN0ZWVtXCJdICwgYXBwOiAnZXN0ZWVtLycrJHJvb3RTY29wZS4kc3RvcmFnZS5hcHB2ZXJzaW9uLCBmb3JtYXQ6ICdtYXJrZG93bitodG1sJyB9O1xuICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJjb21tZW50XCIsIHtcbiAgICAgICAgICBwYXJlbnRfYXV0aG9yOiAkc2NvcGUucG9zdC5hdXRob3IsXG4gICAgICAgICAgcGFyZW50X3Blcm1saW5rOiAkc2NvcGUucG9zdC5wZXJtbGluayxcbiAgICAgICAgICBhdXRob3I6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICBwZXJtbGluazogXCJyZS1cIiskc2NvcGUucG9zdC5hdXRob3IrXCItXCIrJHNjb3BlLnBvc3QucGVybWxpbmsrXCItXCIrdGltZWZvcm1hdCxcbiAgICAgICAgICB0aXRsZTogXCJcIixcbiAgICAgICAgICBib2R5OiAkc2NvcGUuZGF0YS5jb21tZW50LFxuICAgICAgICAgIGpzb25fbWV0YWRhdGE6IGFuZ3VsYXIudG9Kc29uKGpzb24pXG4gICAgICAgIH0pO1xuICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcbiAgICAgICAgJHNjb3BlLnJlcGx5aW5nID0gZmFsc2U7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLmNsb3NlTW9kYWwoKTtcbiAgICAgICAgICAgICRzY29wZS5kYXRhLmNvbW1lbnQgPSBcIlwiO1xuXG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDT01NRU5UX1NVQk1JVFRFRCcpKTtcbiAgICAgICAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfY29udGVudF9yZXBsaWVzXCIsIFskcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLmF1dGhvciwgJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbS5wZXJtbGlua10pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmNvbW1lbnRzID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAzMDAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMJykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX1RPX1gnKSk7XG4gICAgfVxuICB9XG4gICRyb290U2NvcGUuJG9uKFwidXBkYXRlOmNvbnRlbnRcIiwgZnVuY3Rpb24oKXtcbiAgICAkcm9vdFNjb3BlLmxvZyhcInVwZGF0ZTpjb250ZW50XCIpO1xuICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2NvbnRlbnRfcmVwbGllc1wiLCBbJHNjb3BlLnBvc3QuYXV0aG9yLCAkc2NvcGUucG9zdC5wZXJtbGlua10pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgLy90b2RvIGZpeCBhY3RpdmVfdm90ZXNcbiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIC8qYW5ndWxhci5mb3JFYWNoKHJlc3VsdCwgZnVuY3Rpb24odixrKXtcbiAgICAgICAgICAgIHZhciBsZW4gPSB2LmFjdGl2ZV92b3Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgdXNlciA9ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlcjtcbiAgICAgICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSBsZW4gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIGlmICh2LmFjdGl2ZV92b3Rlc1tqXS52b3RlciA9PT0gdXNlci51c2VybmFtZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHYuYWN0aXZlX3ZvdGVzW2pdLnBlcmNlbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHYudXB2b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYuYWN0aXZlX3ZvdGVzW2pdLnBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHYuZG93bnZvdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHYuZG93bnZvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHYudXB2b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pOyovXG4gICAgICAgICAgJHNjb3BlLmNvbW1lbnRzID0gcmVzdWx0O1xuICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgfSk7XG4gICRpb25pY01vZGFsLmZyb21UZW1wbGF0ZVVybCgndGVtcGxhdGVzL3JlcGx5Lmh0bWwnLCB7XG4gICAgc2NvcGU6ICRzY29wZSAgfSkudGhlbihmdW5jdGlvbihtb2RhbCkge1xuICAgICRzY29wZS5tb2RhbCA9IG1vZGFsO1xuICB9KTtcblxuICAkc2NvcGUub3Blbk1vZGFsID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIC8vaWYoISRzY29wZS5tb2RhbCkgcmV0dXJuO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUubW9kYWwuc2hvdygpO1xuICAgIH0sIDUpO1xuICB9O1xuXG4gICRzY29wZS5jbG9zZU1vZGFsID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLnJlcGx5aW5nID0gZmFsc2U7XG4gICAgJHNjb3BlLm1vZGFsLmhpZGUoKTtcbiAgfTtcblxuICAkc2NvcGUuaXNyZXBseWluZyA9IGZ1bmN0aW9uKGNobywgeHgpIHtcbiAgICAkc2NvcGUucmVwbHlpbmcgPSB4eDtcbiAgICBhbmd1bGFyLm1lcmdlKCRzY29wZS5wb3N0LCBjaG8pO1xuICAgIGlmICh4eCkge1xuICAgICAgJHNjb3BlLm9wZW5Nb2RhbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2NvcGUuY2xvc2VNb2RhbCgpO1xuICAgIH1cbiAgfTtcbiAgJHNjb3BlLmFjY291bnRzID0ge307XG4gICRzY29wZS5nZXRDb250ZW50ID0gZnVuY3Rpb24oYXV0aG9yLCBwZXJtbGluaykge1xuICAgIHZhciB1cmwgPSBcIi9cIiskc3RhdGVQYXJhbXMuY2F0ZWdvcnkrXCIvQFwiK2F1dGhvcitcIi9cIitwZXJtbGluaztcbiAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9zdGF0ZVwiLCBbdXJsXSkudGhlbihmdW5jdGlvbihkZCl7XG4gICAgICAgIC8vY29uc29sZS5sb2coZGQpO1xuICAgICAgICB2YXIgY29uID0gZGQuY29udGVudDtcbiAgICAgICAgdmFyIGFjb24gPSBkZC5hY2NvdW50cztcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2goY29uLCBmdW5jdGlvbih2LGspe1xuICAgICAgICAgIHYuY29tbWVudHMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbiwgZnVuY3Rpb24odixrKXtcbiAgICAgICAgICB2YXIgdnBhcmVudCA9IHYucGFyZW50X2F1dGhvcj09XCJcIj92LmF1dGhvcjp2LnBhcmVudF9hdXRob3I7XG4gICAgICAgICAgdmFyIHZwZXJtID0gdi5wYXJlbnRfYXV0aG9yPT1cIlwiP3YucGVybWxpbms6di5wYXJlbnRfcGVybWxpbms7XG4gICAgICAgICAgdmFyIGtleXkgPSB2cGFyZW50K1wiL1wiK3ZwZXJtO1xuICAgICAgICAgIGlmICh2LnBhcmVudF9wZXJtbGluayE9PXYuY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIGNvbltrZXl5XS5jb21tZW50cy5wdXNoKHYpOyAgXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhhY29uKTsgIFxuICAgICAgICAvL30sIDEpO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goYWNvbiwgZnVuY3Rpb24odixrKXtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKHYuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2Lmpzb25fbWV0YWRhdGEgPT09ICdzdHJpbmcnIHx8IHYuanNvbl9tZXRhZGF0YSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh2Lmpzb25fbWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKHYuanNvbl9tZXRhZGF0YSlcbiAgICAgICAgICAgICAgdi5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbih2Lmpzb25fbWV0YWRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBjb25bYXV0aG9yK1wiL1wiK3Blcm1saW5rXTtcblxuICAgICAgICB2YXIgbGVuID0gcmVzdWx0LmFjdGl2ZV92b3Rlcy5sZW5ndGg7XG4gICAgICAgIHZhciB1c2VyID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyO1xuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgIGZvciAodmFyIGogPSBsZW4gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5hY3RpdmVfdm90ZXNbal0udm90ZXIgPT09IHVzZXIudXNlcm5hbWUpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudXB2b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kb3dudm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kb3dudm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXN1bHQudXB2b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0Lmpzb25fbWV0YWRhdGEgPSBhbmd1bGFyLmZyb21Kc29uKHJlc3VsdC5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgLy8kcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtID0gcmVzdWx0O1xuICAgICAgICAvL2NvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICRzY29wZS5wb3N0ID0gcmVzdWx0O1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBhY2NvdW50cyA9IGFjb247XG5cbiAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvKndpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9jb250ZW50XCIsIFthdXRob3IsIHBlcm1saW5rXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgLy9jb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAgICB2YXIgbGVuID0gcmVzdWx0LmFjdGl2ZV92b3Rlcy5sZW5ndGg7XG4gICAgICAgIHZhciB1c2VyID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyO1xuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgIGZvciAodmFyIGogPSBsZW4gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5hY3RpdmVfdm90ZXNbal0udm90ZXIgPT09IHVzZXIudXNlcm5hbWUpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudXB2b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kb3dudm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kb3dudm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXN1bHQudXB2b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbihyZXN1bHQuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0gPSByZXN1bHQ7XG4gICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICAgICRzY29wZS5wb3N0ID0gcmVzdWx0O1xuICAgICAgICAvLyRpb25pY1Njcm9sbERlbGVnYXRlLiRnZXRCeUhhbmRsZSgnbWFpblNjcm9sbCcpLnNjcm9sbFRvcCgpO1xuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgIC8vY29uc29sZS5sb2coJHNjb3BlLnBvc3QpO1xuICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8kcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICovXG4gIH07XG4gICRzY29wZS5mZXRjaENvbW1lbnRzID0gZnVuY3Rpb24oKXtcbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3VwZGF0ZTpjb250ZW50Jyk7XG4gIH1cbiAgJHNjb3BlLiRvbignJGlvbmljVmlldy5iZWZvcmVFbnRlcicsIGZ1bmN0aW9uKCl7XG4gICAgJHJvb3RTY29wZS5sb2coJ2JlZm9yZUVudGVyIHBvc3RjdHJsJyk7XG4gICAgLy8kcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgIGlmICgkc3RhdGVQYXJhbXMuY2F0ZWdvcnkgPT09ICcxMTEnKSB7XG4gICAgICB2YXIgdHRlbXAgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtO1xuICAgICAgJHNjb3BlLnBvc3QgPSB0dGVtcDtcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgndXBkYXRlOmNvbnRlbnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjb3BlLmdldENvbnRlbnQoJHN0YXRlUGFyYW1zLmF1dGhvciwgJHN0YXRlUGFyYW1zLnBlcm1saW5rKTtcbiAgICAgIC8vJHNjb3BlLnBvc3QgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtO1xuICAgICAgLy8kcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3VwZGF0ZTpjb250ZW50Jyk7XG4gICAgfVxuICB9KTtcblxuXG5cbiAgJHNjb3BlLnVwdm90ZVBvc3QgPSBmdW5jdGlvbihwb3N0KSB7XG4gICAgJHJvb3RTY29wZS52b3RlUG9zdChwb3N0LCAndXB2b3RlJywgJ2dldENvbnRlbnQnKTtcbiAgfTtcbiAgJHJvb3RTY29wZS4kb24oJ2dldENvbnRlbnQnLCBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUuZ2V0Q29udGVudCgkcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLmF1dGhvciwgJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbS5wZXJtbGluayk7XG4gIH0pO1xuICAkc2NvcGUuZG93bnZvdGVQb3N0ID0gZnVuY3Rpb24ocG9zdCkge1xuICAgIHZhciBjb25maXJtUG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQVJFX1lPVV9TVVJFJyksXG4gICAgICB0ZW1wbGF0ZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0ZMQUdHSU5HX1RFWFQnKVxuICAgIH0pO1xuICAgIGNvbmZpcm1Qb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgaWYocmVzKSB7XG4gICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIHN1cmUnKTtcbiAgICAgICAgJHJvb3RTY29wZS52b3RlUG9zdChwb3N0LCAnZG93bnZvdGUnLCAnZ2V0Q29udGVudCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgbm90IHN1cmUnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgJHNjb3BlLnVudm90ZVBvc3QgPSBmdW5jdGlvbihwb3N0KSB7XG4gICAgJHJvb3RTY29wZS52b3RlUG9zdChwb3N0LCAndW52b3RlJywgJ2dldENvbnRlbnQnKTtcbiAgfTtcblxuXG59KVxuYXBwLmNvbnRyb2xsZXIoJ0Jvb2ttYXJrQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkcm9vdFNjb3BlLCAkc3RhdGUsIEFQSXMsICRpbnRlcnZhbCwgJGlvbmljU2Nyb2xsRGVsZWdhdGUsICRmaWx0ZXIpIHtcblxuICAkc2NvcGUucmVtb3ZlQm9va21hcmsgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmJvb2ttYXJrKSB7XG4gICAgICBBUElzLnJlbW92ZUJvb2ttYXJrKCRyb290U2NvcGUuJHN0b3JhZ2UuYm9va21hcmtbaW5kZXhdLl9pZCwkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUpLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5ib29rbWFyay5zcGxpY2UoaW5kZXgsMSk7XG4gICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1BPU1RfSVNfVU5CT09LTUFSSycpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmJlZm9yZUVudGVyJywgZnVuY3Rpb24oKXtcbiAgICBBUElzLmdldEJvb2ttYXJrcygkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUpLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgIC8vY29uc29sZS5sb2cocmVzKTtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuYm9va21hcmsgPSByZXMuZGF0YTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuYXBwLmNvbnRyb2xsZXIoJ0RyYWZ0c0N0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJHJvb3RTY29wZSwgJHN0YXRlLCBBUElzLCAkaW50ZXJ2YWwsICRpb25pY1Njcm9sbERlbGVnYXRlLCAkZmlsdGVyKSB7XG4gIC8vSlNPTi5zdHJpbmdpZnkoe1xuICAkc2NvcGUucmVtb3ZlRHJhZnQgPSBmdW5jdGlvbihfaWQpIHtcbiAgICBBUElzLnJlbW92ZURyYWZ0KF9pZCwkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUpLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgIEFQSXMuZ2V0RHJhZnRzKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAvL2NvbnNvbGUubG9nKHJlcyk7XG4gICAgICAgICRzY29wZS5kcmFmdHMgPSByZXMuZGF0YTtcbiAgICAgIH0pO1xuICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUE9TVF9JU19VTkRSQUZUJykpO1xuICAgIH0pO1xuICB9O1xuXG4gICRzY29wZS4kb24oJyRpb25pY1ZpZXcuYmVmb3JlRW50ZXInLCBmdW5jdGlvbigpe1xuICAgIEFQSXMuZ2V0RHJhZnRzKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgLy9jb25zb2xlLmxvZyhyZXMpO1xuICAgICAgJHNjb3BlLmRyYWZ0cyA9IHJlcy5kYXRhO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5hcHAuY29udHJvbGxlcignSW1hZ2VzQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkcm9vdFNjb3BlLCAkc3RhdGUsIEFQSXMsICRpbnRlcnZhbCwgJGlvbmljU2Nyb2xsRGVsZWdhdGUsICRmaWx0ZXIpIHtcbiAgLy9KU09OLnN0cmluZ2lmeSh7XG4gICRzY29wZS5yZW1vdmVJbWFnZSA9IGZ1bmN0aW9uKF9pZCkge1xuICAgIEFQSXMucmVtb3ZlSW1hZ2UoX2lkLCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgQVBJcy5mZXRjaEltYWdlcygkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUpLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhyZXMpO1xuICAgICAgICAkc2NvcGUuaW1hZ2VzID0gcmVzLmRhdGE7XG4gICAgICB9KTtcbiAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0lNQUdFX1JFTU9WRUQnKSk7XG4gICAgfSk7XG4gIH07XG4gICRzY29wZS5jb3B5SW1hZ2UgPSBmdW5jdGlvbih1cmwpe1xuICAgIGNvcmRvdmEucGx1Z2lucy5jbGlwYm9hcmQuY29weSh1cmwpO1xuICB9O1xuICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmJlZm9yZUVudGVyJywgZnVuY3Rpb24oKXtcbiAgICBBUElzLmZldGNoSW1hZ2VzKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgLy9jb25zb2xlLmxvZyhyZXMpO1xuICAgICAgJHNjb3BlLmltYWdlcyA9IHJlcy5kYXRhO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5hcHAuY29udHJvbGxlcignTm90aWZpY2F0aW9uc0N0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJHJvb3RTY29wZSwgJHN0YXRlLCBBUElzLCAkaW50ZXJ2YWwsICRpb25pY1Njcm9sbERlbGVnYXRlKSB7XG5cbiAgJHNjb3BlLnJlbW92ZU5vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2Uubm90aWZpY2F0aW9ucykge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZmljYXRpb25zLnNwbGljZShpbmRleCwxKTtcbiAgICB9XG4gIH07XG59KVxuYXBwLmNvbnRyb2xsZXIoJ0ZvbGxvd0N0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJHJvb3RTY29wZSwgJHN0YXRlLCBBUElzLCAkaW50ZXJ2YWwsICRpb25pY1Njcm9sbERlbGVnYXRlKSB7XG4gICRzY29wZS5zZWFyY2h1ID0ge307XG5cbiAgJHNjb3BlLiRvbignJGlvbmljVmlldy5iZWZvcmVFbnRlcicsIGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLmFjdGl2ZSA9IFwiZm9sbG93ZXJzXCI7XG4gICAgJHNjb3BlLmZvbGxvd2VycyA9IFtdO1xuICAgICRzY29wZS5mb2xsb3dpbmcgPSBbXTtcbiAgICAkc2NvcGUubGltaXQgPSAxMDA7XG4gICAgJHNjb3BlLnR0ID0ge3J1c2VyOlwiXCIsIGR1c2VyOlwiXCJ9O1xuXG4gICAgJHNjb3BlLnJmZXRjaGluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgd2luZG93LkFwaS5mb2xsb3dfYXBpKCkuZXhlYyhcImdldF9mb2xsb3dlcnNcIiwgWyRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSwgJHNjb3BlLnR0LnJ1c2VyLCBcImJsb2dcIiwgJHNjb3BlLmxpbWl0XSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgIGlmIChyZXMgJiYgcmVzLmxlbmd0aD09PSRzY29wZS5saW1pdCkge1xuICAgICAgICAgICAgJHNjb3BlLnR0LnJ1c2VyID0gcmVzW3Jlcy5sZW5ndGgtMV0uZm9sbG93ZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vY29uc29sZS5sb2cocmVzKTtcbiAgICAgICAgICB2YXIgbGwgPSByZXMubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGw7IGkrKykge1xuICAgICAgICAgICAgcmVzW2ldLmlkICs9IDE7XG4gICAgICAgICAgICAkc2NvcGUuZm9sbG93ZXJzLnB1c2gocmVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPCAkc2NvcGUubGltaXQpIHtcbiAgICAgICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoJHNjb3BlLnJmZXRjaGluZywgNSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkc2NvcGUuZGZldGNoaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB3aW5kb3cuQXBpLmZvbGxvd19hcGkoKS5leGVjKFwiZ2V0X2ZvbGxvd2luZ1wiLCBbJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCAkc2NvcGUudHQuZHVzZXIsIFwiYmxvZ1wiLCAkc2NvcGUubGltaXRdKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgaWYgKHJlcyAmJiByZXMubGVuZ3RoPT09JHNjb3BlLmxpbWl0KSB7XG4gICAgICAgICAgICAkc2NvcGUudHQuZHVzZXIgPSByZXNbcmVzLmxlbmd0aC0xXS5mb2xsb3dpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsbCA9IHJlcy5sZW5ndGg7XG5cbiAgICAgICAgICAvL2NvbnNvbGUubG9nKHJlcyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsbDsgaSsrKSB7XG4gICAgICAgICAgICByZXNbaV0uaWQgKz0gMTtcbiAgICAgICAgICAgICRzY29wZS5mb2xsb3dpbmcucHVzaChyZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzLmxlbmd0aDwkc2NvcGUubGltaXQpIHtcbiAgICAgICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoJHNjb3BlLmRmZXRjaGluZywgNSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkc2NvcGUucmZldGNoaW5nKCk7XG4gICAgJHNjb3BlLmRmZXRjaGluZygpO1xuXG4gIH0pO1xuXG4gICRzY29wZS4kb24oJyRpb25pY1ZpZXcubGVhdmUnLCBmdW5jdGlvbigpe1xuICAgIC8qaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKCRzY29wZS5kZmV0Y2hpbmcpKXtcbiAgICAgICRpbnRlcnZhbC5jYW5jZWwoJHNjb3BlLmRmZXRjaGluZyk7XG4gICAgICAkc2NvcGUuZGZldGNoaW5nID0gdW5kZWZpbmVkO1xuICAgICAgJHNjb3BlLmZvbGxvd2luZyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKCRzY29wZS5yZmV0Y2hpbmcpKXtcbiAgICAgICRpbnRlcnZhbC5jYW5jZWwoJHNjb3BlLnJmZXRjaGluZyk7XG4gICAgICAkc2NvcGUucmZldGNoaW5nID0gdW5kZWZpbmVkO1xuICAgICAgJHNjb3BlLmZvbGxvd2VycyA9IHVuZGVmaW5lZDtcbiAgICB9Ki9cbiAgfSk7XG4gICRzY29wZS5pc0ZvbGxvd2VkID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciBsZW4gPSAkc2NvcGUuZm9sbG93aW5nLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoJHNjb3BlLmZvbGxvd2luZ1tpXS5mb2xsb3dpbmcgPT0geCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICAkc2NvcGUuaXNGb2xsb3dpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGxlbiA9ICRzY29wZS5mb2xsb3dlcnMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICgkc2NvcGUuZm9sbG93ZXJzW2ldLmZvbGxvd2VyID09IHgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgJHNjb3BlLmNoYW5nZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICAgICRzY29wZS5hY3RpdmUgPSB0eXBlO1xuICAgICRyb290U2NvcGUubG9nKHR5cGUpO1xuXG4gICAgJGlvbmljU2Nyb2xsRGVsZWdhdGUuJGdldEJ5SGFuZGxlKCdsaXN0U2Nyb2xsJykuc2Nyb2xsVG9wKCk7XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgICAvLyRzY29wZS5sb2FkTW9yZSh0eXBlKTtcbiAgfVxuXG4gICRzY29wZS4kb24oJ2N1cnJlbnQ6cmVsb2FkJywgZnVuY3Rpb24oKXtcbiAgICAkcm9vdFNjb3BlLmxvZygnY3VycmVudDpyZWxvYWQnKTtcbiAgICAvLyRzdGF0ZS5nbygkc3RhdGUuY3VycmVudCwge30sIHtyZWxvYWQ6IHRydWV9KTtcbiAgICAkc2NvcGUuZm9sbG93ZXJzID0gW107XG4gICAgJHNjb3BlLmZvbGxvd2luZyA9IFtdO1xuICAgICRzY29wZS5yZmV0Y2hpbmcoKTtcbiAgICAkc2NvcGUuZGZldGNoaW5nKCk7XG4gIH0pO1xuXG4gICRzY29wZS51bmZvbGxvd1VzZXIgPSBmdW5jdGlvbih4eCl7XG4gICAgJHJvb3RTY29wZS5mb2xsb3dpbmcoeHgsIFwidW5mb2xsb3dcIik7XG4gIH07XG4gICRzY29wZS5mb2xsb3dVc2VyID0gZnVuY3Rpb24oeHgpe1xuICAgICRyb290U2NvcGUuZm9sbG93aW5nKHh4LCBcImZvbGxvd1wiKTtcbiAgfTtcbiAgJHNjb3BlLnByb2ZpbGVWaWV3ID0gZnVuY3Rpb24oeHgpe1xuICAgICRzdGF0ZS5nbygnYXBwLnByb2ZpbGUnLCB7dXNlcm5hbWU6IHh4fSk7XG4gIH07XG5cbn0pXG5cbmFwcC5jb250cm9sbGVyKCdQcm9maWxlQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkcm9vdFNjb3BlLCAkaW9uaWNBY3Rpb25TaGVldCwgJGNvcmRvdmFDYW1lcmEsIEltYWdlVXBsb2FkU2VydmljZSwgJGlvbmljUG9wdXAsICRpb25pY1NpZGVNZW51RGVsZWdhdGUsICRpb25pY0hpc3RvcnksICRzdGF0ZSwgQVBJcywgJGlvbmljUG9wb3ZlciwgJGZpbHRlcikge1xuXG4gIHZhciBmb3JtYXRUb1BlcmNlbnRhZ2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAnJSc7XG4gIH07XG5cbiAgJHNjb3BlLnBzbGlkZXIgPSB7XG4gICAgdmFsdWU6ICRyb290U2NvcGUuJHN0b3JhZ2Uudm90ZVdlaWdodC8xMDAsXG4gICAgb3B0aW9uczoge1xuICAgICAgZmxvb3I6IDEsXG4gICAgICBjZWlsOiAxMDAsXG4gICAgICB0cmFuc2xhdGU6IGZvcm1hdFRvUGVyY2VudGFnZSxcbiAgICAgIHNob3dTZWxlY3Rpb25CYXI6IHRydWVcbiAgICB9XG4gIH07XG5cbiAgJGlvbmljUG9wb3Zlci5mcm9tVGVtcGxhdGVVcmwoJ3BvcG92ZXJTbGlkZXJycC5odG1sJywge1xuICAgICAgc2NvcGU6ICRzY29wZVxuICB9KS50aGVuKGZ1bmN0aW9uKHBvcG92ZXIpIHtcbiAgICAgICRzY29wZS50b29sdGlwU2xpZGVyID0gcG9wb3ZlcjtcbiAgfSk7XG4gIFxuICAkc2NvcGUub3BlblNsaWRlciA9IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICRzY29wZS5wc2xpZGVyID0ge1xuICAgICAgdmFsdWU6ICRyb290U2NvcGUuJHN0b3JhZ2Uudm90ZVdlaWdodC8xMDAsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGZsb29yOiAxLFxuICAgICAgICBjZWlsOiAxMDAsXG4gICAgICAgIHRyYW5zbGF0ZTogZm9ybWF0VG9QZXJjZW50YWdlLFxuICAgICAgICBzaG93U2VsZWN0aW9uQmFyOiB0cnVlXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICAgICRzY29wZS50b29sdGlwU2xpZGVyLnNob3coJGV2ZW50KTtcbiAgfTtcblxuICAkc2NvcGUuY2xvc2VTbGlkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUudG9vbHRpcFNsaWRlci5oaWRlKCk7XG4gIH07XG5cbiAgJHNjb3BlLiR3YXRjaCgncHNsaWRlcicsIGZ1bmN0aW9uKG5ld1ZhbHVlLCBvbGRWYWx1ZSl7XG4gICAgLy9jb25zb2xlLmxvZyhuZXdWYWx1ZS52YWx1ZSk7XG4gICAgaWYgKG5ld1ZhbHVlLnZhbHVlKSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQgPSBuZXdWYWx1ZS52YWx1ZSoxMDA7XG4gICAgfVxuICB9LCB0cnVlKTtcblxuICAkc2NvcGUudHJhbnNsYXRpb25EYXRhID0geyBwbGF0Zm9ybW5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1uYW1lLCBwbGF0Zm9ybXBvd2VyOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtcG93ZXIsIHBsYXRmb3Jtc3VuaXQ6XCIkMS4wMFwiIH07XG5cbiAgJHNjb3BlLmdvQmFjayA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2aWV3SGlzdG9yeSA9ICRpb25pY0hpc3Rvcnkudmlld0hpc3RvcnkoKTtcbiAgICBpZiAoIXZpZXdIaXN0b3J5LmJhY2tWaWV3KSB7XG4gICAgICAkc2NvcGUub3Blbk1lbnUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGlvbmljSGlzdG9yeS5nb0JhY2soKTtcbiAgICB9XG4gIH07XG4gICRzY29wZS5mb2xsb3dVc2VyID0gZnVuY3Rpb24oeHgpe1xuICAgICRyb290U2NvcGUuZm9sbG93aW5nKHh4LCBcImZvbGxvd1wiKTtcbiAgfTtcbiAgJHNjb3BlLnVuZm9sbG93VXNlciA9IGZ1bmN0aW9uKHh4KXtcbiAgICAkcm9vdFNjb3BlLmxvZyh4eCk7XG4gICAgJHJvb3RTY29wZS5mb2xsb3dpbmcoeHgsIFwidW5mb2xsb3dcIik7XG4gIH07XG5cbiAgJHNjb3BlLiRvbignY3VycmVudDpyZWxvYWQnLCBmdW5jdGlvbigpe1xuICAgICRzdGF0ZS5nbygkc3RhdGUuY3VycmVudCwge30sIHtyZWxvYWQ6IHRydWV9KTtcbiAgfSk7XG5cbiAgJGlvbmljUG9wb3Zlci5mcm9tVGVtcGxhdGVVcmwoJ3BvcG92ZXJQVHIuaHRtbCcsIHtcbiAgICAgIHNjb3BlOiAkc2NvcGVcbiAgIH0pLnRoZW4oZnVuY3Rpb24ocG9wb3Zlcikge1xuICAgICAgJHNjb3BlLnRvb2x0aXAgPSBwb3BvdmVyO1xuICAgfSk7XG5cbiAgICRzY29wZS5vcGVuVG9vbHRpcCA9IGZ1bmN0aW9uKCRldmVudCwgZCkge1xuICAgIHZhciB0cHB2ID0gTnVtYmVyKGQudG90YWxfcGVuZGluZ19wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgdmFyIHAgPSBOdW1iZXIoZC5wcm9tb3RlZC5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICB2YXIgdHB2ID0gTnVtYmVyKGQudG90YWxfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgIHZhciBhciA9IE51bWJlcihkLnRvdGFsX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdLWQuY3VyYXRvcl9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgdmFyIGNycCA9IE51bWJlcihkLmN1cmF0b3JfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgIHZhciB0ZXh0aCA9IFwiPGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQQVlPVVRfQ1lDTEUnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiK2QubW9kZS5yZXBsYWNlKCdfJywnICcpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQT1RFTlRJQUxfUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCdnZXRDdXJyZW5jeVN5bWJvbCcpKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kpKyRmaWx0ZXIoJ251bWJlcicpKHRwcHYsIDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQUk9NT1RFRCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcignZ2V0Q3VycmVuY3lTeW1ib2wnKSgkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5KSskZmlsdGVyKCdudW1iZXInKShwLDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQQVNUX1BBWU9VVCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcignZ2V0Q3VycmVuY3lTeW1ib2wnKSgkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5KSskZmlsdGVyKCdudW1iZXInKSh0cHYsMykrXCI8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ0FVVEhPUl9QQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykoYXIsMykrXCI8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ0NVUkFUSU9OX1BBWU9VVCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcignZ2V0Q3VycmVuY3lTeW1ib2wnKSgkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5KSskZmlsdGVyKCdudW1iZXInKShjcnAsMykrXCI8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ1BBWU9VVCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcigndGltZWFnbycpKGQuY2FzaG91dF90aW1lLCB0cnVlKStcIjwvZGl2PjwvZGl2PlwiO1xuICAgICRzY29wZS50b29sdGlwVGV4dCA9IHRleHRoO1xuICAgICRzY29wZS50b29sdGlwLnNob3coJGV2ZW50KTtcbiAgIH07XG5cbiAgICRzY29wZS5jbG9zZVRvb2x0aXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS50b29sdGlwLmhpZGUoKTtcbiAgIH07XG5cbiAgIC8vQ2xlYW51cCB0aGUgcG9wb3ZlciB3aGVuIHdlJ3JlIGRvbmUgd2l0aCBpdCFcbiAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUudG9vbHRpcC5yZW1vdmUoKTtcbiAgIH0pO1xuXG4gICAvLyBFeGVjdXRlIGFjdGlvbiBvbiBoaWRlIHBvcG92ZXJcbiAgICRzY29wZS4kb24oJ3BvcG92ZXIuaGlkZGVuJywgZnVuY3Rpb24oKSB7XG4gICAgICAvLyBFeGVjdXRlIGFjdGlvblxuICAgfSk7XG5cbiAgIC8vIEV4ZWN1dGUgYWN0aW9uIG9uIHJlbW92ZSBwb3BvdmVyXG4gICAkc2NvcGUuJG9uKCdwb3BvdmVyLnJlbW92ZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIC8vIEV4ZWN1dGUgYWN0aW9uXG4gICB9KTtcblxuICAkc2NvcGUuc2hvd1Byb2ZpbGUgPSBmdW5jdGlvbigpIHtcbiAgIHZhciBoaWRlU2hlZXQgPSAkaW9uaWNBY3Rpb25TaGVldC5zaG93KHtcbiAgICAgYnV0dG9uczogW1xuICAgICAgIHsgdGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0NBUFRVUkVfUElDVFVSRScpIH0sXG4gICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VMRUNUX1BJQ1RVUkUnKSB9LFxuICAgICAgIHsgdGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFVF9DVVNUT01fVVJMJykgfSxcbiAgICAgXSxcbiAgICAgZGVzdHJ1Y3RpdmVUZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUkVTRVQnKSxcbiAgICAgdGl0bGVUZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTU9ESUZZX1BJQ1RVUkUnKSxcbiAgICAgY2FuY2VsVGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0NBTkNFTCcpLFxuICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBhZGQgY2FuY2VsIGNvZGUuLlxuICAgICAgfSxcbiAgICAgYnV0dG9uQ2xpY2tlZDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkICYmICEkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSkge1xuICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTF9BJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHNjb3BlLmNoYW5nZVByb2ZpbGVJbmZvKGluZGV4LCAncHJvZmlsZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgIH0sXG4gICAgIGRlc3RydWN0aXZlQnV0dG9uQ2xpY2tlZDogZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgdmFyIGNvbmZpcm1Qb3B1cCA9ICRpb25pY1BvcHVwLmNvbmZpcm0oe1xuICAgICAgICB0aXRsZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FSRV9ZT1VfU1VSRScpLFxuICAgICAgICB0ZW1wbGF0ZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ1JFU0VUX1BJQ1RVUkVfVEVYVCcpXG4gICAgICB9KTtcbiAgICAgIGNvbmZpcm1Qb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBpZihyZXMpIHtcbiAgICAgICAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCAmJiAhJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVBY3RpdmVLZXkpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMX0EnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSB7cHJvZmlsZToge3Byb2ZpbGVfaW1hZ2U6XCJcIn0gfTtcbiAgICAgICAgICAgIGFuZ3VsYXIubWVyZ2UodXBkYXRlLCAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICAgICBpZiAodXBkYXRlLnByb2ZpbGVQaWNVcmwpIHtkZWxldGUgdXBkYXRlLnByb2ZpbGVQaWNVcmw7fVxuXG4gICAgICAgICAgICB1cGRhdGUucHJvZmlsZS5wcm9maWxlX2ltYWdlID0gXCJcIjtcblxuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgc3VyZScpO1xuICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbiA9IG5ldyB3aW5kb3dbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIkpTXCJdLkxvZ2luKCk7XG4gICAgICAgICAgICAgICRzY29wZS5teWxvZ2luLnNldFJvbGVzKFtcImFjdGl2ZVwiXSk7XG4gICAgICAgICAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSAkc2NvcGUubXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmFjdGl2ZS5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSB8fCBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvL3RvZG86IGlmIGpzb25fbWV0YWRhdGEgYWxyZWFkeSBleGlzdCBtYWtlIHN1cmUgdG8ga2VlcCBpdC5cbiAgICAgICAgICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3dbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIkpTXCJdLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImFjY291bnRfdXBkYXRlXCIsIHtcbiAgICAgICAgICAgICAgICAgIGFjY291bnQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgIG1lbW9fa2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIubWVtb19rZXksXG4gICAgICAgICAgICAgICAgICBqc29uX21ldGFkYXRhOiBKU09OLnN0cmluZ2lmeSh1cGRhdGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcbiAgICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5lcnJvciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgncmVmcmVzaExvY2FsVXNlckRhdGEnKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTF9BJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgbm90IHN1cmUnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgfVxuICAgfSk7XG4gIH07XG5cblxuICAkc2NvcGUuY2hhbmdlUHJvZmlsZUluZm8gPSBmdW5jdGlvbih0eXBlLCB3aGljaCkge1xuICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkICYmICEkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSkge1xuICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUxfQScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICh0eXBlID09IDAgfHwgdHlwZSA9PSAxKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgcXVhbGl0eTogNTAsXG4gICAgICAgICAgZGVzdGluYXRpb25UeXBlOiBDYW1lcmEuRGVzdGluYXRpb25UeXBlLkZJTEVfVVJJLFxuICAgICAgICAgIHNvdXJjZVR5cGU6ICh0eXBlPT09MCk/Q2FtZXJhLlBpY3R1cmVTb3VyY2VUeXBlLkNBTUVSQTpDYW1lcmEuUGljdHVyZVNvdXJjZVR5cGUuUEhPVE9MSUJSQVJZLFxuICAgICAgICAgIGFsbG93RWRpdDogKHR5cGU9PT0wKT90cnVlOmZhbHNlLFxuICAgICAgICAgIGVuY29kaW5nVHlwZTogQ2FtZXJhLkVuY29kaW5nVHlwZS5KUEVHLFxuICAgICAgICAgIHRhcmdldFdpZHRoOiB3aGljaD09PSdwcm9maWxlJz81MDA6MTAwMCxcbiAgICAgICAgICB0YXJnZXRIZWlnaHQ6IDUwMCxcbiAgICAgICAgICBwb3BvdmVyT3B0aW9uczogQ2FtZXJhUG9wb3Zlck9wdGlvbnMsXG4gICAgICAgICAgc2F2ZVRvUGhvdG9BbGJ1bTogZmFsc2VcbiAgICAgICAgICAvL2NvcnJlY3RPcmllbnRhdGlvbjp0cnVlXG4gICAgICAgIH07XG4gICAgICAgICRjb3Jkb3ZhQ2FtZXJhLmdldFBpY3R1cmUob3B0aW9ucykudGhlbihmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICAgICAgICBJbWFnZVVwbG9hZFNlcnZpY2UudXBsb2FkSW1hZ2UoaW1hZ2VEYXRhKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgLy92YXIgdXJsID0gcmVzdWx0LnNlY3VyZV91cmwgfHwgJyc7XG4gICAgICAgICAgICB2YXIgdXJsID0gcmVzdWx0LmltYWdlVXJsIHx8ICcnO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IHsgcHJvZmlsZTogeyBjb3Zlcl9pbWFnZTogXCJcIiwgcHJvZmlsZV9pbWFnZTogXCJcIn0gfTtcbiAgICAgICAgICAgIGlmICh3aGljaCA9PT0gJ3Byb2ZpbGUnKSB7XG4gICAgICAgICAgICAgIGFuZ3VsYXIubWVyZ2UodXBkYXRlLCAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICAgICAgIGlmICh1cGRhdGUucHJvZmlsZVBpY1VybCkge2RlbGV0ZSB1cGRhdGUucHJvZmlsZVBpY1VybDt9XG4gICAgICAgICAgICAgIHVwZGF0ZS5wcm9maWxlLnByb2ZpbGVfaW1hZ2UgPSB1cmw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbmd1bGFyLm1lcmdlKHVwZGF0ZSwgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEpO1xuICAgICAgICAgICAgICB1cGRhdGUucHJvZmlsZS5jb3Zlcl9pbWFnZSA9IHVybDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgICAgICRzY29wZS5teWxvZ2luID0gbmV3IHdpbmRvd1skcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluK1wiSlNcIl0uTG9naW4oKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbi5zZXRSb2xlcyhbXCJhY3RpdmVcIl0pO1xuICAgICAgICAgICAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSAkc2NvcGUubXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuYWN0aXZlLmtleV9hdXRoc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgdmFyIHRyID0gbmV3IHdpbmRvd1skcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluK1wiSlNcIl0uVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJhY2NvdW50X3VwZGF0ZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbWVtb19rZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5tZW1vX2tleSxcbiAgICAgICAgICAgICAgICAgICAganNvbl9tZXRhZGF0YTogSlNPTi5zdHJpbmdpZnkodXBkYXRlKVxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG5cbiAgICAgICAgICAgICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24oJHNjb3BlLm15bG9naW4sIG51bGwsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0JST0FEQ0FTVF9FUlJPUicpK1wiIFwiK2xvY2FsU3RvcmFnZS5lcnJvcm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgncmVmcmVzaExvY2FsVXNlckRhdGEnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMX0EnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX1RPX1gnKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDUpO1xuICAgICAgICAgICAgaWYgKCFpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSB8fCAhaW9uaWMuUGxhdGZvcm0uaXNXaW5kb3dzUGhvbmUoKSkge1xuICAgICAgICAgICAgICAkY29yZG92YUNhbWVyYS5jbGVhbnVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVVBMT0FEX0VSUk9SJykpO1xuICAgICAgICAgICAgaWYgKCFpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSB8fCAhaW9uaWMuUGxhdGZvcm0uaXNXaW5kb3dzUGhvbmUoKSkge1xuICAgICAgICAgICAgICAkY29yZG92YUNhbWVyYS5jbGVhbnVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FNRVJBX0NBTkNFTExFRCcpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkaW9uaWNQb3B1cC5wcm9tcHQoe1xuICAgICAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VUX1VSTCcpLFxuICAgICAgICAgIHRlbXBsYXRlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRElSRUNUX0xJTktfUElDVFVSRScpLFxuICAgICAgICAgIGlucHV0VHlwZTogJ3RleHQnLFxuICAgICAgICAgIGlucHV0UGxhY2Vob2xkZXI6ICdodHRwOi8vZXhhbXBsZS5jb20vaW1hZ2UuanBnJ1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3VyIHVybCBpcycrIHJlcyk7XG4gICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IHsgcHJvZmlsZTogeyBwcm9maWxlX2ltYWdlOiBcIlwiLCBjb3Zlcl9pbWFnZTpcIlwiIH0gfTtcbiAgICAgICAgICAgIGlmICh3aGljaD09PVwicHJvZmlsZVwiKSB7XG4gICAgICAgICAgICAgIGFuZ3VsYXIubWVyZ2UodXBkYXRlLCAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICAgICAgIGlmICh1cGRhdGUucHJvZmlsZVBpY1VybCkge2RlbGV0ZSB1cGRhdGUucHJvZmlsZVBpY1VybDt9XG4gICAgICAgICAgICAgIHVwZGF0ZS5wcm9maWxlLnByb2ZpbGVfaW1hZ2UgPSByZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbmd1bGFyLm1lcmdlKHVwZGF0ZSwgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEpO1xuICAgICAgICAgICAgICB1cGRhdGUucHJvZmlsZS5jb3Zlcl9pbWFnZSA9IHJlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgICAgICRzY29wZS5teWxvZ2luID0gbmV3IHdpbmRvd1skcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluK1wiSlNcIl0uTG9naW4oKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbi5zZXRSb2xlcyhbXCJhY3RpdmVcIl0pO1xuICAgICAgICAgICAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSAkc2NvcGUubXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuYWN0aXZlLmtleV9hdXRoc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgdmFyIHRyID0gbmV3IHdpbmRvd1skcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluK1wiSlNcIl0uVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJhY2NvdW50X3VwZGF0ZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbWVtb19rZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5tZW1vX2tleSxcbiAgICAgICAgICAgICAgICAgICAganNvbl9tZXRhZGF0YTogSlNPTi5zdHJpbmdpZnkodXBkYXRlKVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuICAgICAgICAgICAgICAgICAgdHIucHJvY2Vzc190cmFuc2FjdGlvbigkc2NvcGUubXlsb2dpbiwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0JST0FEQ0FTVF9FUlJPUicpK1wiIFwiK2xvY2FsU3RvcmFnZS5lcnJvcm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8kc2NvcGUucmVmcmVzaExvY2FsVXNlckRhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3JlZnJlc2hMb2NhbFVzZXJEYXRhJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTF9BJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX1RPX1gnKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5zaG93Q292ZXIgPSBmdW5jdGlvbigpIHtcbiAgIHZhciBoaWRlU2hlZXQgPSAkaW9uaWNBY3Rpb25TaGVldC5zaG93KHtcbiAgICAgYnV0dG9uczogW1xuICAgICAgIHsgdGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0NBUFRVUkVfUElDVFVSRScpIH0sXG4gICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VMRUNUX1BJQ1RVUkUnKSB9LFxuICAgICAgIHsgdGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFVF9DVVNUT01fVVJMJykgfSxcbiAgICAgXSxcbiAgICAgZGVzdHJ1Y3RpdmVUZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUkVTRVQnKSxcbiAgICAgdGl0bGVUZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTU9ESUZZX0NPVkVSX1BJQ1RVUkUnKSxcbiAgICAgY2FuY2VsVGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0NBTkNFTCcpLFxuICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBhZGQgY2FuY2VsIGNvZGUuLlxuICAgICAgfSxcbiAgICAgYnV0dG9uQ2xpY2tlZDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkICYmICEkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSkge1xuICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTF9BJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHNjb3BlLmNoYW5nZVByb2ZpbGVJbmZvKGluZGV4LCAnY292ZXInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgICB9LFxuICAgICBkZXN0cnVjdGl2ZUJ1dHRvbkNsaWNrZWQ6IGZ1bmN0aW9uKGluZGV4KXtcbiAgICAgIHZhciBjb25maXJtUG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBUkVfWU9VX1NVUkUnKSxcbiAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFQnKVxuICAgICAgfSk7XG4gICAgICBjb25maXJtUG9wdXAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgaWYocmVzKSB7XG4gICAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgJiYgISRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5KSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTF9BJykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlID0ge3Byb2ZpbGU6IHtjb3Zlcl9pbWFnZTpcIlwifSB9O1xuICAgICAgICAgICAgYW5ndWxhci5tZXJnZSh1cGRhdGUsICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgICAgIHVwZGF0ZS5wcm9maWxlLmNvdmVyX2ltYWdlID0gXCJcIjtcblxuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgc3VyZScpO1xuICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbiA9IG5ldyB3aW5kb3dbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIkpTXCJdLkxvZ2luKCk7XG4gICAgICAgICAgICAgICRzY29wZS5teWxvZ2luLnNldFJvbGVzKFtcImFjdGl2ZVwiXSk7XG4gICAgICAgICAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSAkc2NvcGUubXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmFjdGl2ZS5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSB8fCBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvL3RvZG86IGlmIGpzb25fbWV0YWRhdGEgYWxyZWFkeSBleGlzdCBtYWtlIHN1cmUgdG8ga2VlcCBpdC5cbiAgICAgICAgICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3dbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIkpTXCJdLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImFjY291bnRfdXBkYXRlXCIsIHtcbiAgICAgICAgICAgICAgICAgIGFjY291bnQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgIG1lbW9fa2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIubWVtb19rZXksXG4gICAgICAgICAgICAgICAgICBqc29uX21ldGFkYXRhOiBKU09OLnN0cmluZ2lmeSh1cGRhdGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcbiAgICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5lcnJvciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgncmVmcmVzaExvY2FsVXNlckRhdGEnKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTF9BJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgbm90IHN1cmUnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgfVxuICAgfSk7XG4gIH07XG5cblxuICAkcm9vdFNjb3BlLiRvbigncHJvZmlsZVJlZnJlc2gnLCBmdW5jdGlvbigpe1xuICAgICRzY29wZS5yZWZyZXNoKCk7XG4gIH0pO1xuICAkc2NvcGUudXB2b3RlUG9zdCA9IGZ1bmN0aW9uKHBvc3QpIHtcbiAgICAkcm9vdFNjb3BlLnZvdGVQb3N0KHBvc3QsICd1cHZvdGUnLCAncHJvZmlsZVJlZnJlc2gnKTtcbiAgfTtcbiAgJHNjb3BlLmRvd252b3RlUG9zdCA9IGZ1bmN0aW9uKHBvc3QpIHtcbiAgICB2YXIgY29uZmlybVBvcHVwID0gJGlvbmljUG9wdXAuY29uZmlybSh7XG4gICAgICB0aXRsZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FSRV9ZT1VfU1VSRScpLFxuICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdGTEFHR0lOR19URVhUJylcbiAgICB9KTtcbiAgICBjb25maXJtUG9wdXAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgIGlmKHJlcykge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBzdXJlJyk7XG4gICAgICAgICRyb290U2NvcGUudm90ZVBvc3QocG9zdCwgJ2Rvd252b3RlJywgJ3Byb2ZpbGVSZWZyZXNoJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBub3Qgc3VyZScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICAkc2NvcGUudW52b3RlUG9zdCA9IGZ1bmN0aW9uKHBvc3QpIHtcbiAgICAkcm9vdFNjb3BlLnZvdGVQb3N0KHBvc3QsICd1bnZvdGUnLCAncHJvZmlsZVJlZnJlc2gnKTtcbiAgfTtcblxuICAkc2NvcGUuaXNGb2xsb3dpbmcgPSBmdW5jdGlvbih4eCkge1xuICAgIGlmICgkc2NvcGUuZm9sbG93aW5nICYmICRzY29wZS5mb2xsb3dpbmcuaW5kZXhPZih4eCkhPT0tMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gICRzY29wZS5pZkV4aXN0cyA9IGZ1bmN0aW9uKHh4KXtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8ICRzY29wZS5kYXRhLnByb2ZpbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgkc2NvcGUuZGF0YS5wcm9maWxlW2ldLnBlcm1saW5rID09PSB4eCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgJHNjb3BlLmVuZCA9IGZhbHNlO1xuICAkc2NvcGUuY2xlbiA9IDIwO1xuICAkc2NvcGUubW9yZURhdGFDYW5CZUxvYWRlZCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICgkc2NvcGUuZGF0YS5wcm9maWxlICYmICRzY29wZS5kYXRhLnByb2ZpbGUubGVuZ3RoPjApICYmICEkc2NvcGUuZW5kO1xuICB9XG5cbiAgJHNjb3BlLmxvYWRtb3JlID0gZnVuY3Rpb24oKSB7XG4gICAgLy9jb25zb2xlLmxvZygnbG9hZG1vcmUnKTtcbiAgICB2YXIgcGFyYW1zID0ge3RhZzogJHN0YXRlUGFyYW1zLnVzZXJuYW1lLCBsaW1pdDogMjB9O1xuICAgIHZhciBsZW4gPSAkc2NvcGUuZGF0YS5wcm9maWxlPyRzY29wZS5kYXRhLnByb2ZpbGUubGVuZ3RoOjA7XG5cbiAgICAvL2NvbnNvbGUubG9nKCRzY29wZS5kYXRhLnByb2ZpbGUpO1xuXG4gICAgaWYgKGxlbj4wKSB7XG4gICAgICBwYXJhbXMuc3RhcnRfYXV0aG9yID0gJHNjb3BlLmRhdGEucHJvZmlsZVtsZW4tMV0uYXV0aG9yO1xuICAgICAgcGFyYW1zLnN0YXJ0X3Blcm1saW5rID0gJHNjb3BlLmRhdGEucHJvZmlsZVtsZW4tMV0ucGVybWxpbms7XG5cbiAgICAgIGlmICgkc2NvcGUuZW5kKSB7XG4gICAgICAgIC8vJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdSRVFVRVNUX0xJTUlUX1RFWFQnKSk7XG4gICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwuaW5maW5pdGVTY3JvbGxDb21wbGV0ZScpO1xuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhwYXJhbXMpO1xuICAgICAgICAvLyRyb290U2NvcGUubG9nKFwiZmV0Y2hpbmcgcHJvZmlsZS4uLmJsb2cgMjAgXCIpO1xuICAgICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICgkc2NvcGUuYWN0aXZlID09ICdibG9nJykge1xuICAgICAgICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfZGlzY3Vzc2lvbnNfYnlfYmxvZ1wiLCBbcGFyYW1zXSkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVzcG9uc2UubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSByZXNwb25zZVtqXTtcbiAgICAgICAgICAgICAgICAgICAgdi5qc29uX21ldGFkYXRhID0gdi5qc29uX21ldGFkYXRhP2FuZ3VsYXIuZnJvbUpzb24odi5qc29uX21ldGFkYXRhKTp2Lmpzb25fbWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgICEkc2NvcGUuJCRwaGFzZT8kc2NvcGUuJGFwcGx5KCk6Y29uc29sZS5sb2coJ3BoYXNlZCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9ICRzY29wZS5kYXRhLnByb2ZpbGUubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5kYXRhLnByb2ZpbGVbaV0uaWQgPT09IHYuaWQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygkc2NvcGUuZGF0YS5wcm9maWxlW2ldLmlkLCB2LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCl7XG4gICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh2LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5wcm9maWxlLnB1c2godik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5pbmZpbml0ZVNjcm9sbENvbXBsZXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJHNjb3BlLmFjdGl2ZSA9PSAncG9zdHMnKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9kaXNjdXNzaW9uc19ieV9jb21tZW50c1wiLCBbcGFyYW1zXSkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVzcG9uc2UubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSByZXNwb25zZVtqXTtcbiAgICAgICAgICAgICAgICAgICAgdi5qc29uX21ldGFkYXRhID0gdi5qc29uX21ldGFkYXRhP2FuZ3VsYXIuZnJvbUpzb24odi5qc29uX21ldGFkYXRhKTp2Lmpzb25fbWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgICEkc2NvcGUuJCRwaGFzZT8kc2NvcGUuJGFwcGx5KCk6Y29uc29sZS5sb2coJ3BoYXNlZCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9ICRzY29wZS5kYXRhLnByb2ZpbGUubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5kYXRhLnByb2ZpbGVbaV0uaWQgPT09IHYuaWQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygkc2NvcGUuZGF0YS5wcm9maWxlW2ldLmlkLCB2LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCl7XG4gICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh2LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5wcm9maWxlLnB1c2godik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5pbmZpbml0ZVNjcm9sbENvbXBsZXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJHNjb3BlLmFjdGl2ZSA9PSAncmVjZW50LXJlcGxpZXMnKSB7XG4gICAgICAgICAgICAgIHZhciBwcCA9IFskc2NvcGUuZGF0YS5wcm9maWxlWyRzY29wZS5kYXRhLnByb2ZpbGUubGVuZ3RoLTFdLmF1dGhvciwgJHNjb3BlLmRhdGEucHJvZmlsZVskc2NvcGUuZGF0YS5wcm9maWxlLmxlbmd0aC0xXS5wZXJtbGluaywgMjBdO1xuICAgICAgICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfcmVwbGllc19ieV9sYXN0X3VwZGF0ZVwiLCBbcHBdKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVzcG9uc2UubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSByZXNwb25zZVtqXTtcbiAgICAgICAgICAgICAgICAgICAgdi5qc29uX21ldGFkYXRhID0gdi5qc29uX21ldGFkYXRhP2FuZ3VsYXIuZnJvbUpzb24odi5qc29uX21ldGFkYXRhKTp2Lmpzb25fbWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgICEkc2NvcGUuJCRwaGFzZT8kc2NvcGUuJGFwcGx5KCk6Y29uc29sZS5sb2coJ3BoYXNlZCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9ICRzY29wZS5kYXRhLnByb2ZpbGUubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5kYXRhLnByb2ZpbGVbaV0uaWQgPT09IHYuaWQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygkc2NvcGUuZGF0YS5wcm9maWxlW2ldLmlkLCB2LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCl7XG4gICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh2LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5wcm9maWxlLnB1c2godik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5pbmZpbml0ZVNjcm9sbENvbXBsZXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCRzY29wZS5wcm9maWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICB9XG4gICRzY29wZS4kb24oJyRpb25pY1ZpZXcuYmVmb3JlRW50ZXInLCBmdW5jdGlvbigpe1xuICAgICRzY29wZS51c2VyID0ge3VzZXJuYW1lOiAkc3RhdGVQYXJhbXMudXNlcm5hbWV9O1xuICAgICRzY29wZS5mb2xsb3dlciA9IFtdO1xuICAgICRzY29wZS5mb2xsb3dpbmcgPSBbXTtcbiAgICAkc2NvcGUubGltaXQgPSAxMDA7XG4gICAgJHNjb3BlLnR0ID0ge2R1c2VyOiBcIlwiLCBydXNlcjogXCJcIn07XG5cbiAgICAkc2NvcGUucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCEkc2NvcGUuYWN0aXZlKSB7XG4gICAgICAgICRzY29wZS5hY3RpdmUgPSBcImJsb2dcIjtcbiAgICAgIH1cbiAgICAgIGlmICgkc2NvcGUuYWN0aXZlICE9IFwiYmxvZ1wiKSB7XG4gICAgICAgICRzY29wZS5yZXN0ID0gXCIvXCIrJHNjb3BlLmFjdGl2ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRzY29wZS5yZXN0ID0gXCJcIjtcbiAgICAgIH1cblxuICAgICAgJHNjb3BlLm5vbmV4aXN0ID0gZmFsc2U7XG4gICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X3N0YXRlXCIsIFtcIi9AXCIrJHN0YXRlUGFyYW1zLnVzZXJuYW1lKyRzY29wZS5yZXN0XSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICRzY29wZS5kYXRhID0ge3Byb2ZpbGU6IFtdfTtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKHJlcyk7XG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlcy5jb250ZW50KS5sZW5ndGg+MCkge1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlcy5jb250ZW50LCBmdW5jdGlvbih2LGspe1xuICAgICAgICAgICAgICB2Lmpzb25fbWV0YWRhdGEgPSB2Lmpzb25fbWV0YWRhdGE/YW5ndWxhci5mcm9tSnNvbih2Lmpzb25fbWV0YWRhdGEpOnYuanNvbl9tZXRhZGF0YTtcbiAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcil7XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSAhPT0gdi5hdXRob3IpIHtcbiAgICAgICAgICAgICAgICAgIHYucmVibG9nZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IHYuYWN0aXZlX3ZvdGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gbGVuIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2LmFjdGl2ZV92b3Rlc1tqXS52b3RlciA9PT0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2LmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHYudXB2b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodi5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB2LmRvd252b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdi51cHZvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgdi5kb3dudm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5wcm9maWxlLnB1c2godik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzY29wZS5ub25leGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2NvcGUubm9uZXhpc3QgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgICRzY29wZS5nZXRGb2xsb3dzID0gZnVuY3Rpb24ocixkKSB7XG5cbiAgICAgICRzY29wZS5kZmV0Y2hpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICB3aW5kb3cuQXBpLmZvbGxvd19hcGkoKS5leGVjKFwiZ2V0X2ZvbGxvd2luZ1wiLCBbJHN0YXRlUGFyYW1zLnVzZXJuYW1lLCAkc2NvcGUudHQuZHVzZXIsIFwiYmxvZ1wiLCAkc2NvcGUubGltaXRdKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgICBpZiAocmVzICYmIHJlcy5sZW5ndGg9PT0kc2NvcGUubGltaXQpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLnR0LmR1c2VyID0gcmVzW3Jlcy5sZW5ndGgtMV0uZm9sbG93aW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICRzY29wZS5mb2xsb3dpbmcucHVzaChyZXNbaV0uZm9sbG93aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXMubGVuZ3RoPCRzY29wZS5saW1pdCkge1xuICAgICAgICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCRzY29wZS5kZmV0Y2hpbmcsIDUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICAkc2NvcGUucmZldGNoaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgd2luZG93LkFwaS5mb2xsb3dfYXBpKCkuZXhlYyhcImdldF9mb2xsb3dlcnNcIiwgWyRzdGF0ZVBhcmFtcy51c2VybmFtZSwgJHNjb3BlLnR0LnJ1c2VyLCBcImJsb2dcIiwgJHNjb3BlLmxpbWl0XSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgaWYgKHJlcyAmJiByZXMubGVuZ3RoPT09JHNjb3BlLmxpbWl0KSB7XG4gICAgICAgICAgICAgICRzY29wZS50dC5ydXNlciA9IHJlc1tyZXMubGVuZ3RoLTFdLmZvbGxvd2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICRzY29wZS5mb2xsb3dlci5wdXNoKHJlc1tpXS5mb2xsb3dlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzLmxlbmd0aDwkc2NvcGUubGltaXQpIHtcbiAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgkc2NvcGUucmZldGNoaW5nLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgICRyb290U2NvcGUubG9nKFwicmZldGNoaW5nXCIpO1xuICAgICAgICAkc2NvcGUucmZldGNoaW5nKCk7XG5cbiAgICAgIH1cbiAgICAgIGlmIChkKSB7XG4gICAgICAgICRyb290U2NvcGUubG9nKFwiZGZldGNoaW5nXCIpO1xuICAgICAgICAkc2NvcGUuZGZldGNoaW5nKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICAkc2NvcGUuZ2V0T3RoZXJVc2Vyc0RhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCJnZXRPdGhlclVzZXJzRGF0YVwiKTtcbiAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfYWNjb3VudHNcIiwgW1skc3RhdGVQYXJhbXMudXNlcm5hbWVdXSkudGhlbihmdW5jdGlvbihkZCl7XG4gICAgICAgICAgZGQgPSBkZFswXTtcbiAgICAgICAgICBpZiAoZGQgJiYgZGQuanNvbl9tZXRhZGF0YSkge1xuICAgICAgICAgICAgZGQuanNvbl9tZXRhZGF0YSA9IGFuZ3VsYXIuZnJvbUpzb24oZGQuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFuZ3VsYXIubWVyZ2UoJHNjb3BlLnVzZXIsIGRkKTtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKGFuZ3VsYXIudG9Kc29uKCRzY29wZS51c2VyKSk7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZygkc2NvcGUudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuY292ZXJfaW1hZ2UpO1xuXG4gICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgJHNjb3BlLmNzcyA9ICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgPT09ICRzY29wZS51c2VyLnVzZXJuYW1lICYmICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuY292ZXJfaW1hZ2UpID8geydiYWNrZ3JvdW5kJzogJ3VybCgnKyRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuY292ZXJfaW1hZ2UrJyknLCAnYmFja2dyb3VuZC1zaXplJzogJ2NvdmVyJywgJ2JhY2tncm91bmQtcG9zaXRpb24nOidmaXhlZCd9IDogKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSAhPT0gJHNjb3BlLnVzZXIudXNlcm5hbWUgJiYgKCRzY29wZS51c2VyLmpzb25fbWV0YWRhdGEgJiYgJHNjb3BlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmNvdmVyX2ltYWdlKSkgPyB7J2JhY2tncm91bmQnOiAndXJsKCcrJHNjb3BlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmNvdmVyX2ltYWdlKycpJywgJ2JhY2tncm91bmQtc2l6ZSc6ICdjb3ZlcicsICdiYWNrZ3JvdW5kLXBvc2l0aW9uJzonZml4ZWQnfSA6IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzY29wZS5jc3MgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICAgICAgd2luZG93LkFwaS5mb2xsb3dfYXBpKCkuZXhlYyhcImdldF9mb2xsb3dfY291bnRcIiwgWyRzdGF0ZVBhcmFtcy51c2VybmFtZV0pLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKHJlcyk7XG4gICAgICAgICAgJHNjb3BlLmZvbGxvd2RldGFpbHMgPSByZXM7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAkc2NvcGUuZ2V0Rm9sbG93cyhudWxsLCBcImRcIik7XG4gICAgICBpZighJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgICRzY29wZS5yZWZyZXNoKCk7XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSAhPT0gJHN0YXRlUGFyYW1zLnVzZXJuYW1lKSB7XG4gICAgICAgICRzY29wZS5nZXRPdGhlclVzZXJzRGF0YSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcImdldCBmb2xsb3dzIGNvdW50c1wiKTtcbiAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbiA9PSBcInN0ZWVtXCIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICB3aW5kb3cuQXBpLmZvbGxvd19hcGkoKS5leGVjKFwiZ2V0X2ZvbGxvd19jb3VudFwiLCBbJHN0YXRlUGFyYW1zLnVzZXJuYW1lXSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocmVzKTtcbiAgICAgICAgICAgICAgICAkc2NvcGUuZm9sbG93ZGV0YWlscyA9IHJlcztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLmdldEZvbGxvd3MoXCJyXCIsXCJkXCIpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLmZvbGxvd2RldGFpbHMgPSB7Zm9sbG93ZXJfY291bnQ6ICRzY29wZS5mb2xsb3dlci5sZW5ndGgsIGZvbGxvd2luZ19jb3VudDogJHNjb3BlLmZvbGxvd2luZy5sZW5ndGh9OyBcbiAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH0sIDIwMDApOyAgICAgICAgICAgIFxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCRzdGF0ZVBhcmFtcy51c2VybmFtZSkge1xuICAgICAgICAkc2NvcGUuZ2V0T3RoZXJVc2Vyc0RhdGEoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL3NldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUuY3NzID0gKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlciYmICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSA9PT0gJHNjb3BlLnVzZXIudXNlcm5hbWUgJiYgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEgJiYgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZSAmJiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmNvdmVyX2ltYWdlKSA/IHsnYmFja2dyb3VuZCc6ICd1cmwoJyskcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmNvdmVyX2ltYWdlKycpJywgJ2JhY2tncm91bmQtc2l6ZSc6ICdjb3ZlcicsICdiYWNrZ3JvdW5kLXBvc2l0aW9uJzonZml4ZWQnfSA6ICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgJiYgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lICE9PSAkc2NvcGUudXNlci51c2VybmFtZSAmJiAoJHNjb3BlLnVzZXIuanNvbl9tZXRhZGF0YSAmJiAkc2NvcGUudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUgJiYgJHNjb3BlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmNvdmVyX2ltYWdlKSkgPyB7J2JhY2tncm91bmQnOiAndXJsKCcrJHNjb3BlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmNvdmVyX2ltYWdlKycpJywgJ2JhY2tncm91bmQtc2l6ZSc6ICdjb3ZlcicsICdiYWNrZ3JvdW5kLXBvc2l0aW9uJzonZml4ZWQnfSA6IG51bGw7XG4gICAgICAvL2NvbnNvbGUubG9nKCRzY29wZS5jc3MpO1xuICAgIC8vfSwgMSk7XG5cbiAgfSk7XG4gICRzY29wZS5vcGVuTWVudSA9IGZ1bmN0aW9uKCkge1xuICAgICRpb25pY1NpZGVNZW51RGVsZWdhdGUudG9nZ2xlTGVmdCgpO1xuICB9XG4gICRzY29wZS5jaGFuZ2UgPSBmdW5jdGlvbih0eXBlKXtcbiAgICAkc2NvcGUuZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAkc2NvcGUuZGF0YSA9IHtwcm9maWxlOiBbXX07XG4gICAgJHNjb3BlLmFjY291bnRzID0gW107XG4gICAgJHNjb3BlLmFjdGl2ZSA9IHR5cGU7XG4gICAgJHNjb3BlLmVuZCA9IGZhbHNlO1xuICAgIGlmICh0eXBlICE9IFwiYmxvZ1wiKSB7XG4gICAgICAkc2NvcGUucmVzdCA9IFwiL1wiK3R5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzY29wZS5yZXN0ID0gXCJcIjtcbiAgICB9XG4gICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfc3RhdGVcIiwgW1wiL0BcIiskc3RhdGVQYXJhbXMudXNlcm5hbWUrJHNjb3BlLnJlc3RdKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgIC8vY29uc29sZS5sb2cocmVzKTtcbiAgICAgICAgaWYgKHJlcy5jb250ZW50KSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlcy5jb250ZW50KS5sZW5ndGg+MCkge1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlcy5jb250ZW50LCBmdW5jdGlvbih2LGspe1xuICAgICAgICAgICAgICB2Lmpzb25fbWV0YWRhdGEgPSB2Lmpzb25fbWV0YWRhdGE/YW5ndWxhci5mcm9tSnNvbih2Lmpzb25fbWV0YWRhdGEpOnYuanNvbl9tZXRhZGF0YTtcbiAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcil7XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSAhPT0gdi5hdXRob3IpIHtcbiAgICAgICAgICAgICAgICAgIHYucmVibG9nZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IHYuYWN0aXZlX3ZvdGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gbGVuIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2LmFjdGl2ZV92b3Rlc1tqXS52b3RlciA9PT0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2LmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHYudXB2b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodi5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB2LmRvd252b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdi51cHZvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgdi5kb3dudm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5wcm9maWxlLnB1c2godik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzY29wZS5ub25leGlzdCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2NvcGUubm9uZXhpc3QgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZighJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZT09PVwidHJhbnNmZXJzXCIgfHwgdHlwZT09PVwicGVybWlzc2lvbnNcIikge1xuICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHJlcy5hY2NvdW50cykge1xuICAgICAgICAgICAgaWYgKHJlcy5hY2NvdW50cy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLmFjY291bnRzID0gcmVzLmFjY291bnRzW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgLy8kcm9vdFNjb3BlLmxvZyhhbmd1bGFyLnRvSnNvbihyZXMuYWNjb3VudHNbcHJvcGVydHldLnRyYW5zZmVyX2hpc3RvcnkpKTtcbiAgICAgICAgICAgICAgJHNjb3BlLnRyYW5zZmVycyA9IHJlcy5hY2NvdW50c1twcm9wZXJ0eV0udHJhbnNmZXJfaGlzdG9yeTtcbiAgICAgICAgICAgICAgJHNjb3BlLm5vbmV4aXN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG59KVxuXG5hcHAuY29udHJvbGxlcignRXhjaGFuZ2VDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRyb290U2NvcGUpIHtcbiAgJHNjb3BlLnVzZXJuYW1lID0gJHN0YXRlUGFyYW1zLnVzZXJuYW1lO1xuXG4gICRzY29wZS4kb24oJyRpb25pY1ZpZXcuYmVmb3JlRW50ZXInLCBmdW5jdGlvbigpe1xuICAgICRzY29wZS5hY3RpdmUgPSAnYnV5JztcbiAgICAkc2NvcGUub3JkZXJzID0gW107XG4gICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfb3JkZXJfYm9va1wiLCBbMTVdKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICRzY29wZS5vcmRlcnMgPSByZXM7XG4gICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgICRzY29wZS5jaGFuZ2UgPSBmdW5jdGlvbih0eXBlKXtcbiAgICAgICRzY29wZS5hY3RpdmUgPSB0eXBlO1xuICAgICAgaWYgKHR5cGUgPT0gXCJvcGVuXCIpe1xuICAgICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfb3Blbl9vcmRlcnNcIiwgWyRzdGF0ZVBhcmFtcy51c2VybmFtZV0pLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgICRzY29wZS5vcGVub3JkZXJzID0gcmVzO1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gXCJoaXN0b3J5XCIpe1xuICAgICAgICAkc2NvcGUuaGlzdG9yeSA9IFtdO1xuICAgICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICB3aW5kb3cuQXBpLm1hcmtldF9oaXN0b3J5X2FwaSgpLmV4ZWMoXCJnZXRfcmVjZW50X3RyYWRlc1wiLCBbMTVdKS50aGVuKGZ1bmN0aW9uKHIpe1xuICAgICAgICAgICAgJHNjb3BlLnJlY2VudF90cmFkZXMgPSByO1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG59KTtcbmFwcC5jb250cm9sbGVyKCdNYXJrZXRDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkcm9vdFNjb3BlLCAkc3RhdGUsICRpb25pY1BvcG92ZXIsICRpb25pY1BvcHVwLCAkZmlsdGVyLCAkdHJhbnNsYXRlLCAkaW9uaWNQbGF0Zm9ybSwgJHdpbmRvdykge1xuXG4gICRzY29wZS5yZXF1ZXN0QXBwID0gZnVuY3Rpb24obmFtZSkge1xuICAgICRpb25pY1BsYXRmb3JtLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKG5hbWUgPT0gJ05ldycpIHtcbiAgICAgICAgd2luZG93Lm9wZW4oXCJtYWlsdG86aW5mb0Blc3RlZW0ud3M/c3ViamVjdD1TdWdnZXN0aW5nJTIwTmV3JTIwQXBwJTIwZm9yJTIwTWFya2V0JTIwUGxhY2UmYm9keT1IZWxsbyElMEQlMEElMEQlMEFBcHBOYW1lOiUwRCUwQUFwcEF1dGhvcjolMEQlMEFBcHBMaW5rOiUwRCUwQSUwRCUwQVwiLCBcIl9zeXN0ZW1cIik7XG4gICAgICB9XG4gICAgICBpZiAoaW9uaWMuUGxhdGZvcm0uaXNJT1MoKSB8fCBpb25pYy5QbGF0Zm9ybS5pc0lQYWQoKSkge1xuICAgICAgICBpZiAobmFtZSA9PSAnU3RlZW1Nb25pdG9yJykge1xuICAgICAgICAgIC8vY29yZG92YS5wbHVnaW5zLm1hcmtldC5vcGVuKCdpZDExNTg5MTg2OTAnKTtcbiAgICAgICAgICB3aW5kb3cub3BlbihcIml0bXMtYXBwczovL2l0dW5lcy5hcHBsZS5jb20vYXBwL2lkMTE1ODkxODY5MFwiLCBcIl9zeXN0ZW1cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT0gJ1N0ZWVtRmVzdCcpIHtcbiAgICAgICAgICAvL2NvcmRvdmEucGx1Z2lucy5tYXJrZXQub3BlbignaWQxMTcxMzcxNzA4Jyk7XG4gICAgICAgICAgd2luZG93Lm9wZW4oXCJpdG1zLWFwcHM6Ly9pdHVuZXMuYXBwbGUuY29tL2FwcC9pZDExNzEzNzE3MDhcIiwgXCJfc3lzdGVtXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobmFtZSA9PSAnU3RlZW1Nb25pdG9yJykge1xuICAgICAgICAgIC8vY29yZG92YS5wbHVnaW5zLm1hcmtldC5vcGVuKCdjb20ubmV0c29sdXRpb25zLmVzdGVlbXdpdG5lc3MnKTtcbiAgICAgICAgICB3aW5kb3cub3BlbihcIm1hcmtldDovL2RldGFpbHM/aWQ9Y29tLm5ldHNvbHV0aW9ucy5lc3RlZW13aXRuZXNzXCIsIFwiX3N5c3RlbVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PSAnU3RlZW1GZXN0Jykge1xuICAgICAgICAgIC8vY29yZG92YS5wbHVnaW5zLm1hcmtldC5vcGVuKCdjb20ubmV0c29sdXRpb25zLnN0ZWVtZmVzdCcpO1xuICAgICAgICAgIHdpbmRvdy5vcGVuKFwibWFya2V0Oi8vZGV0YWlscz9pZD1jb20ubmV0c29sdXRpb25zLnN0ZWVtZmVzdFwiLCBcIl9zeXN0ZW1cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59KTtcblxuYXBwLmNvbnRyb2xsZXIoJ1NldHRpbmdzQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkcm9vdFNjb3BlLCAkaW9uaWNIaXN0b3J5LCAkc3RhdGUsICRpb25pY1BvcG92ZXIsICRpb25pY1BvcHVwLCBBUElzLCAkZmlsdGVyLCAkdHJhbnNsYXRlLCAkd2luZG93LCAkaW9uaWNTaWRlTWVudURlbGVnYXRlKSB7XG5cbiAgICRpb25pY1BvcG92ZXIuZnJvbVRlbXBsYXRlVXJsKCdwb3BvdmVyLmh0bWwnLCB7XG4gICAgICBzY29wZTogJHNjb3BlXG4gICB9KS50aGVuKGZ1bmN0aW9uKHBvcG92ZXIpIHtcbiAgICAgICRzY29wZS50b29sdGlwID0gcG9wb3ZlcjtcbiAgIH0pO1xuXG4gICAkc2NvcGUub3BlblRvb2x0aXAgPSBmdW5jdGlvbigkZXZlbnQsIGQpIHtcbiAgICAgIHZhciB0ZXh0aCA9IGQ7XG4gICAgICAkc2NvcGUudG9vbHRpcFRleHQgPSB0ZXh0aDtcbiAgICAgICRzY29wZS50b29sdGlwLnNob3coJGV2ZW50KTtcbiAgIH07XG5cbiAgZnVuY3Rpb24gZ2V0RGF0ZSh4eCkge1xuICAgIGFuZ3VsYXIuZm9yRWFjaCgkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmNpZXMsIGZ1bmN0aW9uKHYsayl7XG4gICAgICBpZiAodi5pZCA9PSB4eCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaE9iaihuYW1lS2V5LCBteUFycmF5KSB7XG4gICAgZm9yICh2YXIgaT0wOyBpIDwgbXlBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobXlBcnJheVtpXS5pZCA9PT0gbmFtZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG15QXJyYXlbaV07XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICAkc2NvcGUuY2hhbmdlQ3VycmVuY3kgPSBmdW5jdGlvbih4eCwgaWdub3JlKSB7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjaGFuZ2VkQ3VycmVuY3knLCB7Y3VycmVuY3k6IHh4LCBlbmZvcmNlOiBpZ25vcmV9KTtcbiAgfVxuICAkc2NvcGUuY2hhbmdlQ2hhaW4gPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUucmVzdGFydCA9IHRydWU7XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4gPT0gJ3N0ZWVtJyl7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtbmFtZSA9IFwiU3RlZW1cIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1wb3dlciA9IFwiU3RlZW0gUG93ZXJcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1zdW5pdCA9IFwiU3RlZW1cIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1kb2xsYXIgPSBcIlN0ZWVtIERvbGxhclwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWR1bml0ID0gXCJTQkRcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1wdW5pdCA9IFwiU1BcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1sdW5pdCA9IFwiU1RFRU1cIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uuc29ja2V0c3RlZW0gPSBcIndzczovL3N0ZWVtZC5zdGVlbWl0LmNvbVwiO1xuICAgICAgJHNjb3BlLnNvY2tldCA9IFwid3NzOi8vc3RlZW1kLnN0ZWVtaXQuY29tXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1uYW1lID0gXCLQk9Ce0JvQntChXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtcG93ZXIgPSBcItCh0JjQm9CQINCT0J7Qm9Ce0KHQkFwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybXN1bml0ID0gXCLQk9C+0LvQvtGBXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZG9sbGFyID0gXCLQl9Ce0JvQntCi0J7QmVwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWR1bml0ID0gXCJHQkdcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1wdW5pdCA9IFwi0KHQmNCb0JAg0JPQntCb0J7QodCQXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtbHVuaXQgPSBcItCT0J7Qm9Ce0KFcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uuc29ja2V0Z29sb3MgPSBcIndzczovL3dzLmdvbG9zLmlvL1wiO1xuICAgICAgLy8kc2NvcGUuc29ja2V0ID0gXCJ3c3M6Ly9nb2xvcy5zdGVlbS53c1wiO1xuICAgICAgJHNjb3BlLnNvY2tldCA9IFwid3NzOi8vd3MuZ29sb3MuaW8vXCI7XG4gICAgfVxuICAgICRzY29wZS5jaGFuZ2VDdXJyZW5jeSgkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5LCB0cnVlKTtcbiAgfVxuICAkc2NvcGUucmVzdGFydCA9IGZhbHNlO1xuICAkc2NvcGUuY2xvc2VUb29sdGlwID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLnRvb2x0aXAuaGlkZSgpO1xuICB9O1xuXG4gIC8vQ2xlYW51cCB0aGUgcG9wb3ZlciB3aGVuIHdlJ3JlIGRvbmUgd2l0aCBpdCFcbiAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUudG9vbHRpcC5yZW1vdmUoKTtcbiAgfSk7XG5cbiAgJHNjb3BlLmNoYW5nZUxhbmd1YWdlID0gZnVuY3Rpb24obG9jYWxlKXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgJHRyYW5zbGF0ZS51c2UobG9jYWxlKTtcbiAgICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgfVxuICAgICAgLy8kd2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcbiAgICB9LCAxKTtcbiAgfVxuXG4gICRzY29wZS4kb24oJyRpb25pY1ZpZXcuYmVmb3JlRW50ZXInLCBmdW5jdGlvbigpe1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2VbXCJzb2NrZXRcIiskcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluXSA9IGxvY2FsU3RvcmFnZS5zb2NrZXRVcmw7XG4gICAgJHNjb3BlLmRhdGEgPSB7fTtcbiAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2Uudm90ZVdlaWdodCl7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQgPSAxMDAwMDtcbiAgICAgICRzY29wZS52dmFsdWUgPSAxMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzY29wZS52dmFsdWUgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQvMTAwO1xuICAgIH1cbiAgICBpZighJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgICAkc2NvcGUuc2xpZGVyID0ge1xuICAgICAgdmFsdWU6ICRzY29wZS52dmFsdWUsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGZsb29yOiAxLFxuICAgICAgICBjZWlsOiAxMDBcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSkge1xuICAgICAgJHNjb3BlLmRhdGEgPSB7cGluOiB0cnVlfTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjb3BlLmRhdGEgPSB7cGluOiBmYWxzZX07XG4gICAgfVxuXG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlciAmJiAkcm9vdFNjb3BlLiRzdG9yYWdlLmRldmljZWlkKSB7XG4gICAgICBBUElzLmdldFN1YnNjcmlwdGlvbnMoJHJvb3RTY29wZS4kc3RvcmFnZS5kZXZpY2VpZCkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAkcm9vdFNjb3BlLmxvZyhhbmd1bGFyLnRvSnNvbihyZXMuZGF0YSkpO1xuICAgICAgICBhbmd1bGFyLm1lcmdlKCRzY29wZS5kYXRhLCB7dm90ZTogcmVzLmRhdGFbMF0uc3Vic2NyaXB0aW9uLnZvdGUsIGZvbGxvdzogcmVzLmRhdGFbMF0uc3Vic2NyaXB0aW9uLmZvbGxvdywgY29tbWVudDogcmVzLmRhdGFbMF0uc3Vic2NyaXB0aW9uLmNvbW1lbnQsIG1lbnRpb246IHJlcy5kYXRhWzBdLnN1YnNjcmlwdGlvbi5tZW50aW9uLCByZXN0ZWVtOiByZXMuZGF0YVswXS5zdWJzY3JpcHRpb24ucmVzdGVlbX0pO1xuICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgJHNjb3BlLm5vdGlmaWNhdGlvbkNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2Uuc3Vic2NyaXB0aW9uID0ge1xuICAgICAgdm90ZTogJHNjb3BlLmRhdGEudm90ZSxcbiAgICAgIGNvbW1lbnQ6ICRzY29wZS5kYXRhLmNvbW1lbnQsXG4gICAgICBmb2xsb3c6ICRzY29wZS5kYXRhLmZvbGxvdyxcbiAgICAgIG1lbnRpb246ICRzY29wZS5kYXRhLm1lbnRpb24sXG4gICAgICByZXN0ZWVtOiAkc2NvcGUuZGF0YS5yZXN0ZWVtLFxuICAgICAgZGV2aWNlOiBpb25pYy5QbGF0Zm9ybS5wbGF0Zm9ybSgpLFxuICAgICAgdGltZXN0YW1wOiAkZmlsdGVyKCdkYXRlJykobmV3IERhdGUoKSwgJ21lZGl1bScpLFxuICAgICAgYXBwdmVyc2lvbjogJzEuMy45J1xuICAgIH1cbiAgICBBUElzLnVwZGF0ZVN1YnNjcmlwdGlvbigkcm9vdFNjb3BlLiRzdG9yYWdlLmRldmljZWlkLCAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsICRyb290U2NvcGUuJHN0b3JhZ2Uuc3Vic2NyaXB0aW9uKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICBjb25zb2xlLmxvZyhhbmd1bGFyLnRvSnNvbihyZXMpKTtcbiAgICB9KTtcblxuICB9XG5cbiAgJHNjb3BlLiR3YXRjaCgnc2xpZGVyJywgZnVuY3Rpb24obmV3VmFsdWUsIG9sZFZhbHVlKXtcbiAgICAvL2NvbnNvbGUubG9nKG5ld1ZhbHVlLnZhbHVlKTtcbiAgICBpZiAobmV3VmFsdWUudmFsdWUpIHtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uudm90ZVdlaWdodCA9IG5ld1ZhbHVlLnZhbHVlKjEwMDtcbiAgICB9XG4gIH0sIHRydWUpO1xuXG4gICRzY29wZS5waW5DaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAkcm9vdFNjb3BlLmxvZyhcInBpbkNoYW5nZVwiKTtcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5waW5jb2RlKSB7XG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoXCJwaW46Y2hlY2tcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdChcInBpbjpuZXdcIik7XG4gICAgfVxuICB9XG5cbiAgJHJvb3RTY29wZS4kb24oXCJwaW46Y29ycmVjdFwiLCBmdW5jdGlvbigpe1xuICAgICRyb290U2NvcGUubG9nKFwicGluOmNvcnJlY3QgXCIgKyAkc2NvcGUuZGF0YS5waW4pO1xuICAgIGlmICghJHNjb3BlLmRhdGEucGluKSB7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSkge1xuICAgICAgJHNjb3BlLmRhdGEucGluID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjb3BlLmRhdGEucGluID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgJHJvb3RTY29wZS4kb24oXCJwaW46ZmFpbGVkXCIsIGZ1bmN0aW9uKCl7XG4gICAgJHJvb3RTY29wZS5sb2coXCJwaW46ZmFpbGVkXCIpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5waW5jb2RlKSB7XG4gICAgICAgICRzY29wZS5kYXRhLnBpbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkc2NvcGUuZGF0YS5waW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICB9XG4gICAgfSwgMTApO1xuXG4gIH0pO1xuICAkc2NvcGUubG9nb3V0cyA9IGZ1bmN0aW9uKCkge1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2UudXNlciA9IHVuZGVmaW5lZDtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgPSBudWxsO1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2UubXlsb2dpbiA9IHVuZGVmaW5lZDtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLm15bG9naW4gPSBudWxsO1xuICAgIC8vbWFrZSBzdXJlIHVzZXIgY3JlZGVudGlhbHMgY2xlYXJlZC5cbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5kZXZpY2VpZCkge1xuICAgICAgQVBJcy5kZWxldGVTdWJzY3JpcHRpb24oJHJvb3RTY29wZS4kc3RvcmFnZS5kZXZpY2VpZCkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAkaW9uaWNTaWRlTWVudURlbGVnYXRlLnRvZ2dsZUxlZnQoKTtcbiAgICAgICAgJHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGlvbmljU2lkZU1lbnVEZWxlZ2F0ZS50b2dnbGVMZWZ0KCk7XG4gICAgICAkd2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcbiAgICB9XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSB1bmRlZmluZWQ7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS50YWcgPSB1bmRlZmluZWQ7XG5cbiAgICAkaW9uaWNIaXN0b3J5LmNsZWFyQ2FjaGUoKTtcbiAgICAkaW9uaWNIaXN0b3J5LmNsZWFySGlzdG9yeSgpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpb25pYy5QbGF0Zm9ybS5leGl0QXBwKCk7IC8vIHN0b3BzIHRoZSBhcHBcbiAgICB9LCAxMDApO1xuICB9O1xuICAkc2NvcGUuc29ja2V0ID0gJHJvb3RTY29wZS4kc3RvcmFnZVtcInNvY2tldFwiKyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW5dO1xuICAkc2NvcGUuc29ja2V0Q2hhbmdlID0gZnVuY3Rpb24oeHgpe1xuICAgIGNvbnNvbGUubG9nKHh4KTtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlW1wic29ja2V0XCIrJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbl0gPSB4eDtcbiAgICBsb2NhbFN0b3JhZ2Uuc29ja2V0VXJsID0geHg7XG4gICAgJHNjb3BlLnJlc3RhcnQgPSB0cnVlO1xuICB9XG4gICRzY29wZS5zYXZlID0gZnVuY3Rpb24oKXtcbiAgICBpZiAoJHNjb3BlLnJlc3RhcnQpIHtcbiAgICAgIHZhciBjb25maXJtUG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBUkVfWU9VX1NVUkUnKSxcbiAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdVUERBVEVfUkVRVUlSRVNfUkVTVEFSVCcpXG4gICAgICB9KTtcbiAgICAgIGNvbmZpcm1Qb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBpZihyZXMpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBzdXJlJyk7XG4gICAgICAgICAgLy8kc2NvcGUubG9nb3V0cygpO1xuICAgICAgICAgICR3aW5kb3cubG9jYXRpb24ucmVsb2FkKHRydWUpOyAgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgbm90IHN1cmUnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFVFRJTkdTX1VQREFURUQnKSk7XG4gICAgICAkaW9uaWNIaXN0b3J5Lm5leHRWaWV3T3B0aW9ucyh7XG4gICAgICAgIGRpc2FibGVCYWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIC8vJHN0YXRlLmdvKCdhcHAucG9zdHMnLCB7fSwge3JlbG9hZDogdHJ1ZX0pO1xuICAgICAgJHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQodHJ1ZSk7ICBcbiAgICB9XG4gIH07XG5cbn0pO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL3Bvc3RzL2NvbnRyb2xsZXJzLmpzXCIsXCIvcG9zdHNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cblxudmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdzdGVlbScsIFtcblx0J2lvbmljJyxcblx0J25nU3RvcmFnZScsXG5cdCduZ0NvcmRvdmEnLFxuICAncnpNb2R1bGUnLFxuICAnaW9uLWZsb2F0aW5nLW1lbnUnLFxuICAncGFzY2FscHJlY2h0LnRyYW5zbGF0ZScsXG4gICdqYS5xcidcbl0pO1xuXG5pZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzb2NrZXRVcmxcIikgPT09IG51bGwpIHtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzb2NrZXRVcmxcIiwgXCJ3c3M6Ly9zdGVlbWl0LmNvbS93c3BhXCIpO1xufVxuXG53aW5kb3cuc3RlZW1SUEMgPSByZXF1aXJlKFwic3RlZW0tcnBjXCIpO1xud2luZG93LkFwaSA9IHdpbmRvdy5zdGVlbVJQQy5DbGllbnQuZ2V0KHt1cmw6bG9jYWxTdG9yYWdlLnNvY2tldFVybH0sIHRydWUpO1xud2luZG93LnN0ZWVtSlMgPSByZXF1aXJlKFwic3RlZW1qcy1saWJcIik7XG53aW5kb3cuZ29sb3NKUyA9IHJlcXVpcmUoXCJnb2xvc2pzLWxpYlwiKTtcbndpbmRvdy5kaWZmX21hdGNoX3BhdGNoID0gcmVxdWlyZSgnZGlmZi1tYXRjaC1wYXRjaCcpO1xud2luZG93LmdldFN5bWJvbCA9IHJlcXVpcmUoJ2N1cnJlbmN5LXN5bWJvbC1tYXAnKTtcblxucmVxdWlyZSgnLi9jb25maWcnKShhcHApO1xucmVxdWlyZSgnLi9zZXJ2aWNlcycpKGFwcCk7XG5yZXF1aXJlKCcuL2NvbnRyb2xsZXJzJykoYXBwKTtcblxuXG5hcHAuY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyLCAkdXJsUm91dGVyUHJvdmlkZXIsICRpb25pY0NvbmZpZ1Byb3ZpZGVyLCAkc2NlRGVsZWdhdGVQcm92aWRlciwgJGxvZ1Byb3ZpZGVyLCAkY29tcGlsZVByb3ZpZGVyLCAkYW5pbWF0ZVByb3ZpZGVyLCAkdHJhbnNsYXRlUHJvdmlkZXIpIHtcbiAgJHN0YXRlUHJvdmlkZXJcblxuICAuc3RhdGUoJ2FwcCcsIHtcbiAgICB1cmw6ICcvYXBwJyxcbiAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICB0ZW1wbGF0ZTogXCI8aW9uLXNpZGUtbWVudXMgZW5hYmxlLW1lbnUtd2l0aC1iYWNrLXZpZXdzPVxcXCJmYWxzZVxcXCI+XFxuICA8aW9uLXNpZGUtbWVudS1jb250ZW50IGRyYWctY29udGVudD1cXFwiZmFsc2VcXFwiPlxcbiAgICA8aW9uLW5hdi1iYXIgY2xhc3M9XFxcImJhci1wb3NpdGl2ZVxcXCI+XFxuICAgICAgPGlvbi1uYXYtYmFjay1idXR0b24+XFxuICAgICAgPC9pb24tbmF2LWJhY2stYnV0dG9uPlxcblxcbiAgICAgIDxpb24tbmF2LWJ1dHRvbnMgc2lkZT1cXFwibGVmdFxcXCI+XFxuICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLWljb24gYnV0dG9uLWNsZWFyIGlvbi1uYXZpY29uXFxcIiBtZW51LXRvZ2dsZT1cXFwibGVmdFxcXCI+XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgICA8L2lvbi1uYXYtYnV0dG9ucz5cXG4gICAgPC9pb24tbmF2LWJhcj5cXG4gICAgPGlvbi1uYXYtdmlldyBuYW1lPVxcXCJtZW51Q29udGVudFxcXCI+PC9pb24tbmF2LXZpZXc+XFxuICA8L2lvbi1zaWRlLW1lbnUtY29udGVudD5cXG5cXG4gIDxpb24tc2lkZS1tZW51IHNpZGU9XFxcImxlZnRcXFwiPlxcbiAgICA8IS0tPGlvbi1oZWFkZXItYmFyIGNsYXNzPVxcXCJiYXItcG9zaXRpdmVcXFwiIG5nLWlmPVxcXCIhJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+XFxuICAgICAgPGgxIGNsYXNzPVxcXCJ0aXRsZSBjZW50ZXJcXFwiPmVTdGVlbTwvaDE+XFxuICAgIDwvaW9uLWhlYWRlci1iYXI+LS0+XFxuICAgIDxpb24tY29udGVudD5cXG4gICAgICA8ZGl2IG5nLWlmPVxcXCIhJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+XFxuICAgICAgICA8Y2VudGVyPlxcbiAgICAgICAgICA8cD5cXG4gICAgICAgICAgICA8aW1nIG5nLXNyYz1cXFwiaW1nL2Fib3V0LnBuZ1xcXCIgd2lkdGg9XFxcIjIwMFxcXCIgLz5cXG4gICAgICAgICAgPC9wPlxcbiAgICAgICAgPC9jZW50ZXI+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlclxcXCIgbmctc3R5bGU9XFxcIiRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmNvdmVyX2ltYWdlID8gbWNzcyA6IG51bGxcXFwiPlxcbiAgICAgIDxicj5cXG4gICAgICAgIDxjZW50ZXI+XFxuICAgICAgICAgIDxhIG1lbnUtY2xvc2UgaHJlZj1cXFwiIy9hcHAvcHJvZmlsZS97eyRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWV9fVxcXCIgY2xhc3M9XFxcIml0ZW0tbXlhdmF0YXJcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyXFxcIj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaXRlbS1teWF2YXRhclxcXCIgbmctaWY9XFxcIiEkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEudXNlcl9pbWFnZSAmJiAhJHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUucHJvZmlsZV9pbWFnZVxcXCI+PGltZyBzcmM9XFxcImltZy91c2VyX3Byb2ZpbGUucG5nXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPGltZyBuZy1zcmM9XFxcInt7JHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUucHJvZmlsZV9pbWFnZSB8fCAkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEudXNlcl9pbWFnZX19XFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnVzZXJfaW1hZ2UgfHwgJHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUucHJvZmlsZV9pbWFnZVxcXCIgLz5cXG4gICAgICAgICAgPC9hPlxcbiAgICAgICAgICA8ZGl2IG5nLWNsYXNzPVxcXCJ7J2Zvb3Rwcm9maWxlaW5mb21lbnUnOiRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmNvdmVyX2ltYWdlfVxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaDRcXFwiPkB7eyRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWV9fSZuYnNwOzxkaXYgY2xhc3M9XFxcInJlcHV0YXRpb25cXFwiPnt7JHJvb3QuJHN0b3JhZ2UudXNlci5yZXB1dGF0aW9ufHJlcHV0YXRpb246dHJ1ZXxudW1iZXI6MX19PC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBuZy1jbGljaz1cXFwic2hvd01lRXh0cmEoKVxcXCIgY2xhc3M9XFxcInBhZGRpbmdcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1hbmRyb2lkLWxpc3RcXFwiPjwvaT4mbmJzcDt7eyRyb290LiRzdG9yYWdlLnVzZXIucG9zdF9jb3VudH19Jm5ic3A7Jm5ic3A7PGkgY2xhc3M9XFxcImljb24gaW9uLWFycm93LWdyYXBoLXVwLXJpZ2h0XFxcIj48L2k+Jm5ic3A7e3skcm9vdC4kc3RvcmFnZS51c2VyLnZvdGluZ19wb3dlci8xMDB8bnVtYmVyOjJ9fSA8aSBjbGFzcz1cXFwiaWNvbiBwdWxsLXJpZ2h0XFxcIiBuZy1jbGFzcz1cXFwieydpb24tYXJyb3ctZG93bi1iJzohc2hvd0V4dHJhLCAnaW9uLWFycm93LXVwLWInOnNob3dFeHRyYX1cXFwiPjwvaT48L2Rpdj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2NlbnRlcj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IG5nLWlmPVxcXCJzaG93RXh0cmFcXFwiPlxcbiAgICAgICAgPGlvbi1saXN0PlxcbiAgICAgICAgICA8aW9uLWl0ZW0gbWVudS1jbG9zZSBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2Vyc1xcXCIgbmctcmVwZWF0PVxcXCJ1c2VyIGluICRyb290LiRzdG9yYWdlLnVzZXJzXFxcIiBuZy1jbGljaz1cXFwic2VsZWN0QWNjb3VudCh1c2VyKVxcXCIgbmctY2xhc3M9XFxcInsnYWN0aXZlJzogKHVzZXIudXNlcm5hbWU9PSRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWUmJnVzZXIuY2hhaW49PSRyb290LiRzdG9yYWdlLnVzZXIuY2hhaW4pIH1cXFwiPlxcbiAgICAgICAgICAgIDxpbWcgY2xhc3M9XFxcImljb24gbG9nb3NcXFwiIG5nLXNyYz1cXFwie3snaW1nLycrdXNlci5jaGFpbisnX2ljb24ucG5nJ319XFxcIiAvPlxcbiAgICAgICAgICAgIHt7dXNlci51c2VybmFtZX19XFxuICAgICAgICAgICAgPCEtLTxzcGFuIGNsYXNzPVxcXCJiYWRnZSBiYWRnZS1hc3NlcnRpdmVcXFwiPnt7dXNlci5jaGFpbn19PC9zcGFuPi0tPlxcbiAgICAgICAgICA8L2lvbi1pdGVtPlxcbiAgICAgICAgICA8aW9uLWl0ZW0gbWVudS1jbG9zZSBuZy1jbGljaz1cXFwib3BlbkxvZ2luKClcXFwiIGNsYXNzPVxcXCJpdGVtLWljb24tbGVmdFxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXJcXFwiPlxcbiAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1wbHVzLXJvdW5kXFxcIj48L2k+XFxuICAgICAgICAgICAge3snQUREX0FDQ09VTlQnfHRyYW5zbGF0ZX19XFxuICAgICAgICAgIDwvaW9uLWl0ZW0+XFxuICAgICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIG5nLWNsaWNrPVxcXCJvcGVuUG9zdE1vZGFsKClcXFwiIGNsYXNzPVxcXCJpdGVtLWljb24tbGVmdFxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXJcXFwiPlxcbiAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1hbmRyb2lkLWNyZWF0ZVxcXCI+PC9pPlxcbiAgICAgICAgICAgIHt7J1NVQk1JVF9BX1NUT1JZJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgICA8L2lvbi1pdGVtPlxcbiAgICAgICAgICA8aW9uLWl0ZW0gbWVudS1jbG9zZSBocmVmPVxcXCIjL2FwcC9wcm9maWxlL3t7JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZX19XFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyXFxcIj5cXG4gICAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tcGVyc29uXFxcIj48L2k+XFxuICAgICAgICAgICAge3snUFJPRklMRSd8dHJhbnNsYXRlfX1cXG4gICAgICAgICAgPC9pb24taXRlbT5cXG4gICAgICAgICAgPGlvbi1pdGVtIG1lbnUtY2xvc2UgaHJlZj1cXFwiIy9hcHAvZm9sbG93XFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyXFxcIj5cXG4gICAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tcGVyc29uLXN0YWxrZXJcXFwiPjwvaT5cXG4gICAgICAgICAgICB7eydGT0xMT1cnfHRyYW5zbGF0ZX19XFxuICAgICAgICAgIDwvaW9uLWl0ZW0+XFxuICAgICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIG5nLWNsaWNrPVxcXCJsb2dvdXQoKVxcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+XFxuICAgICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWxvZy1vdXRcXFwiPjwvaT5cXG4gICAgICAgICAgICB7eydMT0dPVVQnfHRyYW5zbGF0ZX19XFxuICAgICAgICAgIDwvaW9uLWl0ZW0+XFxuICAgICAgICA8L2lvbi1saXN0PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxpb24tbGlzdD5cXG4gICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIG5nLWNsaWNrPVxcXCJvcGVuTG9naW4oKVxcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIiBuZy1pZj1cXFwiISRyb290LiRzdG9yYWdlLnVzZXJcXFwiPlxcbiAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tbG9nLWluXFxcIj48L2k+XFxuICAgICAgICAgIHt7J0xPR0lOJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9pb24taXRlbT5cXG4gICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIGhyZWY9XFxcIiMvYXBwL3Bvc3RzL1xcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWhvbWVcXFwiPjwvaT5cXG4gICAgICAgICAge3snSE9NRSd8dHJhbnNsYXRlfX1cXG4gICAgICAgIDwvaW9uLWl0ZW0+XFxuICAgICAgICA8aW9uLWl0ZW0gbWVudS1jbG9zZSBocmVmPVxcXCIjL2FwcC9ib29rbWFya1xcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+XFxuICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1ib29rbWFya1xcXCI+PC9pPlxcbiAgICAgICAgICB7eydCT09LTUFSS1MnfHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2lvbi1pdGVtPlxcbiAgICAgICAgPGlvbi1pdGVtIG1lbnUtY2xvc2UgaHJlZj1cXFwiIy9hcHAvZHJhZnRzXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlclxcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWNvbXBvc2VcXFwiPjwvaT5cXG4gICAgICAgICAge3snRFJBRlRTJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9pb24taXRlbT5cXG4gICAgICAgIDwhLS08aW9uLWl0ZW0gbWVudS1jbG9zZSBocmVmPVxcXCIjL2FwcC9ub3RpZmljYXRpb25zXFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5ub3RpZmljYXRpb25zICYmICRyb290LiRzdG9yYWdlLm5vdGlmaWNhdGlvbnMubGVuZ3RoPjBcXFwiPlxcbiAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tYm9va21hcmtcXFwiPjwvaT5cXG4gICAgICAgICAge3snTk9USUZJQ0FUSU9OUyd8dHJhbnNsYXRlfX1cXG4gICAgICAgIDwvaW9uLWl0ZW0+LS0+XFxuICAgICAgICA8aW9uLWl0ZW0gbWVudS1jbG9zZSBocmVmPVxcXCIjL2FwcC9zZW5kXFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyXFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtc2VuZFxcXCI+PC9pPlxcbiAgICAgICAgICB7eydUUkFOU0ZFUid8dHJhbnNsYXRlfX1cXG4gICAgICAgIDwvaW9uLWl0ZW0+XFxuICAgICAgICA8aW9uLWl0ZW0gbWVudS1jbG9zZSBocmVmPVxcXCIjL2FwcC9leGNoYW5nZS97eyRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWV9fVxcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+XFxuICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1hcnJvdy1zd2FwXFxcIj48L2k+XFxuICAgICAgICAgIHt7J0VYQ0hBTkdFJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9pb24taXRlbT5cXG4gICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIGhyZWY9XFxcIiMvYXBwL21hcmtldFxcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWN1YmVcXFwiPjwvaT5cXG4gICAgICAgICAge3snTUFSS0VUUExBQ0UnfHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2lvbi1pdGVtPlxcbiAgICAgICAgPGlvbi1pdGVtIG1lbnUtY2xvc2UgaHJlZj1cXFwiIy9hcHAvc2V0dGluZ3NcXFwiIGNsYXNzPVxcXCJpdGVtLWljb24tbGVmdFxcXCI+XFxuICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1hbmRyb2lkLXNldHRpbmdzXFxcIj48L2k+XFxuICAgICAgICAgIHt7J1NFVFRJTkdTJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9pb24taXRlbT5cXG4gICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIGhyZWY9XFxcIiMvYXBwL2Fib3V0XFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiPlxcbiAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24taW5mb3JtYXRpb25cXFwiPjwvaT5cXG4gICAgICAgICAge3snQUJPVVQnfHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2lvbi1pdGVtPlxcbiAgICAgIDwvaW9uLWxpc3Q+XFxuICAgIDwvaW9uLWNvbnRlbnQ+XFxuICAgIDwhLS0gYWxpZ24gdG8gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZSAtLT5cXG4gICAgPGRpdiBzdHlsZT1cXFwicG9zaXRpb246IGFic29sdXRlOyBib3R0b206IDBweDsgd2lkdGg6IDEwMCVcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5hcHB2ZXJzaW9uXFxcIj5cXG4gICAgICAgIDxkaXYgc3R5bGU9XFxcInRleHQtYWxpZ246IGNlbnRlcjsgY29sb3I6I2NjYztcXFwiPlxcbiAgICAgICAgICA8cD57eyRyb290LiRzdG9yYWdlLmFwcHZlcnNpb259fTwvcD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvaW9uLXNpZGUtbWVudT5cXG48L2lvbi1zaWRlLW1lbnVzPlxcblwiLFxuICAgIC8vdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvbWVudS5odG1sJyxcbiAgICBjb250cm9sbGVyOiAnQXBwQ3RybCdcbiAgfSlcblxuICAuc3RhdGUoJ2FwcC5zZXR0aW5ncycsIHtcbiAgICB1cmw6ICcvc2V0dGluZ3MnLFxuICAgIHZpZXdzOiB7XG4gICAgICAnbWVudUNvbnRlbnQnOiB7XG4gICAgICAgIC8vdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvc2V0dGluZ3MuaHRtbCdcbiAgICAgICAgdGVtcGxhdGU6IFwiPGlvbi12aWV3IHZpZXctY2FjaGU9XFxcImZhbHNlXFxcIiB2aWV3LXRpdGxlPVxcXCJ7eydTRVRUSU5HUyd8dHJhbnNsYXRlfX1cXFwiPlxcbiAgPGlvbi1jb250ZW50IGNsYXNzPVxcXCJwYWRkaW5nIGhhcy1oZWFkZXIgc2V0dGluZ3NcXFwiPlxcbiAgICA8YnIvPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtIGl0ZW0tZGl2aWRlclxcXCI+XFxuICAgICAge3snU0VDVVJJVFknfHRyYW5zbGF0ZX19XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGFiZWxcXFwiIG5nLWNsaWNrPSdvcGVuVG9vbHRpcCgkZXZlbnQsXFxcInt7XFxcIlBJTl9URVhUXFxcInx0cmFuc2xhdGV9fVxcXCIpJz48aSBjbGFzcz1cXFwiaWNvbiBpb24taW9zLWluZm9ybWF0aW9uLW91dGxpbmUgZ3JheVxcXCI+PC9pPiB7eydQSU5fQ09ERSd8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIHB1bGwtcmlnaHQgdHJpZ2h0XFxcIj5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwidG9nZ2xlIHRvZ2dsZS1wb3NpdGl2ZVxcXCI+XFxuICAgICAgICAgPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBuZy1tb2RlbD1cXFwiZGF0YS5waW5cXFwiIG5nLWNoYW5nZT1cXFwicGluQ2hhbmdlKClcXFwiPlxcbiAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRyYWNrXFxcIj5cXG4gICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImhhbmRsZVxcXCI+PC9kaXY+XFxuICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcIml0ZW0gaXRlbS1kaXZpZGVyXFxcIj5cXG4gICAgICB7eydOT1RJRklDQVRJT05TJ3x0cmFuc2xhdGV9fVxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwic2xhYmVsXFxcIiBuZy1jbGljaz0nb3BlblRvb2x0aXAoJGV2ZW50LFxcXCJ7e1xcXCJWT1RFX1RFWFRcXFwifHRyYW5zbGF0ZX19XFxcIiknPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1pb3MtaW5mb3JtYXRpb24tb3V0bGluZSBncmF5XFxcIj48L2k+IHt7J1ZPVEUnfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBwdWxsLXJpZ2h0IHRyaWdodFxcXCI+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInRvZ2dsZSB0b2dnbGUtcG9zaXRpdmVcXFwiPlxcbiAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgbmctbW9kZWw9XFxcImRhdGEudm90ZVxcXCIgbmctY2hhbmdlPVxcXCJub3RpZmljYXRpb25DaGFuZ2UoKVxcXCI+XFxuICAgICAgICAgPGRpdiBjbGFzcz1cXFwidHJhY2tcXFwiPlxcbiAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGFuZGxlXFxcIj48L2Rpdj5cXG4gICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvbGFiZWw+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGFiZWxcXFwiIG5nLWNsaWNrPSdvcGVuVG9vbHRpcCgkZXZlbnQsXFxcInt7XFxcIkNPTU1FTlRfVEVYVFxcXCJ8dHJhbnNsYXRlfX1cXFwiKSc+PGkgY2xhc3M9XFxcImljb24gaW9uLWlvcy1pbmZvcm1hdGlvbi1vdXRsaW5lIGdyYXlcXFwiPjwvaT4ge3snQ09NTUVOVCd8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIHB1bGwtcmlnaHQgdHJpZ2h0XFxcIj5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwidG9nZ2xlIHRvZ2dsZS1wb3NpdGl2ZVxcXCI+XFxuICAgICAgICAgPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBuZy1tb2RlbD1cXFwiZGF0YS5jb21tZW50XFxcIiBuZy1jaGFuZ2U9XFxcIm5vdGlmaWNhdGlvbkNoYW5nZSgpXFxcIj5cXG4gICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0cmFja1xcXCI+XFxuICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoYW5kbGVcXFwiPjwvZGl2PlxcbiAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0zM1xcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInNsYWJlbFxcXCIgbmctY2xpY2s9J29wZW5Ub29sdGlwKCRldmVudCxcXFwie3tcXFwiRk9MTE9XX1RFWFRcXFwifHRyYW5zbGF0ZX19XFxcIiknPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1pb3MtaW5mb3JtYXRpb24tb3V0bGluZSBncmF5XFxcIj48L2k+IHt7J0ZPTExPVyd8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIHB1bGwtcmlnaHQgdHJpZ2h0XFxcIj5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwidG9nZ2xlIHRvZ2dsZS1wb3NpdGl2ZVxcXCI+XFxuICAgICAgICAgPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBuZy1tb2RlbD1cXFwiZGF0YS5mb2xsb3dcXFwiIG5nLWNoYW5nZT1cXFwibm90aWZpY2F0aW9uQ2hhbmdlKClcXFwiPlxcbiAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRyYWNrXFxcIj5cXG4gICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImhhbmRsZVxcXCI+PC9kaXY+XFxuICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwic2xhYmVsXFxcIiBuZy1jbGljaz0nb3BlblRvb2x0aXAoJGV2ZW50LFxcXCJ7e1xcXCJNRU5USU9OU19URVhUXFxcInx0cmFuc2xhdGV9fVxcXCIpJz48aSBjbGFzcz1cXFwiaWNvbiBpb24taW9zLWluZm9ybWF0aW9uLW91dGxpbmUgZ3JheVxcXCI+PC9pPiB7eydNRU5USU9OUyd8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIHB1bGwtcmlnaHQgdHJpZ2h0XFxcIj5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwidG9nZ2xlIHRvZ2dsZS1wb3NpdGl2ZVxcXCI+XFxuICAgICAgICAgPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBuZy1tb2RlbD1cXFwiZGF0YS5tZW50aW9uXFxcIiBuZy1jaGFuZ2U9XFxcIm5vdGlmaWNhdGlvbkNoYW5nZSgpXFxcIj5cXG4gICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0cmFja1xcXCI+XFxuICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoYW5kbGVcXFwiPjwvZGl2PlxcbiAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0zM1xcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInNsYWJlbFxcXCIgbmctY2xpY2s9J29wZW5Ub29sdGlwKCRldmVudCxcXFwie3tcXFwiUkVTVEVFTV9URVhUXFxcInx0cmFuc2xhdGV9fVxcXCIpJz48aSBjbGFzcz1cXFwiaWNvbiBpb24taW9zLWluZm9ybWF0aW9uLW91dGxpbmUgZ3JheVxcXCI+PC9pPiB7eydSRVNURUVNJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgcHVsbC1yaWdodCB0cmlnaHRcXFwiPlxcbiAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJ0b2dnbGUgdG9nZ2xlLXBvc2l0aXZlXFxcIj5cXG4gICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5nLW1vZGVsPVxcXCJkYXRhLnJlc3RlZW1cXFwiIG5nLWNoYW5nZT1cXFwibm90aWZpY2F0aW9uQ2hhbmdlKClcXFwiPlxcbiAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRyYWNrXFxcIj5cXG4gICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImhhbmRsZVxcXCI+PC9kaXY+XFxuICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcIml0ZW0gaXRlbS1kaXZpZGVyXFxcIj5cXG4gICAgICB7eydDT05GSUdVUkFUSU9OUyd8dHJhbnNsYXRlfX1cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXJcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGFiZWxcXFwiIG5nLWNsaWNrPSdvcGVuVG9vbHRpcCgkZXZlbnQsXFxcInt7XFxcIlZPVElOR19URVhUXFxcInx0cmFuc2xhdGV9fVxcXCIpJz48aSBjbGFzcz1cXFwiaWNvbiBpb24taW9zLWluZm9ybWF0aW9uLW91dGxpbmUgZ3JheVxcXCI+PC9pPiB7eydWT1RJTkcnfHRyYW5zbGF0ZX19ICglKTwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPlxcbiAgICAgIDxyenNsaWRlciByei1zbGlkZXItbW9kZWw9XFxcInNsaWRlci52YWx1ZVxcXCIgcnotc2xpZGVyLW9wdGlvbnM9XFxcInNsaWRlci5vcHRpb25zXFxcIj48L3J6c2xpZGVyPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGFiZWxcXFwiIG5nLWNsaWNrPSdvcGVuVG9vbHRpcCgkZXZlbnQsXFxcInt7XFxcIkxBTkdVQUdFU19URVhUXFxcInx0cmFuc2xhdGV9fVxcXCIpJz48aSBjbGFzcz1cXFwiaWNvbiBpb24taW9zLWluZm9ybWF0aW9uLW91dGxpbmUgZ3JheVxcXCI+PC9pPiB7eydMQU5HVUFHRVMnfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVxcXCIkcm9vdC4kc3RvcmFnZS5sYW5ndWFnZVxcXCIgbmctY2hhbmdlPSdjaGFuZ2VMYW5ndWFnZSgkcm9vdC4kc3RvcmFnZS5sYW5ndWFnZSknPlxcbiAgICAgICAgICA8b3B0aW9uIG5nLXJlcGVhdD1cXFwib3B0aW9uIGluICRyb290LiRzdG9yYWdlLmxhbmd1YWdlc1xcXCIgdmFsdWU9XFxcInt7b3B0aW9uLmlkfX1cXFwiPnt7b3B0aW9uLm5hbWV9fTwvb3B0aW9uPlxcbiAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgICA8IS0tPGRpdiBjbGFzcz1cXFwiY2FwaXRhbFxcXCI+e3skcm9vdC4kc3RvcmFnZS5sYW5ndWFnZX19IDxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L2k+PC9kaXY+PC9kaXY+LS0+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNsYWJlbFxcXCIgbmctY2xpY2s9J29wZW5Ub29sdGlwKCRldmVudCxcXFwie3tcXFwiQ1VSUkVOQ1lfVEVYVFxcXCJ8dHJhbnNsYXRlfX1cXFwiKSc+PGkgY2xhc3M9XFxcImljb24gaW9uLWlvcy1pbmZvcm1hdGlvbi1vdXRsaW5lIGdyYXlcXFwiPjwvaT4ge3snQ1VSUkVOQ1knfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVxcXCIkcm9vdC4kc3RvcmFnZS5jdXJyZW5jeVxcXCIgbmctY2hhbmdlPSdjaGFuZ2VDdXJyZW5jeSgkcm9vdC4kc3RvcmFnZS5jdXJyZW5jeSknPlxcbiAgICAgICAgICA8b3B0aW9uIG5nLXJlcGVhdD1cXFwib3B0aW9uIGluICRyb290LiRzdG9yYWdlLmN1cnJlbmNpZXNcXFwiIHZhbHVlPVxcXCJ7e29wdGlvbi5pZH19XFxcIj57e29wdGlvbi5uYW1lfX08L29wdGlvbj5cXG4gICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgPCEtLTxkaXYgY2xhc3M9XFxcImNhcGl0YWxcXFwiPnt7JHJvb3QuJHN0b3JhZ2UubGFuZ3VhZ2V9fSA8ZGl2IGNsYXNzPVxcXCJwdWxsLXJpZ2h0XFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tY2hldnJvbi1yaWdodFxcXCI+PC9pPjwvZGl2PjwvZGl2Pi0tPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGFiZWxcXFwiIG5nLWNsaWNrPSdvcGVuVG9vbHRpcCgkZXZlbnQsXFxcInt7XFxcIkNIQUlOX1RFWFRcXFwifHRyYW5zbGF0ZX19XFxcIiknPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1pb3MtaW5mb3JtYXRpb24tb3V0bGluZSBncmF5XFxcIj48L2k+IHt7J0NIQUlOJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPlxcbiAgICAgICAgPHNlbGVjdCBuZy1tb2RlbD1cXFwiJHJvb3QuJHN0b3JhZ2UuY2hhaW5cXFwiIG5nLWNoYW5nZT0nY2hhbmdlQ2hhaW4oJHJvb3QuJHN0b3JhZ2UuY2hhaW4pJz5cXG4gICAgICAgICAgPG9wdGlvbiBuZy1yZXBlYXQ9XFxcIm9wdGlvbiBpbiAkcm9vdC4kc3RvcmFnZS5jaGFpbnNcXFwiIHZhbHVlPVxcXCJ7e29wdGlvbi5pZH19XFxcIj57e29wdGlvbi5uYW1lfX08L29wdGlvbj5cXG4gICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgPCEtLTxkaXYgY2xhc3M9XFxcImNhcGl0YWxcXFwiPnt7JHJvb3QuJHN0b3JhZ2UubGFuZ3VhZ2V9fSA8ZGl2IGNsYXNzPVxcXCJwdWxsLXJpZ2h0XFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tY2hldnJvbi1yaWdodFxcXCI+PC9pPjwvZGl2PjwvZGl2Pi0tPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGFiZWxcXFwiIG5nLWNsaWNrPSdvcGVuVG9vbHRpcCgkZXZlbnQsXFxcIjxzcGFuIGNsYXNzPVxcXFxcXFwiYm9sZFxcXFxcXFwiPnt7XFxcIlNFUlZFUl9URVhUXFxcInx0cmFuc2xhdGV9fTo8L3NwYW4+PGJyPjxzcGFuIGNsYXNzPVxcXFxcXFwid3JhcFxcXFxcXFwiPltzdGVlbWl0XSB3c3M6Ly9zdGVlbWQuc3RlZW1pdC5jb208L3NwYW4+PGJyLz48YnIvPjxzcGFuIGNsYXNzPVxcXFxcXFwid3JhcFxcXFxcXFwiPltzdGVlbS53c10gd3NzOi8vbm9kZS5zdGVlbS53czwvc3Bhbj48YnIvPjxici8+PHNwYW4gY2xhc3M9XFxcXFxcXCJ3cmFwXFxcXFxcXCI+W3Bpc3Rvbl0gd3NzOi8vdGhpcy5waXN0b24ucm9ja3M8L3NwYW4+PGJyLz48YnIvPjxzcGFuIGNsYXNzPVxcXFxcXFwid3JhcFxcXFxcXFwiPltnb2xvc10gd3NzOi8vd3MuZ29sb3MuaW88L3NwYW4+PGJyLz48YnIvPjxzcGFuIGNsYXNzPVxcXFxcXFwid3JhcFxcXFxcXFwiPltnb2xvcy53c10gd3NzOi8vbm9kZS5nb2xvcy53czwvc3Bhbj5cXG4gICAgICAgIFxcXCIpJz48aSBjbGFzcz1cXFwiaWNvbiBpb24taW9zLWluZm9ybWF0aW9uLW91dGxpbmUgZ3JheVxcXCI+PC9pPiB7eydTRVJWRVInfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcIlNlcnZlclxcXCIgbmctbW9kZWw9XFxcInNvY2tldFxcXCIgc3R5bGU9XFxcIndpZHRoOjEwMCU7XFxcIiBuZy1jaGFuZ2U9XFxcInNvY2tldENoYW5nZShzb2NrZXQpXFxcIj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDwhLS08ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcG9zaXRpdmVcXFwiIG5nLWNsaWNrPVxcXCJjaGFuZ2VMYW5ndWFnZSgncnUnKVxcXCI+Q2hhbmdlIFJVPC9idXR0b24+LS0+XFxuICAgIDxici8+XFxuICAgIDxzY3JpcHQgaWQgPSBcXFwicG9wb3Zlci5odG1sXFxcIiB0eXBlPVxcXCJ0ZXh0L25nLXRlbXBsYXRlXFxcIj5cXG4gICAgICA8aW9uLXBvcG92ZXItdmlldz5cXG4gICAgICAgIDxpb24tY29udGVudD5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwicGFkZGluZ1xcXCIgbmctYmluZC1odG1sPVxcXCJ0b29sdGlwVGV4dFxcXCI+PC9kaXY+XFxuICAgICAgICA8L2lvbi1jb250ZW50PlxcbiAgICAgIFxcbiAgICAgIDwvaW9uLXBvcG92ZXItdmlldz5cXG4gICAgPC9zY3JpcHQ+XFxuICAgIDxkaXYgY2xhc3M9XFxcInRjZW50ZXJcXFwiPlxcbiAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcG9zaXRpdmVcXFwiIG5nLWNsaWNrPVxcXCJzYXZlKClcXFwiPnt7J1NBVkVfQ0hBTkdFUyd8dHJhbnNsYXRlfX08L2J1dHRvbj5cXG4gICAgPC9kaXY+XFxuICA8L2lvbi1jb250ZW50PlxcbjwvaW9uLXZpZXc+XFxuXCIsXG4gICAgICAgIGNvbnRyb2xsZXI6ICdTZXR0aW5nc0N0cmwnXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIC5zdGF0ZSgnYXBwLmFib3V0Jywge1xuICAgIHVybDogJy9hYm91dCcsXG4gICAgdmlld3M6IHtcbiAgICAgICdtZW51Q29udGVudCc6IHtcbiAgICAgICAgLy90ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9zZXR0aW5ncy5odG1sJ1xuICAgICAgICB0ZW1wbGF0ZTogXCI8aW9uLXZpZXcgdmlldy1jYWNoZT1cXFwiZmFsc2VcXFwiIHZpZXctdGl0bGU9XFxcInt7J0FCT1VUJyB8IHRyYW5zbGF0ZX19IC0gdnt7JHJvb3QuJHN0b3JhZ2UuYXBwdmVyc2lvbn19XFxcIj5cXG4gIDxpb24tY29udGVudCBjbGFzcz1cXFwicGFkZGluZ1xcXCI+XFxuICAgIDxjZW50ZXI+PGltZyBzcmM9XFxcImltZy9hYm91dC5wbmdcXFwiPjwvY2VudGVyPlxcbiAgICA8cD48Yj5lU3RlZW08L2I+IHt7J0FCT1VUXzInfHRyYW5zbGF0ZX19IDxkaXYgbmctYmluZC1odG1sPVxcXCInQUJPVVRfMTEnfHRyYW5zbGF0ZVxcXCI+PC9kaXY+XFxuICAgIDwvcD5cXG4gICAgPHAgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXJcXFwiPnt7XFxcIkZPVU5ERVJcXFwifHRyYW5zbGF0ZX19IDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9nb29kLWthcm1hXFxcIj5nb29kLWthcm1hPC9hPjwvcD5cXG4gICAgPGRpdiBjbGFzcz1cXFwidGNlbnRlclxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXJcXFwiPjxzcGFuIG5nLWlmPVxcXCIhJHJvb3QuaXNXaXRuZXNzVm90ZWQoKVxcXCI+PGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1wb3NpdGl2ZVxcXCIgbmctY2xpY2s9XFxcIiRyb290LnZvdGVXaXRuZXNzKClcXFwiPnt7J0FCT1VUXzgnfHRyYW5zbGF0ZX19PC9idXR0b24+PC9zcGFuPjwvZGl2PlxcbiAgICA8cD5cXG4gICAgPGI+PHU+e3snQUJPVVRfOSd8dHJhbnNsYXRlfX08L3U+PC9iPlxcbiAgICA8YnI+PGEgaHJlZj1cXFwibWFpbHRvOmluZm9AZXN0ZWVtLndzP1N1YmplY3Q9RmVlZGJhY2tcXFwiPmluZm9AZXN0ZWVtLndzPC9hPlxcbiAgICA8YnI+PGEgaHJlZj1cXFwiaHR0cDovL2VzdGVlbS53c1xcXCI+aHR0cDovL2VzdGVlbS53czwvYT5cXG4gICAgPC9wPlxcbiAgICA8cD5cXG4gICAgICAgIDxiPjx1Pnt7J1RSQU5TTEFUSU9OUyd8dHJhbnNsYXRlfX08L3U+PC9iPjxicj5cXG4gICAgICAgINCg0YPRgdGB0LrQuNC5IC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL3Rlc3R6XFxcIj50ZXN0ejwvYT4sIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9vbjB0b2xlXFxcIj5vbjB0b2xlPC9hPjxicj5cXG4gICAgICAgIERldXRzY2ggLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvZGV6MTMzN1xcXCI+ZGV6MTMzNzwvYT4sIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9ob21vc2FwaWVuc1xcXCI+aG9tb3NhcGllbnM8L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvdXdlbGFuZ1xcXCI+dXdlbGFuZzwvYT48YnI+XFxuICAgICAgICBGcmFuw6dhaXMgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvcGlja291bVxcXCI+cGlja291bTwvYT48YnI+XFxuICAgICAgICBFc3Bhw7FvbCAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9kcmVzZGVuXFxcIj5kcmVzZGVuPC9hPiwgPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL3BnYXJjZ29cXFwiPnBnYXJjZ288L2E+PGJyPlxcbiAgICAgICAgzpXOu867zrfOvc65zrrOrCAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9saW9uZGFuaVxcXCI+bGlvbmRhbmk8L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvc3RlZW15Y2hpY2tlbjFcXFwiPnN0ZWVteWNoaWNrZW4xPC9hPjxicj5cXG4gICAgICAgINCR0YrQu9Cz0LDRgNGB0LrQuCAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9yb3NzZW5wYXZsb3ZcXFwiPnJvc3NlbnBhdmxvdjwvYT48YnI+XFxuICAgICAgICBOZWRlcmxhbmRzIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL21heHNlXFxcIj5tYXhzZTwvYT48YnI+XFxuICAgICAgICBNYWd5YXIgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvdGlib25vdmFcXFwiPnRpYm9ub3ZhPC9hPjxicj5cXG4gICAgICAgIMSMZcWhdGluYSAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS92YWx0clxcXCI+dmFsdHI8L2E+PGJyPlxcbiAgICAgICAg16LXkdeo15nXquKAjiAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9ib3NyYWRcXFwiPmJvc3JhZDwvYT48YnI+XFxuICAgICAgICBQb2xza2kgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUva25pdHR5YnluYXR1cmVcXFwiPmtuaXR0eWJ5bmF0dXJlPC9hPjxicj5cXG4gICAgICAgIFBvcnR1Z3XDqnMgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvYWxhbXlyanVuaW9yXFxcIj5hbGFteXJqdW5pb3I8L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvY2hhcmxpZTc3N3B0XFxcIj5jaGFybGllNzc3cHQ8L2E+PGJyPlxcbiAgICAgICAgUG9ydHVndcOqcyBCUiAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9jaGFybGllNzc3cHRcXFwiPmNoYXJsaWU3NzdwdDwvYT48YnI+XFxuICAgICAgICBCYWhhc2EgSW5kb25lc2lhIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2xldnljb3JlXFxcIj5sZXZ5Y29yZTwvYT4sIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9oYXBweXBob2VuaXhcXFwiPmhhcHB5cGhvZW5peDwvYT48YnI+XFxuICAgICAgICDnuYHpq5TkuK3mlocgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvZGVhbmxpdVxcXCI+ZGVhbmxpdTwvYT48YnI+XFxuICAgICAgICDnroDkvZPkuK3mlocgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvaHVhbmdkYXNodWFuZ1xcXCI+aHVhbmdkYXNodWFuZzwvYT4sIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9vZmx5aGlnaFxcXCI+b2ZseWhpZ2g8L2E+PGJyPlxcbiAgICAgICAgRG9sYW4gLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvbWF4c2VcXFwiPm1heHNlPC9hPjxicj5cXG4gICAgICAgIFN2ZW5zayAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9hY2lkeW9cXFwiPmFjaWR5bzwvYT4sIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS90aGUtZWdvLXlvdVxcXCI+dGhlLWVnby1pcy15b3U8L2E+PGJyPlxcbiAgICAgICAgPCEtLVxcbiAgICAgICAgbWFsYXkta2lsbHVtaW5hdGljXFxuICAgICAgICAtLT5cXG4gICAgPC9wPlxcbiAgICA8cD5cXG4gICAgPGI+PHU+e3snQUJPVVRfMTAnfHRyYW5zbGF0ZX19PC91PjwvYj5cXG4gICAgPGJyPjxhIGhyZWY9XFxcImh0dHBzOi8vc3RlZW0uaW9cXFwiPmh0dHBzOi8vc3RlZW0uaW88L2E+XFxuICAgIDxicj48YSBocmVmPVxcXCJodHRwczovL2dvbG9zLmlvXFxcIj5odHRwczovL2dvbG9zLmlvPC9hPlxcbiAgICA8L3A+XFxuICA8L2lvbi1jb250ZW50PlxcbjwvaW9uLXZpZXc+XFxuXCJcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cblx0LnN0YXRlKCdhcHAubWFya2V0Jywge1xuXHRcdHVybDogJy9tYXJrZXQnLFxuXHRcdHZpZXdzOiB7XG5cdFx0XHQnbWVudUNvbnRlbnQnOiB7XG5cdFx0XHRcdC8vdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvc2V0dGluZ3MuaHRtbCdcblx0XHRcdFx0dGVtcGxhdGU6IFwiPGlvbi12aWV3IHZpZXctY2FjaGU9XFxcImZhbHNlXFxcIiB2aWV3LXRpdGxlPVxcXCJ7eydNQVJLRVRQTEFDRScgfCB0cmFuc2xhdGV9fVxcXCI+XFxuICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcInBhZGRpbmdcXFwiPlxcbiAgICA8aDQ+e3snRVhURVJOQUxfQVBQUyd8dHJhbnNsYXRlfX08L2g0PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCIgbmctY2xpY2s9XFxcInJlcXVlc3RBcHAoJ1N0ZWVtTW9uaXRvcicpXFxcIj5cXG4gICAgICAgIDxjZW50ZXI+XFxuICAgICAgICAgIDxpbWcgc3JjPVxcXCJpbWcvbG9nb19zdGVlbW1vbml0b3IucG5nXFxcIiBhbHQ9XFxcIlN0ZWVtIE1vbml0b3JcXFwiIHdpZHRoPVxcXCIxMDBcXFwiPlxcbiAgICAgICAgICA8Yj5TdGVlbSBNb25pdG9yPC9iPlxcbiAgICAgICAgICA8cCBjbGFzcz1cXFwiZ3JheVxcXCI+e3snQlknfHRyYW5zbGF0ZX19IDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9nb29kLWthcm1hXFxcIj5GZXJ1ejwvYT48L3A+XFxuICAgICAgICA8L2NlbnRlcj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiIG5nLWNsaWNrPVxcXCJyZXF1ZXN0QXBwKCdTdGVlbUZlc3QnKVxcXCI+XFxuICAgICAgICA8Y2VudGVyPlxcbiAgICAgICAgICA8aW1nIHNyYz1cXFwiaW1nL2xvZ29fc3RlZW1mZXN0LnBuZ1xcXCIgYWx0PVxcXCJTdGVlbSBGZXN0XFxcIiB3aWR0aD1cXFwiMTAwXFxcIj5cXG4gICAgICAgICAgPGI+U3RlZW0gRmVzdDwvYj5cXG4gICAgICAgICAgPHAgY2xhc3M9XFxcImdyYXlcXFwiPnt7J0JZJ3x0cmFuc2xhdGV9fSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvZ29vZC1rYXJtYVxcXCI+RmVydXo8L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvcm9lbGFuZHBcXFwiPlJvZWxhbmQ8L2E+ICZhbXA7IDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9jYXNzXFxcIj5DYXNzPC9hPjwvcD5cXG4gICAgICAgIDwvY2VudGVyPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj48YnIvPlxcbiAgICA8aDQ+e3snUExVR0lOUyd8dHJhbnNsYXRlfX08L2g0PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBpdGFsaWNcXFwiPlxcbiAgICAgICAgPGNlbnRlcj5cXG4gICAgICAgICAge3snQ09NSU5HX1NPT04nfHRyYW5zbGF0ZX19Li4uXFxuICAgICAgICA8L2NlbnRlcj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxici8+XFxuICAgIDxoND57eydTVUdHRVNUJ3x0cmFuc2xhdGV9fTwvaDQ+PGJyLz5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiIG5nLWNsaWNrPVxcXCJyZXF1ZXN0QXBwKCdOZXcnKVxcXCI+XFxuICAgICAgICA8Y2VudGVyPlxcbiAgICAgICAgICA8aW1nIHNyYz1cXFwiaW1nL3BsdXMucG5nXFxcIiBhbHQ9XFxcIlN1Z2dlc3QgTmV3XFxcIiB3aWR0aD1cXFwiMTAwXFxcIj5cXG4gICAgICAgICAgPGI+e3snTkVXJ3x0cmFuc2xhdGV9fTwvYj5cXG4gICAgICAgIDwvY2VudGVyPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9pb24tY29udGVudD5cXG48L2lvbi12aWV3PlxcblwiLFxuXHRcdFx0XHRjb250cm9sbGVyOiAnTWFya2V0Q3RybCdcblx0XHRcdH1cblx0XHR9XG5cdH0pXG5cbiAgLnN0YXRlKCdhcHAuc2VuZCcsIHtcbiAgICB1cmw6ICcvc2VuZCcsXG4gICAgdmlld3M6IHtcbiAgICAgICdtZW51Q29udGVudCc6IHtcbiAgICAgICAgLy90ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9zZXR0aW5ncy5odG1sJ1xuICAgICAgICB0ZW1wbGF0ZTogXCI8aW9uLXZpZXcgdmlldy1jYWNoZT1cXFwiZmFsc2VcXFwiIHZpZXctdGl0bGU9XFxcInt7J1RSQU5TRkVSJ3x0cmFuc2xhdGV9fVxcXCI+XFxuICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcInBhZGRpbmdcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJsaXN0XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtIGl0ZW0taW5wdXQgaXRlbS1pY29uLXJpZ2h0XFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1sYWJlbFxcXCI+e3snVE8nfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIG5nLW1vZGVsPVxcXCJkYXRhLnVzZXJuYW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwie3snVE9fREVTQyd8dHJhbnNsYXRlfX1cXFwiIG5nLWNoYW5nZT1cXFwiY2hhbmdlVXNlcm5hbWUoKVxcXCI+XFxuICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24taW9zLWNhbWVyYS1vdXRsaW5lXFxcIiBuZy1jbGljaz1cXFwicXJTY2FuKClcXFwiPjwvaT5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8bGFiZWwgY2xhc3M9XFxcIml0ZW0gaXRlbS1pbnB1dCBpdGVtLXNlbGVjdFxcXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtbGFiZWxcXFwiPnt7J0FTU0VUJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICAgIDwhLS08c2VsZWN0IG5nLW1vZGVsPVxcXCJkYXRhLnR5cGVcXFwiIG5nLWNoYW5nZT1cXFwidHlwZWNoYW5nZSgpXFxcIj5cXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJzdGVlbVxcXCI+U1RFRU08L29wdGlvbj5cXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJzYmRcXFwiPlNCRDwvb3B0aW9uPlxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcInNwXFxcIj5TUDwvb3B0aW9uPlxcbiAgICAgICAgPC9zZWxlY3Q+LS0+XFxuICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVxcXCJkYXRhLnR5cGVcXFwiIG5nLW9wdGlvbnM9XFxcIml0ZW0udHlwZSBhcyBpdGVtLm5hbWUgZm9yIGl0ZW0gaW4gZGF0YS50eXBlcyB0cmFjayBieSBpdGVtLmlkXFxcIj48L3NlbGVjdD5cXG4gICAgICA8L2xhYmVsPlxcbiAgICAgIDxsYWJlbCBjbGFzcz1cXFwiaXRlbSBpdGVtLWlucHV0XFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1sYWJlbFxcXCI+e3snQU1PVU5UJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJudW1iZXJcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eydBTU9VTlQnfHRyYW5zbGF0ZX19XFxcIiBzdGVwPVxcXCIwLjAwMVxcXCIgbmctbW9kZWw9XFxcImRhdGEuYW1vdW50XFxcIj5cXG4gICAgICA8L2xhYmVsPlxcbiAgICAgIDxsYWJlbCBjbGFzcz1cXFwiaXRlbSBpdGVtLWlucHV0XFxcIiBuZy1pZj1cXFwiZGF0YS50eXBlICE9ICdzcCcmJmRhdGEudHlwZSAhPSAnZ29sb3NwJ1xcXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtbGFiZWxcXFwiPnt7J01FTU8nfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgICAgPHRleHRhcmVhIG5nLW1vZGVsPVxcXCJkYXRhLm1lbW9cXFwiIHJvd3M9XFxcIjNcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eydQVUJMSUNfTUVNTyd8dHJhbnNsYXRlfX1cXFwiPjwvdGV4dGFyZWE+XFxuICAgICAgPC9sYWJlbD5cXG4gICAgICA8cCBjbGFzcz1cXFwiaXRlbVxcXCIgbmctaWY9XFxcImJhbGFuY2VcXFwiPnt7J0FWQUlMQUJMRSd8dHJhbnNsYXRlfX06IHt7YmFsYW5jZS5iYWxhbmNlfX0sIHt7YmFsYW5jZS5zYmRfYmFsYW5jZX19IDxpIGNsYXNzPVxcXCJpY29uIGlvbi1yZWZyZXNoIHB1bGwtcmlnaHRcXFwiIG5nLWNsaWNrPVxcXCJyZWZyZXNoKClcXFwiPjwvaT48L3A+XFxuICAgICAgPGJyPlxcbiAgICAgIDxjZW50ZXI+PGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1wb3NpdGl2ZVxcXCIgbmctY2xpY2s9XFxcInRyYW5zZmVyKClcXFwiPlxcbiAgICAgICAge3snU0VORCd8dHJhbnNsYXRlfX1cXG4gICAgICA8L2J1dHRvbj48L2NlbnRlcj5cXG4gICAgICA8YnI+XFxuICAgICAgPGNlbnRlcj48cXIgdGV4dD1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZVxcXCI+PC9xcj48L2NlbnRlcj5cXG4gICAgICA8Y2VudGVyPjxpIGNsYXNzPVxcXCJpdGFsaWNcXFwiPnt7JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZX19PC9pPjwvY2VudGVyPlxcbiAgICA8L2Rpdj5cXG4gIDwvaW9uLWNvbnRlbnQ+XFxuPC9pb24tdmlldz5cXG5cIixcbiAgICAgICAgY29udHJvbGxlcjogJ1NlbmRDdHJsJ1xuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICAuc3RhdGUoJ2FwcC5mb2xsb3cnLCB7XG4gICAgdXJsOiAnL2ZvbGxvdycsXG4gICAgdmlld3M6IHtcbiAgICAgICdtZW51Q29udGVudCc6IHtcbiAgICAgICAgLy90ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9mb2xsb3cuaHRtbCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIjxpb24tdmlldyB2aWV3LWNhY2hlPVxcXCJmYWxzZVxcXCIgdmlldy10aXRsZT1cXFwie3snRk9MTE9XJyB8IHRyYW5zbGF0ZX19XFxcIj5cXG4gIDxpb24tY29udGVudCBjbGFzcz1cXFwicGFkZGluZyBoYXMtZm9vdGVyXFxcIiBkZWxlZ2F0ZS1oYW5kbGU9XFxcImxpc3RTY3JvbGxcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJsaXN0IGxpc3QtaW5zZXRcXFwiIG5nLWlmPVxcXCJhY3RpdmU9PSdmb2xsb3dlcnMnXFxcIj5cXG4gICAgICA8bGFiZWwgY2xhc3M9XFxcIml0ZW0gaXRlbS1pbnB1dFxcXCI+XFxuICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tc2VhcmNoIHBsYWNlaG9sZGVyLWljb25cXFwiPjwvaT5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwic2VhcmNodS5mb2xsb3dlclxcXCIgcGxhY2Vob2xkZXI9XFxcInt7J1NFQVJDSF9GT0xMT1dFUlMnIHwgdHJhbnNsYXRlfX1cXFwiPlxcbiAgICAgIDwvbGFiZWw+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJsaXN0IGxpc3QtaW5zZXRcXFwiIG5nLWlmPVxcXCJhY3RpdmU9PSdmb2xsb3dpbmcnXFxcIj5cXG4gICAgICA8bGFiZWwgY2xhc3M9XFxcIml0ZW0gaXRlbS1pbnB1dFxcXCI+XFxuICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tc2VhcmNoIHBsYWNlaG9sZGVyLWljb25cXFwiPjwvaT5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwic2VhcmNodS5mb2xsb3dpbmdcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eydTRUFSQ0hfRk9MTE9XSU5HJyB8IHRyYW5zbGF0ZX19XFxcIj5cXG4gICAgICA8L2xhYmVsPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibGlzdFxcXCIgbmctaWY9XFxcImFjdGl2ZT09J2ZvbGxvd2VycycgJiYgZm9sbG93ZXJzLmxlbmd0aD4wXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtIGl0ZW0tYnV0dG9uLXJpZ2h0XFxcIiBuZy1yZXBlYXQ9XFxcImYgaW4gZm9sbG93ZXJzIHwgZmlsdGVyOnNlYXJjaHUgIHRyYWNrIGJ5ICRpbmRleFxcXCI+XFxuICAgICAgICA8c3BhbiBuZy1jbGljaz1cXFwicHJvZmlsZVZpZXcoZi5mb2xsb3dlcilcXFwiPnt7Zi5mb2xsb3dlcn19PC9zcGFuPlxcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1wb3NpdGl2ZSBidXR0b24tb3V0bGluZVxcXCIgbmctaWY9XFxcIiFpc0ZvbGxvd2VkKGYuZm9sbG93ZXIpXFxcIiBuZy1jbGljaz1cXFwiZm9sbG93VXNlcihmLmZvbGxvd2VyKVxcXCI+XFxuICAgICAgICB7eydGT0xMT1dfQkFDSycgfCB0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9idXR0b24+XFxuICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXBvc2l0aXZlXFxcIiBuZy1pZj1cXFwiaXNGb2xsb3dlZChmLmZvbGxvd2VyKVxcXCIgbmctY2xpY2s9XFxcInVuZm9sbG93VXNlcihmLmZvbGxvd2VyKVxcXCI+XFxuICAgICAgICB7eydGT0xMT1dFRCcgfCB0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9idXR0b24+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJsaXN0XFxcIiBuZy1pZj1cXFwiYWN0aXZlPT0nZm9sbG93aW5nJyAmJiBmb2xsb3dpbmcubGVuZ3RoPjBcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW0gaXRlbS1idXR0b24tcmlnaHRcXFwiIG5nLXJlcGVhdD1cXFwiZiBpbiBmb2xsb3dpbmcgfCBmaWx0ZXI6c2VhcmNodSAgdHJhY2sgYnkgJGluZGV4XFxcIj5cXG4gICAgICAgIDxzcGFuIG5nLWNsaWNrPVxcXCJwcm9maWxlVmlldyhmLmZvbGxvd2luZylcXFwiPnt7Zi5mb2xsb3dpbmd9fTwvc3Bhbj5cXG4gICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcG9zaXRpdmUgYnV0dG9uLW91dGxpbmVcXFwiIG5nLWlmPVxcXCIhaXNGb2xsb3dpbmcoZi5mb2xsb3dpbmcpXFxcIiBuZy1jbGljaz1cXFwidW5mb2xsb3dVc2VyKGYuZm9sbG93aW5nKVxcXCI+XFxuICAgICAgICB7eydVTkZPTExPVycgfCB0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9idXR0b24+XFxuICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXBvc2l0aXZlXFxcIiBuZy1pZj1cXFwiaXNGb2xsb3dpbmcoZi5mb2xsb3dpbmcpXFxcIj5cXG4gICAgICAgIHt7J0ZPTExPV0lORycgfCB0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9idXR0b24+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8IS0tPGlvbi1pbmZpbml0ZS1zY3JvbGwgb24taW5maW5pdGU9XFxcImxvYWRNb3JlKClcXFwiIG5nLWlmPVxcXCJsYXN0ZFxcXCIgZGlzdGFuY2U9XFxcIjIlXFxcIj48L2lvbi1pbmZpbml0ZS1zY3JvbGw+LS0+XFxuICA8L2lvbi1jb250ZW50PlxcbiAgPGRpdiBjbGFzcz1cXFwiYmFyIHByb2ZpbGUgYmFyLWZvb3RlclxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImJ1dHRvbi1iYXJcXFwiPlxcbiAgICAgIDxhIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLWxhcmdlIGJ1dHRvbi1yb3lhbCBpY29uIGlvbi1pb3MtcGVvcGxlXFxcIiBuZy1jbGFzcz1cXFwieydhY3RpdmUnOmFjdGl2ZT09J2ZvbGxvd2Vycyd9XFxcIiBuZy1jbGljaz1cXFwiY2hhbmdlKCdmb2xsb3dlcnMnKVxcXCI+IHt7J0ZPTExPV0VSUycgfCB0cmFuc2xhdGV9fSA8c3BhbiBuZy1pZj1cXFwiZm9sbG93ZXJzLmxlbmd0aD4wXFxcIj4oe3tmb2xsb3dlcnMubGVuZ3RofX0pPC9zcGFuPjwvYT5cXG4gICAgICA8YSBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1yb3lhbCBpY29uIGlvbi1wZXJzb24tYWRkXFxcIiBuZy1jbGFzcz1cXFwieydhY3RpdmUnOmFjdGl2ZT09J2ZvbGxvd2luZyd9XFxcIiBuZy1jbGljaz1cXFwiY2hhbmdlKCdmb2xsb3dpbmcnKVxcXCI+IHt7J0ZPTExPV0VEJyB8IHRyYW5zbGF0ZX19IDxzcGFuIG5nLWlmPVxcXCJmb2xsb3dpbmcubGVuZ3RoPjBcXFwiPih7e2ZvbGxvd2luZy5sZW5ndGh9fSk8L3NwYW4+PC9hPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvaW9uLXZpZXc+XFxuXCIsXG4gICAgICAgIGNvbnRyb2xsZXI6ICdGb2xsb3dDdHJsJ1xuICAgICAgfVxuICAgIH1cbiAgfSlcblxuXG4gIC5zdGF0ZSgnYXBwLmV4Y2hhbmdlJywge1xuICAgIHVybDogJy9leGNoYW5nZS86dXNlcm5hbWUnLFxuICAgIHZpZXdzOiB7XG4gICAgICAnbWVudUNvbnRlbnQnOiB7XG4gICAgICBcdHRlbXBsYXRlOiBcIjxpb24tdmlldyB2aWV3LWNhY2hlPVxcXCJmYWxzZVxcXCIgdmlldy10aXRsZT1cXFwie3snTUFSS0VUX1ZJRVcnIHwgdHJhbnNsYXRlfX1cXFwiPlxcbiAgPGlvbi1jb250ZW50IGNsYXNzPVxcXCJwYWRkaW5nIGhhcy1mb290ZXIgZXhjaGFuZ2VcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJcXFwiIG5nLWlmPVxcXCJhY3RpdmU9PSdidXknXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgaGVhZGVyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3snUFJJQ0UnIHwgdHJhbnNsYXRlfX08L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3snQU1PVU5UJyB8IHRyYW5zbGF0ZX19PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7J1RPVEFMJyB8IHRyYW5zbGF0ZX19PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIiBuZy1yZXBlYXQ9XFxcIihrZXksIGYpIGluIG9yZGVycy5iaWRzXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tmLnJlYWxfcHJpY2V8bnVtYmVyOjR9fTwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2Yub3JkZXJfcHJpY2UucXVvdGV9fTwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2Yub3JkZXJfcHJpY2UuYmFzZX19PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJcXFwiIG5nLWlmPVxcXCJhY3RpdmU9PSdzZWxsJ1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicm93IGhlYWRlclxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7J1BSSUNFJyB8IHRyYW5zbGF0ZX19PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7J0FNT1VOVCcgfCB0cmFuc2xhdGV9fTwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57eydUT1RBTCcgfCB0cmFuc2xhdGV9fTwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCIgbmctcmVwZWF0PVxcXCIoa2V5LCBmKSBpbiBvcmRlcnMuYXNrc1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7Zi5yZWFsX3ByaWNlfG51bWJlcjo0fX08L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tmLm9yZGVyX3ByaWNlLnF1b3RlfX08L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tmLm9yZGVyX3ByaWNlLmJhc2V9fTwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiXFxcIiBuZy1pZj1cXFwiYWN0aXZlPT0nb3BlbidcXFwiPlxcbiAgICAgIDxwIGNsYXNzPVxcXCJwYWRkaW5nXFxcIiBuZy1pZj1cXFwib3Blbm9yZGVycy5sZW5ndGg8MVxcXCI+XFxuICAgICAgICB7eydOT09SREVSUycgfCB0cmFuc2xhdGV9fSBAe3t1c2VybmFtZX19XFxuICAgICAgPC9wPlxcbiAgICAgIDxkaXYgbmctaWY9XFxcIm9wZW5vcmRlcnMubGVuZ3RoPjBcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93IGhlYWRlclxcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3snUFJJQ0UnIHwgdHJhbnNsYXRlfX08L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57eydBTU9VTlQnIHwgdHJhbnNsYXRlfX08L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57eydUT1RBTCcgfCB0cmFuc2xhdGV9fTwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiIG5nLXJlcGVhdD1cXFwiKGtleSwgZikgaW4gb3Blbm9yZGVyc1xcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tmLnJlYWxfcHJpY2V8bnVtYmVyOjR9fTwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiIG5nLWlmPVxcXCJmLnNlbGxlcj09JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZVxcXCI+e3tmLnNlbGxfcHJpY2UucXVvdGV9fTwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiIG5nLWlmPVxcXCJmLnNlbGxlcj09JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZVxcXCI+e3tmLnNlbGxfcHJpY2UuYmFzZX19PC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCIgbmctaWY9XFxcImYuYnV5ZXI9PSRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWVcXFwiPnt7Zi5idXlfcHJpY2UucXVvdGV9fTwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiIG5nLWlmPVxcXCJmLmJ1eWVyPT0kcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lXFxcIj57e2YuYnV5X3ByaWNlLmJhc2V9fTwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJcXFwiIG5nLWlmPVxcXCJhY3RpdmU9PSdoaXN0b3J5J1xcXCI+XFxuICAgICAgPCEtLTxwIGNsYXNzPVxcXCJwYWRkaW5nXFxcIj5Ob3RoaW5nIGhlcmUsIHlldC4uLjwvcD4tLT5cXG4gICAgICA8ZGl2IG5nLWlmPVxcXCJyZWNlbnRfdHJhZGVzLmxlbmd0aD4wXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvdyBoZWFkZXJcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7J0RBVEUnIHwgdHJhbnNsYXRlfX08L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57eydQUklDRScgfCB0cmFuc2xhdGV9fTwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7JHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1zdW5pdH19PC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3skcm9vdC4kc3RvcmFnZS5wbGF0Zm9ybWRvbGxhcn19PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCIgbmctcmVwZWF0PVxcXCIoa2V5LCBmKSBpbiByZWNlbnRfdHJhZGVzXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2YuZGF0ZXx0aW1lYWdvfX08L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2YuY3VycmVudF9wYXlzLnNwbGl0KFxcXCIgXFxcIilbMF0vZi5vcGVuX3BheXMuc3BsaXQoXFxcIiBcXFwiKVswXXxudW1iZXI6Nn19PC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tmLmN1cnJlbnRfcGF5cy5zcGxpdChcXFwiIFxcXCIpWzBdfG51bWJlcjozfX08L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2Yub3Blbl9wYXlzLnNwbGl0KFxcXCIgXFxcIilbMF18bnVtYmVyOjN9fTwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9pb24tY29udGVudD5cXG4gIDxkaXYgY2xhc3M9XFxcInByb2ZpbGUgYmFyIGJhci1mb290ZXJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJidXR0b24tYmFyXFxcIj5cXG4gICAgICA8YSBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1sYXJnZSBidXR0b24tcm95YWwgaWNvbiBpb24tYXJyb3ctZG93bi1hXFxcIiBuZy1jbGFzcz1cXFwieydhY3RpdmUnOmFjdGl2ZT09J2J1eSd9XFxcIiBuZy1jbGljaz1cXFwiY2hhbmdlKCdidXknKVxcXCI+IHt7J0JVWScgfCB0cmFuc2xhdGV9fTwvYT5cXG4gICAgICA8YSBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1yb3lhbCBpY29uIGlvbi1hcnJvdy11cC1hXFxcIiBuZy1jbGFzcz1cXFwieydhY3RpdmUnOmFjdGl2ZT09J3NlbGwnfVxcXCIgbmctY2xpY2s9XFxcImNoYW5nZSgnc2VsbCcpXFxcIj4ge3snU0VMTCcgfCB0cmFuc2xhdGV9fTwvYT5cXG4gICAgICA8YSBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1yb3lhbCBpY29uIGlvbi1mbGFnXFxcIiBuZy1jbGFzcz1cXFwieydhY3RpdmUnOmFjdGl2ZT09J29wZW4nfVxcXCIgbmctY2xpY2s9XFxcImNoYW5nZSgnb3BlbicpXFxcIj57eydPUEVOJyB8IHRyYW5zbGF0ZX19PC9hPlxcbiAgICAgIDxhIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXJveWFsIGljb24gaW9uLWlvcy1jbG9ja1xcXCIgbmctY2xhc3M9XFxcInsnYWN0aXZlJzphY3RpdmU9PSdoaXN0b3J5J31cXFwiICBuZy1jbGljaz1cXFwiY2hhbmdlKCdoaXN0b3J5JylcXFwiPnt7J0hJU1RPUlknIHwgdHJhbnNsYXRlfX08L2E+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9pb24tdmlldz5cXG5cIixcbiAgICAgICAgLy90ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9leGNoYW5nZS5odG1sJyxcbiAgICAgICAgY29udHJvbGxlcjogJ0V4Y2hhbmdlQ3RybCdcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgLnN0YXRlKCdhcHAucHJvZmlsZScsIHtcbiAgICB1cmw6ICcvcHJvZmlsZS86dXNlcm5hbWUnLFxuICAgIHZpZXdzOiB7XG4gICAgICAnbWVudUNvbnRlbnQnOiB7XG4gICAgICAgIC8vdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvcHJvZmlsZS5odG1sJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiPGlvbi12aWV3IHZpZXctdGl0bGU9XFxcIlxcXCIgaGlkZS1uYXYtYmFyPVxcXCJ0cnVlXFxcIiB2aWV3LWNhY2hlPVxcXCJmYWxzZVxcXCI+PCEtLW5nLWNsYXNzPVxcXCJ7J21wYic6JHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuY292ZXJfaW1hZ2V9XFxcIi0tPlxcbiAgPGlvbi1jb250ZW50IGNsYXNzPVxcXCJoYXMtZm9vdGVyXFxcIiBvdmVyZmxvdy1zY3JvbGw9XFxcInRydWVcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJiYXIgYmFyLXN1YmhlYWRlciBteXN1YmhlYWRlciBiYXItcG9zaXRpdmVcXFwiIG5nLXN0eWxlPVxcXCJjc3N8fG1jc3NcXFwiPlxcbiAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24taWNvbiBidXR0b24tY2xlYXIgaW9uLWlvcy1hcnJvdy1iYWNrIHByb2ZpbGVidG5cXFwiIG9uLXRhcD1cXFwiZ29CYWNrKClcXFwiPjwvYnV0dG9uPlxcbiAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tb3V0bGluZSBidXR0b24tbGlnaHQgcHJvZmlsZWJ0bl9mb2xsb3dcXFwiIG9uLXRhcD1cXFwiZm9sbG93VXNlcih1c2VyLnVzZXJuYW1lKVxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXIgJiYgJHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZSAhPSB1c2VyLnVzZXJuYW1lICYmICFpc0ZvbGxvd2luZyh1c2VyLnVzZXJuYW1lKVxcXCI+PCEtLTxpIGNsYXNzPVxcXCJmYSBmYS11c2VyLXBsdXMgZmEtbGdcXFwiPjwvaT4tLT57eydGT0xMT1cnfHRyYW5zbGF0ZX19PC9idXR0b24+XFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1jbGVhciBwcm9maWxlYnRuX2ZvbGxvdyBidXR0b24taWNvbiBpb24tY2FtZXJhXFxcIiBvbi10YXA9XFxcInNob3dDb3ZlcigpXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlciAmJiAkcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lID09PSB1c2VyLnVzZXJuYW1lXFxcIj48L2J1dHRvbj5cXG4gICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLW91dGxpbmUgYnV0dG9uLWxpZ2h0IHByb2ZpbGVidG5fZm9sbG93XFxcIiBvbi10YXA9XFxcInVuZm9sbG93VXNlcih1c2VyLnVzZXJuYW1lKVxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXIgJiYgJHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZSAhPSB1c2VyLnVzZXJuYW1lICYmIGlzRm9sbG93aW5nKHVzZXIudXNlcm5hbWUpXFxcIj48IS0tYnV0dG9uLWljb24gYnV0dG9uLWNsZWFyPGkgY2xhc3M9XFxcImZhIGZhLXVzZXItdGltZXMgZmEtbGdcXFwiPjwvaT4tLT57eydVTkZPTExPVyd8dHJhbnNsYXRlfX08L2J1dHRvbj4mbmJzcDtcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjZW50ZXJcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtLW15YXZhdGFyXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlciAmJiAkcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lID09IHVzZXIudXNlcm5hbWVcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpdGVtLW15YXZhdGFyXFxcIiBuZy1pZj1cXFwiISgkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5wcm9maWxlX2ltYWdlfHwkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEudXNlcl9pbWFnZSlcXFwiPjxpbWcgc3JjPVxcXCJpbWcvdXNlcl9wcm9maWxlLnBuZ1xcXCIgb24tdGFwPVxcXCJzaG93UHJvZmlsZSgpXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPGltZyBuZy1zcmM9XFxcInt7JHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUucHJvZmlsZV9pbWFnZSB8fCAkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEudXNlcl9pbWFnZX19XFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnVzZXJfaW1hZ2UgfHwgJHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUucHJvZmlsZV9pbWFnZVxcXCIgb24tdGFwPVxcXCJzaG93UHJvZmlsZSgpXFxcIiAvPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvb3Rwcm9maWxlaW5mb1xcXCI+XFxuICAgICAgICAgICAgICA8aDQgY2xhc3M9XFxcImNlbnRlclxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJsaWdodFxcXCI+QHt7JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZX19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAmbmJzcDtcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicmVwdXRhdGlvblxcXCI+e3skcm9vdC4kc3RvcmFnZS51c2VyLnJlcHV0YXRpb258cmVwdXRhdGlvbn19XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgPC9oND5cXG4gICAgICAgICAgICAgIDxwPnt7JHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuYWJvdXR9fTwvcD5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInBhZGRpbmdcXFwiPlxcbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tYW5kcm9pZC1saXN0XFxcIj48L2k+Jm5ic3A7XFxuICAgICAgICAgICAgICAgIHt7JHJvb3QuJHN0b3JhZ2UudXNlci5wb3N0X2NvdW50fX0mbmJzcDtcXG4gICAgICAgICAgICAgICAgfCZuYnNwO1xcbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tYXJyb3ctZ3JhcGgtdXAtcmlnaHRcXFwiPjwvaT4mbmJzcDtcXG4gICAgICAgICAgICAgICAge3skcm9vdC4kc3RvcmFnZS51c2VyLnZvdGluZ19wb3dlci8xMDB8bnVtYmVyOjJ9fSZuYnNwO1xcbiAgICAgICAgICAgICAgICB8Jm5ic3A7PGkgY2xhc3M9XFxcImljb24gaW9uLWlvcy1wZW9wbGVcXFwiPjwvaT4mbmJzcDtcXG4gICAgICAgICAgICAgICAge3tmb2xsb3dkZXRhaWxzLmZvbGxvd2VyX2NvdW50fX0mbmJzcDtcXG4gICAgICAgICAgICAgICAgfCZuYnNwOzxpIGNsYXNzPVxcXCJpb24tcGVyc29uLWFkZFxcXCI+PC9pPiZuYnNwO1xcbiAgICAgICAgICAgICAgICB7e2ZvbGxvd2RldGFpbHMuZm9sbG93aW5nX2NvdW50fX1cXG4gICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgPHA+PHNwYW4gbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlICYmICRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmxvY2F0aW9uXFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWxvY2F0aW9uXFxcIj48L2k+Jm5ic3A7XFxuICAgICAgICAgICAgICAgIHt7JHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUubG9jYXRpb259fVxcbiAgICAgICAgICAgICAgICAmbmJzcDtcXG4gICAgICAgICAgICAgIDwvc3Bhbj4mbmJzcDtcXG4gICAgICAgICAgICAgIDxzcGFuIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZSAmJiAkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS53ZWJzaXRlXFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWxpbmtcXFwiPjwvaT4mbmJzcDtcXG4gICAgICAgICAgICAgICAgPGEgb24tdGFwPVxcXCJ3aW5kb3cub3Blbigne3skcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS53ZWJzaXRlfX0nLCAnX3N5c3RlbScpO1xcXCIgc3R5bGU9XFxcImNvbG9yOndoaXRlIWltcG9ydGFudDt0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXFwiPldlYlNpdGU8L2E+XFxuICAgICAgICAgICAgICAgICZuYnNwO1xcbiAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgPHNwYW4gbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXIuY3JlYXRlZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1jYWxlbmRhclxcXCI+PC9pPiZuYnNwO1xcbiAgICAgICAgICAgICAgICB7eyRyb290LiRzdG9yYWdlLnVzZXIuY3JlYXRlZHxkYXRlfX1cXG4gICAgICAgICAgICAgICAgJm5ic3A7XFxuICAgICAgICAgICAgICA8L3NwYW4+PC9wPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbS1teWF2YXRhclxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgIT09IHVzZXIudXNlcm5hbWVcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpdGVtLW15YXZhdGFyXFxcIiBuZy1pZj1cXFwiISh1c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5wcm9maWxlX2ltYWdlfHx1c2VyLmpzb25fbWV0YWRhdGEudXNlcl9pbWFnZSlcXFwiPjxpbWcgc3JjPVxcXCJpbWcvdXNlcl9wcm9maWxlLnBuZ1xcXCIgLz48L3NwYW4+XFxuICAgICAgICAgICAgPGltZyBuZy1zcmM9XFxcInt7dXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUucHJvZmlsZV9pbWFnZSB8fCB1c2VyLmpzb25fbWV0YWRhdGEudXNlcl9pbWFnZX19XFxcIiBuZy1pZj1cXFwidXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUucHJvZmlsZV9pbWFnZSB8fCB1c2VyLmpzb25fbWV0YWRhdGEudXNlcl9pbWFnZVxcXCIgLz5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb290cHJvZmlsZWluZm9cXFwiPlxcbiAgICAgICAgICAgICAgPGg0IGNsYXNzPVxcXCJjZW50ZXJcXFwiPjxzcGFuIGNsYXNzPVxcXCJsaWdodFxcXCI+QHt7dXNlci51c2VybmFtZX19PC9zcGFuPiZuYnNwOzxkaXYgY2xhc3M9XFxcInJlcHV0YXRpb25cXFwiPnt7dXNlci5yZXB1dGF0aW9ufHJlcHV0YXRpb259fTwvZGl2PjwvaDQ+XFxuICAgICAgICAgICAgICA8cD57e3VzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmFib3V0fX08L3A+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYWRkaW5nXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tYW5kcm9pZC1saXN0XFxcIj48L2k+Jm5ic3A7e3t1c2VyLnBvc3RfY291bnR9fSZuYnNwO3wmbmJzcDs8aSBjbGFzcz1cXFwiaWNvbiBpb24tYXJyb3ctZ3JhcGgtdXAtcmlnaHRcXFwiPjwvaT4mbmJzcDt7e3VzZXIudm90aW5nX3Bvd2VyLzEwMHxudW1iZXI6Mn19Jm5ic3A7fCZuYnNwOzxpIGNsYXNzPVxcXCJpY29uIGlvbi1pb3MtcGVvcGxlXFxcIj48L2k+Jm5ic3A7XFxuICAgICAgICAgICAgICB7e2ZvbGxvd2RldGFpbHMuZm9sbG93ZXJfY291bnR9fSZuYnNwO1xcbiAgICAgICAgICAgICAgfCZuYnNwOzxpIGNsYXNzPVxcXCJpb24tcGVyc29uLWFkZFxcXCI+PC9pPiZuYnNwO1xcbiAgICAgICAgICAgICAge3tmb2xsb3dkZXRhaWxzLmZvbGxvd2luZ19jb3VudH19PC9kaXY+XFxuICAgICAgICAgICAgICA8cD48c3BhbiBuZy1pZj1cXFwidXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUgJiYgdXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUubG9jYXRpb25cXFwiPlxcbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tbG9jYXRpb25cXFwiPjwvaT4mbmJzcDtcXG4gICAgICAgICAgICAgICAge3t1c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5sb2NhdGlvbn19XFxuICAgICAgICAgICAgICAgICZuYnNwO1xcbiAgICAgICAgICAgICAgPC9zcGFuPiZuYnNwO1xcbiAgICAgICAgICAgICAgPHNwYW4gbmctaWY9XFxcInVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlICYmIHVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLndlYnNpdGVcXFwiPlxcbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tbGlua1xcXCI+PC9pPiZuYnNwO1xcbiAgICAgICAgICAgICAgICA8YSBvbi10YXA9XFxcIndpbmRvdy5vcGVuKCd7e3VzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLndlYnNpdGV9fScsICdfc3lzdGVtJyk7XFxcIiBzdHlsZT1cXFwiY29sb3I6d2hpdGUhaW1wb3J0YW50O3RleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcXCI+V2ViU2l0ZTwvYT5cXG4gICAgICAgICAgICAgICAgJm5ic3A7XFxuICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICA8c3BhbiBuZy1pZj1cXFwidXNlci5jcmVhdGVkXFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWNhbGVuZGFyXFxcIj48L2k+Jm5ic3A7XFxuICAgICAgICAgICAgICAgIHt7dXNlci5jcmVhdGVkfGRhdGV9fVxcbiAgICAgICAgICAgICAgICAmbmJzcDtcXG4gICAgICAgICAgICAgIDwvc3Bhbj48L3A+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiaGFzLW15c3ViaGVhZGVyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJveCBibHVlXFxcIiBuZy1pZj1cXFwiYWN0aXZlIT0nd2FsbGV0J3x8YWN0aXZlIT0ncGVybWlzc2lvbnMnXFxcIj5cXG4gICAgICAgICAgPHAgY2xhc3M9XFxcInBhZGRpbmdcXFwiIG5nLWlmPVxcXCJub25leGlzdFxcXCI+e3snTk9USElOR19IRVJFJ3x0cmFuc2xhdGV9fTwvcD5cXG4gICAgICAgICAgPGlvbi1saXN0PlxcbiAgICAgICAgICAgIDwhLS08ZGl2IG5nLXJlcGVhdD1cXFwiKGtleSwgcGxheWxpc3QpIGluIHByb2ZpbGVcXFwiIGNsYXNzPVxcXCJpdGVtIHdyYXBcXFwiIG9uLXRhcD1cXFwib3BlbihwbGF5bGlzdClcXFwiPlxcbiAgICAgICAgICAgIDxoMyBjbGFzcz1cXFwiYm9sZFxcXCI+e3twbGF5bGlzdC5yb290X3RpdGxlfX08L2gzPlxcbiAgICAgICAgICAgIDxzcGFuIG5nLWJpbmQtaHRtbD1cXFwicGxheWxpc3QuYm9keS5zdWJzdHJpbmcoMCwxMDApfHBhcnNlVXJsXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9kaXY+LS0+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgbmctcmVwZWF0PVxcXCJwbGF5bGlzdCBpbiBkYXRhLnByb2ZpbGUgfCBvcmRlckJ5OictY3JlYXRlZCcgfCBsaW1pdFRvOjI1IHRyYWNrIGJ5ICRpbmRleFxcXCIgbmctY2xhc3M9XFxcInsnaXRlbS10aHVtYm5haWwtbGVmdCc6IHBsYXlsaXN0Lmpzb25fbWV0YWRhdGEuaW1hZ2V9XFxcIj5cXG4gICAgICAgICAgICAgIDxpbWcgbmctc3JjPVxcXCJ7e3BsYXlsaXN0Lmpzb25fbWV0YWRhdGEuaW1hZ2VbMF19fVxcXCIgb24tdGFwPVxcXCJvcGVuKHBsYXlsaXN0KVxcXCIgbmctaWY9XFxcInBsYXlsaXN0Lmpzb25fbWV0YWRhdGEuaW1hZ2VcXFwiIG9uZXJyb3I9XFxcInRoaXMuc3JjPSdpbWcvbm9pbWFnZS5wbmcnXFxcIi8+XFxuICAgICAgICAgICAgICAgIDxkaXYgb24tdGFwPVxcXCJvcGVuKHBsYXlsaXN0KVxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIndyYXBcXFwiPlxcbiAgICAgICAgICAgICAgICAgIDxoMj48aSBjbGFzcz1cXFwiZmEgZmEtbW9uZXkgcG9zaXRpdmVcXFwiIG5nLWlmPVxcXCJwbGF5bGlzdC5wcm9tb3RlZC5zcGxpdCgnICcpWzBdICE9PSAnMC4wMDAnXFxcIj48L2k+IDxpIGNsYXNzPVxcXCJmYSBmYS1maXJlIHBvc2l0aXZlXFxcIiBuZy1pZj1cXFwicGxheWxpc3QucGVyY2VudF9zdGVlbV9kb2xsYXJzID09PSAwXFxcIj48L2k+e3twbGF5bGlzdC5yb290X3RpdGxlfX08L2gyPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicG9zdGRldGFpbHNcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1hbmRyb2lkLXRpbWVcXFwiPjwvaT4mbmJzcDt7e3BsYXlsaXN0LmNyZWF0ZWR8dGltZWFnb319Jm5ic3A7e3snQlknfHRyYW5zbGF0ZX19Jm5ic3A7PGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtcGVyc29uXFxcIj48L2k+Jm5ic3A7e3twbGF5bGlzdC5hdXRob3J9fSZuYnNwOzxkaXYgY2xhc3M9XFxcInJlcHV0YXRpb25cXFwiPnt7cGxheWxpc3QuYXV0aG9yX3JlcHV0YXRpb258cmVwdXRhdGlvbnxudW1iZXI6MH19PC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgZ3JheSBwcm9maWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPjxpb24tc3Bpbm5lciBuZy1pZj1cXFwicGxheWxpc3QuaW52b3RpbmdcXFwiPjwvaW9uLXNwaW5uZXI+XFxuICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tY2lyY2xlLXVwIGZhLWxnXFxcIiBvbi10YXA9XFxcInVwdm90ZVBvc3QocGxheWxpc3QpXFxcIiBuZy1pZj1cXFwiIXBsYXlsaXN0LnVwdm90ZWRcXFwiIG9uLWhvbGQ9XFxcIm9wZW5TbGlkZXIoJGV2ZW50KVxcXCI+PC9pPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS11cCBmYS1sZyBwb3NpdGl2ZVxcXCIgb24tdGFwPVxcXCJ1bnZvdGVQb3N0KHBsYXlsaXN0KVxcXCIgbmctaWY9XFxcInBsYXlsaXN0LnVwdm90ZWRcXFwiPjwvaT4mbmJzcDsmbmJzcDs8c3BhbiBvbi10YXA9XFxcIiRyb290Lm9wZW5JbmZvKHBsYXlsaXN0KVxcXCI+e3twbGF5bGlzdC5uZXRfdm90ZXN9fTwvc3Bhbj4mbmJzcDsmbmJzcDtcXG4gICAgICAgICAgICAgICAgICAgPCEtLTxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS1kb3duIGZhLWxnXFxcIiBvbi10YXA9XFxcImRvd252b3RlUG9zdChwbGF5bGlzdClcXFwiIG5nLWlmPVxcXCIhcGxheWxpc3QuZG93bnZvdGVkXFxcIj48L2k+PGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tY2lyY2xlLWRvd24gZmEtbGcgcG9zaXRpdmVcXFwiIG9uLXRhcD1cXFwidW52b3RlUG9zdChwbGF5bGlzdClcXFwiIG5nLWlmPVxcXCJwbGF5bGlzdC5kb3dudm90ZWRcXFwiPjwvaT4tLT48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiIG9uLXRhcD1cXFwib3BlblRvb2x0aXAoJGV2ZW50LHBsYXlsaXN0KVxcXCI+Jm5ic3A7IDxiPnt7JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3l8Z2V0Q3VycmVuY3lTeW1ib2x9fTwvYj4gPHNwYW4gbmctaWY9XFxcInBsYXlsaXN0Lm1heF9hY2NlcHRlZF9wYXlvdXQuc3BsaXQoJyAnKVswXSA9PT0gJzAuMDAwJ1xcXCI+PGRlbD57e3BsYXlsaXN0IHwgc3VtUG9zdFRvdGFsOiRyb290LiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSB8IG51bWJlcn19PC9kZWw+PC9zcGFuPjxzcGFuIG5nLWlmPVxcXCJwbGF5bGlzdC5tYXhfYWNjZXB0ZWRfcGF5b3V0LnNwbGl0KCcgJylbMF0gIT09ICcwLjAwMCdcXFwiPnt7cGxheWxpc3QgfCBzdW1Qb3N0VG90YWw6JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3lSYXRlIHwgbnVtYmVyfX08L3NwYW4+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj4mbmJzcDsgPGkgY2xhc3M9XFxcImljb24gaW9uLWNoYXRidWJibGVzXFxcIj48L2k+Jm5ic3A7e3twbGF5bGlzdC5jaGlsZHJlbn19PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIiBuZy1pZj1cXFwicGxheWxpc3QuYXV0aG9yIT09dXNlci51c2VybmFtZSAmJiBhY3RpdmUhPT0ncmVjZW50LXJlcGxpZXMnXFxcIj4mbmJzcDsgPGkgY2xhc3M9XFxcImljb24gaW9uLWFycm93LXJldHVybi1yaWdodFxcXCI+PC9pPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPC9pb24tbGlzdD5cXG4gICAgICAgICAgPGlvbi1pbmZpbml0ZS1zY3JvbGwgb24taW5maW5pdGU9XFxcImxvYWRtb3JlKClcXFwiIG5nLWlmPVxcXCJtb3JlRGF0YUNhbkJlTG9hZGVkKClcXFwiIGRpc3RhbmNlPVxcXCIxNSVcXFwiPjwvaW9uLWluZmluaXRlLXNjcm9sbD5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicGFkZGluZ1xcXCIgbmctaWY9XFxcImFjdGl2ZT09J3RyYW5zZmVycydcXFwiPlxcbiAgICAgICAgICA8cCBjbGFzcz1cXFwiYm9sZCB1cHBlcmNhc2VcXFwiPlxcbiAgICAgICAgICAgIHt7J0JBTEFOQ0VTJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgICA8L3A+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC02N1xcXCI+XFxuICAgICAgICAgICAge3skcm9vdC4kc3RvcmFnZS5wbGF0Zm9ybW5hbWV9fSA8YnI+PHNwYW4gY2xhc3M9XFxcImdyYXkgd3JhcFxcXCI+e3snUFJPRklMRV8xJ3x0cmFuc2xhdGU6dHJhbnNsYXRpb25EYXRhIH19PC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgICAgICAgIHt7YWNjb3VudHMuYmFsYW5jZSB8IHN0IHwgbnVtYmVyfX0ge3skcm9vdC4kc3RvcmFnZS5wbGF0Zm9ybWx1bml0fX1cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC02N1xcXCI+XFxuICAgICAgICAgICAge3skcm9vdC4kc3RvcmFnZS5wbGF0Zm9ybXBvd2VyfX0gPGJyPjxzcGFuIGNsYXNzPVxcXCJncmF5IHdyYXBcXFwiPnt7J1BST0ZJTEVfMid8dHJhbnNsYXRlOnRyYW5zbGF0aW9uRGF0YX19PC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgICAgICAgIHt7YWNjb3VudHMudmVzdGluZ19zaGFyZXMgfCBzcCB8IG51bWJlcn19IHt7JHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1wdW5pdH19XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtNjdcXFwiPlxcbiAgICAgICAgICAgIHt7JHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1kb2xsYXJ9fSA8YnI+PHNwYW4gY2xhc3M9XFxcImdyYXkgd3JhcFxcXCI+e3snUFJPRklMRV8zJ3x0cmFuc2xhdGU6dHJhbnNsYXRpb25EYXRhfX08L3NwYW4+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0zM1xcXCI+XFxuICAgICAgICAgICAge3thY2NvdW50cy5zYmRfYmFsYW5jZSB8IHNiZCB8IG51bWJlcn19IHt7JHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1kdW5pdH19XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtNjdcXFwiPlxcbiAgICAgICAgICAgIHt7J0VTVElNQVRFRF9WQUxVRSd8dHJhbnNsYXRlfX0gPGJyPjxzcGFuIGNsYXNzPVxcXCJncmF5IHdyYXBcXFwiPnt7J1BST0ZJTEVfNCd8dHJhbnNsYXRlOnRyYW5zbGF0aW9uRGF0YX19PC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgICAgICAgIHt7JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3l8Z2V0Q3VycmVuY3lTeW1ib2x9fSB7e2FjY291bnRzLnZlc3Rpbmdfc2hhcmVzIHwgc2Q6YWNjb3VudHMuYmFsYW5jZTphY2NvdW50cy5zYmRfYmFsYW5jZSB8IG51bWJlcn19XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8cCBjbGFzcz1cXFwiYm9sZFxcXCI+e3snVFJBTlNBQ1RJT05fSElTVE9SWSd8dHJhbnNsYXRlfX08L3A+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImxpc3QgbGlzdC1pbnNldFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgbmctcmVwZWF0PVxcXCJ0ciBpbiB0cmFuc2ZlcnMgfCBvcmRlckJ5OictWzBdJyB8IGxpbWl0VG86MTUgdHJhY2sgYnkgJGluZGV4XFxcIj5cXG4gICAgICAgICAgICAgIDxzcGFuPnt7dHJbMV0udGltZXN0YW1wIHwgdGltZWFnb319IC0ge3t0clsxXS5vcFswXX19PC9zcGFuPlxcbiAgICAgICAgICAgICAgPGRpdiBuZy1pZj1cXFwidHJbMV0ub3BbMF09PSdjb21tZW50X3Jld2FyZCdcXFwiPnt7dHJbMV0ub3BbMV0uc2JkX3BheW91dH19IHwge3t0clsxXS5vcFsxXS52ZXN0aW5nX3BheW91dH19PC9kaXY+XFxuICAgICAgICAgICAgICA8ZGl2IG5nLWlmPVxcXCJ0clsxXS5vcFswXT09J2F1dGhvcl9yZXdhcmQnXFxcIj57e3RyWzFdLm9wWzFdLnNiZF9wYXlvdXR9fSB8IHt7dHJbMV0ub3BbMV0uc3RlZW1fcGF5b3V0fX0gfCB7e3RyWzFdLm9wWzFdLnZlc3RpbmdfcGF5b3V0fX08L2Rpdj5cXG4gICAgICAgICAgICAgIDxkaXYgbmctaWY9XFxcInRyWzFdLm9wWzBdPT0nY3VyYXRpb25fcmV3YXJkJ1xcXCI+e3t0clsxXS5vcFsxXS5yZXdhcmR9fSB8IHt7dHJbMV0ub3BbMV0udmVzdGluZ19wYXlvdXR9fTwvZGl2PlxcbiAgICAgICAgICAgICAgPGRpdiBuZy1pZj1cXFwidHJbMV0ub3BbMF09PSd0cmFuc2ZlcidcXFwiPnt7dHJbMV0ub3BbMV0uYW1vdW50fX0gfCB7e3RyWzFdLm9wWzFdLm1lbW99fTwvZGl2PlxcbiAgICAgICAgICAgICAgPGRpdiBuZy1pZj1cXFwidHJbMV0ub3BbMF09PSd0cmFuc2Zlcl90b192ZXN0aW5nJ1xcXCI+e3t0clsxXS5vcFsxXS5hbW91bnR9fSB8IHt7dHJbMV0ub3BbMV0ubWVtb319PC9kaXY+XFxuICAgICAgICAgICAgICA8ZGl2IG5nLWlmPVxcXCJ0clsxXS5vcFswXT09J3dpdGhkcmF3X3Zlc3RpbmcnXFxcIj57e3RyWzFdLm9wWzFdLnZlc3Rpbmdfc2hhcmVzfX0gfCB7e3RyWzFdLm9wWzFdLm1lbW99fTwvZGl2PlxcbiAgICAgICAgICAgICAgPHAgbmctaWY9XFxcInRyWzFdLm9wWzBdPT0nY29tbWVudF9yZXdhcmQnXFxcIj5Ae3t0clsxXS5vcFsxXS5hdXRob3J9fS97e3RyWzFdLm9wWzFdLnBlcm1saW5rfX08L3A+XFxuICAgICAgICAgICAgICA8cCBuZy1pZj1cXFwidHJbMV0ub3BbMF09PSdhdXRob3JfcmV3YXJkJ1xcXCI+QHt7dHJbMV0ub3BbMV0uYXV0aG9yfX0ve3t0clsxXS5vcFsxXS5wZXJtbGlua319PC9wPlxcbiAgICAgICAgICAgICAgPHAgbmctaWY9XFxcInRyWzFdLm9wWzBdPT0nY3VyYXRpb25fcmV3YXJkJ1xcXCI+QHt7dHJbMV0ub3BbMV0uY29tbWVudF9hdXRob3J9fS97e3RyWzFdLm9wWzFdLmNvbW1lbnRfcGVybWxpbmt9fTwvcD5cXG4gICAgICAgICAgICAgIDxwIG5nLWlmPVxcXCJ0clsxXS5vcFswXT09J3RyYW5zZmVyJ1xcXCI+e3snRlJPTSd8dHJhbnNsYXRlfX0ge3t0clsxXS5vcFsxXS5mcm9tfX0ge3snVE8nfHRyYW5zbGF0ZX19ICB7e3RyWzFdLm9wWzFdLnRvfX08L3A+XFxuICAgICAgICAgICAgICA8cCBuZy1pZj1cXFwidHJbMV0ub3BbMF09PSd0cmFuc2Zlcl90b192ZXN0aW5nJ1xcXCI+e3snRlJPTSd8dHJhbnNsYXRlfX0gIHt7dHJbMV0ub3BbMV0uZnJvbX19IHt7J1RPJ3x0cmFuc2xhdGV9fSAge3t0clsxXS5vcFsxXS50b319PC9wPlxcbiAgICAgICAgICAgICAgPHAgbmctaWY9XFxcInRyWzFdLm9wWzBdPT0nd2l0aGRyYXdfdmVzdGluZydcXFwiPnt7dHJbMV0ub3BbMV0uYWNjb3VudH19PC9wPlxcblxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94IHBpbmtcXFwiIG5nLWlmPVxcXCJhY3RpdmU9PSdwZXJtaXNzaW9ucydcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaXN0IGNhcmRcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiPlxcbiAgICAgICAgICAgICAgPGgyPjxkaXYgY2xhc3M9XFxcImJvbGRcXFwiPnt7J1BPU1RJTkcnfHRyYW5zbGF0ZX19PC9kaXY+PC9oMj5cXG4gICAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJ3cmFwXFxcIj57eyRyb290LiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNbMF1bMF19fTwvcD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtIGl0ZW0tYm9keVxcXCI+XFxuICAgICAgICAgICAgICA8Y2VudGVyPjxxcmNvZGUgY2xhc3M9XFxcImZ1bGwtaW1hZ2VcXFwiIHRleHQ9XFxcInt7JHJvb3QuJHN0b3JhZ2UudXNlci5wb3N0aW5nLmtleV9hdXRoc1swXVswXX19XFxcIj48L3FyY29kZT48L2NlbnRlcj5cXG4gICAgICAgICAgICAgIDxwPlxcbiAgICAgICAgICAgICAgICB7eydQUk9GSUxFXzUnfHRyYW5zbGF0ZX19XFxuICAgICAgICAgICAgICA8L3A+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCI+XFxuICAgICAgICAgICAgICA8aDI+PGRpdiBjbGFzcz1cXFwiYm9sZFxcXCI+e3snT1dORVInfHRyYW5zbGF0ZX19PC9kaXY+PC9oMj5cXG4gICAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJ3cmFwXFxcIj57eyRyb290LiRzdG9yYWdlLnVzZXIub3duZXIua2V5X2F1dGhzWzBdWzBdfX08L3A+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbSBpdGVtLWJvZHlcXFwiPlxcbiAgICAgICAgICAgICAgPGNlbnRlcj48cXJjb2RlIGNsYXNzPVxcXCJmdWxsLWltYWdlXFxcIiB0ZXh0PVxcXCJ7eyRyb290LiRzdG9yYWdlLnVzZXIub3duZXIua2V5X2F1dGhzWzBdWzBdfX1cXFwiPjwvcXJjb2RlPjwvY2VudGVyPlxcbiAgICAgICAgICAgICAgPHA+XFxuICAgICAgICAgICAgICAgIHt7J1BST0ZJTEVfNid8dHJhbnNsYXRlfX1cXG4gICAgICAgICAgICAgIDwvcD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtXFxcIj5cXG4gICAgICAgICAgICAgIDxoMj48ZGl2IGNsYXNzPVxcXCJib2xkXFxcIj57eydBQ1RJVkUnfHRyYW5zbGF0ZX19PC9kaXY+PC9oMj5cXG4gICAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJ3cmFwXFxcIj57eyRyb290LiRzdG9yYWdlLnVzZXIuYWN0aXZlLmtleV9hdXRoc1swXVswXX19PC9wPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW0gaXRlbS1ib2R5XFxcIj5cXG4gICAgICAgICAgICAgIDxjZW50ZXI+PHFyY29kZSBjbGFzcz1cXFwiZnVsbC1pbWFnZVxcXCIgdGV4dD1cXFwie3skcm9vdC4kc3RvcmFnZS51c2VyLmFjdGl2ZS5rZXlfYXV0aHNbMF1bMF19fVxcXCI+PC9xcmNvZGU+PC9jZW50ZXI+XFxuICAgICAgICAgICAgICA8cD5cXG4gICAgICAgICAgICAgICAge3snUFJPRklMRV83J3x0cmFuc2xhdGV9fVxcbiAgICAgICAgICAgICAgPC9wPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiPlxcbiAgICAgICAgICAgICAgPGgyPjxkaXYgY2xhc3M9XFxcImJvbGRcXFwiPnt7J01FTU8nfHRyYW5zbGF0ZX19PC9kaXY+PC9oMj5cXG4gICAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJ3cmFwXFxcIj57eyRyb290LiRzdG9yYWdlLnVzZXIubWVtb19rZXl9fTwvcD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtIGl0ZW0tYm9keVxcXCI+XFxuICAgICAgICAgICAgICA8Y2VudGVyPjxxcmNvZGUgY2xhc3M9XFxcImZ1bGwtaW1hZ2VcXFwiIHRleHQ9XFxcInt7JHJvb3QuJHN0b3JhZ2UudXNlci5tZW1vX2tleX19XFxcIj48L3FyY29kZT48L2NlbnRlcj5cXG4gICAgICAgICAgICAgIDxwPlxcbiAgICAgICAgICAgICAgICB7eydQUk9GSUxFXzgnfHRyYW5zbGF0ZX19XFxuICAgICAgICAgICAgICA8L3A+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8c2NyaXB0IGlkID0gXFxcInBvcG92ZXJQVHIuaHRtbFxcXCIgdHlwZT1cXFwidGV4dC9uZy10ZW1wbGF0ZVxcXCI+XFxuICAgICAgPGlvbi1wb3BvdmVyLXZpZXcgY2xhc3M9XFxcImRldGFpbGVkUG9zdFxcXCI+XFxuICAgICAgICA8aW9uLWNvbnRlbnQ+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInBhZGRpbmdcXFwiIG5nLWJpbmQtaHRtbD1cXFwidG9vbHRpcFRleHRcXFwiPjwvZGl2PlxcbiAgICAgICAgPC9pb24tY29udGVudD5cXG4gICAgICA8L2lvbi1wb3BvdmVyLXZpZXc+XFxuICAgIDwvc2NyaXB0PlxcbiAgICA8c2NyaXB0IGlkID0gXFxcInBvcG92ZXJTbGlkZXJycC5odG1sXFxcIiB0eXBlPVxcXCJ0ZXh0L25nLXRlbXBsYXRlXFxcIj5cXG4gICAgICA8aW9uLXBvcG92ZXItdmlldyBjbGFzcz1cXFwiZGV0YWlsZWRTbGlkZVxcXCI+XFxuICAgICAgICA8aW9uLWNvbnRlbnQ+XFxuICAgICAgICAgIDxyenNsaWRlciByei1zbGlkZXItbW9kZWw9XFxcInBzbGlkZXIudmFsdWVcXFwiIHJ6LXNsaWRlci1vcHRpb25zPVxcXCJwc2xpZGVyLm9wdGlvbnNcXFwiPjwvcnpzbGlkZXI+XFxuICAgICAgICA8L2lvbi1jb250ZW50PlxcbiAgICAgIDwvaW9uLXBvcG92ZXItdmlldz5cXG4gICAgPC9zY3JpcHQ+XFxuICA8L2lvbi1jb250ZW50PlxcbiAgPGRpdiBjbGFzcz1cXFwicHJvZmlsZSBiYXIgYmFyLWZvb3RlclxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImJ1dHRvbi1iYXJcXFwiPlxcbiAgICAgIDwhLS08YSBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1sYXJnZSBidXR0b24tcG9zaXRpdmUgaWNvbiBpb24taW9zLWhlYXJ0XFxcIiBuZy1jbGFzcz1cXFwieydhY3RpdmUnOmFjdGl2ZT09J2ZlZWQnfVxcXCIgb24tdGFwPVxcXCJjaGFuZ2UoJ2ZlZWQnKVxcXCI+Jm5ic3A7RmVlZHM8L2E+LS0+XFxuICAgICAgPGEgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tbGFyZ2UgYnV0dG9uLXBvc2l0aXZlIGljb24gaW9uLWNvbXBvc2VcXFwiIG5nLWNsYXNzPVxcXCJ7J2FjdGl2ZSc6YWN0aXZlPT0nYmxvZyd9XFxcIiBvbi10YXA9XFxcImNoYW5nZSgnYmxvZycpXFxcIj4mbmJzcDt7eydCTE9HJ3x0cmFuc2xhdGV9fTwvYT5cXG4gICAgICA8YSBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1wb3NpdGl2ZSBpY29uIGlvbi1kb2N1bWVudC10ZXh0XFxcIiBuZy1jbGFzcz1cXFwieydhY3RpdmUnOmFjdGl2ZT09J3Bvc3RzJ31cXFwiIG9uLXRhcD1cXFwiY2hhbmdlKCdwb3N0cycpXFxcIj4mbmJzcDt7eydQT1NUUyd8dHJhbnNsYXRlfX08L2E+XFxuICAgICAgPGEgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcG9zaXRpdmUgaWNvbiBpb24tY2hhdGJ1YmJsZXNcXFwiIG5nLWNsYXNzPVxcXCJ7J2FjdGl2ZSc6YWN0aXZlPT0ncmVjZW50LXJlcGxpZXMnfVxcXCIgb24tdGFwPVxcXCJjaGFuZ2UoJ3JlY2VudC1yZXBsaWVzJylcXFwiPiZuYnNwO3t7J1JFUExJRVMnfHRyYW5zbGF0ZX19PC9hPlxcbiAgICAgIDxhIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXBvc2l0aXZlIGljb24gaW9uLWNhcmRcXFwiIG5nLWNsYXNzPVxcXCJ7J2FjdGl2ZSc6YWN0aXZlPT0ndHJhbnNmZXJzJ31cXFwiICBvbi10YXA9XFxcImNoYW5nZSgndHJhbnNmZXJzJylcXFwiPiZuYnNwO3t7J1dBTExFVCd8dHJhbnNsYXRlfX08L2E+XFxuICAgICAgPCEtLTxhIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXJveWFsIGljb24gaW9uLWxvY2stY29tYmluYXRpb25cXFwiIG5nLWNsYXNzPVxcXCJ7J2FjdGl2ZSc6YWN0aXZlPT0ncGVybWlzc2lvbnMnfVxcXCIgb24tdGFwPVxcXCJjaGFuZ2UoJ3Blcm1pc3Npb25zJylcXFwiPktleXM8L2E+LS0+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9pb24tdmlldz5cXG5cIixcbiAgICAgICAgY29udHJvbGxlcjogXCJQcm9maWxlQ3RybFwiXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIC5zdGF0ZSgnYXBwLnBvc3RzJywge1xuICAgIHVybDogJy9wb3N0cy86dGFncycsXG4gICAgdmlld3M6IHtcbiAgICAgICdtZW51Q29udGVudCc6IHtcbiAgICAgICAgLy90ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9wb3N0cy5odG1sJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiPGlvbi12aWV3IHZpZXctY2FjaGU9XFxcImZhbHNlXFxcIj5cXG5cXHQ8aW9uLW5hdi1iYXIgY2xhc3M9XFxcImJhci1wb3NpdGl2ZVxcXCI+XFxuXFx0XFx0PGlvbi1uYXYtYmFjay1idXR0b24+XFxuICBcXHRcXHQ8L2lvbi1uYXYtYmFjay1idXR0b24+XFxuXFx0ICAgIDxpb24tbmF2LWJ1dHRvbnMgc2lkZT1cXFwibGVmdFxcXCI+XFxuXFx0ICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGJ1dHRvbi1jbGVhciBpb24tbmF2aWNvblxcXCIgbmctaWY9XFxcIiEkcm9vdC52b2ljZU92ZXJcXFwiIG1lbnUtdG9nZ2xlPVxcXCJsZWZ0XFxcIj48L2J1dHRvbj5cXG5cXHQgICAgICA8YSBocmVmIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLWljb24gYnV0dG9uLWNsZWFyIGlvbi1uYXZpY29uXFxcIiBuZy1pZj1cXFwiJHJvb3Qudm9pY2VPdmVyXFxcIiBtZW51LXRvZ2dsZT1cXFwibGVmdFxcXCI+e3snTUVOVSd8dHJhbnNsYXRlfX08L2E+XFxuXFx0ICAgIDwvaW9uLW5hdi1idXR0b25zPlxcblxcdCAgICA8aW9uLW5hdi10aXRsZSBvbi10YXA9XFxcInNob3dGaWx0ZXIoKVxcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInBhZ2UtdGl0bGVcXFwiPnt7JHJvb3QuJHN0b3JhZ2UuZmlsdGVyTmFtZX19IHt7JHJvb3QuJHN0b3JhZ2UudGFnfX0gJmVtc3A7IDxpIGNsYXNzPVxcXCJpY29uIGlvbi1hcnJvdy1kb3duLWJcXFwiPjwvaT48L2Rpdj5cXG4gICAgICAgIDwvaW9uLW5hdi10aXRsZT5cXG5cXHQgICAgPGlvbi1uYXYtYnV0dG9ucyBzaWRlPVxcXCJyaWdodFxcXCI+XFxuXFx0ICAgICAgPCEtLTxidXR0b24gY2xhc3M9XFxcImJ1dHRvblxcXCIgb24tdGFwPVxcXCJ0ZXN0ZnVuY3Rpb24oKVxcXCI+VGVzdDwvYnV0dG9uPi0tPlxcblxcdCAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24taWNvbiBpb24tbW9yZVxcXCIgbmctaWY9XFxcIiEkcm9vdC52b2ljZU92ZXJcXFwiIG9uLXRhcD1cXFwib3Blbk1lbnVQb3BvdmVyKCRldmVudClcXFwiPjwvYnV0dG9uPlxcblxcdCAgICAgIDxhIGhyZWYgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24taWNvbiBpb24tbW9yZVxcXCIgb24tdGFwPVxcXCJvcGVuTWVudVBvcG92ZXIoJGV2ZW50KVxcXCIgbmctaWY9XFxcIiRyb290LnZvaWNlT3ZlclxcXCI+e3snT1BUSU9OUyd8dHJhbnNsYXRlfX08L2E+XFxuXFx0ICAgIDwvaW9uLW5hdi1idXR0b25zPlxcblxcdDwvaW9uLW5hdi1iYXI+XFxuICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcImhhcy1oZWFkZXJcXFwiIHNjcm9sbD1cXFwidHJ1ZVxcXCIgZGVsZWdhdGUtaGFuZGxlPVxcXCJtYWluU2Nyb2xsXFxcIiBvdmVyZmxvdy1zY3JvbGw9XFxcInRydWVcXFwiPlxcblxcdFxcdDxpb24tcmVmcmVzaGVyIHB1bGxpbmctdGV4dD1cXFwie3snUFVMTF9ET1dOX1RPX1JFRlJFU0gnfHRyYW5zbGF0ZX19XFxcIiBvbi1yZWZyZXNoPVxcXCJyZWZyZXNoKClcXFwiPlxcbiAgXFx0PC9pb24tcmVmcmVzaGVyPlxcbiAgXFx0XFx0PGRpdiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2Uudmlldz09J2NvbXBhY3QnICYmIGRhdGEubGVuZ3RoPjBcXFwiIGNsYXNzPVxcXCJtYXNvbnJ5LWxheW91dFxcXCI+XFxuXFx0ICAgIFxcdDxkaXYgbmctcmVwZWF0PVxcXCJkIGluIGRhdGEgdHJhY2sgYnkgJGluZGV4XFxcIiBjbGFzcz1cXFwibWFzb25yeS1sYXlvdXRfX3BhbmVsXFxcIj5cXG5cXHQgICAgXFx0ICAgPGRpdiBjbGFzcz1cXFwibGlzdCBtYXNvbnJ5LWxheW91dF9fcGFuZWwtY29udGVudFxcXCI+XFxuXFx0XFx0ICAgIFxcdDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiPlxcblxcdFxcdFxcdFxcdCAgICA8ZGl2IG9uLXRhcD1cXFwib3BlbihkKVxcXCI+XFxuXFx0XFx0XFx0XFx0ICAgIDxzcGFuIG5nLWlmPVxcXCJkLnJlYmxvZ2dlZF9ieS5sZW5ndGg+MFxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWFycm93LXJldHVybi1yaWdodFxcXCI+PC9pPiB7eydSRVNURUVNRURfQlknfHRyYW5zbGF0ZX19IHt7ZC5yZWJsb2dnZWRfYnl9fTwvc3Bhbj5cXG5cXHRcXHRcXHRcXHQgICAgPHA+PGgyPjxpIGNsYXNzPVxcXCJmYSBmYS1tb25leSBwb3NpdGl2ZVxcXCIgbmctaWY9XFxcImQucHJvbW90ZWQuc3BsaXQoJyAnKVswXSAhPT0gJzAuMDAwJ1xcXCI+PC9pPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1maXJlIHBvc2l0aXZlXFxcIiBuZy1pZj1cXFwiZC5wZXJjZW50X3N0ZWVtX2RvbGxhcnMgPT09IDBcXFwiPjwvaT4ge3tkLnRpdGxlfX08L2gyPjwvcD5cXG5cXHRcXHRcXHRcXHQgICAgPGRpdiBjbGFzcz1cXFwicm93IHBvc3RkZXRhaWxzIHdyYXBcXFwiPjxkaXYgY2xhc3M9XFxcImNvbFxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtdGltZVxcXCI+PC9pPiB7e2QuY3JlYXRlZHx0aW1lYWdvfX0mbmJzcDt7eydCWSd8dHJhbnNsYXRlfX0mbmJzcDs8Yj57e2QuYXV0aG9yfX08L2I+Jm5ic3A7PGRpdiBjbGFzcz1cXFwicmVwdXRhdGlvblxcXCI+e3tkLmF1dGhvcl9yZXB1dGF0aW9ufHJlcHV0YXRpb258bnVtYmVyOjB9fTwvZGl2PiB7eydJTid8dHJhbnNsYXRlfX0ge3tkLmNhdGVnb3J5fX0gJm1pZGRvdDsge3tkLmJvZHl8cmVhZGluZ3RpbWV9fSB7eydNSU5fUkVBRCd8dHJhbnNsYXRlfX08L2Rpdj48L2Rpdj5cXG5cXHRcXHRcXHRcXHQgICAgPC9kaXY+XFxuXFx0XFx0XFx0XFx0ICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuXFx0XFx0XFx0XFx0ICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuXFx0XFx0XFx0XFx0ICAgICAgPHNwYW4gbmctaWY9XFxcIiEkcm9vdC52b2ljZU92ZXJcXFwiPlxcblxcdFxcdFxcdFxcdCAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIiBuZy1pZj1cXFwiIWQudXB2b3RlZFxcXCIgb24tdGFwPVxcXCJ2b3RlUG9zdChkKVxcXCIgb24taG9sZD1cXFwib3BlblNsaWRlcigkZXZlbnQpXFxcIj48aW9uLXNwaW5uZXIgbmctaWY9XFxcImQuaW52b3RpbmdcXFwiPjwvaW9uLXNwaW5uZXI+PGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tY2lyY2xlLXVwIGZhLWxnXFxcIiBuZy1pZj1cXFwiIWQuaW52b3RpbmdcXFwiPjwvaT48L2E+PGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcInN1YmR1ZWRcXFwiIG5nLWlmPVxcXCJkLnVwdm90ZWRcXFwiIG9uLXRhcD1cXFwidW52b3RlUG9zdChkKVxcXCI+PGlvbi1zcGlubmVyIG5nLWlmPVxcXCJkLmludm90aW5nXFxcIj48L2lvbi1zcGlubmVyPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS11cCBmYS1sZyBwb3NpdGl2ZVxcXCIgbmctaWY9XFxcIiFkLmludm90aW5nXFxcIj48L2k+PC9hPiZuYnNwOzxzcGFuIGNsYXNzPVxcXCJncmF5XFxcIiBvbi10YXA9XFxcIm9wZW5Ub29sdGlwKCRldmVudCxkKVxcXCI+PGI+e3skcm9vdC4kc3RvcmFnZS5jdXJyZW5jeXxnZXRDdXJyZW5jeVN5bWJvbH19PC9iPiA8c3BhbiBuZy1pZj1cXFwiZC5tYXhfYWNjZXB0ZWRfcGF5b3V0LnNwbGl0KCcgJylbMF0gPT09ICcwLjAwMCdcXFwiPjxkZWw+MC4wMDA8L2RlbD48L3NwYW4+PHNwYW4gbmctaWY9XFxcImQubWF4X2FjY2VwdGVkX3BheW91dC5zcGxpdCgnICcpWzBdICE9PSAnMC4wMDAnXFxcIj57e2QgfCBzdW1Qb3N0VG90YWw6JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3lSYXRlIHwgbnVtYmVyfX08L3NwYW4+PC9zcGFuPjwvc3Bhbj5cXG5cXHRcXHRcXHRcXHQgICAgICA8c3BhbiBuZy1pZj1cXFwiJHJvb3Qudm9pY2VPdmVyXFxcIj5cXG5cXHRcXHRcXHRcXHQgICAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwic3ViZHVlZFxcXCIgbmctaWY9XFxcIiFkLnVwdm90ZWRcXFwiIG9uLXRhcD1cXFwidm90ZVBvc3QoZClcXFwiIG9uLWhvbGQ9XFxcIm9wZW5TbGlkZXIoJGV2ZW50KVxcXCI+PGlvbi1zcGlubmVyIG5nLWlmPVxcXCJkLmludm90aW5nXFxcIj48L2lvbi1zcGlubmVyPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS11cCBmYS1sZ1xcXCIgbmctaWY9XFxcIiFkLmludm90aW5nXFxcIj48L2k+e3snVVBWT1RFJ3x0cmFuc2xhdGV9fTwvYT48YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwic3ViZHVlZFxcXCIgbmctaWY9XFxcImQudXB2b3RlZFxcXCIgb24tdGFwPVxcXCJ1bnZvdGVQb3N0KGQpXFxcIj48aW9uLXNwaW5uZXIgbmctaWY9XFxcImQuaW52b3RpbmdcXFwiPjwvaW9uLXNwaW5uZXI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tY2lyY2xlLXVwIGZhLWxnIHBvc2l0aXZlXFxcIiBuZy1pZj1cXFwiIWQuaW52b3RpbmdcXFwiPjwvaT57eydVTlZPVEUnfHRyYW5zbGF0ZX19PC9hPiZuYnNwOzxzcGFuIGNsYXNzPVxcXCJncmF5XFxcIiBvbi10YXA9XFxcIm9wZW5Ub29sdGlwKCRldmVudCxkKVxcXCI+PGI+e3skcm9vdC4kc3RvcmFnZS5jdXJyZW5jeXxnZXRDdXJyZW5jeVN5bWJvbH19PC9iPiA8c3BhbiBuZy1pZj1cXFwiZC5tYXhfYWNjZXB0ZWRfcGF5b3V0LnNwbGl0KCcgJylbMF0gPT09ICcwLjAwMCdcXFwiPjxkZWw+e3tkIHwgc3VtUG9zdFRvdGFsOiRyb290LiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSB8IG51bWJlcn19PC9kZWw+PC9zcGFuPjxzcGFuIG5nLWlmPVxcXCJkLm1heF9hY2NlcHRlZF9wYXlvdXQuc3BsaXQoJyAnKVswXSAhPT0gJzAuMDAwJ1xcXCI+e3tkIHwgc3VtUG9zdFRvdGFsOiRyb290LiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSB8IG51bWJlcn19PC9zcGFuPjwvc3Bhbj48L3NwYW4+XFxuXFx0XFx0XFx0XFx0ICAgICAgPC9kaXY+XFxuXFx0XFx0XFx0XFx0ICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0yNSB0cmlnaHRcXFwiPlxcblxcdFxcdFxcdFxcdCAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIiBvbi10YXA9XFxcIiRyb290Lm9wZW5JbmZvKGQpXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tcGVyc29uLXN0YWxrZXJcXFwiPjwvaT4mbmJzcDt7e2QubmV0X3ZvdGVzfX08L2E+XFxuXFx0XFx0XFx0XFx0ICAgICAgPC9kaXY+XFxuXFx0XFx0XFx0XFx0ICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0yNSB0cmlnaHRcXFwiPlxcblxcdFxcdFxcdFxcdCAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tY2hhdGJ1YmJsZXNcXFwiPjwvaT4mbmJzcDt7e2QuY2hpbGRyZW59fTwvYT5cXG5cXHRcXHRcXHRcXHQgICAgICA8L2Rpdj5cXG5cXHRcXHRcXHRcXHQgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTEwIHRyaWdodFxcXCI+XFxuXFx0XFx0XFx0XFx0ICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcInN1YmR1ZWRcXFwiIG9uLXRhcD1cXFwiJHJvb3QucmVCbG9nKHMuYXV0aG9yLCBzLnBlcm1saW5rKVxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWFycm93LXJldHVybi1yaWdodFxcXCI+PC9pPiZuYnNwOzwvYT5cXG5cXHRcXHRcXHRcXHQgICAgICA8L2Rpdj5cXG5cXHRcXHRcXHRcXHQgICAgPC9kaXY+XFxuXFx0XFx0XFx0ICBcXHQ8L2Rpdj5cXG5cXHRcXHRcXHQgIDwvZGl2PlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdDwvZGl2PlxcblxcdFxcdDxkaXYgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnZpZXc9PSdjYXJkJyAmJiBkYXRhLmxlbmd0aD4wXFxcIiBjbGFzcz1cXFwibWFzb25yeS1sYXlvdXRcXFwiPlxcblxcdFxcdFxcdDxkaXYgbmctcmVwZWF0PVxcXCJkcyBpbiBkYXRhIHRyYWNrIGJ5ICRpbmRleFxcXCIgY2xhc3M9XFxcIm1hc29ucnktbGF5b3V0X19wYW5lbFxcXCI+XFxuXFx0ICAgIFxcdCAgIDxkaXYgY2xhc3M9XFxcImxpc3QgY2FyZCBtYXNvbnJ5LWxheW91dF9fcGFuZWwtY29udGVudFxcXCIgbmctaWY9XFxcImRzXFxcIj5cXG5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJpdGVtXFxcIiBvbi10YXA9XFxcIm9wZW4oZHMpXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQ8c3BhbiBuZy1pZj1cXFwiZHMucmVibG9nZ2VkX2J5Lmxlbmd0aD4wXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tYXJyb3ctcmV0dXJuLXJpZ2h0XFxcIj48L2k+IHt7J1JFU1RFRU1FRF9CWSd8dHJhbnNsYXRlfX0ge3tkcy5yZWJsb2dnZWRfYnl9fTwvc3Bhbj5cXG5cXHRcXHRcXHRcXHQgICAgPGgyPjxpIGNsYXNzPVxcXCJmYSBmYS1tb25leSBwb3NpdGl2ZVxcXCIgbmctaWY9XFxcImRzLnByb21vdGVkLnNwbGl0KCcgJylbMF0gIT09ICcwLjAwMCdcXFwiPjwvaT4gPGkgY2xhc3M9XFxcImZhIGZhLWZpcmUgcG9zaXRpdmVcXFwiIG5nLWlmPVxcXCJkcy5wZXJjZW50X3N0ZWVtX2RvbGxhcnMgPT09IDBcXFwiPjwvaT57e2RzLnRpdGxlfX08L2gyPlxcblxcdFxcdFxcdFxcdCAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgcG9zdGRldGFpbHMgd3JhcFxcXCI+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tYW5kcm9pZC10aW1lXFxcIj48L2k+IHt7ZHMuY3JlYXRlZHx0aW1lYWdvfX0mbmJzcDt7eydCWSd8dHJhbnNsYXRlfX0mbmJzcDs8Yj57e2RzLmF1dGhvcn19PC9iPiZuYnNwOzxkaXYgY2xhc3M9XFxcInJlcHV0YXRpb25cXFwiPnt7ZHMuYXV0aG9yX3JlcHV0YXRpb258cmVwdXRhdGlvbnxudW1iZXI6MH19PC9kaXY+IHt7J0lOJ3x0cmFuc2xhdGV9fSB7e2RzLmNhdGVnb3J5fX0gJm1pZGRvdDsge3tkcy5ib2R5fHJlYWRpbmd0aW1lfX0ge3snTUlOX1JFQUQnfHRyYW5zbGF0ZX19PC9kaXY+PC9kaXY+XFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiaXRlbS1ib2R5XFxcIj5cXG5cXHRcXHRcXHRcXHQgICAgPGltZyBjbGFzcz1cXFwiZnVsbC1pbWFnZVxcXCIgbmctc3JjPVxcXCJ7e2RzLmpzb25fbWV0YWRhdGEuaW1hZ2VbMF19fVxcXCIgb24tdGFwPVxcXCJvcGVuKGRzKVxcXCIgbmctaWY9XFxcImRzLmpzb25fbWV0YWRhdGEuaW1hZ2VbMF1cXFwiIG9uZXJyb3I9XFxcInRoaXMuc3JjPSdpbWcvbm9pbWFnZS5wbmcnXFxcIi8+XFxuXFx0XFx0XFx0XFx0ICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuXFx0XFx0XFx0XFx0XFx0ICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPHNwYW4gbmctaWY9XFxcIiEkcm9vdC52b2ljZU92ZXJcXFwiPlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIiBuZy1pZj1cXFwiIWRzLnVwdm90ZWRcXFwiIG9uLXRhcD1cXFwidm90ZVBvc3QoZHMpXFxcIiBvbi1ob2xkPVxcXCJvcGVuU2xpZGVyKCRldmVudClcXFwiPjxpb24tc3Bpbm5lciBuZy1pZj1cXFwiZHMuaW52b3RpbmdcXFwiPjwvaW9uLXNwaW5uZXI+PGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tY2lyY2xlLXVwIGZhLWxnXFxcIiBuZy1pZj1cXFwiIWRzLmludm90aW5nXFxcIj48L2k+PC9hPjxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIiBuZy1pZj1cXFwiZHMudXB2b3RlZFxcXCIgb24tdGFwPVxcXCJ1bnZvdGVQb3N0KGRzKVxcXCI+PGlvbi1zcGlubmVyIG5nLWlmPVxcXCJkcy5pbnZvdGluZ1xcXCI+PC9pb24tc3Bpbm5lcj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtY2hldnJvbi1jaXJjbGUtdXAgZmEtbGcgcG9zaXRpdmVcXFwiIG5nLWlmPVxcXCIhZHMuaW52b3RpbmdcXFwiPjwvaT48L2E+Jm5ic3A7PHNwYW4gY2xhc3M9XFxcImdyYXlcXFwiIG9uLXRhcD1cXFwib3BlblRvb2x0aXAoJGV2ZW50LGRzKVxcXCI+PGI+e3skcm9vdC4kc3RvcmFnZS5jdXJyZW5jeXxnZXRDdXJyZW5jeVN5bWJvbH19PC9iPiA8c3BhbiBuZy1pZj1cXFwiZHMubWF4X2FjY2VwdGVkX3BheW91dC5zcGxpdCgnICcpWzBdID09PSAnMC4wMDAnXFxcIj48ZGVsPnt7ZHMgfCBzdW1Qb3N0VG90YWw6JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3lSYXRlIHwgbnVtYmVyfX08L2RlbD48L3NwYW4+PHNwYW4gbmctaWY9XFxcImRzLm1heF9hY2NlcHRlZF9wYXlvdXQuc3BsaXQoJyAnKVswXSAhPT0gJzAuMDAwJ1xcXCI+e3tkcyB8IHN1bVBvc3RUb3RhbDokcm9vdC4kc3RvcmFnZS5jdXJyZW5jeVJhdGUgfCBudW1iZXJ9fTwvc3Bhbj48L3NwYW4+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPC9zcGFuPlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDxzcGFuIG5nLWlmPVxcXCIkcm9vdC52b2ljZU92ZXJcXFwiPlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIiBuZy1pZj1cXFwiIWRzLnVwdm90ZWRcXFwiIG9uLXRhcD1cXFwidm90ZVBvc3QoZHMpXFxcIiBvbi1ob2xkPVxcXCJvcGVuU2xpZGVyKCRldmVudClcXFwiPjxpb24tc3Bpbm5lciBuZy1pZj1cXFwiZHMuaW52b3RpbmdcXFwiPjwvaW9uLXNwaW5uZXI+PGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tY2lyY2xlLXVwIGZhLWxnXFxcIiBuZy1pZj1cXFwiIWRzLmludm90aW5nXFxcIj48L2k+e3snVVBWT1RFJ3x0cmFuc2xhdGV9fTwvYT5cXG5cXHRcXHRcXHRcXHRcXHQgICAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwic3ViZHVlZFxcXCIgbmctaWY9XFxcImRzLnVwdm90ZWRcXFwiIG9uLXRhcD1cXFwidW52b3RlUG9zdChkcylcXFwiPjxpb24tc3Bpbm5lciBuZy1pZj1cXFwiZHMuaW52b3RpbmdcXFwiPjwvaW9uLXNwaW5uZXI+PGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tY2lyY2xlLXVwIGZhLWxnIHBvc2l0aXZlXFxcIiBuZy1pZj1cXFwiIWRzLmludm90aW5nXFxcIj48L2k+e3snVU5WT1RFJ3x0cmFuc2xhdGV9fTwvYT4mbmJzcDs8c3BhbiBjbGFzcz1cXFwiZ3JheVxcXCIgb24tdGFwPVxcXCJvcGVuVG9vbHRpcCgkZXZlbnQsZHMpXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8Yj57eyRyb290LiRzdG9yYWdlLmN1cnJlbmN5fGdldEN1cnJlbmN5U3ltYm9sfX08L2I+IDxzcGFuIG5nLWlmPVxcXCJkcy5tYXhfYWNjZXB0ZWRfcGF5b3V0LnNwbGl0KCcgJylbMF0gPT09ICcwLjAwMCdcXFwiPjxkZWw+MC4wMDA8L2RlbD48L3NwYW4+PHNwYW4gbmctaWY9XFxcImRzLm1heF9hY2NlcHRlZF9wYXlvdXQuc3BsaXQoJyAnKVswXSAhPT0gJzAuMDAwJ1xcXCI+e3tkcyB8IHN1bVBvc3RUb3RhbDokcm9vdC4kc3RvcmFnZS5jdXJyZW5jeVJhdGUgfCBudW1iZXJ9fTwvc3Bhbj48L3NwYW4+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPC9zcGFuPlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMjUgdHJpZ2h0XFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQgICAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwic3ViZHVlZFxcXCIgb24tdGFwPVxcXCIkcm9vdC5vcGVuSW5mbyhkcylcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1wZXJzb24tc3RhbGtlclxcXCI+PC9pPiZuYnNwO3t7ZHMubmV0X3ZvdGVzfX08L2E+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0yNSB0cmlnaHRcXFwiPlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tY2hhdGJ1YmJsZXNcXFwiPjwvaT4mbmJzcDt7e2RzLmNoaWxkcmVufX08L2E+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0xMCB0cmlnaHRcXFwiPlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIiBvbi10YXA9XFxcIiRyb290LnJlQmxvZyhkcy5hdXRob3IsIGRzLnBlcm1saW5rKVxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWFycm93LXJldHVybi1yaWdodFxcXCI+PC9pPiZuYnNwOzwvYT5cXG5cXHRcXHRcXHRcXHRcXHQgICAgICA8L2Rpdj5cXG5cXHRcXHRcXHRcXHQgICAgICA8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG4gICAgPGlvbi1pbmZpbml0ZS1zY3JvbGwgbmctaWY9XFxcIm1vcmVEYXRhQ2FuQmVMb2FkZWQoKVxcXCIgb24taW5maW5pdGU9XFxcImxvYWRNb3JlKClcXFwiIGRpc3RhbmNlPVxcXCIxNSVcXFwiPjwvaW9uLWluZmluaXRlLXNjcm9sbD5cXG4gICAgPGJyPlxcbiAgICA8c2NyaXB0IGlkID0gXFxcInBvcG92ZXJULmh0bWxcXFwiIHR5cGU9XFxcInRleHQvbmctdGVtcGxhdGVcXFwiPlxcbiAgICAgIDxpb24tcG9wb3Zlci12aWV3IGNsYXNzPVxcXCJkZXRhaWxlZFBvc3RcXFwiPlxcbiAgICAgICAgPGlvbi1jb250ZW50PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYWRkaW5nXFxcIiBuZy1iaW5kLWh0bWw9XFxcInRvb2x0aXBUZXh0XFxcIj48L2Rpdj5cXG4gICAgICAgIDwvaW9uLWNvbnRlbnQ+XFxuICAgICAgPC9pb24tcG9wb3Zlci12aWV3PlxcbiAgICA8L3NjcmlwdD5cXG4gICAgPHNjcmlwdCBpZCA9IFxcXCJwb3BvdmVyU2xpZGVyLmh0bWxcXFwiIHR5cGU9XFxcInRleHQvbmctdGVtcGxhdGVcXFwiPlxcbiAgICAgIDxpb24tcG9wb3Zlci12aWV3IGNsYXNzPVxcXCJkZXRhaWxlZFNsaWRlXFxcIj5cXG4gICAgICAgIDxpb24tY29udGVudD5cXG4gICAgICAgICAgXFx0PHJ6c2xpZGVyIHJ6LXNsaWRlci1tb2RlbD1cXFwicHNsaWRlci52YWx1ZVxcXCIgcnotc2xpZGVyLW9wdGlvbnM9XFxcInBzbGlkZXIub3B0aW9uc1xcXCI+PC9yenNsaWRlcj5cXG4gICAgICAgIDwvaW9uLWNvbnRlbnQ+XFxuICAgICAgPC9pb24tcG9wb3Zlci12aWV3PlxcbiAgICA8L3NjcmlwdD5cXG4gIDwvaW9uLWNvbnRlbnQ+XFxuPC9pb24tdmlldz5cXG5cIixcbiAgICAgICAgY29udHJvbGxlcjogJ1Bvc3RzQ3RybCdcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgLnN0YXRlKCdhcHAuYm9va21hcmsnLCB7XG4gICAgdXJsOiAnL2Jvb2ttYXJrJyxcbiAgICB2aWV3czoge1xuICAgICAgJ21lbnVDb250ZW50Jzoge1xuICAgICAgICAvL3RlbXBsYXRlVXJsOiAndGVtcGxhdGVzL3Bvc3QuaHRtbCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIjxpb24tdmlldyB2aWV3LXRpdGxlPVxcXCJ7eydCT09LTUFSS1MnIHwgdHJhbnNsYXRlfX1cXFwiPlxcbiAgPGlvbi1jb250ZW50IGNsYXNzPVxcXCJoYXMtaGVhZGVyXFxcIj5cXG5cXHQ8aW9uLWxpc3QgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLmJvb2ttYXJrXFxcIiBjYW4tc3dpcGU9XFxcInRydWVcXFwiPlxcbiAgXFx0XFx0PGlvbi1pdGVtIG5nLXJlcGVhdD1cXFwiaXRlbSBpbiAkcm9vdC4kc3RvcmFnZS5ib29rbWFya1xcXCIgbmctY2xpY2s9XFxcIiRyb290LmdldENvbnRlbnRBbmRPcGVuKGl0ZW0pXFxcIj5cXG5cXHRcXHQgICAgPHA+PGgyPnt7aXRlbS5hdXRob3J9fTwvaDI+PC9wPlxcbiAgICAgICAgPHA+e3tpdGVtLnBlcm1saW5rfX08L3A+XFxuXFx0XFx0ICAgIDxkaXYgY2xhc3M9XFxcInJvdyBwb3N0ZGV0YWlscyB0d3JhcFxcXCI+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tYW5kcm9pZC10aW1lXFxcIj48L2k+IHt7aXRlbS5jcmVhdGVkfHRpbWVhZ299fTwvZGl2PjwvZGl2PlxcblxcdFxcdCAgICA8aW9uLW9wdGlvbi1idXR0b24gY2xhc3M9XFxcImJ1dHRvbi1hc3NlcnRpdmVcXFwiIG5nLWNsaWNrPVxcXCJyZW1vdmVCb29rbWFyaygkaW5kZXgpXFxcIj57eydSRU1PVkUnIHwgdHJhbnNsYXRlfX1cXG5cXHRcXHQgICAgPC9pb24tb3B0aW9uLWJ1dHRvbj5cXG4gICAgXFx0PC9pb24taXRlbT5cXG4gICAgPC9pb24tbGlzdD5cXG4gICAgPHAgY2xhc3M9XFxcInRjZW50ZXIgZ3JheSBwYWRkaW5nXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UuYm9va21hcmsubGVuZ3RoPjBcXFwiPnt7J1NXSVBFX0xFRlQnfHRyYW5zbGF0ZX19PC9wPlxcbiAgICA8cCBjbGFzcz1cXFwidGNlbnRlciBncmF5IHBhZGRpbmdcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5ib29rbWFyay5sZW5ndGg9PTBcXFwiPnt7J05PVEhJTkdfSEVSRSd8dHJhbnNsYXRlfX08L3A+XFxuXFxuICA8L2lvbi1jb250ZW50PlxcbjwvaW9uLXZpZXc+XFxuXCIsXG4gICAgICAgIGNvbnRyb2xsZXI6ICdCb29rbWFya0N0cmwnXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG5cdC5zdGF0ZSgnYXBwLmRyYWZ0cycsIHtcbiAgICB1cmw6ICcvZHJhZnRzJyxcbiAgICB2aWV3czoge1xuICAgICAgJ21lbnVDb250ZW50Jzoge1xuICAgICAgICAvL3RlbXBsYXRlVXJsOiAndGVtcGxhdGVzL3Bvc3QuaHRtbCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIjxpb24tdmlldyB2aWV3LXRpdGxlPVxcXCJ7eydEUkFGVFMnIHwgdHJhbnNsYXRlfX1cXFwiPlxcbiAgPGlvbi1jb250ZW50IGNsYXNzPVxcXCJoYXMtaGVhZGVyXFxcIj5cXG5cXHQ8aW9uLWxpc3QgbmctaWY9XFxcImRyYWZ0c1xcXCIgY2FuLXN3aXBlPVxcXCJ0cnVlXFxcIj5cXG4gIFxcdFxcdDxpb24taXRlbSBuZy1yZXBlYXQ9XFxcIml0ZW0gaW4gZHJhZnRzXFxcIiBuZy1jbGljaz1cXFwiJHJvb3Qub3BlbkRyYWZ0KGl0ZW0pXFxcIj5cXG5cXHRcXHQgICAgPHA+PGgyPnt7aXRlbS50aXRsZX19PC9oMj48L3A+XFxuXFx0XFx0XFx0ICAgIDxkaXYgY2xhc3M9XFxcInJvdyBwb3N0ZGV0YWlscyB0d3JhcFxcXCI+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tYW5kcm9pZC10aW1lXFxcIj48L2k+IHt7aXRlbS5jcmVhdGVkfHRpbWVhZ299fSZuYnNwO3t7J1RBR1MnIHwgdHJhbnNsYXRlfX06Jm5ic3A7PGI+e3tpdGVtLnRhZ3N9fTwvYj48L2Rpdj48L2Rpdj5cXG5cXHRcXHQgICAgPGlvbi1vcHRpb24tYnV0dG9uIGNsYXNzPVxcXCJidXR0b24tYXNzZXJ0aXZlXFxcIiBuZy1jbGljaz1cXFwicmVtb3ZlRHJhZnQoaXRlbS5faWQpXFxcIj57eydSRU1PVkUnIHwgdHJhbnNsYXRlfX1cXG5cXHRcXHQgICAgPC9pb24tb3B0aW9uLWJ1dHRvbj5cXG4gICAgXFx0PC9pb24taXRlbT5cXG4gICAgPC9pb24tbGlzdD5cXG4gICAgPHAgY2xhc3M9XFxcInRjZW50ZXIgZ3JheVxcXCIgbmctaWY9XFxcImRyYWZ0cy5sZW5ndGg+MFxcXCI+e3snU1dJUEVfTEVGVCd8dHJhbnNsYXRlfX08L3A+XFxuICAgIDxwIGNsYXNzPVxcXCJ0Y2VudGVyIGdyYXlcXFwiIG5nLWlmPVxcXCJkcmFmdHMubGVuZ3RoPT0wXFxcIj57eydOT1RISU5HX0hFUkUnfHRyYW5zbGF0ZX19PC9wPlxcblxcbiAgPC9pb24tY29udGVudD5cXG48L2lvbi12aWV3PlxcblwiLFxuICAgICAgICBjb250cm9sbGVyOiAnRHJhZnRzQ3RybCdcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cblx0LnN0YXRlKCdhcHAuaW1hZ2VzJywge1xuICAgIHVybDogJy9pbWFnZXMnLFxuICAgIHZpZXdzOiB7XG4gICAgICAnbWVudUNvbnRlbnQnOiB7XG4gICAgICAgIC8vdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvcG9zdC5odG1sJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiPGlvbi12aWV3IHZpZXctdGl0bGU9XFxcInt7J01BTkFHRScgfCB0cmFuc2xhdGV9fSB7eydHQUxMRVJZJyB8IHRyYW5zbGF0ZX19XFxcIj5cXG4gIDxpb24tY29udGVudCBjbGFzcz1cXFwiaGFzLWhlYWRlclxcXCI+XFxuXFx0PGlvbi1saXN0IG5nLWlmPVxcXCJpbWFnZXNcXFwiIGNhbi1zd2lwZT1cXFwidHJ1ZVxcXCI+XFxuICBcXHRcXHQ8aW9uLWl0ZW0gbmctcmVwZWF0PVxcXCJpdGVtIGluIGltYWdlc1xcXCIgY2xhc3M9XFxcIml0ZW0tdGh1bWJuYWlsLWxlZnRcXFwiPlxcbiAgICAgICAgPGltZyBuZy1zcmM9XFxcInt7aXRlbS51cmx9fVxcXCIvPlxcbiAgICAgICAgPHA+PGgyPnt7aXRlbS51cmx9fTwvaDI+PC9wPlxcblxcdFxcdFxcdCAgPGRpdiBjbGFzcz1cXFwicm93IHBvc3RkZXRhaWxzIHR3cmFwXFxcIj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1hbmRyb2lkLXRpbWVcXFwiPjwvaT4ge3tpdGVtLmNyZWF0ZWR8dGltZWFnb319Jm5ic3A7PC9kaXY+PC9kaXY+XFxuICAgICAgICA8aW9uLW9wdGlvbi1idXR0b24gY2xhc3M9XFxcImJ1dHRvbi1hc3NlcnRpdmVcXFwiIG5nLWNsaWNrPVxcXCJyZW1vdmVJbWFnZShpdGVtLl9pZClcXFwiPnt7J1JFTU9WRScgfCB0cmFuc2xhdGV9fVxcblxcdFxcdCAgICA8L2lvbi1vcHRpb24tYnV0dG9uPlxcblxcdFxcdCAgICA8aW9uLW9wdGlvbi1idXR0b24gY2xhc3M9XFxcImJ1dHRvbi1jYWxtXFxcIiBuZy1jbGljaz1cXFwiY29weUltYWdlKGl0ZW0udXJsKVxcXCI+e3snQ09QWScgfCB0cmFuc2xhdGV9fVxcblxcdFxcdCAgICA8L2lvbi1vcHRpb24tYnV0dG9uPlxcbiAgICBcXHQ8L2lvbi1pdGVtPlxcbiAgICA8L2lvbi1saXN0PlxcbiAgICA8cCBjbGFzcz1cXFwidGNlbnRlciBncmF5XFxcIiBuZy1pZj1cXFwiaW1hZ2VzLmxlbmd0aD4wXFxcIj57eydTV0lQRV9MRUZUJ3x0cmFuc2xhdGV9fTwvcD5cXG4gICAgPHAgY2xhc3M9XFxcInRjZW50ZXIgZ3JheVxcXCIgbmctaWY9XFxcImltYWdlcy5sZW5ndGg9PTBcXFwiPnt7J05PVEhJTkdfSEVSRSd8dHJhbnNsYXRlfX08L3A+XFxuICA8L2lvbi1jb250ZW50PlxcbjwvaW9uLXZpZXc+XFxuXCIsXG4gICAgICAgIGNvbnRyb2xsZXI6ICdJbWFnZXNDdHJsJ1xuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICAuc3RhdGUoJ2FwcC5ub3RpZmljYXRpb25zJywge1xuICAgIHVybDogJy9ub3RpZmljYXRpb25zJyxcbiAgICB2aWV3czoge1xuICAgICAgJ21lbnVDb250ZW50Jzoge1xuICAgICAgICAvL3RlbXBsYXRlVXJsOiAndGVtcGxhdGVzL3Bvc3QuaHRtbCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIjxpb24tdmlldyB2aWV3LXRpdGxlPVxcXCJ7eydOT1RJRklDQVRJT05TJyB8IHRyYW5zbGF0ZX19XFxcIj5cXG4gIDxpb24tY29udGVudCBjbGFzcz1cXFwiaGFzLWhlYWRlclxcXCI+XFxuXFx0PGlvbi1saXN0IG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5ub3RpZmljYXRpb25zXFxcIiBjYW4tc3dpcGU9XFxcInRydWVcXFwiPlxcbiAgXFx0XFx0PGlvbi1pdGVtIG5nLXJlcGVhdD1cXFwiaXRlbSBpbiAkcm9vdC4kc3RvcmFnZS5ub3RpZmljYXRpb25zIHwgb3JkZXJCeTogJy1jcmVhdGVkJyBcXFwiIG5nLWNsaWNrPVxcXCIkcm9vdC5nZXRDb250ZW50QW5kT3BlbihpdGVtKVxcXCI+XFxuXFx0XFx0ICAgIDxwPjxoMj57e2l0ZW0udGl0bGV9fTwvaDI+PC9wPlxcblxcdFxcdCAgICA8c3Bhbj57e2l0ZW0ubWVzc2FnZX19PC9zcGFuPlxcblxcdFxcdCAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgcG9zdGRldGFpbHMgdHdyYXBcXFwiPjxkaXYgY2xhc3M9XFxcImNvbFxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtdGltZVxcXCI+PC9pPiB7e2l0ZW0uY3JlYXRlZHx0aW1lYWdvfX0mbmJzcDt7eydCWScgfCB0cmFuc2xhdGV9fSZuYnNwOzxiPnt7aXRlbS5hdXRob3J9fSZuYnNwOzwvYj48L2Rpdj48L2Rpdj5cXG5cXHRcXHQgICAgPGlvbi1vcHRpb24tYnV0dG9uIGNsYXNzPVxcXCJidXR0b24tYXNzZXJ0aXZlXFxcIiBuZy1jbGljaz1cXFwicmVtb3ZlTm90aWZpY2F0aW9uKCRpbmRleClcXFwiPnt7J1JFTU9WRScgfCB0cmFuc2xhdGV9fVxcblxcdFxcdCAgICA8L2lvbi1vcHRpb24tYnV0dG9uPlxcbiAgICBcXHQ8L2lvbi1pdGVtPlxcbiAgICA8L2lvbi1saXN0PlxcbiAgPC9pb24tY29udGVudD5cXG48L2lvbi12aWV3PlxcblwiLFxuICAgICAgICBjb250cm9sbGVyOiAnTm90aWZpY2F0aW9uc0N0cmwnXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG5cbiAgLnN0YXRlKCdhcHAucG9zdCcsIHtcbiAgICB1cmw6ICcvcG9zdC86Y2F0ZWdvcnkvOmF1dGhvci86cGVybWxpbmsnLFxuICAgIHZpZXdzOiB7XG4gICAgICAnbWVudUNvbnRlbnQnOiB7XG4gICAgICAgIC8vdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvcG9zdC5odG1sJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiPGlvbi12aWV3IHZpZXctdGl0bGU9XFxcIlxcXCI+XFxuXFx0PGlvbi1uYXYtYmFyIGNsYXNzPVxcXCJiYXItcG9zaXRpdmVcXFwiPlxcblxcdFxcdDxpb24tbmF2LWJhY2stYnV0dG9uPlxcbiAgICBcXHQ8L2lvbi1uYXYtYmFjay1idXR0b24+XFxuXFx0ICAgIDxpb24tbmF2LWJ1dHRvbnMgc2lkZT1cXFwibGVmdFxcXCI+XFxuXFx0ICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGJ1dHRvbi1jbGVhciBpb24tbmF2aWNvblxcXCIgbmctaWY9XFxcIiEkcm9vdC52b2ljZU92ZXJcXFwiIG1lbnUtdG9nZ2xlPVxcXCJsZWZ0XFxcIj48L2J1dHRvbj5cXG4gICAgICAgIDxhIGhyZWYgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24taWNvbiBpb24tbW9yZVxcXCIgbmctaWY9XFxcIiRyb290LnZvaWNlT3ZlclxcXCIgbWVudS10b2dnbGU9XFxcImxlZnRcXFwiPnt7J01FTlUnfHRyYW5zbGF0ZX19PC9hPlxcblxcdCAgICA8L2lvbi1uYXYtYnV0dG9ucz5cXG5cXHQgICAgPGlvbi1uYXYtYnV0dG9ucyBzaWRlPVxcXCJyaWdodFxcXCI+XFxuICAgICAgPHNwYW4gbmctaWY9XFxcIiEkcm9vdC52b2ljZU92ZXJcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGJ1dHRvbi1jbGVhclxcXCIgb24tdGFwPVxcXCJib29rbWFyaygpXFxcIj48aSBjbGFzcz1cXFwiaWNvblxcXCIgbmctY2xhc3M9XFxcInsnaW9uLWlvcy1ib29rbWFya3MnOmlzQm9va21hcmtlZCgpLCAnaW9uLWlvcy1ib29rbWFya3Mtb3V0bGluZSc6IWlzQm9va21hcmtlZCgpfVxcXCI+PC9pPjwvYnV0dG9uPiAmbmJzcDsgXFxuXFx0ICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGJ1dHRvbi1jbGVhciBpb24tYW5kcm9pZC1zaGFyZS1hbHRcXFwiIG9uLXRhcD1cXFwic2hhcmUoKVxcXCI+PC9idXR0b24+XFxuICAgICAgPC9zcGFuPlxcbiAgICAgIDxzcGFuIG5nLWlmPVxcXCIkcm9vdC52b2ljZU92ZXJcXFwiPlxcbiAgICAgICAgPGEgaHJlZiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGJ1dHRvbi1jbGVhclxcXCIgb24tdGFwPVxcXCJib29rbWFyaygpXFxcIj48aSBjbGFzcz1cXFwiaWNvblxcXCIgbmctY2xhc3M9XFxcInsnaW9uLWlvcy1ib29rbWFya3MnOmlzQm9va21hcmtlZCgpLCAnaW9uLWlvcy1ib29rbWFya3Mtb3V0bGluZSc6IWlzQm9va21hcmtlZCgpfVxcXCI+PC9pPnt7J0JPT0tNQVJLJ3x0cmFuc2xhdGV9fTwvYT4gJm5ic3A7IFxcbiAgICAgICAgPGEgaHJlZiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGJ1dHRvbi1jbGVhciBpb24tYW5kcm9pZC1zaGFyZS1hbHRcXFwiIG9uLXRhcD1cXFwic2hhcmUoKVxcXCI+e3snU0hBUkUnfHRyYW5zbGF0ZX19PC9hPlxcbiAgICAgIDwvc3Bhbj5cXG5cXHQgICAgPC9pb24tbmF2LWJ1dHRvbnM+XFxuXFx0PC9pb24tbmF2LWJhcj5cXG4gIDxpb24tZmxvYXRpbmctbWVudSBtZW51LWNvbG9yPVxcXCIjMzg3ZWY1XFxcIiBtZW51LW9wZW4tY29sb3I9XFxcIiMzODdlZjVcXFwiIGhhcy1mb290ZXI9XFxcInRydWVcXFwiPlxcbiAgICA8aW9uLWZsb2F0aW5nLWl0ZW0gaWNvbj1cXFwiaW9uLWNoYXRidWJibGVzXFxcIiBjbGljaz1cXFwiaXNyZXBseWluZygkcm9vdC4kc3RvcmFnZS5zaXRlbSwgdHJ1ZSlcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lXFxcIiBidXR0b24tY29sb3I9XFxcIiMzODdlZjVcXFwiIGljb24tY29sb3I9XFxcIiNmZmZcXFwiIHRleHQ9XFxcInt7J1JFUExZJ3x0cmFuc2xhdGV9fVxcXCIgdGV4dC1jbGFzcz1cXFwidGV4dC1jbGFzc1xcXCI+PC9pb24tZmxvYXRpbmctaXRlbT5cXG4gICAgPGlvbi1mbG9hdGluZy1pdGVtIGljb249XFxcImlvbi1hbmRyb2lkLWFycm93LWRyb3B1cC1jaXJjbGVcXFwiIGNsaWNrPVxcXCJ1cHZvdGVQb3N0KCRyb290LiRzdG9yYWdlLnNpdGVtKVxcXCIgYnV0dG9uLWNvbG9yPVxcXCIjMzg3ZWY1XFxcIiBpY29uLWNvbG9yPVxcXCIjZmZmXFxcIiB0ZXh0PVxcXCJ7eydVUFZPVEUnfHRyYW5zbGF0ZX19XFxcIiB0ZXh0LWNsYXNzPVxcXCJ0ZXh0LWNsYXNzXFxcIj48L2lvbi1mbG9hdGluZy1pdGVtPlxcbiAgICA8aW9uLWZsb2F0aW5nLWl0ZW0gaWNvbj1cXFwiaW9uLWVkaXRcXFwiIGNsaWNrPVxcXCJlZGl0UG9zdCgkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5zaXRlbS5tb2RlIT09J2FyY2hpdmVkJyAmJiAkcm9vdC4kc3RvcmFnZS5zaXRlbS5hdXRob3I9PSRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWVcXFwiIGJ1dHRvbi1jb2xvcj1cXFwiIzM4N2VmNVxcXCIgaWNvbi1jb2xvcj1cXFwiI2ZmZlxcXCIgdGV4dD1cXFwie3snRURJVCd8dHJhbnNsYXRlfX1cXFwiIHRleHQtY2xhc3M9XFxcInRleHQtY2xhc3NcXFwiPjwvaW9uLWZsb2F0aW5nLWl0ZW0+XFxuICAgIDxpb24tZmxvYXRpbmctaXRlbSBpY29uPVxcXCJpb24taW1hZ2VcXFwiIGNsaWNrPVxcXCJzaG93SW1hZ2VzKDApXFxcIiBuZy1pZj1cXFwiaXNJbWFnZXMoKVxcXCIgYnV0dG9uLWNvbG9yPVxcXCIjMzg3ZWY1XFxcIiBpY29uLWNvbG9yPVxcXCIjZmZmXFxcIiB0ZXh0PVxcXCJ7eydHQUxMRVJZJ3x0cmFuc2xhdGV9fVxcXCIgdGV4dC1jbGFzcz1cXFwidGV4dC1jbGFzc1xcXCI+PC9pb24tZmxvYXRpbmctaXRlbT5cXG4gICAgPGlvbi1mbG9hdGluZy1pdGVtIGljb249XFxcImlvbi1hcnJvdy1yZXR1cm4tcmlnaHRcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lICE9PSAkcm9vdC4kc3RvcmFnZS5zaXRlbS5hdXRob3JcXFwiIGNsaWNrPVxcXCIkcm9vdC5yZUJsb2coJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yLCAkcm9vdC4kc3RvcmFnZS5zaXRlbS5wZXJtbGluaylcXFwiIGJ1dHRvbi1jb2xvcj1cXFwiIzM4N2VmNVxcXCIgaWNvbi1jb2xvcj1cXFwiI2ZmZlxcXCIgdGV4dD1cXFwie3snUkVCTE9HJ3x0cmFuc2xhdGV9fVxcXCIgdGV4dC1jbGFzcz1cXFwidGV4dC1jbGFzc1xcXCI+PC9pb24tZmxvYXRpbmctaXRlbT5cXG4gIDwvaW9uLWZsb2F0aW5nLW1lbnU+XFxuICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcInBhZGRpbmcgaGFzLWhlYWRlclxcXCIgZGVsZWdhdGUtaGFuZGxlPVxcXCJtYWluU2Nyb2xsXFxcIiBvdmVyZmxvdy1zY3JvbGw9XFxcInRydWVcXFwiPjwhLS0tLT5cXG4gICAgPGRpdiBuZy1pZj0nJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0nPlxcbiAgICBcXHQ8cCBjbGFzcz1cXFwidGl0bGUgaDNcXFwiPnt7JHJvb3QuJHN0b3JhZ2Uuc2l0ZW0udGl0bGV9fTwvcD5cXG4gICAgXFx0PGRpdiBjbGFzcz1cXFwic3RpdGxlIHJvdyBncmF5XFxcIj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPlxcbiAgICAgICAgPGltZyBjbGFzcz1cXFwicm91bmQtYXZhdGFyXFxcIiBzcmM9XFxcImltZy91c2VyX3Byb2ZpbGUucG5nXFxcIiBuZy1zcmM9XFxcInt7JHJvb3QuJHN0b3JhZ2UucGFjY291bnRzWyRyb290LiRzdG9yYWdlLnNpdGVtLmF1dGhvcl0uanNvbl9tZXRhZGF0YS51c2VyX2ltYWdlfHwkcm9vdC4kc3RvcmFnZS5wYWNjb3VudHNbJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yXS5qc29uX21ldGFkYXRhLnByb2ZpbGUucHJvZmlsZV9pbWFnZX19XFxcIiBvbmVycm9yPVxcXCJ0aGlzLnNyYz1cXFxcJ2ltZy91c2VyX3Byb2ZpbGUucG5nXFxcXCdcXFwiIG9uYWJvcnQ9XFxcInRoaXMuc3JjPVxcXFwnaW1nL3VzZXJfcHJvZmlsZS5wbmdcXFxcJ1xcXCIgLz4gPGI+PGEgaHJlZj1cXFwiIy9hcHAvcHJvZmlsZS97eyRyb290LiRzdG9yYWdlLnNpdGVtLmF1dGhvcn19XFxcIj57eyRyb290LiRzdG9yYWdlLnNpdGVtLmF1dGhvcn19PC9hPjwvYj4mbmJzcDs8ZGl2IGNsYXNzPVxcXCJyZXB1dGF0aW9uXFxcIj57eyRyb290LiRzdG9yYWdlLnNpdGVtLmF1dGhvcl9yZXB1dGF0aW9ufHJlcHV0YXRpb258bnVtYmVyOjB9fTwvZGl2PiZtaWRkb3Q7e3skcm9vdC4kc3RvcmFnZS5zaXRlbS5jcmVhdGVkfHRpbWVhZ299fSB7eydJTid8dHJhbnNsYXRlfX0mbmJzcDt7eyRyb290LiRzdG9yYWdlLnNpdGVtLmNhdGVnb3J5fX08L2Rpdj48ZGl2IGNsYXNzPVxcXCJwdWxsLXJpZ2h0XFxcIj48c3BhbiBuZy1pZj1cXFwiJHJvb3Qudm9pY2VPdmVyXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtZmxhZ1xcXCIgb24tdGFwPVxcXCJkb3dudm90ZVBvc3QoJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0pXFxcIiBuZy1pZj1cXFwiISRyb290LiRzdG9yYWdlLnNpdGVtLmRvd252b3RlZFxcXCI+e3snRE9XTlZPVEUnfHRyYW5zbGF0ZX19PC9pPjxpIGNsYXNzPVxcXCJmYSBmYS1mbGFnIHBvc2l0aXZlXFxcIiBvbi10YXA9XFxcInVudm90ZVBvc3QoJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0pXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uZG93bnZvdGVkXFxcIj57eydVTlZPVEVfRE9XTlZPVEVEJ3x0cmFuc2xhdGV9fTwvaT48L3NwYW4+PHNwYW4gbmctaWY9XFxcIiEkcm9vdC52b2ljZU92ZXJcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1mbGFnXFxcIiBvbi10YXA9XFxcImRvd252b3RlUG9zdCgkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiIG5nLWlmPVxcXCIhJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uZG93bnZvdGVkXFxcIj48L2k+PGkgY2xhc3M9XFxcImZhIGZhLWZsYWcgcG9zaXRpdmVcXFwiIG9uLXRhcD1cXFwidW52b3RlUG9zdCgkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5zaXRlbS5kb3dudm90ZWRcXFwiPjwvaT48L3NwYW4+PC9kaXY+PC9kaXY+XFxuICAgIFxcdDxicj48IS0tLS0+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYm9keXRleHQgc2VsZWN0YWJsZVxcXCIgbmctYmluZC1odG1sPVxcXCIkcm9vdC4kc3RvcmFnZS5zaXRlbS5ib2R5IHwgcGFyc2VVcmwgXFxcIj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IG5nLWlmPSckcm9vdC4kc3RvcmFnZS5zaXRlbS5qc29uX21ldGFkYXRhLnRhZ3MnIGNsYXNzPVxcXCJ0YWdzXFxcIj5cXG4gICAgICAgIDxkaXYgbmctcmVwZWF0PSd0YWcgaW4gJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uanNvbl9tZXRhZGF0YS50YWdzJz5cXG4gICAgICAgICAgPHNwYW4+PGRpdiBjbGFzcz1cXFwidGFnXFxcIiBvbi10YXA9XFxcIm9wZW5UYWcodGFnLCA1KVxcXCI+e3t0YWd9fTwvZGl2PjwvbGk+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgZ3JheVxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIiBuZy1pZj1cXFwiISRyb290LnZvaWNlT3ZlclxcXCI+PGlvbi1zcGlubmVyIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5zaXRlbS5pbnZvdGluZ1xcXCI+PC9pb24tc3Bpbm5lcj5cXG4gICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS11cCBmYS1sZ1xcXCIgb24tdGFwPVxcXCJ1cHZvdGVQb3N0KCRyb290LiRzdG9yYWdlLnNpdGVtKVxcXCIgbmctaWY9XFxcIiEkcm9vdC4kc3RvcmFnZS5zaXRlbS51cHZvdGVkICYmICEkcm9vdC4kc3RvcmFnZS5zaXRlbS5pbnZvdGluZ1xcXCIgb24taG9sZD1cXFwib3BlblNsaWRlcnIoJGV2ZW50KVxcXCI+PC9pPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS11cCBmYS1sZyBwb3NpdGl2ZVxcXCIgb24tdGFwPVxcXCJ1bnZvdGVQb3N0KCRyb290LiRzdG9yYWdlLnNpdGVtKVxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnNpdGVtLnVwdm90ZWQgJiYgISRyb290LiRzdG9yYWdlLnNpdGVtLmludm90aW5nXFxcIj48L2k+Jm5ic3A7Jm5ic3A7Jm5ic3A7PHNwYW4gb24tdGFwPVxcXCIkcm9vdC5vcGVuSW5mbygkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiPnt7JHJvb3QuJHN0b3JhZ2Uuc2l0ZW0ubmV0X3ZvdGVzfX08L3NwYW4+PC9kaXY+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIiBuZy1pZj1cXFwiJHJvb3Qudm9pY2VPdmVyXFxcIj48aW9uLXNwaW5uZXIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnNpdGVtLmludm90aW5nXFxcIj48L2lvbi1zcGlubmVyPlxcbiAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtYXJyb3ctZHJvcHVwLWNpcmNsZVxcXCIgb24tdGFwPVxcXCJ1cHZvdGVQb3N0KCRyb290LiRzdG9yYWdlLnNpdGVtKVxcXCIgbmctaWY9XFxcIiEkcm9vdC4kc3RvcmFnZS5zaXRlbS51cHZvdGVkXFxcIiBvbi1ob2xkPVxcXCJvcGVuU2xpZGVycigkZXZlbnQpXFxcIj57eydVUFZPVEUnfHRyYW5zbGF0ZX19PC9pPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1hbmRyb2lkLWFycm93LWRyb3B1cC1jaXJjbGUgcG9zaXRpdmVcXFwiIG9uLXRhcD1cXFwidW52b3RlUG9zdCgkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5zaXRlbS51cHZvdGVkXFxcIj57eydVTlZPVEVfVVBWT1RFRCd8dHJhbnNsYXRlfX08L2k+Jm5ic3A7Jm5ic3A7Jm5ic3A7PHNwYW4gb24tdGFwPVxcXCIkcm9vdC5vcGVuSW5mbygkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiPnt7JHJvb3QuJHN0b3JhZ2Uuc2l0ZW0ubmV0X3ZvdGVzfX08L3NwYW4+PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIiBvbi10YXA9XFxcIm9wZW5Ub29sdGlwKCRldmVudCwkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiPjxiPnt7JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3l8Z2V0Q3VycmVuY3lTeW1ib2x9fTwvYj4ge3skcm9vdC4kc3RvcmFnZS5zaXRlbSB8IHN1bVBvc3RUb3RhbDokcm9vdC4kc3RvcmFnZS5jdXJyZW5jeVJhdGUgfCBudW1iZXJ9fTwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tY2hhdGJ1YmJsZXNcXFwiPjwvaT57eyRyb290LiRzdG9yYWdlLnNpdGVtLmNoaWxkcmVufX08L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCIgb24tdGFwPVxcXCJpc3JlcGx5aW5nKCRyb290LiRzdG9yYWdlLnNpdGVtLCB0cnVlKVxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWVcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1yZXBseVxcXCI+PC9pPjwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIiBvbi10YXA9XFxcImVkaXRQb3N0KCRyb290LiRzdG9yYWdlLnNpdGVtKVxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnNpdGVtLm1vZGU9PSdmaXJzdF9wYXlvdXQnICYmICRyb290LiRzdG9yYWdlLnNpdGVtLmF1dGhvcj09JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZVxcXCI+PGkgY2xhc3M9XFxcImZhICBmYS1wZW5jaWwtc3F1YXJlLW9cXFwiPjwvaT48L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCIgb24tdGFwPVxcXCJkZWxldGVQb3N0KCRyb290LiRzdG9yYWdlLnNpdGVtKVxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnNpdGVtLm5ldF92b3Rlcz09MCAmJiAkcm9vdC4kc3RvcmFnZS5zaXRlbS5hdXRob3I9PSRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWVcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS10cmFzaC1vXFxcIj48L2k+PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGlvbi10aHJlYWQgY29tbWVudHM9XFxcInBvc3QuY29tbWVudHNcXFwiPjwvaW9uLXRocmVhZD5cXG4gICAgPC9kaXY+XFxuICAgIDxzY3JpcHQgaWQgPSBcXFwicG9wb3ZlclRyLmh0bWxcXFwiIHR5cGU9XFxcInRleHQvbmctdGVtcGxhdGVcXFwiPlxcbiAgICAgIDxpb24tcG9wb3Zlci12aWV3IGNsYXNzPVxcXCJkZXRhaWxlZFBvc3RcXFwiPlxcbiAgICAgICAgPGlvbi1jb250ZW50PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYWRkaW5nXFxcIiBuZy1iaW5kLWh0bWw9XFxcInRvb2x0aXBUZXh0XFxcIj48L2Rpdj5cXG4gICAgICAgIDwvaW9uLWNvbnRlbnQ+XFxuICAgICAgXFxuICAgICAgPC9pb24tcG9wb3Zlci12aWV3PlxcbiAgICA8L3NjcmlwdD5cXG4gICAgPHNjcmlwdCBpZCA9IFxcXCJwb3BvdmVyU2xpZGVyci5odG1sXFxcIiB0eXBlPVxcXCJ0ZXh0L25nLXRlbXBsYXRlXFxcIj5cXG4gICAgICA8aW9uLXBvcG92ZXItdmlldyBjbGFzcz1cXFwiZGV0YWlsZWRTbGlkZVxcXCI+XFxuICAgICAgICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcInBhZGRpbmdcXFwiPlxcbiAgICAgICAgICA8cnpzbGlkZXIgcnotc2xpZGVyLW1vZGVsPVxcXCJwc2xpZGVyLnZhbHVlXFxcIiByei1zbGlkZXItb3B0aW9ucz1cXFwicHNsaWRlci5vcHRpb25zXFxcIj48L3J6c2xpZGVyPlxcbiAgICAgICAgPC9pb24tY29udGVudD5cXG4gICAgICA8L2lvbi1wb3BvdmVyLXZpZXc+XFxuICAgIDwvc2NyaXB0PlxcbiAgPC9pb24tY29udGVudD5cXG48L2lvbi12aWV3PlxcblwiLFxuICAgICAgICBjb250cm9sbGVyOiAnUG9zdEN0cmwnXG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgLy8gaWYgbm9uZSBvZiB0aGUgYWJvdmUgc3RhdGVzIGFyZSBtYXRjaGVkLCB1c2UgdGhpcyBhcyB0aGUgZmFsbGJhY2tcbiAgJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZSgnL2FwcC9wb3N0cy8nKTtcbiAgJGlvbmljQ29uZmlnUHJvdmlkZXIubmF2QmFyLmFsaWduVGl0bGUoJ2xlZnQnKVxuICAkaW9uaWNDb25maWdQcm92aWRlci5iYWNrQnV0dG9uLnRleHQoJycpLmljb24oJ2lvbi1jaGV2cm9uLWxlZnQnKTtcbiAgJGlvbmljQ29uZmlnUHJvdmlkZXIudmlld3Muc3dpcGVCYWNrRW5hYmxlZChmYWxzZSk7XG4gICRpb25pY0NvbmZpZ1Byb3ZpZGVyLnZpZXdzLm1heENhY2hlKDIpO1xuXG4gICRhbmltYXRlUHJvdmlkZXIuY2xhc3NOYW1lRmlsdGVyKCAvXFxiYW5pbWF0ZWRcXGIvICk7XG4gICRpb25pY0NvbmZpZ1Byb3ZpZGVyLnNjcm9sbGluZy5qc1Njcm9sbGluZyhmYWxzZSk7XG5cbiAgaWYgKHdpbmRvdy5jb3Jkb3ZhKSB7XG4gICAgICAkbG9nUHJvdmlkZXIuZGVidWdFbmFibGVkKGZhbHNlKTtcbiAgICAgICRjb21waWxlUHJvdmlkZXIuZGVidWdJbmZvRW5hYmxlZChmYWxzZSk7XG4gIH1cblxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdlbi1VUycsIHJlcXVpcmUoJy4vbG9jYWxlcy9lbicpKTsgLy9FbmdsaXNoXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ3J1LVJVJywgcmVxdWlyZSgnLi9sb2NhbGVzL3J1LVJVJykpOyAvL1J1c3NpYW5cbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnZGUtREUnLCByZXF1aXJlKCcuL2xvY2FsZXMvZGUtREUnKSk7IC8vR2VybWFuXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2ZyLUZSJywgcmVxdWlyZSgnLi9sb2NhbGVzL2ZyLUZSJykpOyAvL0ZyZW5jaFxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdlcy1FUycsIHJlcXVpcmUoJy4vbG9jYWxlcy9lcy1FUycpKTsgLy9TcGFuaXNoXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2VsLUdSJywgcmVxdWlyZSgnLi9sb2NhbGVzL2VsLUdSJykpOyAvL0dyZWVrXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2JnLUJHJywgcmVxdWlyZSgnLi9sb2NhbGVzL2JnLUJHJykpOyAvL0J1bGdhcmlhblxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdubC1OTCcsIHJlcXVpcmUoJy4vbG9jYWxlcy9ubC1OTCcpKTsgLy9EdXRjaFxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdodS1IVScsIHJlcXVpcmUoJy4vbG9jYWxlcy9odS1IVScpKTsgLy9IdW5nYXJpYW5cbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnY3MtQ1onLCByZXF1aXJlKCcuL2xvY2FsZXMvY3MtQ1onKSk7IC8vQ3plY2hcbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnaGUtSUwnLCByZXF1aXJlKCcuL2xvY2FsZXMvaGUtSUwnKSk7IC8vSGVicmV3XG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ3BsLVBMJywgcmVxdWlyZSgnLi9sb2NhbGVzL3BsLVBMJykpOyAvL1BvbGlzaFxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdwdC1QVCcsIHJlcXVpcmUoJy4vbG9jYWxlcy9wdC1QVCcpKTsgLy9Qb3J0dWd1ZXNlXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ3B0LUJSJywgcmVxdWlyZSgnLi9sb2NhbGVzL3B0LUJSJykpOyAvL1BvcnR1Z3Vlc2UgQnJhemlsXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2lkLUlEJywgcmVxdWlyZSgnLi9sb2NhbGVzL2lkLUlEJykpOyAvL0luZG9uZXNpYW5cbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnemgtVFcnLCByZXF1aXJlKCcuL2xvY2FsZXMvemgtVFcnKSk7IC8vQ2hpbmVzZSB0cmFkaXRpb25hbFxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCd6aC1DTicsIHJlcXVpcmUoJy4vbG9jYWxlcy96aC1DTicpKTsgLy9DaGluZXNlIHNpbXBsaWZpZWRcbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnZG9sYW4nLCByZXF1aXJlKCcuL2xvY2FsZXMvZG9sJykpOyAvL0RvbGFuXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ3N2LVNFJywgcmVxdWlyZSgnLi9sb2NhbGVzL3N2LVNFJykpOyAvL0NoaW5lc2Ugc2ltcGxpZmllZFxuXG4gICR0cmFuc2xhdGVQcm92aWRlci51c2VTYW5pdGl6ZVZhbHVlU3RyYXRlZ3kobnVsbCk7XG5cbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnByZWZlcnJlZExhbmd1YWdlKCdlbi1VUycpO1xuICAkdHJhbnNsYXRlUHJvdmlkZXIuZmFsbGJhY2tMYW5ndWFnZSgnZW4tVVMnKTtcblxufSk7XG5cbmFwcC5ydW4oZnVuY3Rpb24oJGlvbmljUGxhdGZvcm0sICRyb290U2NvcGUsICRsb2NhbFN0b3JhZ2UsICRpbnRlcnZhbCwgJGlvbmljUG9wdXAsICRpb25pY0xvYWRpbmcsICRjb3Jkb3ZhU3BsYXNoc2NyZWVuLCAkaW9uaWNNb2RhbCwgJHRpbWVvdXQsICRjb3Jkb3ZhVG9hc3QsIEFQSXMsICRzdGF0ZSwgJGxvZywgJGlvbmljU2Nyb2xsRGVsZWdhdGUsICRmaWx0ZXIsICR0cmFuc2xhdGUpIHtcbiAgJHJvb3RTY29wZS4kc3RvcmFnZSA9ICRsb2NhbFN0b3JhZ2U7XG4gICRyb290U2NvcGUubG9nID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICRsb2cuaW5mbyhtZXNzYWdlKTtcbiAgfTtcbiAgJGlvbmljUGxhdGZvcm0ucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgLy8gSGlkZSB0aGUgYWNjZXNzb3J5IGJhciBieSBkZWZhdWx0IChyZW1vdmUgdGhpcyB0byBzaG93IHRoZSBhY2Nlc3NvcnkgYmFyIGFib3ZlIHRoZSBrZXlib2FyZFxuICAgIC8vIGZvciBmb3JtIGlucHV0cylcbiAgICBpZiAod2luZG93LmNvcmRvdmEgJiYgd2luZG93LmNvcmRvdmEucGx1Z2lucy5LZXlib2FyZCkge1xuICAgICAgY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmhpZGVLZXlib2FyZEFjY2Vzc29yeUJhcih0cnVlKTtcbiAgICAgIGNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5kaXNhYmxlU2Nyb2xsKHRydWUpO1xuICAgIH1cbiAgICBpZiAod2luZG93LlN0YXR1c0Jhcikge1xuICAgICAgLy8gb3JnLmFwYWNoZS5jb3Jkb3ZhLnN0YXR1c2JhciByZXF1aXJlZFxuICAgICAgU3RhdHVzQmFyLnN0eWxlRGVmYXVsdCgpO1xuICAgIH1cbiAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2UudXNlcnMpIHtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UudXNlcnMgPSBbXTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLnNvY2tldGdvbG9zKVxuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5zb2NrZXRnb2xvcyA9IFwid3NzOi8vd3MuZ29sb3MuaW8vXCI7XG4gICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLnNvY2tldHN0ZWVtKVxuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5zb2NrZXRzdGVlbSA9IFwid3NzOi8vc3RlZW1kLnN0ZWVtaXQuY29tXCI7XG5cblxuICAgIGlmICghYW5ndWxhci5pc0RlZmluZWQoJHJvb3RTY29wZS4kc3RvcmFnZS5sYW5ndWFnZSkpIHtcbiAgICAgIGlmKHR5cGVvZiBuYXZpZ2F0b3IuZ2xvYmFsaXphdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIG5hdmlnYXRvci5nbG9iYWxpemF0aW9uLmdldFByZWZlcnJlZExhbmd1YWdlKGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICR0cmFuc2xhdGUudXNlKGxhbmd1YWdlLnZhbHVlKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU1VDQ0VTUyAtPiBcIiArIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5sYW5ndWFnZSA9IGxhbmd1YWdlLnZhbHVlO1xuICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFUlJPUiAtPiBcIiArIGVycm9yKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmxhbmd1YWdlID0gJ2VuJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJHRyYW5zbGF0ZS51c2UoJHJvb3RTY29wZS4kc3RvcmFnZS5sYW5ndWFnZSk7XG4gICAgfVxuICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbil7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtbmFtZSA9IFwiU3RlZW1cIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1wb3dlciA9IFwiU3RlZW0gUG93ZXJcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1zdW5pdCA9IFwiU3RlZW1cIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1kb2xsYXIgPSBcIlN0ZWVtIERvbGxhclwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWR1bml0ID0gXCJTQkRcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1wdW5pdCA9IFwiU1BcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1sdW5pdCA9IFwiU1RFRU1cIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4gPSBcInN0ZWVtXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5ID0gXCJ1c2RcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlID0gMTtcbiAgICB9XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5sYW5ndWFnZXMgPSBbXG4gICAgICB7aWQ6J2VuJywgbmFtZTogJ0VuZ2xpc2gnfSwgXG4gICAgICB7aWQ6J2VzLUVTJywgbmFtZTogJ0VzcGHDsW9sJ30sIFxuICAgICAge2lkOidlbC1HUicsIG5hbWU6ICfOlc67zrvOt869zrnOus6sJ30sIFxuICAgICAge2lkOidmci1GUicsIG5hbWU6ICdGcmFuw6dhaXMnfSwgXG4gICAgICB7aWQ6J2RlLURFJywgbmFtZTogJ0RldXRzY2gnfSwgXG4gICAgICB7aWQ6J3J1LVJVJywgbmFtZTogJ9Cg0YPRgdGB0LrQuNC5J30sIFxuICAgICAge2lkOidiZy1CRycsIG5hbWU6ICfQkdGK0LvQs9Cw0YDRgdC60LgnfSwgXG4gICAgICB7aWQ6J25sLU5MJywgbmFtZTogJ05lZGVybGFuZHMnfSwgXG4gICAgICB7aWQ6J2h1LUhVJywgbmFtZTogJ01hZ3lhcid9LCBcbiAgICAgIHtpZDonY3MtQ1onLCBuYW1lOiAnxIxlxaF0aW5hJ30sIFxuICAgICAge2lkOidoZS1JTCcsIG5hbWU6ICfXoteR16jXmdeq4oCOJ30sIFxuICAgICAge2lkOidwbC1QTCcsIG5hbWU6ICdQb2xza2nigI4nfSwgXG4gICAgICB7aWQ6J3B0LVBUJywgbmFtZTogJ1BvcnR1Z3XDqnMnfSwgXG4gICAgICB7aWQ6J3B0LUJSJywgbmFtZTogJ1BvcnR1Z3XDqnMgQlInfSxcbiAgICAgIHtpZDonc3YtU0UnLCBuYW1lOiAnU3ZlbnNrJ30sXG4gICAgICB7aWQ6J2lkLUlEJywgbmFtZTogJ0JhaGFzYSBJbmRvbmVzaWEnfSwgXG4gICAgICB7aWQ6J3poLUNOJywgbmFtZTogJ+e5gemrlOS4reaWhyd9LCBcbiAgICAgIHtpZDonemgtVFcnLCBuYW1lOiAn566A5L2T5Lit5paHJ30sXG4gICAgICB7aWQ6J2RvbGFuJywgbmFtZTogJ0RvbGFuJ31cbiAgICBdO1xuXG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbnMgPSBbe2lkOidzdGVlbScsIG5hbWU6ICdTdGVlbSd9LCB7aWQ6J2dvbG9zJywgbmFtZTogJ0dvbG9zJ31dO1xuXG4gICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmNpZXMpIHtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY2llcyA9IFtcbiAgICAgICAge2lkOididGMnLCBuYW1lOiAnQlRDJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSwgXG4gICAgICAgIHtpZDondXNkJywgbmFtZTogJ1VTRCcsIHJhdGU6IDAsIGRhdGU6IFwiMS8xLzIwMTZcIn0sIFxuICAgICAgICB7aWQ6J2V1cicsIG5hbWU6ICdFVVInLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LCBcbiAgICAgICAge2lkOidydWInLCBuYW1lOiAnUlVCJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSwgXG4gICAgICAgIHtpZDonZ2JwJywgbmFtZTogJ0dCUCcsIHJhdGU6IDAsIGRhdGU6IFwiMS8xLzIwMTZcIn0sIFxuICAgICAgICB7aWQ6J2pweScsIG5hbWU6ICdKUFknLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LCBcbiAgICAgICAge2lkOidrcncnLCBuYW1lOiAnS1JXJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSwgXG4gICAgICAgIHtpZDonaW5yJywgbmFtZTogJ0lOUicsIHJhdGU6IDAsIGRhdGU6IFwiMS8xLzIwMTZcIn0sIFxuICAgICAgICB7aWQ6J2NueScsIG5hbWU6ICdDTlknLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LCBcbiAgICAgICAge2lkOid1YWgnLCBuYW1lOiAnVUFIJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSwgXG4gICAgICAgIHtpZDonc2VrJywgbmFtZTogJ1NFSycsIHJhdGU6IDAsIGRhdGU6IFwiMS8xLzIwMTZcIn0sIFxuICAgICAgICB7aWQ6J3RyeScsIG5hbWU6ICdUUlknLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9XG4gICAgICBdO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cuY29yZG92YSkge1xuICAgICAgaWYgKGlvbmljLlBsYXRmb3JtLmlzSVBhZCgpIHx8IGlvbmljLlBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgICAgTW9iaWxlQWNjZXNzaWJpbGl0eS5pc1ZvaWNlT3ZlclJ1bm5pbmcoZnVuY3Rpb24oYm9vbCkge1xuICAgICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUubG9nKFwiU2NyZWVuIHJlYWRlcjogT05cIik7XG4gICAgICAgICAgICAgICRyb290U2NvcGUudm9pY2VPdmVyID0gYm9vbDtcbiAgICAgICAgICAgICAgLy8kaW9uaWNDb25maWdQcm92aWRlci5uYXZCYXIuYWxpZ25UaXRsZSgnY2VudGVyJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJTY3JlZW4gcmVhZGVyOiBPRkZcIik7XG4gICAgICAgICAgICAgICRyb290U2NvcGUudm9pY2VPdmVyID0gYm9vbDtcbiAgICAgICAgICAgICAgLy8kaW9uaWNDb25maWdQcm92aWRlci5uYXZCYXIuYWxpZ25UaXRsZSgnbGVmdCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUudm9pY2VPdmVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICRyb290U2NvcGUudm9pY2VPdmVyID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLnZpZXcpIHtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UudmlldyA9ICdjb21wYWN0JztcbiAgICB9XG4gICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlcikge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSBcInRyZW5kaW5nXCI7XG4gICAgfVxuICAgIGlmIChuYXZpZ2F0b3Iuc3BsYXNoc2NyZWVuKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBuYXZpZ2F0b3Iuc3BsYXNoc2NyZWVuLmhpZGUoKTtcbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgICAkcm9vdFNjb3BlLmxvZyhcImFwcCBzdGFydCByZWFkeVwiKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSkge1xuICAgICAgICAkcm9vdFNjb3BlLnBpbmNoZWNrID0gdHJ1ZTtcbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KFwicGluOmNoZWNrXCIpO1xuICAgICAgfVxuICAgIH0sIDEwMDApO1xuICAgICRyb290U2NvcGUuc2hvd0FsZXJ0ID0gZnVuY3Rpb24odGl0bGUsIG1zZykge1xuICAgICAgdmFyIGFsZXJ0UG9wdXAgPSAkaW9uaWNQb3B1cC5hbGVydCh7XG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgdGVtcGxhdGU6IG1zZ1xuICAgICAgfSk7XG4gICAgICBpZiAobXNnLmluZGV4T2YoXCJlcnJvclwiKT4tMSkge1xuICAgICAgICAvL3dpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZyhcImJyb2FkY2FzdCBlcnJvclwiKTtcbiAgICAgICAgLy99KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGVydFBvcHVwLyoudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgJHJvb3RTY29wZS5sb2coJ1RoYW5rIHlvdSAuLi4nKTtcbiAgICAgIH0pOyovXG4gICAgfTtcbiAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlID0gZnVuY3Rpb24odGl0bGUsIG1zZykge1xuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIGlmICh3aW5kb3cuY29yZG92YSkge1xuICAgICAgICAgICRjb3Jkb3ZhVG9hc3Quc2hvd0xvbmdCb3R0b20odGl0bGUrXCI6IFwiK21zZykudGhlbihmdW5jdGlvbihzdWNjZXNzKSB7XG4gICAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcInRvYXN0XCIrc3VjY2Vzcyk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBlcnJvclxuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJ0b2FzdFwiK2Vycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCh0aXRsZSwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgJHJvb3RTY29wZS4kb24oJ3Nob3c6bG9hZGluZycsIGZ1bmN0aW9uKGV2ZW50LCBhcmdzKXtcbiAgICAgICRyb290U2NvcGUubG9nKCdzaG93OmxvYWRpbmcnKTtcbiAgICAgICRpb25pY0xvYWRpbmcuc2hvdyh7XG4gICAgICAgIG5vQmFja2Ryb3AgOiB0cnVlLFxuICAgICAgICB0ZW1wbGF0ZTogJzxpb24tc3Bpbm5lciBpY29uPVwicmlwcGxlXCIgY2xhc3M9XCJzcGlubmVyLWVuZXJnaXplZFwiPjwvaW9uLXNwaW5uZXI+J1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgJHJvb3RTY29wZS4kb24oJ2hpZGU6bG9hZGluZycsIGZ1bmN0aW9uKGV2ZW50LCBhcmdzKXtcbiAgICAgICRyb290U2NvcGUubG9nKCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICRpb25pY0xvYWRpbmcuaGlkZSgpO1xuICAgICAgfSwgMTAwMCk7XG4gICAgfSk7XG5cbiAgICAkcm9vdFNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3RhcnQnLCBmdW5jdGlvbihldmVudCwgdG9TdGF0ZSwgdG9QYXJhbXMsIGZyb21TdGF0ZSwgZnJvbVBhcmFtcyl7XG4gICAgICAkcm9vdFNjb3BlLmxvZyhcImZyb20gXCIrZnJvbVN0YXRlLm5hbWUrXCIgdG8gXCIrdG9TdGF0ZS5uYW1lKTtcbiAgICB9KTtcblxuICAgICRpb25pY1BsYXRmb3JtLm9uKCdyZXN1bWUnLCBmdW5jdGlvbigpe1xuICAgICAgJHJvb3RTY29wZS5sb2coXCJhcHAgcmVzdW1lXCIpO1xuICAgICAgdmFyIHN0ZWVtUlBDID0gcmVxdWlyZShcInN0ZWVtLXJwY1wiKTtcbiAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInNvY2tldFVybFwiKSA9PT0gbnVsbCkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInNvY2tldFVybFwiLCBcIndzczovL3N0ZWVtaXQuY29tL3dzcGFcIik7XG4gICAgICB9XG4gICAgICB3aW5kb3cuQXBpID0gc3RlZW1SUEMuQ2xpZW50LmdldCh7dXJsOmxvY2FsU3RvcmFnZS5zb2NrZXRVcmx9LCB0cnVlKTtcbiAgICAgIHdpbmRvdy5zdGVlbUpTID0gcmVxdWlyZShcInN0ZWVtanMtbGliXCIpO1xuICAgICAgd2luZG93LmdvbG9zSlMgPSByZXF1aXJlKFwiZ29sb3Nqcy1saWJcIik7XG5cbiAgICAgIC8vaWYgKCFhbmd1bGFyLmlzRGVmaW5lZCgkcm9vdFNjb3BlLnRpbWVpbnQpKSB7XG4gICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgJHJvb3RTY29wZS5sb2coXCJBcGkgcmVhZHkgc3RhdGUgY2hhbmdlOiBcIithbmd1bGFyLnRvSnNvbihyZXNwb25zZSkpO1xuICAgICAgICAkcm9vdFNjb3BlLnRpbWVpbnQgPSAkaW50ZXJ2YWwoZnVuY3Rpb24oKXtcbiAgICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfZHluYW1pY19nbG9iYWxfcHJvcGVydGllc1wiLCBbXSkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcImdldF9keW5hbWljX2dsb2JhbF9wcm9wZXJ0aWVzIFwiICsgcmVzcG9uc2UuaGVhZF9ibG9ja19udW1iZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAxNTAwMCk7XG4gICAgICB9KTtcbiAgICAgIC8vfVxuICAgICAgd2luZG93LkZpcmViYXNlUGx1Z2luLm9uTm90aWZpY2F0aW9uT3BlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICRyb290U2NvcGUubG9nKGFuZ3VsYXIudG9Kc29uKGRhdGEpKTtcbiAgICAgICAgaWYoZGF0YS50YXApe1xuICAgICAgICAgIC8vTm90aWZpY2F0aW9uIHdhcyByZWNlaXZlZCBvbiBkZXZpY2UgdHJheSBhbmQgdGFwcGVkIGJ5IHRoZSB1c2VyLlxuICAgICAgICAgIC8vY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICAgIGlmIChkYXRhLmF1dGhvciAmJiBkYXRhLnBlcm1saW5rKSB7XG4gICAgICAgICAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSkge1xuXG4gICAgICAgICAgICAgIHZhciBhbGVydFBvcHVwID0gJGlvbmljUG9wdXAuY29uZmlybSh7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGRhdGEudGl0bGUsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGRhdGEuYm9keSArICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdPUEVOSU5HX1BPU1QnKVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBhbGVydFBvcHVwLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1RoYW5rIHlvdSBmb3Igc2VlaW5nIGFsZXJ0IGZyb20gdHJheScpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuZ2V0Q29udGVudEFuZE9wZW4oe2F1dGhvcjpkYXRhLmF1dGhvciwgcGVybWxpbms6ZGF0YS5wZXJtbGlua30pO1xuICAgICAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcIm5vdCBzdXJlIHRvIG9wZW4gYWxlcnRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZkRhdGEgPSB7dGl0bGU6ZGF0YS50aXRsZSwgYm9keTogZGF0YS5ib2R5LCBhdXRob3I6IGRhdGEuYXV0aG9yLCBwZXJtbGluazogZGF0YS5wZXJtbGlua307XG4gICAgICAgICAgICAgICRyb290U2NvcGUucGluZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgLy9Ob3RpZmljYXRpb24gd2FzIHJlY2VpdmVkIGluIGZvcmVncm91bmQuIE1heWJlIHRoZSB1c2VyIG5lZWRzIHRvIGJlIG5vdGlmaWVkLlxuICAgICAgICAgIC8vYWxlcnQoIEpTT04uc3RyaW5naWZ5KGRhdGEpICk7XG4gICAgICAgICAgaWYgKGRhdGEuYXV0aG9yICYmIGRhdGEucGVybWxpbmspIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoZGF0YS50aXRsZSwgZGF0YS5ib2R5K1wiIFwiK2RhdGEucGVybWxpbmspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKGRhdGEudGl0bGUsIGRhdGEuYm9keSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnBpbmNvZGUpIHtcbiAgICAgICAgJHJvb3RTY29wZS5waW5jaGVjayA9IHRydWU7XG4gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdChcInBpbjpjaGVja1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdpbmRvdy5jb3Jkb3ZhKSB7XG4gICAgICAgIGlmIChpb25pYy5QbGF0Zm9ybS5pc0lQYWQoKSB8fCBpb25pYy5QbGF0Zm9ybS5pc0lPUygpKSB7XG5cbiAgICAgICAgICBNb2JpbGVBY2Nlc3NpYmlsaXR5LmlzVm9pY2VPdmVyUnVubmluZyhmdW5jdGlvbihib29sKSB7XG4gICAgICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKFwiU2NyZWVuIHJlYWRlcjogT05cIik7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS52b2ljZU92ZXIgPSBib29sO1xuICAgICAgICAgICAgICAgIC8vJGlvbmljQ29uZmlnUHJvdmlkZXIubmF2QmFyLmFsaWduVGl0bGUoJ2NlbnRlcicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcIlNjcmVlbiByZWFkZXI6IE9GRlwiKTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnZvaWNlT3ZlciA9IGJvb2w7XG4gICAgICAgICAgICAgICAgLy8kaW9uaWNDb25maWdQcm92aWRlci5uYXZCYXIuYWxpZ25UaXRsZSgnbGVmdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRyb290U2NvcGUudm9pY2VPdmVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUudm9pY2VPdmVyID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICB9KTtcbiAgICAkaW9uaWNQbGF0Zm9ybS5vbigncGF1c2UnLCBmdW5jdGlvbigpe1xuICAgICAgJHJvb3RTY29wZS5sb2coXCJhcHAgcGF1c2VcIik7XG4gICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoJHJvb3RTY29wZS50aW1laW50KSkge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZyhcImNhbmNlbCBpbnRlcnZhbFwiKTtcbiAgICAgICAgJGludGVydmFsLmNhbmNlbCgkcm9vdFNjb3BlLnRpbWVpbnQpO1xuICAgICAgICAkcm9vdFNjb3BlLnRpbWVpbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdpbmRvdy5BcGkuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgICRpb25pY1BsYXRmb3JtLm9uKCdvZmZsaW5lJywgZnVuY3Rpb24oKXtcbiAgICAgICRyb290U2NvcGUubG9nKFwiYXBwIG9mZmxpbmVcIik7XG4gICAgfSk7XG5cbiAgICAkcm9vdFNjb3BlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICRyb290U2NvcGUucGFzc2NvZGUgPSBcIlwiO1xuICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgJHJvb3RTY29wZS5hZGQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgJHJvb3RTY29wZS5waW5lcnJvciA9IFwiXCI7XG4gICAgICBpZigkcm9vdFNjb3BlLnBhc3Njb2RlLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgJHJvb3RTY29wZS5wYXNzY29kZSA9ICRyb290U2NvcGUucGFzc2NvZGUgKyB2YWx1ZTtcbiAgICAgICAgaWYoJHJvb3RTY29wZS5wYXNzY29kZS5sZW5ndGggPT0gNCkge1xuICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJQSU4gXCIrJHJvb3RTY29wZS5wYXNzY29kZSk7XG4gICAgICAgICAgICBpZiAoJHJvb3RTY29wZS5waW50eXBlID09IDMpIHtcbiAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSA9PSAkcm9vdFNjb3BlLnBhc3Njb2RlKSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5wYXNzY29kZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5jbG9zZVBpbigpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUucGludHJ5ICs9IDE7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5waW5lcnJvciA9ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdOT1RfTUFUQ0gnKStcIihcIiskcm9vdFNjb3BlLnBpbnRyeStcIilcIjtcbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS5waW50cnk+Mykge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5waW5jb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5waW50cnkgPSAwO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KFwicGluOmZhaWxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuY2xvc2VQaW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLnBpbnR5cGUgPT0gMCkge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcInR5cGUgMDogc2V0IHBpblwiKTtcbiAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSkge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUucGluY2hlY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdChcInBpbjpjaGVja1wiKTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmNsb3NlUGluKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5waW5jb2RlID0gJHJvb3RTY29wZS5wYXNzY29kZTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnBpbnN1YnRpdGxlID0gJGZpbHRlcigndHJhbnNsYXRlJykoJ0NPTkZJUk1fUElOJyk7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5wYXNzY29kZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5waW50eXBlID0gMztcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnBpbnRyeSA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLnBpbnR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcInR5cGUgMTogY2hlY2sgcGluXCIpO1xuICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5waW5jb2RlID09ICRyb290U2NvcGUucGFzc2NvZGUpe1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgncGluOmNvcnJlY3QnKTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnBhc3Njb2RlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmNsb3NlUGluKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5waW50cnkgKz0gMTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnBpbmVycm9yID0gJGZpbHRlcigndHJhbnNsYXRlJykoJ0lOQ09SUkVDVCcpK1wiKFwiKyRyb290U2NvcGUucGludHJ5K1wiKVwiO1xuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLnBpbnRyeT4zKSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLiRyZXNldCgpO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5jbG9zZVBpbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSwgNTApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgICRyb290U2NvcGUuZGVsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAkcm9vdFNjb3BlLnBpbmVycm9yID0gXCJcIjtcbiAgICAgIGlmKCRyb290U2NvcGUucGFzc2NvZGUubGVuZ3RoID4gMCkge1xuICAgICAgICAkcm9vdFNjb3BlLnBhc3Njb2RlID0gJHJvb3RTY29wZS5wYXNzY29kZS5zdWJzdHJpbmcoMCwgJHJvb3RTY29wZS5wYXNzY29kZS5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAkaW9uaWNNb2RhbC5mcm9tVGVtcGxhdGVVcmwoJ3RlbXBsYXRlcy9waW5jb2RlLmh0bWwnLCB7XG4gICAgICBzY29wZTogJHJvb3RTY29wZVxuICAgIH0pLnRoZW4oZnVuY3Rpb24obW9kYWwpIHtcbiAgICAgICRyb290U2NvcGUucGlubW9kYWwgPSBtb2RhbDtcbiAgICB9KTtcbiAgICAkcm9vdFNjb3BlLmNsb3NlUGluID0gZnVuY3Rpb24oKSB7XG4gICAgICAkcm9vdFNjb3BlLnBpbm1vZGFsLmhpZGUoKTtcbiAgICAgIGlmICgkcm9vdFNjb3BlLnBpbmVuYWJsZWQpIHtcbiAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2Uubm90aWZEYXRhKSB7XG4gICAgICAgICAgdmFyIGFsZXJ0UG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgICAgICAgIHRpdGxlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmRGF0YS50aXRsZSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmRGF0YS5ib2R5ICsgJGZpbHRlcigndHJhbnNsYXRlJykoJ09QRU5JTkdfUE9TVCcpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWxlcnRQb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1RoYW5rIHlvdSBmb3Igc2VlaW5nIGFsZXJ0IGZyb20gdHJheScpO1xuICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLmdldENvbnRlbnRBbmRPcGVuKHthdXRob3I6JHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZkRhdGEuYXV0aG9yLCBwZXJtbGluazokcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmRGF0YS5wZXJtbGlua30pO1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUubG9nKFwibm90IHN1cmUgdG8gb3BlbiBhbGVydFwiKTtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZkRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnBpbmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgJHJvb3RTY29wZS5vcGVuUGluID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgJHJvb3RTY29wZS5wYXNzY29kZSA9IFwiXCI7XG4gICAgICBpZiAodHlwZSA9PSAwKSB7XG4gICAgICAgICRyb290U2NvcGUucGludHlwZSA9IDA7XG4gICAgICAgICRyb290U2NvcGUucGludGl0bGUgPSAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VUX1BJTicpO1xuICAgICAgICAkcm9vdFNjb3BlLnBpbnN1YnRpdGxlID0gJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFVF9QSU4nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IDEpIHtcbiAgICAgICAgJHJvb3RTY29wZS5waW50eXBlID0gMTtcbiAgICAgICAgJHJvb3RTY29wZS5waW50cnkgPSAwO1xuICAgICAgICAkcm9vdFNjb3BlLnBpbnRpdGxlID0gJGZpbHRlcigndHJhbnNsYXRlJykoJ0VOVEVSX1BJTicpO1xuICAgICAgICAkcm9vdFNjb3BlLnBpbnN1YnRpdGxlID0gJGZpbHRlcigndHJhbnNsYXRlJykoJ0VOVEVSX1BJTicpO1xuICAgICAgfVxuICAgICAgJHJvb3RTY29wZS5waW5tb2RhbC5zaG93KCk7XG4gICAgfTtcbiAgICAkcm9vdFNjb3BlLiRvbihcInBpbjpuZXdcIiwgZnVuY3Rpb24oKXtcbiAgICAgICRyb290U2NvcGUucGluY2hlY2sgPSBmYWxzZTtcbiAgICAgICRyb290U2NvcGUub3BlblBpbigwKTtcbiAgICB9KTtcbiAgICAkcm9vdFNjb3BlLiRvbihcInBpbjpjaGVja1wiLCBmdW5jdGlvbigpe1xuICAgICAgJHJvb3RTY29wZS5waW5jaGVjayA9IHRydWU7XG4gICAgICAkcm9vdFNjb3BlLm9wZW5QaW4oMSk7XG4gICAgfSk7XG5cblxuICAgICRpb25pY01vZGFsLmZyb21UZW1wbGF0ZVVybCgndGVtcGxhdGVzL2luZm8uaHRtbCcsIHtcbiAgICAgIHNjb3BlOiAkcm9vdFNjb3BlXG4gICAgICAvL2FuaW1hdGlvbjogXCJudWxsXCJcbiAgICB9KS50aGVuKGZ1bmN0aW9uKG1vZGFsKSB7XG4gICAgICAkcm9vdFNjb3BlLmluZm9tb2RhbCA9IG1vZGFsO1xuICAgIH0pO1xuICAgICRyb290U2NvcGUub3BlbkluZm8gPSBmdW5jdGlvbih4eCkge1xuICAgICAgJHJvb3RTY29wZS52b3RlcnMgPSB4eDtcbiAgICAgICRyb290U2NvcGUuaW5mb21vZGFsLnNob3coKTtcbiAgICB9O1xuXG4gICAgJHJvb3RTY29wZS5jbG9zZUluZm8gPSBmdW5jdGlvbigpIHtcbiAgICAgICRyb290U2NvcGUuaW5mb21vZGFsLmhpZGUoKTtcbiAgICAgIC8vJHJvb3RTY29wZS5pbmZvbW9kYWwucmVtb3ZlKCk7XG4gICAgfTtcblxuICAgIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZUF0PWZ1bmN0aW9uKGluZGV4LCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic3RyKDAsIGluZGV4KSArIGNoYXJhY3RlciArIHRoaXMuc3Vic3RyKGluZGV4K2NoYXJhY3Rlci5sZW5ndGgpO1xuICAgIH1cblx0XHQkcm9vdFNjb3BlLm9wZW5EcmFmdCA9IGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0aXRlbS5vcGVyYXRpb25fdHlwZSA9IGl0ZW0ucG9zdF90eXBlO1xuXHRcdFx0JHJvb3RTY29wZS4kc3RvcmFnZS5zcG9zdCA9IGl0ZW07XG5cdFx0XHQkc3RhdGUuZ28oJ2FwcC5wb3N0cycpO1xuXHRcdFx0JHJvb3RTY29wZS4kYnJvYWRjYXN0KCdvcGVuUG9zdE1vZGFsJyk7XG5cdFx0fVxuICAgICRyb290U2NvcGUuZ2V0Q29udGVudEFuZE9wZW4gPSBmdW5jdGlvbihpdGVtKSB7XG5cbiAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfY29udGVudFwiLCBbaXRlbS5hdXRob3IsIGl0ZW0ucGVybWxpbmtdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAgICAgdmFyIF9sZW4gPSByZXN1bHQuYWN0aXZlX3ZvdGVzLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBqID0gX2xlbiAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmFjdGl2ZV92b3Rlc1tqXS52b3RlciA9PT0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKSB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuYWN0aXZlX3ZvdGVzW2pdLnBlcmNlbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnVwdm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZG93bnZvdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZG93bnZvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnVwdm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQuanNvbl9tZXRhZGF0YSA9IGFuZ3VsYXIuZnJvbUpzb24ocmVzdWx0Lmpzb25fbWV0YWRhdGEpO1xuICAgICAgICAgIHZhciBpdGVtID0gcmVzdWx0O1xuICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0gPSBpdGVtO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyRzdGF0ZS5nbygnYXBwLnBvc3QnKTtcbiAgICAgICAgICAgICRzdGF0ZS5nbygnYXBwLnBvc3QnLCB7Y2F0ZWdvcnk6IGl0ZW0uY2F0ZWdvcnksIGF1dGhvcjogaXRlbS5hdXRob3IsIHBlcm1saW5rOiBpdGVtLnBlcm1saW5rfSk7XG5cbiAgICAgICAgICB9LCA1KTtcblxuICAgICAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgfTtcblxuICAgICRyb290U2NvcGUucmVCbG9nID0gZnVuY3Rpb24oYXV0aG9yLCBwZXJtbGluaykge1xuICAgICAgdmFyIGNvbmZpcm1Qb3B1cCA9ICRpb25pY1BvcHVwLmNvbmZpcm0oe1xuICAgICAgICB0aXRsZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FSRV9ZT1VfU1VSRScpLFxuICAgICAgICB0ZW1wbGF0ZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ1JFQkxPR19URVhUJylcbiAgICAgIH0pO1xuICAgICAgY29uZmlybVBvcHVwLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIGlmKHJlcykge1xuICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIHN1cmUnKTtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5teWxvZ2luID0gbmV3IHdpbmRvd1skcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluK1wiSlNcIl0uTG9naW4oKTtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5teWxvZ2luLnNldFJvbGVzKFtcInBvc3RpbmdcIl0pO1xuICAgICAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHJvb3RTY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZVBvc3RpbmdLZXkgfHwgbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3dbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIkpTXCJdLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgIHZhciBqc29uO1xuXG4gICAgICAgICAgICAgICAganNvbiA9IFtcInJlYmxvZ1wiLHthY2NvdW50OiRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSwgYXV0aG9yOmF1dGhvciwgcGVybWxpbms6cGVybWxpbmt9XTtcblxuICAgICAgICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImN1c3RvbV9qc29uXCIsIHtcbiAgICAgICAgICAgICAgICAgIGlkOiAnZm9sbG93JyxcbiAgICAgICAgICAgICAgICAgIHJlcXVpcmVkX3Bvc3RpbmdfYXV0aHM6IFskcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWVdLFxuICAgICAgICAgICAgICAgICAganNvbjogSlNPTi5zdHJpbmdpZnkoanNvbilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuICAgICAgICAgICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24oJHJvb3RTY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdSRUJMT0dfVEVYVCcpK1wiIFwiK2xvY2FsU3RvcmFnZS5lcnJvcm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyRzY29wZS5yZWZyZXNoRm9sbG93ZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1JFQkxPR0dFRF9QT1NUJykpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTCcpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9UT19YJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBub3Qgc3VyZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgJHJvb3RTY29wZS52b3RlUG9zdCA9IGZ1bmN0aW9uKHBvc3QsIHR5cGUsIGFmdGVyd2FyZCkge1xuICAgICAgcG9zdC5pbnZvdGluZyA9IHRydWU7XG4gICAgICB2YXIgdHQgPSAxO1xuICAgICAgaWYgKHR5cGUgPT09IFwidXB2b3RlXCIpIHtcbiAgICAgICAgdHQgPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiZG93bnZvdGVcIikge1xuICAgICAgICB0dCA9IC0xO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwidW52b3RlXCIpIHtcbiAgICAgICAgdHQgPSAwO1xuICAgICAgfVxuICAgICAgJHJvb3RTY29wZS5sb2coJ3ZvdGluZyAnK3R0KTtcblxuICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcIkFwaSByZWFkeTpcIiArIGFuZ3VsYXIudG9Kc29uKHJlc3BvbnNlKSk7XG4gICAgICAgICAgJHJvb3RTY29wZS5teWxvZ2luID0gbmV3IHdpbmRvd1skcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluK1wiSlNcIl0uTG9naW4oKTtcbiAgICAgICAgICAkcm9vdFNjb3BlLm15bG9naW4uc2V0Um9sZXMoW1wicG9zdGluZ1wiXSk7XG4gICAgICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRyb290U2NvcGUubXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVQb3N0aW5nS2V5IHx8IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChsb2dpblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3dbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIkpTXCJdLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwidm90ZVwiLCB7XG4gICAgICAgICAgICAgICAgdm90ZXI6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBhdXRob3I6IHBvc3QuYXV0aG9yLFxuICAgICAgICAgICAgICAgIHBlcm1saW5rOiBwb3N0LnBlcm1saW5rLFxuICAgICAgICAgICAgICAgIHdlaWdodDogJHJvb3RTY29wZS4kc3RvcmFnZS52b3RlV2VpZ2h0KnR0IHx8IDEwMDAwKnR0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRyKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRyb290U2NvcGUubXlsb2dpbiwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBwb3N0Lmludm90aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAodHQ+MCl7XG5cdFx0XHRcdFx0XHRcdFx0XHRwb3N0LnVwdm90ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodHQ8MCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zdC5kb3dudm90ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwb3N0LnVwdm90ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdHBvc3QuZG93bnZvdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0fVxuICAgICAgICAgICAgICAgIGlmIChhZnRlcndhcmQgPT09ICdmZXRjaENvbnRlbnQnKSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoYWZ0ZXJ3YXJkLCB7IGFueToge2F1dGhvcjogcG9zdC5hdXRob3IsIHBlcm1saW5rOiBwb3N0LnBlcm1saW5rfSB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KGFmdGVyd2FyZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG5cbiAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTCcpKTtcbiAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICBwb3N0Lmludm90aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgIHBvc3QuaW52b3RpbmcgPSBmYWxzZTtcbiAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX1RPX1gnKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgICRyb290U2NvcGUuaXNXaXRuZXNzVm90ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgJiYgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLndpdG5lc3Nfdm90ZXMuaW5kZXhPZihcImdvb2Qta2FybWFcIik+LTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICAkcm9vdFNjb3BlLnZvdGVXaXRuZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb25maXJtUG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgICAgICB0aXRsZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FSRV9ZT1VfU1VSRScpLFxuICAgICAgICAgIHRlbXBsYXRlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVk9URV9GT1JfV0lUTkVTUycpK1wiIEBnb29kLWthcm1hXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbmZpcm1Qb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgIGlmKHJlcykge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgc3VyZScpO1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSkge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUubXlsb2dpbiA9IG5ldyB3aW5kb3dbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIkpTXCJdLkxvZ2luKCk7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5teWxvZ2luLnNldFJvbGVzKFtcImFjdGl2ZVwiXSk7XG4gICAgICAgICAgICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRyb290U2NvcGUubXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5hY3RpdmUua2V5X2F1dGhzXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5IHx8IG51bGxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChsb2dpblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3dbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIkpTXCJdLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwiYWNjb3VudF93aXRuZXNzX3ZvdGVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgIGFjY291bnQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBhcHByb3ZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgIHdpdG5lc3M6IFwiZ29vZC1rYXJtYVwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG5cbiAgICAgICAgICAgICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24oJHJvb3RTY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5lcnJvciA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyRzY29wZS5yZWZyZXNoRm9sbG93ZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdWT1RFRF9GT1JfV0lUTkVTUycpKycgQGdvb2Qta2FybWEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3JlZnJlc2hMb2NhbFVzZXJEYXRhJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUwnKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9UT19YJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBub3Qgc3VyZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICRyb290U2NvcGUuZm9sbG93aW5nID0gZnVuY3Rpb24oeHgsIG10eXBlKSB7XG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgICAgJHJvb3RTY29wZS5sb2coeHgpO1xuICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICRyb290U2NvcGUubXlsb2dpbiA9IG5ldyB3aW5kb3dbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIkpTXCJdLkxvZ2luKCk7XG4gICAgICAgICAgJHJvb3RTY29wZS5teWxvZ2luLnNldFJvbGVzKFtcInBvc3RpbmdcIl0pO1xuICAgICAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSAkcm9vdFNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICAgICAgcG9zdGluZzogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBvc3Rpbmcua2V5X2F1dGhzXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlUG9zdGluZ0tleSB8fCBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgICAgICB2YXIgdHIgPSBuZXcgd2luZG93WyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4rXCJKU1wiXS5UcmFuc2FjdGlvbkJ1aWxkZXIoKTtcbiAgICAgICAgICAgIHZhciBqc29uO1xuICAgICAgICAgICAgaWYgKG10eXBlID09PSBcImZvbGxvd1wiKSB7XG4gICAgICAgICAgICAgIGpzb24gPSBbJ2ZvbGxvdycse2ZvbGxvd2VyOiRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSwgZm9sbG93aW5nOnh4LCB3aGF0OiBbXCJibG9nXCJdfV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBqc29uID0gWydmb2xsb3cnLHtmb2xsb3dlcjokcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsIGZvbGxvd2luZzp4eCwgd2hhdDogW119XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwiY3VzdG9tX2pzb25cIiwge1xuICAgICAgICAgICAgICBpZDogJ2ZvbGxvdycsXG4gICAgICAgICAgICAgIHJlcXVpcmVkX3Bvc3RpbmdfYXV0aHM6IFskcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWVdLFxuICAgICAgICAgICAgICBqc29uOiBhbmd1bGFyLnRvSnNvbihqc29uKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuICAgICAgICAgICAgdHIucHJvY2Vzc190cmFuc2FjdGlvbigkcm9vdFNjb3BlLm15bG9naW4sIG51bGwsIHRydWUpO1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0JST0FEQ0FTVF9FUlJPUicpK1wiIFwiK2xvY2FsU3RvcmFnZS5lcnJvcm1lc3NhZ2UpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8kc2NvcGUucmVmcmVzaEZvbGxvd2VycygpO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY3VycmVudDpyZWxvYWQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9UT19YJykpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9mZWVkX2hpc3RvcnlcIiwgW10pLnRoZW4oZnVuY3Rpb24ocil7XG4gICAgICAgIC8vJHJvb3RTY29wZS5sb2cocik7XG4gICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5iYXNlID0gci5jdXJyZW50X21lZGlhbl9oaXN0b3J5LmJhc2Uuc3BsaXQoXCIgXCIpWzBdO1xuICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9keW5hbWljX2dsb2JhbF9wcm9wZXJ0aWVzXCIsIFtdKS50aGVuKGZ1bmN0aW9uKHIpe1xuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2cocik7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnN0ZWVtX3Blcl9tdmVzdHMgPSAoTnVtYmVyKHIudG90YWxfdmVzdGluZ19mdW5kX3N0ZWVtLnN1YnN0cmluZygwLCByLnRvdGFsX3Zlc3RpbmdfZnVuZF9zdGVlbS5sZW5ndGggLSA2KSkgLyBOdW1iZXIoci50b3RhbF92ZXN0aW5nX3NoYXJlcy5zdWJzdHJpbmcoMCwgci50b3RhbF92ZXN0aW5nX3NoYXJlcy5sZW5ndGggLSA2KSkpICogMWU2O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sIDEwKTtcbiAgICBpZiAoIWFuZ3VsYXIuaXNEZWZpbmVkKCRyb290U2NvcGUuJHN0b3JhZ2Uubm90aWZpY2F0aW9ucykpIHtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uubm90aWZpY2F0aW9ucyA9IFtdO1xuICAgIH1cbiAgICAkcm9vdFNjb3BlLiRvbignY2hhbmdlZENoYWluJywgZnVuY3Rpb24oKXtcbiAgICAgIGNvbnNvbGUubG9nKCdjaGFuZ2VDSGFpbicpO1xuICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4gPT0gJ3N0ZWVtJyl7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1uYW1lID0gXCJTdGVlbVwiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtcG93ZXIgPSBcIlN0ZWVtIFBvd2VyXCI7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1zdW5pdCA9IFwiU3RlZW1cIjtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWRvbGxhciA9IFwiU3RlZW0gRG9sbGFyXCI7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1kdW5pdCA9IFwiU0JEXCI7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1wdW5pdCA9IFwiU1BcIjtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWx1bml0ID0gXCJTVEVFTVwiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnNvY2tldHN0ZWVtID0gXCJ3c3M6Ly9zdGVlbWQuc3RlZW1pdC5jb21cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1uYW1lID0gXCLQk9Ce0JvQntChXCI7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1wb3dlciA9IFwi0KHQmNCb0JAg0JPQntCb0J7QodCQXCI7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1zdW5pdCA9IFwi0JPQvtC70L7RgVwiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZG9sbGFyID0gXCLQl9Ce0JvQntCi0J7QmVwiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZHVuaXQgPSBcIkdCR1wiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtcHVuaXQgPSBcItCh0JjQm9CQINCT0J7Qm9Ce0KHQkFwiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtbHVuaXQgPSBcItCT0J7Qm9Ce0KFcIjtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5zb2NrZXRnb2xvcyA9IFwid3NzOi8vd3MuZ29sb3MuaW8vXCI7XG4gICAgICAgIC8vJHNjb3BlLnNvY2tldCA9IFwid3NzOi8vZ29sb3Muc3RlZW0ud3NcIjtcbiAgICAgIH1cbiAgICAgIGxvY2FsU3RvcmFnZS5zb2NrZXRVcmwgPSAkcm9vdFNjb3BlLiRzdG9yYWdlW1wic29ja2V0XCIrJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbl07XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY2hlY2tEYXRlKGRhdGUsIGlnbm9yZSkge1xuICAgICAgdmFyIGVvbGQgPSA4NjQwMDAwMDsgLy8xICogMjQgKiA2MCAqIDYwICogMTAwMDsgLy8xIGRheSBvbGRcbiAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHZhciBvbGQgPSBuZXcgRGF0ZShkYXRlKS5nZXRUaW1lKCk7XG4gICAgICByZXR1cm4gaWdub3JlfHxub3ctb2xkPj1lb2xkO1xuICAgIH1cbiAgICAkcm9vdFNjb3BlLiRvbignY2hhbmdlZEN1cnJlbmN5JywgZnVuY3Rpb24oZXZlbnQsIGFyZ3Mpe1xuICAgICAgdmFyIHh4ID0gYXJncy5jdXJyZW5jeTtcbiAgICAgIHZhciBpZ25vcmUgPSBhcmdzLmVuZm9yY2U7XG5cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHh4KTtcbiAgICAgICAgdmFyIHJlc3VsdE9iamVjdCA9ICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY2llcy5maWx0ZXIoZnVuY3Rpb24gKCBvYmogKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmlkID09PSB4eDtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIC8vc2VhcmNoT2JqKHh4LCAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmNpZXMpO1xuICAgICAgICBpZiAoY2hlY2tEYXRlKHJlc3VsdE9iamVjdC5kYXRlLCBpZ25vcmUpKSB7XG4gICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4gPT0gJ3N0ZWVtJyl7XG4gICAgICAgICAgICBBUElzLmdldEN1cnJlbmN5UmF0ZShcIlVTRFwiLCB4eCApLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGUgPSBOdW1iZXIocmVzLmRhdGEucXVlcnkucmVzdWx0cy5yYXRlLlJhdGUpO1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmNpZXMuZmlsdGVyKGZ1bmN0aW9uKG9iail7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5pZCA9PSB4eCkge1xuICAgICAgICAgICAgICAgICAgb2JqLnJhdGUgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICAgICAgICAgICAgICAgIG9iai5kYXRlID0gcmVzLmRhdGEucXVlcnkucmVzdWx0cy5yYXRlLkRhdGU9PT1cIk4vQVwiP25ldyBEYXRlKCkgOiByZXMuZGF0YS5xdWVyeS5yZXN1bHRzLnJhdGUuRGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEFQSXMuZ2V0Q3VycmVuY3lSYXRlKFwiWEFVXCIsIHh4ICkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgICAvL1hBVSAtIDMxLjEwMzQ3NjhnXG4gICAgICAgICAgICAgIC8vR0JHIHJhdGUgaW4gbWcuIHNvIGV4Y2hhbmdlUmF0ZS8zMTEwMy40NzY4XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlID0gTnVtYmVyKHJlcy5kYXRhLnF1ZXJ5LnJlc3VsdHMucmF0ZS5SYXRlKS8zMTEwMy40NzY4O1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmNpZXMuZmlsdGVyKGZ1bmN0aW9uKG9iail7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5pZCA9PSB4eCkge1xuICAgICAgICAgICAgICAgICAgb2JqLnJhdGUgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICAgICAgICAgICAgICAgIG9iai5kYXRlID0gcmVzLmRhdGEucXVlcnkucmVzdWx0cy5yYXRlLkRhdGU9PT1cIk4vQVwiP25ldyBEYXRlKCkgOiByZXMuZGF0YS5xdWVyeS5yZXN1bHRzLnJhdGUuRGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSA9IHJlc3VsdE9iamVjdC5yYXRlO1xuICAgICAgICB9XG4gICAgICB9LCAxKTtcbiAgICB9KTtcblxuICAgIGlmICh3aW5kb3cuY29yZG92YSkge1xuICAgICAgaWYgKCFpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgIGlmIChpb25pYy5QbGF0Zm9ybS5pc0lPUygpIHx8IGlvbmljLlBsYXRmb3JtLmlzSVBhZCgpKSB7XG4gICAgICAgICAgLy93aW5kb3cuRmlyZWJhc2VQbHVnaW4uZ3JhbnRQZXJtaXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKndpbmRvdy5GaXJlYmFzZVBsdWdpbi5nZXRUb2tlbihmdW5jdGlvbih0b2tlbikge1xuICAgICAgICAgICAgLy8gc2F2ZSB0aGlzIHNlcnZlci1zaWRlIGFuZCB1c2UgaXQgdG8gcHVzaCBub3RpZmljYXRpb25zIHRvIHRoaXMgZGV2aWNlXG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcImRldmljZSBcIit0b2tlbik7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmRldmljZWlkID0gdG9rZW47XG4gICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgICAgIEFQSXMuc2F2ZVN1YnNjcmlwdGlvbih0b2tlbiwgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCB7IGRldmljZTogaW9uaWMuUGxhdGZvcm0ucGxhdGZvcm0oKSB9KS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coYW5ndWxhci50b0pzb24ocmVzKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgQVBJcy5zYXZlU3Vic2NyaXB0aW9uKHRva2VuLCBcIlwiLCB7IGRldmljZTogaW9uaWMuUGxhdGZvcm0ucGxhdGZvcm0oKSB9KS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coYW5ndWxhci50b0pzb24ocmVzKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIH0pOyovXG5cbiAgICAgICAgRkNNUGx1Z2luLmdldFRva2VuKGZ1bmN0aW9uKHRva2VuKXtcbiAgICAgICAgICAvLyBzYXZlIHRoaXMgc2VydmVyLXNpZGUgYW5kIHVzZSBpdCB0byBwdXNoIG5vdGlmaWNhdGlvbnMgdG8gdGhpcyBkZXZpY2VcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcImRldmljZSBcIit0b2tlbik7XG4gICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5kZXZpY2VpZCA9IHRva2VuO1xuICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgIEFQSXMuc2F2ZVN1YnNjcmlwdGlvbih0b2tlbiwgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCB7IGRldmljZTogaW9uaWMuUGxhdGZvcm0ucGxhdGZvcm0oKSB9KS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgICAgICRyb290U2NvcGUubG9nKGFuZ3VsYXIudG9Kc29uKHJlcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEFQSXMuc2F2ZVN1YnNjcmlwdGlvbih0b2tlbiwgXCJcIiwgeyBkZXZpY2U6IGlvbmljLlBsYXRmb3JtLnBsYXRmb3JtKCkgfSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhhbmd1bGFyLnRvSnNvbihyZXMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyp3aW5kb3cuRmlyZWJhc2VQbHVnaW4ub25Ub2tlblJlZnJlc2goZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICBBUElzLnVwZGF0ZVRva2VuKCRyb290U2NvcGUuJHN0b3JhZ2UuZGV2aWNlaWQsIHRva2VuKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhhbmd1bGFyLnRvSnNvbihyZXMpKTtcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZGV2aWNlaWQgPSB0b2tlbiAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIH0pOyovXG4gICAgICAgIEZDTVBsdWdpbi5vblRva2VuUmVmcmVzaChmdW5jdGlvbih0b2tlbil7XG4gICAgICAgICAgQVBJcy51cGRhdGVUb2tlbigkcm9vdFNjb3BlLiRzdG9yYWdlLmRldmljZWlkLCB0b2tlbikudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coYW5ndWxhci50b0pzb24ocmVzKSk7XG4gICAgICAgICAgICBpZiAocmVzLnN0YXR1cykge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmRldmljZWlkID0gdG9rZW4gIFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKXtcbiAgICAgICAgICAgICRyb290U2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvKndpbmRvdy5GaXJlYmFzZVBsdWdpbi5vbk5vdGlmaWNhdGlvbk9wZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coYW5ndWxhci50b0pzb24oZGF0YSkpO1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGFuZ3VsYXIudG9Kc29uKGRhdGEpKTtcblxuICAgICAgICAgICAgLy8kcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmaWNhdGlvbnMucHVzaCh7dGl0bGU6ZGF0YS50aXRsZSwgbWVzc2FnZTogZGF0YS5ib2R5LCBhdXRob3I6IGRhdGEuYXV0aG9yLCBwZXJtbGluazogZGF0YS5wZXJtbGluaywgY3JlYXRlZDogbmV3IERhdGUoKX0pO1xuXG4gICAgICAgICAgICBpZihkYXRhLnRhcCl7XG4gICAgICAgICAgICAgIC8vTm90aWZpY2F0aW9uIHdhcyByZWNlaXZlZCBvbiBkZXZpY2UgdHJheSBhbmQgdGFwcGVkIGJ5IHRoZSB1c2VyLlxuICAgICAgICAgICAgICBpZiAoZGF0YS5hdXRob3IgJiYgZGF0YS5wZXJtbGluaykge1xuICAgICAgICAgICAgICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS5waW5jb2RlKSB7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBhbGVydFBvcHVwID0gJGlvbmljUG9wdXAuY29uZmlybSh7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBkYXRhLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogZGF0YS5ib2R5ICsgJGZpbHRlcigndHJhbnNsYXRlJykoJ09QRU5JTkdfUE9TVCcpXG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgYWxlcnRQb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnVGhhbmsgeW91IGZvciBzZWVpbmcgYWxlcnQgZnJvbSB0cmF5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5nZXRDb250ZW50QW5kT3Blbih7YXV0aG9yOmRhdGEuYXV0aG9yLCBwZXJtbGluazpkYXRhLnBlcm1saW5rfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKFwibm90IHN1cmUgdG8gb3BlbiBhbGVydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZkRhdGEgPSB7dGl0bGU6ZGF0YS50aXRsZSwgYm9keTogZGF0YS5ib2R5LCBhdXRob3I6IGRhdGEuYXV0aG9yLCBwZXJtbGluazogZGF0YS5wZXJtbGlua307XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnBpbmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICAvL05vdGlmaWNhdGlvbiB3YXMgcmVjZWl2ZWQgaW4gZm9yZWdyb3VuZC4gTWF5YmUgdGhlIHVzZXIgbmVlZHMgdG8gYmUgbm90aWZpZWQuXG4gICAgICAgICAgICAgIC8vYWxlcnQoIEpTT04uc3RyaW5naWZ5KGRhdGEpICk7XG4gICAgICAgICAgICAgIGlmIChkYXRhLmF1dGhvciAmJiBkYXRhLnBlcm1saW5rKSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZShkYXRhLnRpdGxlLCBkYXRhLmJvZHkrXCIgXCIrZGF0YS5wZXJtbGluayk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZShkYXRhLnRpdGxlLCBkYXRhLmJvZHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgICovXG5cbiAgICAgICAgLy9GQ01QbHVnaW4ub25Ob3RpZmljYXRpb24oIG9uTm90aWZpY2F0aW9uQ2FsbGJhY2soZGF0YSksIHN1Y2Nlc3NDYWxsYmFjayhtc2cpLCBlcnJvckNhbGxiYWNrKGVycikgKVxuICAgICAgICAvL0hlcmUgeW91IGRlZmluZSB5b3VyIGFwcGxpY2F0aW9uIGJlaGF2aW91ciBiYXNlZCBvbiB0aGUgbm90aWZpY2F0aW9uIGRhdGEuXG4gICAgICAgIEZDTVBsdWdpbi5vbk5vdGlmaWNhdGlvbihmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhhbmd1bGFyLnRvSnNvbihkYXRhKSk7XG5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coYW5ndWxhci50b0pzb24oZGF0YSkpO1xuXG4gICAgICAgICAgICAvLyRyb290U2NvcGUuJHN0b3JhZ2Uubm90aWZpY2F0aW9ucy5wdXNoKHt0aXRsZTpkYXRhLnRpdGxlLCBtZXNzYWdlOiBkYXRhLmJvZHksIGF1dGhvcjogZGF0YS5hdXRob3IsIHBlcm1saW5rOiBkYXRhLnBlcm1saW5rLCBjcmVhdGVkOiBuZXcgRGF0ZSgpfSk7XG5cbiAgICAgICAgICAgIGlmKGRhdGEud2FzVGFwcGVkKXtcbiAgICAgICAgICAgICAgLy9Ob3RpZmljYXRpb24gd2FzIHJlY2VpdmVkIG9uIGRldmljZSB0cmF5IGFuZCB0YXBwZWQgYnkgdGhlIHVzZXIuXG4gICAgICAgICAgICAgIGlmIChkYXRhLmF1dGhvciAmJiBkYXRhLnBlcm1saW5rKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLnBpbmNvZGUpIHtcblxuICAgICAgICAgICAgICAgICAgdmFyIGFsZXJ0UG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGRhdGEudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBkYXRhLmJvZHkgKyAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnT1BFTklOR19QT1NUJylcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBhbGVydFBvcHVwLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdUaGFuayB5b3UgZm9yIHNlZWluZyBhbGVydCBmcm9tIHRyYXknKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmdldENvbnRlbnRBbmRPcGVuKHthdXRob3I6ZGF0YS5hdXRob3IsIHBlcm1saW5rOmRhdGEucGVybWxpbmt9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJub3Qgc3VyZSB0byBvcGVuIGFsZXJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmRGF0YSA9IHt0aXRsZTpkYXRhLnRpdGxlLCBib2R5OiBkYXRhLmJvZHksIGF1dGhvcjogZGF0YS5hdXRob3IsIHBlcm1saW5rOiBkYXRhLnBlcm1saW5rfTtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUucGluZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICAgIC8vTm90aWZpY2F0aW9uIHdhcyByZWNlaXZlZCBpbiBmb3JlZ3JvdW5kLiBNYXliZSB0aGUgdXNlciBuZWVkcyB0byBiZSBub3RpZmllZC5cbiAgICAgICAgICAgICAgLy9hbGVydCggSlNPTi5zdHJpbmdpZnkoZGF0YSkgKTtcbiAgICAgICAgICAgICAgaWYgKGRhdGEuYXV0aG9yICYmIGRhdGEucGVybWxpbmspIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKGRhdGEudGl0bGUsIGRhdGEuYm9keStcIiBcIitkYXRhLnBlcm1saW5rKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKGRhdGEudGl0bGUsIGRhdGEuYm9keSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgfSk7XG59KTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9wb3N0cy9pbmRleC5qc1wiLFwiL3Bvc3RzXCIpIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIkhPTUVcIjpcItCd0LDRh9Cw0LvQvlwiLFxuICBcIkxPR0lOXCI6XCLQktGF0L7QtFwiLFxuICBcIkxPR09VVFwiOlwi0J7RgtC/0LjRgdCy0LDQvdC1XCIsXG4gIFwiUFJPRklMRVwiOlwi0J/RgNC+0YTQuNC7XCIsXG4gIFwiRk9MTE9XXCI6XCLQodC70LXQtNCy0LDQvdC1XCIsXG4gIFwiQk9PS01BUktTXCI6XCLQm9GO0LHQuNC80LhcIixcbiAgXCJUUkFOU0ZFUlwiOlwi0KLRgNCw0L3RgdGE0LXRgFwiLFxuICBcIk1BUktFVFwiOlwi0J/QsNC30LDRgFwiLFxuICBcIlNFVFRJTkdTXCI6XCLQndCw0YHRgtGA0L7QudC60LhcIixcbiAgXCJBQk9VVFwiOlwi0JfQsCDQv9GA0LjQu9C+0LbQtdC90LjQtdGC0L5cIixcbiAgXCJBQk9VVF8xXCI6XCLQktGB0LXQutC4INC80L7QttC1INC00LAg0L/QtdGH0LXQu9C4INC+0YIg0L/Rg9Cx0LvQuNC60YPQstCw0L3QtSDQvdCwINGB0YLQsNGC0LjQuCFcIixcbiAgXCJBQk9VVF8yXCI6XCLQv9C+0LvQt9Cy0LAge3twbGF0Zm9ybW5hbWV9fS4g0JDQv9C70LjQutCw0YbQuNGP0YLQsCDQtSDRgdGK0LfQtNCw0LTQtdC90LAg0L7RglwiLFxuICBcIkFCT1VUXzNcIjpcItC4INC1INC80L7QsdC40LvQvdC+INC/0YDQuNC70L7QttC10L3QuNC1INGBINC+0YLQstC+0YDQtdC9INC60L7QtC4g0JjQvNCw0YLQtSDRgdCy0L7QsdC+0LTQtdC9INC00L7RgdGC0YrQvyDQtNC+INGB0YrQtNGK0YDQttCw0L3QuNC1INC30LAg0YfQtdGC0LXQvdC1LCDQutC+0LzQtdC90YLQsNGA0LgsINCz0LvQsNGB0YPQstCw0L3QtSwg0L/Rg9Cx0LvQuNC60YPQstCw0L3QtSwg0YPQv9GA0LDQstC70LXQvdC40LUg0L3QsCDQv9GA0LjRhdC+0LTQuCDQt9CwINGC0YDQsNC90YHRhNC10YAg0Lgg0YIu0L0uINGE0YPQvdC60YbQuNC4LCDQv9GA0LXQtNC70LDQs9Cw0L3QuCDQvtGCIHt7cGxhdGZvcm1uYW1lfX0g0LHQu9C+0LrRh9C10LnQvdCwINC90LAge3tzaXRlbmFtZX19LlwiLFxuICBcIkFCT1VUXzRcIjpcIjEuINCQ0L/Qu9C40LrQsNGG0LjRj9GC0LAg0L3Rj9C80LAg0LTQuNGA0LXQutGC0LXQvSDQtNC+0YHRgtGK0L8g0LTQviDRgdGA0LXQtNGB0YLQstCw0YLQsCDQvdCwINC/0L7RgtGA0LXQsdC40YLQtdC70Y8uXCIsXG4gIFwiQUJPVVRfNVwiOlwiMi4g0JDQv9C70LjQutCw0YbQuNGP0YLQsCDQv9GA0LXQtNC70LDQs9CwINC80L7QtNC10Lsg0L3QsCDRgdC40LPRg9GA0L3QvtGB0YIg0LfQsCDRgdGC0YDQsNC90LAg0L3QsCDQutC70LjQtdC90YLQsCwg0YEg0YfQsNGB0YLQvdC4INC60LvRjtGH0L7QstC1LCDRgdGK0YXRgNCw0L3Rj9Cy0LDQvdC1INC90LAg0LzQtdGB0YLQvdC+INC90LjQstC+INC4INC90LjQutC+0LPQsCDQvdC1INGB0LUg0LjQt9C/0YDQsNGJ0LDRgiDQtNC+INGB0YrRgNCy0YrRgNC4LlwiLFxuICBcIkFCT1VUXzZcIjpcIjMuINCQ0L/Qu9C40LrQsNGG0LjRj9GC0LAg0L/RgNC10LTQu9Cw0LPQsCDQv9GA0L7RgdGCINC4INCw0YLRgNCw0LrRgtC40LLQtdC9INC/0L7RgtGA0LXQsdC40YLQtdC70YHQutC4INC40L3RgtC10YDRhNC10LnRgS5cIixcbiAgXCJBQk9VVF83XCI6XCI0LiDQkNC/0LvQuNC60LDRhtC40Y/RgtCwINC90LjQutC+0LPQsCDQvdC1INC40LfQuNGB0LrQstCwINC+0YIg0L/QvtGC0YDQtdCx0LjRgtC10LvRj9GCINC00LAg0LLRitCy0LXQttC00LAg0LvQuNGH0L3QuCDQtNCw0L3QvdC4LlwiLFxuICBcIkFCT1VUXzhcIjpcItCT0LvQsNGB0YPQstCw0LnRgtC1INC30LAgZ29vZC1rYXJtYS5cIixcbiAgXCJBQk9VVF85XCI6XCLQmtC+0L3RgtCw0LrRgiDQuCDQvtCx0YDQsNGC0L3QsCDQstGA0YrQt9C60LA6XCIsXG4gIFwiQUJPVVRfMTBcIjpcItCe0YnQtSDQuNC90YTQvtGA0LzQsNGG0LjRj1wiLFxuICBcIlJFTU9WRVwiOlwi0J/RgNC10LzQsNGF0L3QuFwiLFxuICBcIk1BUktFVF9WSUVXXCI6XCLQmNC30LPQu9C10LQg0L3QsCDQv9Cw0LfQsNGA0LBcIixcbiAgXCJQUklDRVwiOlwi0KbQtdC90LBcIixcbiAgXCJBTU9VTlRcIjpcItCh0YPQvNCwXCIsXG4gIFwiVE9UQUxcIjpcItCe0LHRidC+XCIsXG4gIFwiTk9PUkRFUlNcIjpcItCd0Y/QvNCwINC+0YLQstC+0YDQtdC90Lgg0LfQsNGP0LLQutC4XCIsXG4gIFwiREFURVwiOlwi0JTQsNGC0LBcIixcbiAgXCJCVVlcIjpcItCa0YPQv9C4XCIsXG4gIFwiU0VMTFwiOlwi0J/RgNC+0LTQsNC5XCIsXG4gIFwiT1BFTlwiOlwi0J7RgtCy0L7RgNC4XCIsXG4gIFwiSElTVE9SWVwiOlwi0JjRgdGC0L7RgNC40Y9cIixcbiAgXCJGT0xMT1dfQkFDS1wiOlwi0KHQu9C10LTQstCw0L3QtSDQvtCx0YDQsNGC0L3QvlwiLFxuICBcIkZPTExPV0VEXCI6XCLQodC70LXQtNCy0LDQvVwiLFxuICBcIlVORk9MTE9XXCI6XCLQodC/0YDQtdGC0LUg0YHQu9C10LTQtdC90LXRgtC+XCIsXG4gIFwiRk9MTE9XSU5HXCI6XCLQodC70LXQtNCy0LDQvdC1XCIsXG4gIFwiRk9MTE9XRVJTXCI6XCLQn9C+0YHQu9C10LTQvtCy0LDRgtC10LvQuFwiLFxuICBcIlNFQVJDSF9GT0xMT1dFUlNcIjpcItCi0YrRgNGB0Lgg0L/QvtGB0LvQtdC00L7QstCw0YLQtdC70LhcIixcbiAgXCJTRUFSQ0hfRk9MTE9XSU5HXCI6XCLQotGK0YDRgdC4INGB0LvQtdC00LLQsNC90LhcIixcbiAgXCJCWVwiOlwi0L7RglwiLFxuICBcIklOXCI6XCLQslwiLFxuICBcIk1FTlVcIjpcItCc0LXQvdGOXCIsXG4gIFwiQk9PS01BUktcIjpcItCb0Y7QsdC40LzQuFwiLFxuICBcIlJFQkxPR1wiOlwi0KDQtdCx0LvQvtCzXCIsXG4gIFwiVVBWT1RFXCI6XCLQk9C70LDRgVwiLFxuICBcIkRPV05WT1RFXCI6XCLQndC10LPQsNGC0LjQstC10L0g0LPQu9Cw0YFcIixcbiAgXCJVTlZPVEVfRE9XTlZPVEVEXCI6XCLQntGC0LrQsNC20Lgg0L3QtdCz0LDRgtC40LLQvdC40Y8g0LPQu9Cw0YFcIixcbiAgXCJVTlZPVEVfVVBWT1RFRFwiOlwi0J7RgtC60LDQttC4INCz0LvQsNGB0LBcIixcbiAgXCJSRVBMWVwiOlwi0J7RgtCz0L7QstC+0YBcIixcbiAgXCJFRElUXCI6XCLQoNC10LTQsNC60YLQuNGA0LDQvdC1XCIsXG4gIFwiUE9TVF8xXCI6XCLQn9C70YrQt9C90LXRgtC1INC90LAg0LvRj9Cy0L4sINC30LAg0LTQsCDQstC40LTQuNGC0LUg0L7Qv9GG0LjQuNGC0LVcIixcbiAgXCJQT1NUXzJcIjpcItCY0LfQsdC10YDQtdGC0LUg0L3Rj9C60L7QuSDQutC+0LzQtdC90YLQsNGALCDQt9CwINC00LAg0LLQuNC00LjRgtC1INC/0L7QtC3QutC+0LzQtdC90YLQsNGA0Lgg0LrRitC8INGC0Y/RhS5cIixcbiAgXCJPUFRJT05TXCI6XCLQndCw0YHRgtGA0L7QudC60LhcIixcbiAgXCJSRVNURUVNRURfQllcIjpcItCf0YDQtdC/0YDQsNGC0LXQvdC+INC+0YJcIixcbiAgXCJOT1RISU5HX0hFUkVcIjpcItCS0YHQtSDQvtGJ0LUg0L3QuNGJ0L4uLi5cIixcbiAgXCJCQUxBTkNFU1wiOlwi0JHQsNC70LDQvdGB0Lgg0L/QviDRgdC80LXRgtC60LBcIixcbiAgXCJQUk9GSUxFXzFcIjpcInt7cGxhdGZvcm1uYW1lfX0g0LUg0YDQsNC30LzQtdC90Y/QtdC80LAg0LrRgNC40L/RgtC+0LLQsNC70YPRgtCwLCDQutC+0Y/RgtC+INC80L7QttC1INC00LAg0LHRitC00LUg0YLRgNCw0L3RgdGE0LXRgNC40YDQsNC90LAg0LLRitCyINCy0YHQtdC60Lgg0LXQtNC40L0g0LzQvtC80LXQvdGCLiB7e3BsYXRmb3JtbmFtZX19INC80L7QttC1INC00LAg0LHRitC00LUg0L7QsdGK0YDQvdCw0YLQsCDQsiB7e3BsYXRmb3JtcG93ZXJ9fSDRh9GA0LXQtyDQv9GA0L7RhtC10YEg0L3QsNGA0YfQtdC9INCX0LDRhdGA0LDQvdCy0LDQvdC1LlwiLFxuICBcIlBST0ZJTEVfMlwiOlwie3twbGF0Zm9ybXBvd2VyfX0g0LLQu9C40Y/QtSDQstGK0YDRhdGDINC/0LXRh9Cw0LvQsdC40YLQtS4g0JrQvtC70LrQvtGC0L4g0L/QvtCy0LXRh9C1INC40LzQsCDQv9C+0YLRgNC10LHQuNGC0LXQu9GPLCDRgdC40YHRgtC10LzQsNGC0LAg0LPQviDQvdCw0LPRgNCw0LbQtNCw0LLQsCDQv9C+0LLQtdGH0LUg0LrQvtCz0LDRgtC+INCz0LvQsNGB0YPQstCwINC4INC/0YPQsdC70LjQutGD0LLQsC5cIixcbiAgXCJQUk9GSUxFXzNcIjpcItCe0LrQvtC70L4ge3twbGF0Zm9ybXN1bml0fX0g0L3QsCB7e3BsYXRmb3JtbmFtZX19LlwiLFxuICBcIkVTVElNQVRFRF9WQUxVRVwiOlwi0J/RgNC40LHQu9C40LfQuNGC0LXQu9C90LAg0YHRgtC+0LnQvdC+0YHRglwiLFxuICBcIlBST0ZJTEVfNFwiOlwi0J/RgNC40LHQu9C40LfQuNGC0LXQu9C90LDRgtCwINGB0YLQvtC50L3QvtGB0YIg0YHQtSDQvtGG0LXQvdGP0LLQsCDQvdCwIDcg0LTQvdC4INC+0YIg0YHRgNC10LTQvdCwINGB0YLQvtC50L3QvtGB0YIg0L3QsCB7e3BsYXRmb3JtbmFtZX19LlwiLFxuICBcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjpcItCY0YHRgtC+0YDQuNGPINC90LAg0YLRgNCw0L3Qt9Cw0LrRhtC40LnRgtC1XCIsXG4gIFwiUE9TVElOR1wiOlwi0J/Rg9Cx0LvQuNC60YPQstCw0L3QtVwiLFxuICBcIlBST0ZJTEVfNVwiOlwi0JrQu9GO0YfRitGCINC30LAg0L/Rg9Cx0LvQuNC60YPQstCw0L3QtSDRgdC1INC40LfQv9C+0LvQt9Cy0LAg0LfQsCDQv9GD0LHQu9C40LrRg9Cy0LDQvdC1INC4INCz0LvQsNGB0YPQstCw0L3QtS4g0KLRgNGP0LHQstCwINC00LAg0LHRitC00LUg0YDQsNC30LvQuNGH0LXQvSDQvtGCINCQ0LrRgtC40LLQvdC40Y8g0Lgg0KHQvtCx0YHRgtCy0LXQvdC40Y8g0LrQu9GO0YcuXCIsXG4gIFwiT1dORVJcIjpcItCh0L7QsdGB0YLQstC10L3QuNC6XCIsXG4gIFwiUFJPRklMRV82XCI6XCLQodC+0LHRgdGC0LLQtdC90LjRj9GCINC60LvRjtGHINC1INC+0YHQvdC+0LLQvdC40Y/RgiDQutC70Y7RhyDQvdCwINC/0YDRhNC40LvQsCDQuCDQtSDQvdC10L7QsdGF0L7QtNC40Lwg0LfQsCDQv9GA0L7QvNGP0L3QsCDQvdCwINC00YDRg9Cz0LjRgtC1INC60LvRjtGH0L7QstC1LiDQm9C40YfQvdC40Y/RgiDQutC70Y7RhyDQuNC70Lgg0L/QsNGA0L7Qu9CwINC30LAg0LrQu9GO0YfQsCDQvdCwINGB0L7QsdGB0YLQstC10L3QuNC60LAg0YLRgNGP0LHQstCwINGB0LUg0YHRitGF0YDQsNC90Y/QstCwINC90LAg0YHQuNCz0YPRgNC90L4g0LzRj9GB0YLQvi5cIixcbiAgXCJBQ1RJVkVcIjpcItCQ0LrRgtC40LLQvdC4XCIsXG4gIFwiUFJPRklMRV83XCI6XCLQkNC60YLQuNCy0L3QuNGP0YIg0LrQu9GO0Ycg0YHQtSDQuNC30L/QvtC70LfQstCwLCDQt9CwINGC0YDQsNC90YHRhNC10YDQuCDQuCDQtNCw0LLQsNC90LUg0L/QvtGA0YrRh9C60Lgg0LIg0YDQsNC80LrQuNGC0LUg0L3QsCDQstGK0YLRgNC10YjQvdC40Y8g0L/QsNC30LDRgC5cIixcbiAgXCJNRU1PXCI6XCLQkdC10LvQtdC20LrQsFwiLFxuICBcIlBST0ZJTEVfOFwiOlwi0JrQu9GO0YfRitGCINC30LAg0LHQtdC70LXQttC60LAg0YHQtSDQuNC30L/QvtC70LfQstCwINC30LAg0YHRitC30LTQsNCy0LDQvdC1INC4INGH0LXRgtC10L3QtSDQvdCwINCx0LXQu9C10LbQutC4LlwiLFxuICBcIkJMT0dcIjpcItCR0LvQvtCzXCIsXG4gIFwiUE9TVFNcIjpcItCh0YLQsNGC0LjQuFwiLFxuICBcIlJFUExJRVNcIjpcItCe0YLQs9C+0LLQvtGA0LhcIixcbiAgXCJXQUxMRVRcIjpcItCf0L7RgNGC0YTQtdC50LtcIixcbiAgXCJUQUdcIjpcItCi0LDQs1wiLFxuICBcIlVTRVJcIjpcItCf0L7RgtGA0LXQsdC40YLQtdC7XCIsXG4gIFwiQ0xPU0VcIjpcItCX0LDRgtCy0LDRgNGP0L3QtVwiLFxuICBcIlRPXCI6XCLQl9CwXCIsXG4gIFwiQVNTRVRcIjpcItCQ0LrRgtC40LJcIixcbiAgXCJTRU5EXCI6XCLQn9GA0LDRgtC4XCIsXG4gIFwiU0VDVVJJVFlcIjpcItCh0LjQs9GD0YDQvdC+0YHRglwiLFxuICBcIkFWQUlMQUJMRVwiOlwi0J3QsNC70LjRh9C90L7RgdGCXCIsXG4gIFwiUFVCTElDX01FTU9cIjpcItCf0YPQsdC70LjRh9C90LAg0LHQtdC70LXQttC60LBcIixcbiAgXCJUT19ERVNDXCI6XCLQn9C+0YLRgNC10LHQuNGC0LXQuywg0L3QsNC/0YDQuNC80LXRgCBnb29kLWthcm1hXCIsXG4gIFwiUElOX0NPREVcIjpcItCf0LjQvS3QutC+0LRcIixcbiAgXCJQSU5fVEVYVFwiOlwi0J/QuNC9LdC60L7QtNGK0YIg0L7QsdC10LfQvtC/0LDRgdGP0LLQsCDQtNCw0L3QvdC40YLQtSDQstC4INCyINC/0YDQuNC70L7QttC10L3QuNC10YLQvi4gPGJyLz48YnIvPtCS0LXQtNC90YrQtiDQsNC60YLQuNCy0LjRgNCw0L0sINC40LzQsNGC0LUg0YHQsNC80L4gNCDQvtC/0LjRgtCwINC30LAg0LTQsCDQs9C+INC+0YLQutC70Y7Rh9C40YLQtSwg0LDQutC+INGB0YLQtSDQt9Cw0LHRgNCw0LLQuNC70Lgg0YHQstC+0YLRjyDQv9C40L0t0LrQvtC0INC40LvQuCDQvdC1INGB0YLQtSDQs9C+INCy0YrQstC10LvQuCDQv9GA0LDQstC40LvQvdC+LCDQsNC/0LvQuNC60LDRhtC40Y/RgtCwINGJ0LUg0L/RgNC10LzQsNGF0L3QtSDQtNCw0L3QvdC40YLQtSDQvdCwINC/0L7RgtGA0LXQsdC40YLQtdC70Y8g0L/RgNC4INCy0LvQuNC30LDQvdC1LiDQnNC+0LbQtdGC0LUg0L/QvtCy0YLQvtGA0L3QviDQtNCwINCy0LvQtdC30L3QtdGC0LUg0Lgg0L/RgNC+0LTRitC70LbQuNGC0LUg0LTQsCDQuNC30L/QvtC70LfQstCw0YLQtSDQv9GA0LjQu9C+0LbQtdC90LjQtdGC0L4uXCIsXG4gIFwiTk9USUZJQ0FUSU9OU1wiOlwi0JjQt9Cy0LXRgdGC0LjRj1wiLFxuICBcIlZPVEVfVEVYVFwiOlwi0KnQtSDQv9C+0LvRg9GH0LjRgtC1INC40LfQstC10YHRgtC40LUsINC60L7Qs9Cw0YLQviDQvdGP0LrQvtC5INCz0LvQsNGB0YPQstCwINC30LAg0LLQsNGI0LAg0YHRgtCw0YLQuNGPLiA8YnIvPtCj0LLQtdC00L7QvNC70LXQvdC40Y/RgtCwINCy0LrQu9GO0YfQstCw0YIg0KHQuNC70LAg0L3QsCDQs9C70LDRgSDQutCw0LrRgtC+INC4INC/0YDQtdC00YPQv9GA0LXQtNC40YLQtdC70L3QuCDRgdGK0L7QsdGJ0LXQvdC40Y8uXCIsXG4gIFwiVk9URVwiOlwi0JPQu9Cw0YFcIixcbiAgXCJDT01NRU5UX1RFWFRcIjpcItCp0LUg0L/QvtC70YPRh9C40YLQtSDQuNC30LLQtdGB0YLQuNC1LCDQutC+0LPQsNGC0L4g0L3Rj9C60L7QuSDQutC+0LzQtdC90YLQuNGA0LAg0LLQsNGI0LjRgtC1INC/0YPQsdC70LjQutCw0YbQuNC4INC40LvQuCDQutC+0LzQtdC90YLQsNGA0LghPGJyLz4g0JjQt9Cy0LXRgdGC0LjRj9GC0LAg0YHRitGJ0L4g0LLQutC70Y7Rh9Cy0LDRgiDQutC+0LPQsNGC0L4g0L3Rj9C60L7QuSDRgNC10LTQsNC60YLQuNGA0LAg0YHQstC+0LjRgtC1INC60L7QvNC10L3RgtCw0YDQuC5cIixcbiAgXCJDT01NRU5UXCI6XCLQmtC+0LzQtdC90YLQsNGAXCIsXG4gIFwiRk9MTE9XX1RFWFRcIjpcItCp0LUg0L/QvtC70YPRh9C40YLQtSDQuNC30LLQtdGB0YLQuNC1LCDQutC+0LPQsNGC0L4g0L3Rj9C60L7QuSDQstC4INGB0LvQtdC00Lgg0LjQu9C4INGJ0LUg0YHQv9GA0LUg0LTQsCDQstC4INGB0LvQtdC00LghXCIsXG4gIFwiTUVOVElPTlNcIjpcItCh0L/QvtC80LXQvdCw0LLQsNC90LjRj1wiLFxuICBcIk1FTlRJT05TX1RFWFRcIjpcItCp0LUg0L/QvtC70YPRh9C40YLQtSDQuNC30LLQtdGB0YLQuNC1LCDQutC+0LPQsNGC0L4g0L3Rj9C60L7QuSDQstC4INGB0L/QvtC80LXQvdC1INCyINGB0LLQvtGPINC/0YPQsdC70LjQutCw0YbQuNGPINC40LvQuCDQutC+0LzQtdC90YLQsNGAIVwiLFxuICBcIlJFU1RFRU1cIjpcItCh0L/QvtC00LXQu9GP0L3QtVwiLFxuICBcIlJFU1RFRU1fVEVYVFwiOlwi0KnQtSDQv9C+0LvRg9GH0LjRgtC1INC40LfQstC10YHRgtC40LUsINC60L7Qs9Cw0YLQviDQvdGP0LrQvtC5INGB0L/QvtC00LXQu9C4INCy0LDRiCDQv9C+0YHRgiFcIixcbiAgXCJDT05GSUdVUkFUSU9OU1wiOlwi0J3QsNGB0YLRgNC+0LnQutC4XCIsXG4gIFwiVk9USU5HXCI6XCLQk9C70LDRgdGD0LLQsNC90LVcIixcbiAgXCJWT1RJTkdfVEVYVFwiOlwi0JjQt9Cx0LXRgNC10YLQtSDQsiDQv9GA0L7RhtC10L3RgtC4INGB0LjQu9Cw0YLQsCDQvdCwINCz0LvQsNGB0LAg0LLQuC5cXG4gPGJyLz48YnIvPtCi0L7QstCwINGJ0LUg0L7Qv9GA0LXQtNC10LvQuCDRgNCw0LfQvNC10YDQsCDQstGK0LbQvdCw0LPRgNCw0LbQtNC10L3QuNGPICwg0LrQvtC40YLQviDQv9C+0LvRg9GH0LDQstCw0YIg0YHRgtCw0YLQuNC40YLQtSwg0LfQsCDQutC+0LjRgtC+INCz0LvQsNGB0YPQstCw0YLQtS5cIixcbiAgXCJTRVJWRVJcIjpcItCh0YrRgNCy0YrRgFwiLFxuICBcIlNFUlZFUl9URVhUXCI6XCLQn9GA0LXQv9C+0YDRitGH0LjRgtC10LvQvdC+XCIsXG4gIFwiU0FWRV9DSEFOR0VTXCI6XCLQl9Cw0L/QsNC30LhcIixcbiAgXCJWT1RFUlNfSU5GT1wiOlwi0JjQvdGE0L7RgNC80LDRhtC40Y8g0LfQsCDQs9C70LDRgdGD0LLQsNC70LjRgtC1XCIsXG4gIFwiV0VMQ09NRV9CQUNLXCI6XCLQl9C00YDQsNCy0LXQuSwg0L7RgtC90L7QstC+IVwiLFxuICBcIkxPR0lOXzFcIjpcItCS0LvQtdC30YLQtSDRgSDQv9C+0YLRgNC10LHQuNGC0LXQu9GB0LrQviDQuNC80LUg0Lgg0L/QsNGA0L7Qu9CwINC30LAg0LTQsCDQv9GA0L7QtNGK0LvQttC40YLQtS5cIixcbiAgXCJMT0dJTl8yXCI6XCLQmtC70Y7Rh9GK0YIg0LfQsCDQv9GD0LHQu9C40LrRg9Cy0LDQvdC1INGB0LUg0LjQt9C/0L7Qu9C30LLQsCDQt9CwINC/0YPQsdC70LjQutGD0LLQsNC90LUsINC60L7QvNC10L3RgtC40YDQsNC90LUsINCz0LvQsNGB0YPQstCw0L3QtSDQuCDRgdC70LXQtNC10L3QtS5cIixcbiAgXCJMT0dJTl8zXCI6XCLQkNC60YLQuNCy0L3QuNGP0YIg0LrQu9GO0Ycg0YHQtSDQuNC30L/QvtC70LfQstCwINC30LAg0YLRgNCw0L3RgdGE0LXRgNC4INC4INC+0LHQvdC+0LLQu9C10L3QuNC1INC90LAg0L/RgNC+0YTQuNC70L3QsCDRgdC90LjQvNC60LAuXCIsXG4gIFwiTE9HSU5fNFwiOlwi0J/QvtGC0YDQtdCx0LjRgtC10LvRgdC60Lgg0LjQtNC10L3RgtC40YTQuNC60LDRhtC40L7QvdC90Lgg0LTQsNC90L3QuCDRgdC1INGB0YrRhdGA0LDQvdGP0LLQsNGCINC70L7QutCw0LvQvdC+INC90LAg0YPRgdGC0YDQvtC50YHRgtCy0LDRgtCwINCy0LguINCf0YDQuCDQuNC30YXQvtC0INC/0YrQu9C90L7QvNC+0YnQuNGP0YLQsCDRgdC1INC+0YLRgdGC0YDQsNC90Y/QstCw0YIhXCIsXG4gIFwiRE9OVF9IQVZFXCI6XCLQndGP0LzQsNGC0LUg0L/RgNC+0YTQuNC7P1wiLFxuICBcIlNJR05fVVBfTk9XXCI6XCLQoNC10LPQuNGB0YLRgNC40YDQsNC50YLQtSDRgdC1INGB0LXQs9CwIVwiLFxuICBcIkNBTkNFTFwiOlwi0J7RgtC60LDQt1wiLFxuICBcIkFEVkFOQ0VEXCI6XCLQoNCw0LfRiNC40YDQtdC9INGA0LXQttC40LxcIixcbiAgXCJBQ1RJVkVfUFJJS0VZXCI6XCLQkNC60YLQuNCy0LXQvSDQu9C40YfQtdC9INC60LvRjtGHXCIsXG4gIFwiUE9TVElOR19QUklLRVlcIjpcItCb0LjRh9C10L0g0LrQu9GO0Ycg0LfQsCDQv9GD0LHQu9C40LrRg9Cy0LDQvdC1XCIsXG4gIFwiTUFTVEVSX1BBU1NcIjpcItCe0YHQvdC+0LLQvdCwINC/0LDRgNC+0LvQsFwiLFxuICBcIlVTRVJOQU1FXCI6XCLQn9C+0YLRgNC10LHQuNGC0LXQu9GB0LrQviDQuNC80LVcIixcbiAgXCJDQVJEX1ZJRVdcIjpcItCa0LDRgNGC0LjRh9C60LhcIixcbiAgXCJDT01QQUNUX1ZJRVdcIjpcItCh0L/QuNGB0YrRhtC4XCIsXG4gIFwiU0VBUkNIXCI6XCLQotGK0YDRgdC4XCIsXG4gIFwiU1VCTUlUX0FfU1RPUllcIjpcItCf0YPQsdC70LjQutGD0LLQsNC50YLQtSDQvdC10YnQvlwiLFxuICBcIlJFUExZVE9cIjpcItCe0YLQs9C+0LLQvtGAINC90LBcIixcbiAgXCJQT1NUXCI6XCLQn9GD0LHQu9C40LrRg9Cy0LDQvdC1XCIsXG4gIFwiUFJFVklFV1wiOlwi0J/RgNC10LPQu9C10LRcIixcbiAgXCJERUZBVUxUXCI6XCI1MCUgLyA1MCVcIixcbiAgXCJQT1dFUlVQXCI6XCLQl9Cw0YXRgNCw0L3QstCw0L3QtSAxMDAlXCIsXG4gIFwiREVDTElORV9QQVlPVVRcIjpcItCe0YLQutCw0Lcg0L3QsCDQstGK0LfQvdCw0LPRgNCw0LbQtNC10L3QuNC1XCIsXG4gIFwiU0FWRV9GT1JfTEFURVJcIjpcItCX0LDQv9Cw0LfQstCw0L3QtSDQt9CwINC/0L4t0LrRitGB0L3QvlwiLFxuICBcIkNMRUFSXCI6XCLQmNC30YfQuNGB0YLQstCw0L3QtVwiLFxuICBcIlBPU1RfQ09OVEVOVFwiOlwi0JrQvtC80LXQvdGC0LDRgFwiLFxuICBcIkNPTU1FTlRfQ09OVEVOVFwiOlwi0KHRitC00YrRgNC20LDQvdC40LUg0L3QsCDQutC+0LzQtdC90YLQsNGA0LBcIixcbiAgXCJUSVRMRVwiOlwi0JfQsNCz0LvQsNCy0LjQtVwiLFxuICBcIlRBR1NcIjpcItCi0LDQs9C+0LLQtVwiLFxuICBcIk5PVF9NQVRDSFwiOlwi0J3QtSDRgdGK0LLQv9Cw0LTQsFwiLFxuICBcIkNPTkZJUk1fUElOXCI6XCLQn9C+0YLQstGK0YDQtNC10YLQtSDQv9C40L0t0LrQvtC00LBcIixcbiAgXCJJTkNPUlJFQ1RcIjpcItCT0YDQtdGI0L3QvlwiLFxuICBcIk9QRU5JTkdfUE9TVFwiOlwi0J7RgtCy0LDRgNCw0L3QtSDQvdCwINGB0YLQsNGC0LjRjy5cIixcbiAgXCJTRVRfUElOXCI6XCLQl9Cw0LTQsNC50YLQtSDQv9C40L0t0LrQvtC0LlwiLFxuICBcIkVOVEVSX1BJTlwiOlwi0JLRitCy0LXQtNC10YLQtSDQv9C40L0t0LrQvtC0LlwiLFxuICBcIkFSRV9ZT1VfU1VSRVwiOlwi0KHQuNCz0YPRgNC90Lgg0LvQuCDRgdGC0LU/XCIsXG4gIFwiUkVCTE9HX1RFWFRcIjpcItCh0L/QvtC00LXQu9GP0L3QtdGC0L4g0LUg0L3QtdC+0LHRgNCw0YLQuNC80L4sINC40YHQutCw0YLQtSDQu9C4INC00LAg0L/RgNC+0LTRitC70LbQuNGC0LU/XCIsXG4gIFwiQlJPQURDQVNUX0VSUk9SXCI6XCLQk9GA0LXRiNC60LAg0L/RgNC4INGB0LLRitGA0LfQstCw0L3QtSwg0L7Qv9C40YLQsNC50YLQtSDQvtGC0L3QvtCy0L4hXCIsXG4gIFwiU1VDQ0VTU1wiOlwi0KPRgdC/0LXRhSFcIixcbiAgXCJSRUJMT0dHRURfUE9TVFwiOlwi0KHQv9C+0LTQtdC70LXQvdCwINC/0YPQsdC70LjQutCw0YbQuNGPIVwiLFxuICBcIkxPR0lOX0ZBSUxcIjpcItCd0LXRg9GB0L/QtdGI0L3QviDQstC70LjQt9Cw0L3QtSEg0JzQvtC70Y8sINGD0LLQtdGA0LXRgtC1INGB0LUsINGH0LUg0YHRgtC1INCy0LvQtdC30LvQuCDQsiDRgdC40YHRgtC10LzQsNGC0LAg0YEg0LPQu9Cw0LLQvdCw0YLQsCDQv9Cw0YDQvtC70LAg0LjQu9C4INGBINGH0LDRgdGC0LXQvSDQutC70Y7RhyDQt9CwINC/0YPQsdC70LjQutGD0LLQsNC90LUg0L/RgNC4INCy0LvQuNC30LDQvdC1LCDQsNC60L4g0YHRgtC1INC40LfQsdGA0LDQu9C4INCg0LDQt9GI0LjRgNC10L0g0YDQtdC20LjQvC5cIixcbiAgXCJMT0dJTl9GQUlMX0FcIjpcItCd0LXRg9GB0L/QtdGI0L3QviDQstC70LjQt9Cw0L3QtSEg0JzQvtC70Y8sINGD0LLQtdGA0LXRgtC1INGB0LUsINGH0LUg0YHRgtC1INCy0LvQtdC30LvQuCDQsiDRgdC40YHRgtC10LzQsNGC0LAg0YEg0LPQu9Cw0LLQvdCw0YLQsCDQv9Cw0YDQvtC70LAg0LjQu9C4INGBINCQ0LrRgtC40LLQvdC40Y8g0YfQsNGB0YLQtdC9INC60LvRjtGHINC/0YDQuCDQstC70LjQt9Cw0L3QtSwg0LDQutC+INGB0YLQtSDQuNC30LHRgNCw0LvQuCDQoNCw0LfRiNC40YDQtdC9INGA0LXQttC40LwuXCIsXG4gIFwiV0FSTklOR1wiOlwi0JLQvdC40LzQsNC90LjQtVwiLFxuICBcIlZPVEVfRk9SX1dJVE5FU1NcIjpcItCT0LvQsNGB0YPQstCw0L3QtSDQt9CwIHdpdG5lc3NcIixcbiAgXCJWT1RFRF9GT1JfV0lUTkVTU1wiOlwi0JPQu9Cw0YHRg9Cy0LDQvdC+INC30LAgd2l0bmVzc1wiLFxuICBcIkFHT1wiOlwiLVwiLFxuICBcIkZST01fTk9XXCI6XCLQvtGC0L/RgNC10LTQuFwiLFxuICBcIlNFQ1NcIjpcItGB0LXQulwiLFxuICBcIkFfTUlOXCI6XCLQvNC40L1cIixcbiAgXCJNSU5TXCI6XCLQvNC40L1cIixcbiAgXCJBTl9IT1VSXCI6XCLRh9Cw0YFcIixcbiAgXCJIT1VSU1wiOlwi0YfQsNGB0LBcIixcbiAgXCJBX0RBWVwiOlwi0LTQtdC9XCIsXG4gIFwiREFZU1wiOlwi0LTQvdC4XCIsXG4gIFwiQV9NT05USFwiOlwi0LzQtdGB0LXRhlwiLFxuICBcIk1PTlRIU1wiOlwi0LzQtdGB0LXRhtCwXCIsXG4gIFwiQV9ZRUFSXCI6XCLQs9C+0LTQuNC90LBcIixcbiAgXCJZRUFSU1wiOlwi0LPQvtC00LjQvdC4XCIsXG4gIFwiTUlOX1JFQURcIjpcIi3QvNC40L3Rg9GC0L3QviDRh9C10YLQtdC90LUuXCIsXG4gIFwiRE9XTlZPVEVfRkxBR1wiOlwi0J7RgtGA0LjRhtCw0YLQtdC70LXQvSDQs9C70LDRgSDQuNC70Lgg0YHQu9Cw0LPQsNC90LUg0L3QsCDRhNC70LDQsy5cIixcbiAgXCJDQVBUVVJFX1BJQ1RVUkVcIjpcItCh0L3QuNC80LrQsFwiLFxuICBcIlNFTEVDVF9QSUNUVVJFXCI6XCLQmNC30LHQtdGA0LXRgtC1INGB0L3QuNC80LrQsFwiLFxuICBcIlNFVF9DVVNUT01fVVJMXCI6XCLQl9Cw0LTQsNC50YLQtSBVUkxcIixcbiAgXCJJTlNFUlRfUElDVFVSRVwiOlwi0JTQvtCx0LDQstC10YLQtSDRgdC90LjQvNC60LBcIixcbiAgXCJFUlJPUlwiOlwi0JPRgNC10YjQutCwXCIsXG4gIFwiVVBMT0FEX0VSUk9SXCI6XCLQk9GA0LXRiNC60LAg0L/RgNC4INC60LDRh9Cy0LDQvdC1XCIsXG4gIFwiQ0FNRVJBX0NBTkNFTExFRFwiOlwi0J3Rj9C80LAg0LTQvtGB0YLRitC/INC00L4g0LrQsNC80LXRgNCw0YLQsC5cIixcbiAgXCJTRVRfVVJMXCI6XCLQodC70L7QttC10YLQtSBVUkxcIixcbiAgXCJESVJFQ1RfTElOS19QSUNUVVJFXCI6XCLQlNC40YDQtdC60YLQvdCwINCy0YDRitC30LrQsCDQutGK0Lwg0YHQvdC40LzQutCw0YLQsFwiLFxuICBcIkNPTU1FTlRfU1VCTUlUVEVEXCI6XCLQmtC+0LzQtdC90YLQsNGA0YrRgiDQtSDQv9GD0LHQu9C40LrRg9Cy0LDQvSFcIixcbiAgXCJERUxFVEVfQ09NTUVOVFwiOlwi0JjQt9GC0YDQuNCy0LDQvdC10YLQviDQvdCwINC60L7QvNC10L3RgtCw0YDQuCDQtSDQvdC10L7QsdGA0LDRgtC40LzQvlwiLFxuICBcIkRFTEVURURfQ09NTUVOVFwiOlwi0JjQt9GC0YDQuNGCINC60L7QvNC10L3RgtCw0YBcIixcbiAgXCJVUExPQURJTkdfUElDVFVSRVwiOlwi0JrQsNGH0LLQsNC90LUg0L3QsCDRgdC90LjQvNC60LBcIixcbiAgXCJVUExPQURfQ09NUExFVEVEXCI6XCLQmtCw0YfQstCw0L3QtdGC0L4g0L/RgNC40LrQu9GO0YfQuFwiLFxuICBcIlVQTE9BRF9GQUlMRURcIjpcItCT0YDQtdGI0LrQsCDQv9GA0Lgg0LrQsNGH0LLQsNC90LVcIixcbiAgXCJQQVNTV09SRF9JTkNPUlJFQ1RcIjpcItCf0LDRgNC+0LvQsNGC0LAg0LjQu9C4INC/0L7RgtGA0LXQsdC40YLQtdC70YHQutC+0YLQviDQuNC80LUg0YHQsCDQs9GA0LXRiNC90LhcIixcbiAgXCJJTkZPXCI6XCLQmNC90YTQvtGA0LzQsNGG0LjRj1wiLFxuICBcIlFSX1RFWFRcIjpcItCf0L7RgdGC0LDQstC10YLQtSDQvdCwIFFSINC60L7QtCDQsiDQv9C+0LvQtdGC0L4g0LfQsCDRgdC60LDQvdC40YDQsNC90LVcIixcbiAgXCJCQUxBTkNFX1RFWFRcIjpcItCj0LLQtdGA0LXRgtC1INGB0LUsINGH0LUg0LjQvNCw0YLQtSDQtNC+0YHRgtCw0YLRitGH0L3QsCDRgdGD0LzQsCDQt9CwINGC0YDQsNC90YHRhNC10YAhXCIsXG4gIFwiTk9ORVhJU1RfVVNFUlwiOlwi0J/QvtGC0YDQtdCx0LjRgtC10LvRj9GCINC60YrQvCwg0LrQvtCz0L7RgtC+INGB0LUg0L7Qv9C40YLQstCw0YLQtSDQtNCwINC/0YDQtdGF0LLRitGA0LvQuNGC0LUg0YHRg9C80LDRgtCwINC90LUg0YHRitGJ0LXRgdGC0LLRg9Cy0LAhXCIsXG4gIFwiVFJBTlNGRVJfVEVYVFwiOlwi0KHQuNCz0YPRgNC90Lgg0LvQuCDRgdGC0LUsINGH0LUg0LjRgdC60LDRgtC1INC00LAg0L/RgNC10LLQtdC00LXRgtC1INGB0YPQvNCw0YLQsD9cIixcbiAgXCJDT05GSVJNQVRJT05cIjpcItCf0L7RgtCy0YrRgNC20LTQsNCy0LDQvdC1XCIsXG4gIFwiVFhfQlJPQURDQVNURURcIjpcItCi0YDQsNC90LfQsNC60YbQuNGP0YLQsCDRgdC1INC40LfQu9GK0YfQstCwLi4uXCIsXG4gIFwiRkVFRFwiOlwi0J/QvtGC0L7QulwiLFxuICBcIlRSRU5ESU5HXCI6XCLQotC10L3QtNC10L3RhtC40LhcIixcbiAgXCJIT1RcIjpcItCT0L7RgNC10YnQuFwiLFxuICBcIk5FV1wiOlwi0J3QvtCy0LhcIixcbiAgXCJQUk9NT1RFRFwiOlwi0J/RgNC+0LzQvtGC0LjRgNCw0L3QuFwiLFxuICBcIlZPVEVTXCI6XCLQk9C70LDRgdC+0LLQtVwiLFxuICBcIlBBWU9VVFwiOlwi0JjQt9C/0LvQsNGJ0LDQvdC1XCIsXG4gIFwiQ09NTUVOVFNcIjpcItCa0L7QvNC10L3RgtCw0YDQuFwiLFxuICBcIlRSRU5ESU5HXzMwXCI6XCLQotC10L3QtNC10L3RhtC40Lgg0LfQsCDQv9C+0YHQu9C10LTQvdC40YLQtSAzMCDQtNC90LhcIixcbiAgXCJTT1JUX1BPU1RfQllcIjpcItCh0L7RgNGC0LjRgNCw0L3QtSDQv9C+OlwiLFxuICBcIlBBWU9VVF9DWUNMRVwiOlwi0KbQuNC60YrQuyDQvdCwINC40LfQv9C70LDRidCw0L3QtVwiLFxuICBcIlBPVEVOVElBTF9QQVlPVVRcIjpcItCf0L7RgtC10L3RhtC40LDQu9C90L4g0LjQt9C/0LvQsNGJ0LDQvdC1XCIsXG4gIFwiUEFTVF9QQVlPVVRcIjpcItCf0L7RgdC70LXQtNC90L4g0LjQt9C/0LvQsNGJ0LDQvdC1XCIsXG4gIFwiQVVUSE9SX1BBWU9VVFwiOlwi0JDQstGC0L7RgNGB0LrQviDQstGK0LfQvdCw0LPRgNCw0LbQtNC10L3QuNC1XCIsXG4gIFwiQ1VSQVRJT05fUEFZT1VUXCI6XCLQktGK0LfQvdCw0LPRgNCw0LbQtNC10L3QuNGPINC+0YIg0LrRg9GA0LDRgtC+0YDRgdGC0LLQvlwiLFxuICBcIlBPU1RfU1VCTUlUVEVEXCI6XCLQodGC0LDRgtC40Y/RgtCwINC1INC/0YPQsdC70LjQutGD0LLQsNC90LBcIixcbiAgXCJQT1NUX0xBVEVSXCI6XCLQn9GD0LHQu9C40LrRg9Cy0LDQudGC0LUg0L/Qvi3QutGK0YHQvdC+IVwiLFxuICBcIlNBVkVEXCI6XCLQl9Cw0L/QsNC30LXQvdC+XCIsXG4gIFwiQ0xFQVJFRFwiOlwi0JjQt9GH0LjRgdGC0LXQvdC+XCIsXG4gIFwiRkxBR0dJTkdfVEVYVFwiOlwi0KHQu9Cw0LPQsNC90LXRgtC+INC90LAg0YTQu9Cw0LMg0LzQvtC20LUg0LTQsCDQvdCw0LzQsNC70Lgg0L3QsNCz0YDQsNC00LjRgtC1INC4INC00LAg0YHQstCw0LvQuCDRgdGC0LDRgtC40Y/RgtCwINC+0YIg0L/RgNC10LTQvdC40YLQtSDRgNC10LTQuNGG0LguPGJyPjxicj7QpNC70LDQs9GK0YIg0LHQuNCy0LAg0LTQsCDRgdC1INC/0L7Qu9C30LLQsCDQv9GA0Lgg0LjQt9C80LDQvNC4INC40LvQuCDQv9C70LDQs9GP0YLRgdGC0LLQviwg0L7QvNGA0LDQt9C90LAg0YDQtdGHLCDQuNC90YLQtdGA0L3QtdGCINGC0YDQvtC70LgsINGD0LzQuNGI0LvQtdC90L4g0L3QtdC/0YDQsNCy0LjQu9C90L4g0LrQsNGC0LXQs9C+0YDQuNC30LjRgNCw0L3QviDRgdGK0LTRitGA0LbQsNC90LjQtSDQuCDRgdC/0LDQvC5cIixcbiAgXCJSRVFVRVNUX0xJTUlUX1RFWFRcIjpcItCb0LjQvNC40YIg0LfQsCDQt9Cw0Y/QstC60LAg0LUg0LTQvtGB0YLQuNCz0L3QsNGCLiDQoNCw0LfQs9C70LXQtNCw0LnRgtC1INC00YDRg9Cz0Lgg0YLQtdC90LTQtdC90YbQuNC4L9GC0LDQs9C+0LLQtSFcIixcbiAgXCJQT1NUX0lTX1VOQk9PS01BUktcIjpcItCh0YLQsNGC0LjRj9GC0LAg0LUg0L/RgNC10LzQsNGF0L3QsNGC0LAg0L7RgiDQu9GO0LHQuNC80LghXCIsXG4gIFwiUE9TVF9JU19CT09LTUFSS1wiOlwi0KHRgtCw0YLQuNGP0YLQsCDQtSDQtNC+0LHQsNCy0LXQvdCwINCyINCb0Y7QsdC40LzQuCFcIixcbiAgXCJSRVNFVFwiOlwi0JjQt9GH0LjRgdGC0LLQsNC90LVcIixcbiAgXCJNT0RJRllfUElDVFVSRVwiOlwi0J/RgNC+0LzRj9C90LAg0L3QsCDQv9GA0L7RhNC40LvQvdCwINGB0L3QuNC80LrQsFwiLFxuICBcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6XCLQn9GA0L7QvNGP0L3QsCDQvdCwINGI0LDQsdC70L7QvdC90LDRgtCwINGB0L3QuNC80LrQsFwiLFxuICBcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOlwi0JzQvtC70Y8sINC/0YDQtdC00YHRgtCw0LLQtdGC0LUg0JDQutGC0LjQstC10L0g0YfQsNGB0YLQtdC9INC60LvRjtGHLCDQsNC60L4g0YHRgtC1INC40LfQsdGA0LDQu9C4INCg0LDQt9GI0LjRgNC10L0g0YDQtdC20LjQvCDQt9CwINCy0YXQvtC0IVwiLFxuICBcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOlwi0KLQvtCy0LAg0YnQtSDQv9GA0LXQvNCw0YXQvdC1INC/0YDQvtGE0LjQu9C90LDRgtCwINGB0L3QuNC60LzQutCwXCIsXG4gIFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6XCLQotC+0LLQsCDRidC1INC/0YDQtdC80LDRhdC90LUg0YjQsNCx0LvQvtC90L3QsNGC0LAg0YHQvdC40LrQvNC60LBcIixcbiAgXCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOlwi0J3Rg9C20LXQvSDQtSDRgNC10YHRgtCw0YDRgiDQvdCwINGB0YrRgNCy0YrRgNCwIVwiLFxuICBcIlNFVFRJTkdTX1VQREFURURcIjpcItCd0LDRgdGC0YDQvtC50LrQuNGC0LUg0YHQsCDQvtCx0L3QvtCy0LXQvdC4IVwiLFxuICBcIkxBTkdVQUdFU1wiOlwi0JXQt9C40LpcIixcbiAgXCJMQU5HVUFHRVNfVEVYVFwiOlwi0J7RgiDRgtGD0Log0YHQtSDRgdC80LXQvdGP0YIg0LXQt9C40YbQuNGC0LUg0L3QsCDQsNC/0LvQuNC60LDRhtC40Y/RgtCwLlwiLFxuICBcIkxPR0lOX1RPX1hcIjpcItCi0LDQt9C4INC+0L/QtdGA0LDRhtC40Y8g0LjQt9C40YHQutCy0LAg0L/QvtGC0YDQtdCx0LjRgtC10LvRjyDQtNCwINCy0LvQtdC30LXRgtC1INCyINC/0YDQvtGE0LjQu9CwINGBINC+0YHQvdC+0LLQvdCwINC/0LDRgNC+0LvQsCwg0YEg0LDQutGC0LjQstC10L0v0L/Rg9Cx0LvQuNC60YPQstCw0L3QtSDQutC70Y7Rhy4g0JzQvtC70Y8sINCy0LvQtdC30YLQtSDQuCDQvtC/0LjRgtCw0LnRgtC1INC+0YLQvdC+0LLQvi5cIixcbiAgXCJHQUxMRVJZXCI6XCLQk9Cw0LvQtdGA0LjRj1wiLFxuICBcIlRSQU5TTEFUSU9OU1wiOlwi0J/RgNC10LLQvtC00LDRh9C4XCIsXG4gIFwiU0hBUkVcIjpcItCh0L/QvtC00LXQu9C4XCIsXG4gIFwiTUFSS0VUUExBQ0VcIjpcItCR0L7RgNGB0LBcIixcbiAgXCJFWENIQU5HRVwiOlwi0J7QsdC80Y/QvdCwXCIsXG4gIFwiRFJBRlRTXCI6XCLQp9C10YDQvdC+0LLQuFwiLFxuICBcIlBPU1RfSVNfVU5EUkFGVFwiOlwi0KHRgtCw0YLQuNGP0YLQsCDQtSDQv9GA0LXQvNCw0YXQvdCw0YLQsCDQvtGCINGH0LXRgNC90L7QstC40YLQtSFcIixcbiAgXCJQT1NUX0lTX0RSQUZUXCI6XCLQodGC0LDRgtC40Y/RgtCwINC1INC00L7QsdCw0LLQtdC90LAg0LIg0YfQtdGA0L3QvtCy0LjRgtC1IVwiLFxuICBcIlNXSVBFX0xFRlRcIjpcItCf0YrQu9C30L3QtdGC0LUg0L3QsNC70Y/QstC+INC30LAg0L7Qv9GG0LjQuFwiLFxuICBcIk1BTkFHRVwiOlwi0KPQv9GA0LDQstC70LXQvdC40LVcIixcbiAgXCJJTUFHRV9SRU1PVkVEXCI6XCLQodC90LjQvNC60LDRgtCwINC1INC/0YDQtdC80LDRhdC90LDRgtCwXCIsXG4gIFwiQ09QWVwiOlwi0JrQvtC/0LjRgNCw0L3QtVwiLFxuICBcIk5PX0lNQUdFXCI6XCLQktGB0LUg0L7RidC1INC90LUg0YHRgtC1INC60LDRh9C40LvQuCDRgdC90LjQvNC60LAhXCIsXG4gIFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjpcItCf0LvRitC30L3QtdGC0LUg0L3QsNC00L7Qu9GDINC30LAg0L7Qv9GA0LXRgdC90Y/QstCw0L3QtVwiLFxuICBcIkVYVEVSTkFMX0FQUFNcIjpcItCS0YrQvdGI0L3QuCDQsNC/0LvQuNC60LDRhtC40LhcIixcbiAgXCJQTFVHSU5TXCI6XCLQlNC+0LHQsNCy0LrQuFwiLFxuICBcIlNVR0dFU1RcIjpcItCf0YDQtdC00LvQvtC20LXRgtC1XFxuXCIsXG4gIFwiQ09NSU5HX1NPT05cIjpcItCe0YfQsNC60LLQsNC50YLQtSDRgdC60L7RgNC+XCIsXG4gIFwiQ0hBSU5cIjpcItCR0LvQvtC60YfQtdC50L1cIixcbiAgXCJDSEFJTl9URVhUXCI6XCLQntGCINGC0YPQuiDRgdC1INC40LfQsdC40YDQsCDQsdC70L7QutGH0LXQudC9INC40LvQuCDQsdCw0LfQvtCy0LDRgtCwINC/0LvQsNGC0YTQvtGA0LzQsC5cIixcbiAgXCJDVVJSRU5DWVwiOlwi0JLQsNC70YPRgmFcIixcbiAgXCJDVVJSRU5DWV9URVhUXCI6XCLQotGD0Log0LzQvtC20LXRgtC1INC00LAg0L/RgNC+0LzQtdC90LjRgtC1INCy0LDQu9GD0YLQsNGC0LAg0LIg0LrQvtGP0YLQviDQuNGB0LrQsNGC0LUg0LTQsCDQstC40LbQtNCw0YLQtSDQstGK0LfQvdCw0LPRgNCw0LbQtNC10L3QuNGP0YLQsC5cIixcbiAgXCJBQk9VVF8xMVwiOlwiPGJyPjxiPtCk0YPQvdC60YbQuNC4INCyIGVTdGVlbTwvYj48YnI+LdCU0L7RgdGC0YrQvyDQtNC+INGD0L3QuNC60LDQu9C90Lgg0YHRgtCw0YLQuNC4INC90LAg0LLRgdGP0LrQsNC60LLQuCDRgtC10LzQuCwg0LrQvtC40YLQviDQstC4INC40L3RgtC10YDQtdGB0YPQstCw0YIuIDxicj4t0JDQstGC0L7RgtC40YLQtSDQv9C+0LvRg9GH0LDQstCw0YIg0LLRitC30L3QsNCz0YDQsNC20LXQvdC40Y8g0LHQu9Cw0LPQvtC00LDRgNC10L3QuNC1INC90LAg0LPQu9Cw0YHQvtCy0LXRgtC1INC+0YIg0LrRg9GA0LDRgtC+0YDQuNGC0LUsINC60L7QuNGC0L4g0YHRitGJ0L4g0L/QvtC70YPRh9Cw0LLQsNGCINC00Y/QuyDQvtGCINC/0LXRh9Cw0LvQsdC40YLQtS48YnI+LdCf0LXRh9C10LvQuNGC0LUg0L7RgiDQs9C70LDRgdC+0LLQtdGC0LUsINC60L7QuNGC0L4g0L/QvtC70YPRh9Cw0LLQsNGCINCy0LDRiNC40YLQtSDRgdGC0LDRgtC40LgsINC60LDQutGC0L4g0Lgg0L7RgiDQutGD0YDQsNGC0L7RgNGB0YLQstC+LiDQlNCw0LLQsNC50LrQuCDRgdCy0L7RjyDQs9C70LDRgSDQvdCwINC00YDRg9Cz0Lgg0LDQstGC0L7RgNC4INGB0YrRidC+INC/0LXRh9C10LvQuNGC0LUg0LLRitC30L3QsNCz0YDQsNC20LTQtdC90LjQtS48YnI+LdCf0YPQsdC70LjQutGD0LLQsNC50YLQtSDQstCw0YjQuNGC0LUg0YHRgtCw0YLQuNC4INC4INCz0Lgg0YHRitGF0YDQsNC90Y/QstCw0LnRgtC1INCx0LXQt9C/0LvQsNGC0L1vLiDQn9C10YfQtdC70LXRgtC1INCy0YrQt9C90LDQs9GA0LDQttC00LXQvdC40Y8g0L7RgiDQstCw0YjQuNGPINCx0LvQvtCzLjxicj4t0J/QuNGI0LXRgtC1INGB0YLQsNGC0LjQuSDQsiDQtNCy0LjQttC10L3QuNC1LiDQmNC80LDRgtC1INC+0L/RhtC40Y8g0LfQsCDQt9Cw0L/QsNC30LLQsNC90LUg0L3QsCDQvdGP0LrQvtC70LrQviDRh9C10YDQvdC+0LLQuCDQt9CwINC/0L4t0LrRitGB0L3QviDQv9GD0LHQu9C40LrRg9Cy0LDQvdC1Ljxicj4t0JfQsNC/0LDQt9C10YLQtSDRgdGC0LDRgtC40Lgg0LIgXFxcItCb0Y7QsdC40LzQuFxcXCIsINC30LAg0LTQsCDQs9C4INC/0YDQvtGH0LXRgtC10YLQtSDQv9C+LdC60YrRgdC90L4uPGJyPi3QkdC+0YDRgdCwINC4INGC0LXQs9C70LXQvdC1INC90LAg0L/RgNC40YXQvtC00LguPGJyPi3QmNC30L/RgNCw0YnQsNC90LUg0L3QsCDRgdGA0LXQtNGB0YLQstCwINC60YrQvCDQutC+0LPQvtGC0L4g0Lgg0LTQsCDQtSDQsNCy0YLQvtGALCDQv9C+0YLRgNC10LHQuNGC0LXQuywg0L/RgNC40Y/RgtC10LssINC/0L7RgdC70LXRhNC+0LLQsNGC0LXQuyDQuCDRgtC9Ljxicj4t0KHQu9C10LTQstCw0LnRgtC1INC40L3RgtC10YDQtdGB0L3QuCDQsdC70L7Qs9GK0YDQuC48YnI+LdCd0LDQvNC10YDQtdGC0LUg0LLQsNGI0LjRgtC1INC/0L7RgdC70LXQtNC+0LLQsNGC0LXQu9C4INC4INGF0L7RgNCwLCDQutC+0LjRgtC+INGB0LvQtdC00LjRgtC1Ljxicj4t0J/QvtC70YPRh9Cw0LLQsNC90LUg0L3QsCDQuNC30LLQsNGB0YLQuNGPLiDQn9C+0LTRitGA0LbQsNC50YLQtSDQstGA0YrQt9C60LAg0YHRitGBINGB0LLQvtC40YLQtSDQv9C+0YHQu9C10LTQvtCy0LDRgtC10LvQuCwg0YHQu9C10LTQtdGC0LUg0LTQuNGB0LrRg9GB0YLQuNC4LCDQsiDQutC+0LjRgtC+INGD0YfQsNGB0YLQstCw0YLQtS48YnI+LdCi0YrRgNGB0LXQvdC1INC90LAg0LjQvdGC0LXRgNC10YHQvdC4INGC0LDQs9C+0LLQtS/QutCw0YLQtdCz0L7RgNC40Lgg0Lgg0LDQstGC0L7RgNC4LiA8YnI+IC3Qn9C10YDRgdC+0L3QsNC70LjQt9C40YDQsNC90LUg0L3QsCDQstCw0YjQuNGPINC/0YDQvtGE0LjQuy4gPGJyPtCc0L3QvtCz0L4g0YTRg9C90LrRhtC40Lgg0YnQtSDQsdGK0LTQsNGCINC00L7QsdCw0LLQtdC90LguIDxicj48YnI+PGI+0KHQuNCz0YPRgNC90L7RgdGCPC9iPiA8YnI+MS4g0JDQv9C70LjQutCw0YbQuNGP0YLQsCDQvdGP0LzQsCDQtNC40YDQtdC60YLQtdC9INC00L7RgdGC0YrQvyDQutGK0Lwg0LLQsNGI0LjRgtC1INGB0YDQtdC00YHRgtCy0LAuIDxicj4yLiDQkNC/0LvQuNC60LDRhtC40Y/RgtCwINC/0YDQtdC00LvQsNCz0LAg0LzQvtC00LXQuyDQt9CwINGB0LjQs9GD0YDQvdC+0YHRgiDQvtGCINGB0YLRgNCw0L3QsCDQvdCwINC/0L7RgtGA0LXQsdC40YLQtdC70Y8uINCn0LDRgdGC0L3QuNGC0LUg0LrQu9GO0YfQvtCy0LUg0YHQtSDRgdGK0YXRgNCw0L3Rj9Cy0LDRgiDQu9C+0LrQsNC70L3QviDQuCDQvdC40LrQvtCz0LAg0L3QtSDRgdC1INC40LfQv9GA0LDRidCw0YIg0LrRitC8INGB0YrRgNCy0YrRgNC4LiDQktC40LUg0YHRgtC1INC+0YLQs9C+0LLQvtGA0L3QuCDQt9CwINC30LDQv9Cw0LfQstCw0L3QtdGC0L4g0Lgg0YHRitGF0YDQsNC90LDQvdC40LXRgtC+INC90LAg0LLQsNGI0LjRgtC1INC/0LDRgNC+0LvQuC4gPGJyPjMuINCQ0L/Qu9C40LrQsNGG0LjRj9GC0LAg0L/RgNC10LTQu9Cw0LPQsCDQvtC/0YDQvtGB0YLQtdC9INC4INC/0YDQuNCy0LvQtdC60LDRgtC10LvQtdC9INC/0L7RgtGA0LXQsdC40YLQtdC70YHQutC4INC40L3RgtC10YDRhNC10LnRgS4gPGJyPjQuINCQ0L/Qu9C40LrQsNGG0LjRj9GC0LAg0L/RgNC10LTQu9Cw0LPQsCDQtNC+0L/RitC70L3QuNGC0LXQu9C90L4g0L3QuNCy0L4g0L3QsCDRgdC40LPRg9GA0L3QvtGB0YIg0YEg0L/QuNC9LdC60L7QtCA8YnI+PGJyPmVTdGVlbSDQv9C+0LTRitGA0LbQsCDQv9C70LDRgtGE0L7RgNC80LjRgtC1IFN0ZWVtINC4IEdvbG9zLjxicj5cIixcbiAgXCJGT1VOREVSXCI6XCLQntGB0L3QvtCy0LDRgtC10Lsg0Lgg0LPQu9Cw0LLQtdC9INC/0YDQvtCz0YDQsNC80LjRgdGCXCIsXG4gIFwiQUREX0FDQ09VTlRcIjpcItCU0L7QsdCw0LLRj9C90LUg0L3QsCDQtNC+0L/RitC70L3QuNGC0LXQu9C10L0g0L/RgNC+0YTQuNC7XCIsXG4gIFwiUExBVEZPUk1cIjpcItCf0LvQsNGC0YTQvtGA0LzQsFwiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIkhPTUVcIjpcIkRvbcWvXCIsXG4gIFwiTE9HSU5cIjpcIlDFmWlobMOhxaFlbsOtXCIsXG4gIFwiTE9HT1VUXCI6XCJPZGhsw6HFoWVuw61cIixcbiAgXCJQUk9GSUxFXCI6XCJQcm9maWxcIixcbiAgXCJGT0xMT1dcIjpcIk7DoXNsZWR1alwiLFxuICBcIkJPT0tNQVJLU1wiOlwiWsOhbG/Fvmt5XCIsXG4gIFwiVFJBTlNGRVJcIjpcIlDFmWV2b2RcIixcbiAgXCJNQVJLRVRcIjpcIlRyaFwiLFxuICBcIlNFVFRJTkdTXCI6XCJOYXN0YXZlbsOtXCIsXG4gIFwiQUJPVVRcIjpcIk8gbsOhc1wiLFxuICBcIkFCT1VUXzFcIjpcImtkZSBrZG9rb2xpdiBtxa/FvmUgesOtc2thdCBvZG3Em251IHphIHN2xa9qIG9ic2FoIVwiLFxuICBcIkFCT1VUXzJcIjpcImplIHBvc3RhdmVuIG5hIHt7cGxhdGZvcm1uYW1lfX0gcGxhdGZvcm3Emy4gQXBsaWthY2kgdnl0dm/FmWlsXCIsXG4gIFwiQUJPVVRfM1wiOlwiYSBqZSB0byBrb211bml0bsOtLCBvcGVuLXNvdXJjZSBtb2JpbG7DrSBwcm9qZWt0LiBOYWLDrXrDrSBwxZnDrXN0dXAgayBvYnNhaHUgcHJvIMSNdGVuw60sIGtvbWVudG92w6Fuw60sIGhsYXNvdsOhbsOtLCB2eXN0YXZvdsOhbsOtIHDFmcOtc3DEm3Zrxa8sIHDFmWV2b2QgdsO9ZMSbbGvFryBhdGQuIHBvc2t5dG92YW7DqSB7e3BsYXRmb3JtbmFtZX19IGJsb2NrY2hhaW5lbSBhIHt7c2l0ZW5hbWV9fS5cIixcbiAgXCJBQk9VVF80XCI6XCIxLiBBcGxpa2FjZSBuZW3DoSBwxZnDrXN0dXAgayB1xb5pdmF0ZWxvdsO9bSBmb25kxa9tIGFuaSBqZSBuaWtkeSBuZXZsYXN0bsOtLlwiLFxuICBcIkFCT1VUXzVcIjpcIjIuIEFwbGlrYWNlIG5hYsOtesOtIGJlenBlxI1ub3N0bsOtIG1vZGVsIG5hIHN0cmFuxJsga2xpZW50YS4gUHJpdsOhdG7DrSBrbMOtxI1lIGpzb3UgZHLFvmVueSBsb2vDoWxuxJsgYSBuaWtkeSBuZWpzb3UgcG9zw61sw6FueSDFvsOhZG7DvW0gc2VydmVyxa9tLlwiLFxuICBcIkFCT1VUXzZcIjpcIjMuIEFwbGlrYWNlIG5hYsOtesOtIGplZG5vZHVjaMOhLCBhdHJha3Rpdm7DrSB1xb5pdmF0ZWxza8OhIHJvemhyYW7DrSBhIHrDocW+aXRreS5cIixcbiAgXCJBQk9VVF83XCI6XCI0LiBBcGxpa2FjZSBwbyB1xb5pdmF0ZWzDrWNoIG5pa2R5IG5lcG/FvmFkdWplIMW+w6FkbsOpIG9zb2Juw60gaW5mb3JtYWNlLlwiLFxuICBcIkFCT1VUXzhcIjpcIkhsYXN1anRlIHBybyBzdsSbZGthIGdvb2Qta2FybWFcIixcbiAgXCJBQk9VVF85XCI6XCJLb250YWt0L1pwxJt0bsOhIHZhemJhOlwiLFxuICBcIkFCT1VUXzEwXCI6XCJWw61jZSBpbmZvcm1hY8OtOlwiLFxuICBcIlJFTU9WRVwiOlwiT2RzdHJhbml0XCIsXG4gIFwiTUFSS0VUX1ZJRVdcIjpcIlpvYnJhemVuw60gdHJodVwiLFxuICBcIlBSSUNFXCI6XCJDZW5hXCIsXG4gIFwiQU1PVU5UXCI6XCJTdW1hXCIsXG4gIFwiVE9UQUxcIjpcIkNlbGtlbVwiLFxuICBcIk5PT1JERVJTXCI6XCLFvcOhZG7DqSBvdGV2xZllbsOpIG9iamVkbsOhdmt5IHByb1wiLFxuICBcIkRBVEVcIjpcIkRhdHVtXCIsXG4gIFwiQlVZXCI6XCJOw6FrdXBcIixcbiAgXCJTRUxMXCI6XCJQcm9kZWpcIixcbiAgXCJPUEVOXCI6XCJPdGV2xZllbm9cIixcbiAgXCJISVNUT1JZXCI6XCJIaXN0b3JpZVwiLFxuICBcIkZPTExPV19CQUNLXCI6XCJTbGVkb3ZhdFwiLFxuICBcIkZPTExPV0VEXCI6XCJTbGVkb3bDoW5cIixcbiAgXCJVTkZPTExPV1wiOlwiUMWZZXN0YXQgc2xlZG92YXRcIixcbiAgXCJGT0xMT1dJTkdcIjpcIlNsZWRvdmFuw61cIixcbiAgXCJGT0xMT1dFUlNcIjpcIlNsZWR1asOtY8OtXCIsXG4gIFwiU0VBUkNIX0ZPTExPV0VSU1wiOlwiSGxlZGVqIHNsZWR1asOtY8OtXCIsXG4gIFwiU0VBUkNIX0ZPTExPV0lOR1wiOlwiSGxlZGVqIHNsZWRvdmFuw6lcIixcbiAgXCJCWVwiOlwia8O9bVwiLFxuICBcIklOXCI6XCJ2XCIsXG4gIFwiTUVOVVwiOlwiXCIsXG4gIFwiQk9PS01BUktcIjpcIlrDoWxvxb5rYVwiLFxuICBcIlJFQkxPR1wiOlwiXCIsXG4gIFwiVVBWT1RFXCI6XCJIbGFzdWp0ZSBwcm9cIixcbiAgXCJET1dOVk9URVwiOlwiSGxhc3VqdGUgcHJvdGlcIixcbiAgXCJVTlZPVEVfRE9XTlZPVEVEXCI6XCJWcmHFpXRlIGhsYXMgcHJvdGlcIixcbiAgXCJVTlZPVEVfVVBWT1RFRFwiOlwiVnJhxaV0ZSBobGFzIHByb1wiLFxuICBcIlJFUExZXCI6XCJPZHBvdsSbenRlXCIsXG4gIFwiRURJVFwiOlwiVXByYXZ0ZVwiLFxuICBcIlBPU1RfMVwiOlwiUHJvIHpvYnJhemVuw60gdm9sZWIgcMWZZWplxI8gdmxldm8gbmEga29tZW50w6HFmWVcIixcbiAgXCJQT1NUXzJcIjpcIlBybyB6b2JyYXplbsOtIHN1YmtvbWVudMOhxZnFryBrbGVwbsSbdGUgbmEga29tZW50w6HFmWVcIixcbiAgXCJPUFRJT05TXCI6XCJWb2xieVwiLFxuICBcIlJFU1RFRU1FRF9CWVwiOlwiUmVzdGVlbW92w6FubyBrw71tXCIsXG4gIFwiTk9USElOR19IRVJFXCI6XCJQxZlpcHJhdnVqZSBzZVwiLFxuICBcIkJBTEFOQ0VTXCI6XCJaxa9zdGF0a3lcIixcbiAgXCJQUk9GSUxFXzFcIjpcInt7cGxhdGZvcm1uYW1lfX0sIG9iY2hvZG92YXRlbG7DqSB0b2tlbnksIGt0ZXLDqSBtb2hvdSBiw710IGtkeWtvbGl2IHDFmWV2ZWRlbnkuIHt7cGxhdGZvcm1uYW1lfX0gbW9ob3UgYsO9dCBwxZlldmVkZW55IG5hIHt7cGxhdGZvcm1wb3dlcn19IHYgcHJvY2VzdSB6dmFuw6ltIHBvd2VyaW5nIHVwLlwiLFxuICBcIlBST0ZJTEVfMlwiOlwie3twbGF0Zm9ybXBvd2VyfX0sIHZsaXZvdsOpIHRva2VueSwga3RlcsOpIHBvc2lsdWrDrSBwxZlpIGRsb3Vob2RvYsOpbSBkcsW+ZW7DrSBhIGhsYXNvdsOhbsOtIG8gcMWZw61zcMSbdmPDrWNoLiDEjMOtbSB2w61jZSBqaWNoIG7Em2tkbyBkcsW+w60sIHTDrW0gdsOtY2UgbcWvxb5lIG92bGl2bml0IG9kbcSbbnkgZHJ1aMO9Y2ggYSBzw6FtIHrDrXNrYXQgb2RtxJtudSB6YSBzcHLDoXZuw6kgaGxhc292w6Fuw60uXCIsXG4gIFwiUFJPRklMRV8zXCI6XCJUb2tlbnkgdiBjZW7EmyBva29sbyB7e3BsYXRmb3Jtc3VuaXR9fSB2IHt7cGxhdGZvcm1uYW1lfX0uXCIsXG4gIFwiRVNUSU1BVEVEX1ZBTFVFXCI6XCJPxI1la8OhdmFuw6EgY2VuYVwiLFxuICBcIlBST0ZJTEVfNFwiOlwiT8SNZWvDoXZhbsOhIGNlbmEgamUgemFsb8W+ZW5hIG5hIDcgZGVubsOtIHByxa9txJtybsOpIGNlbsSbIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG4gIFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOlwiSGlzdG9yaWUgdHJhbnNha2PDrVwiLFxuICBcIlBPU1RJTkdcIjpcIk9kZXPDrWzDoW7DrVwiLFxuICBcIlBST0ZJTEVfNVwiOlwiT2Rlc8OtbGFjw60ga2zDrcSNIGplIHBvdcW+w612w6FuIHBybyBvZGVzw61sw6Fuw60gcMWZw61zcMSbdmvFryBhIGhsYXNvdsOhbsOtLiBNxJtsIGJ5IGLDvXQgcm96ZMOtbG7DvSBvZCBha3Rpdm7DrWhvIGEgdmxhc3RuaWNrw6lobyBrbMOtxI1lLlwiLFxuICBcIk9XTkVSXCI6XCJWbGFzdG7DrWtcIixcbiAgXCJQUk9GSUxFXzZcIjpcIlZsYXN0bmlja8O9IGtsw63EjSBqZSBobGF2bsOtIGtsw63EjSDDusSNdHUgYSBqZSBwb8W+YWRvdsOhbiBwcm8gem3Em251IG9zdGF0bsOtY2ggw7rEjXTFry4gUHJpdsOhdG7DrSBrbMOtxI0gbmVibyBoZXNsbyBwcm8gdmxhc3RuaWNrw70ga2zDrcSNIGJ5IG3Em2x5IGLDvXQgZHLFvmVueSBwb2t1ZCBtb8W+bm8gY28gbmVqdsOtY2Ugb2ZmbGluZS5cIixcbiAgXCJBQ1RJVkVcIjpcIkFrdGl2bsOtXCIsXG4gIFwiUFJPRklMRV83XCI6XCJBa3Rpdm7DrSBrbMOtxI0gc2UgcG91xb7DrXbDoSBwcm8gcMWZZXZvZHkgYSB6YWTDoW7DrSBvYmplZG7DoXZlayBuYSB2bml0xZluw61tIHRyaHUuXCIsXG4gIFwiTUVNT1wiOlwiUG96bsOhbWthXCIsXG4gIFwiUFJPRklMRV84XCI6XCJQb3puw6Fta292w70ga2zDrcSNIHNlIHBvdcW+w612w6EgcHJvIHR2b3JidSBhIMSNdGVuw60gcG96bsOhbWVrLlwiLFxuICBcIkJMT0dcIjpcIlwiLFxuICBcIlBPU1RTXCI6XCJQxZnDrXNwxJt2a3lcIixcbiAgXCJSRVBMSUVTXCI6XCJPZHBvdsSbZGlcIixcbiAgXCJXQUxMRVRcIjpcIlBlbsSbxb5lbmthXCIsXG4gIFwiVEFHXCI6XCLFoHTDrXRla1wiLFxuICBcIlVTRVJcIjpcIlXFvml2YXRlbFwiLFxuICBcIkNMT1NFXCI6XCJaYXbFmcOtdFwiLFxuICBcIlRPXCI6XCJkb1wiLFxuICBcIkFTU0VUXCI6XCJBa3RpdnVtXCIsXG4gIFwiU0VORFwiOlwiUG9zbGF0XCIsXG4gIFwiU0VDVVJJVFlcIjpcIlphYmV6cGXEjWVuw61cIixcbiAgXCJBVkFJTEFCTEVcIjpcIkRvc3R1cG7DvVwiLFxuICBcIlBVQkxJQ19NRU1PXCI6XCJWZcWZZWpuw6EgcG96bsOhbWthXCIsXG4gIFwiVE9fREVTQ1wiOlwiVcW+aXZhdGVsIG5hcMWZLiBnb29kLWthcm1hXCIsXG4gIFwiUElOX0NPREVcIjpcIlBpbiBrw7NkXCIsXG4gIFwiUElOX1RFWFRcIjpcIlBJTiBrw7NkIHBvbcOhaMOhIHphYmV6cGXEjWl0IGFwbGlrYWNpIGEgZGF0YS4gPGJyLz48YnIvPjxiPlBvem7DoW1rYTo8L2I+IEpha21pbGUgamUgYWt0aXZuw60sIG3DoXRlIG1heGltw6FsbsSbIDQgcG9rdXN5IG5hIG9kZW3EjWVuw60uIFBva3VkIHBpbiB6YXBvbWVuZXRlIG5lYm8gbmV1c3DEm2pldGUsIGFwbGlrYWNlIG9kc3RyYW7DrSB1xb5pdmF0ZWxza8OhIGRhdGEgdG9ob3RvIHDFmWlobMOhxaFlbsOtLiBNxa/FvmV0ZSBzZSBvcMSbdCBwxZlpaGzDoXNpdCBhIHBva3JhxI1vdmF0IHYgcHLDoWNpLlwiLFxuICBcIk5PVElGSUNBVElPTlNcIjpcIk96bsOhbWVuw61cIixcbiAgXCJWT1RFX1RFWFRcIjpcIlBva3VkIG7Em2tkbyBobGFzdWplIHBybyBWw6HFoSBwxZnDrXNwxJt2ZWssIG9iZHLFvsOtdGUgdXBvem9ybsSbbsOtISA8YnIvPiA8Yj5Qb3puw6Fta2E6PC9iPiBUYXRvIG96bsOhbWVuw60gb2JzYWh1asOtIHbDoWh1IGhsYXN1IChhxaUgdcW+IGplIHRvIGhsYXMgcHJvLCBwcm90aSwgbmVibyBvZHZvbMOhbsOtIGhsYXNvdsOhbsOtKS5cIixcbiAgXCJWT1RFXCI6XCJIbGFzdWp0ZVwiLFxuICBcIkNPTU1FTlRfVEVYVFwiOlwiUG9rdWQgbsSba2RvIGtvbWVudHVqZSBWw6HFoSBwxZnDrXNwxJt2ZWsgbmVibyBrb21lbnTDocWZLCBvYmRyxb7DrXRlIG96bsOhbWVuw60hIDxici8+IDxiPlBvem7DoW1rYTo8L2I+IFVwb3pvcm7Em27DrSBqZSB6YXNsw6FubyB0w6nFviBwb2t1ZCBuxJtrZG8gPGI+ZWRpdHVqZTwvYj4gc3bFr2oga29tZW50w6HFmS5cIixcbiAgXCJDT01NRU5UXCI6XCJQb3puw6Fta2FcIixcbiAgXCJGT0xMT1dfVEVYVFwiOlwiT2JkcsW+w610ZSB1cG96b3JuxJtuw60ga2R5xb4gdsOhcyBuxJtrZG8gemHEjW5lIHNsZWRvdmF0LCBuZWJvIHNsZWRvdsOhbsOtIHpydcWhw60hXCIsXG4gIFwiTUVOVElPTlNcIjpcIlptw61ua3lcIixcbiAgXCJNRU5USU9OU19URVhUXCI6XCJQb2t1ZCB2w6FzIG7Em2tkbyB6bcOtbsOtIHYgcMWZw61zcMSbdmt1L2tvbWVudMOhxZlpLCBvYmRyxb7DrXRlIHVwb3pvcm7Em27DrSFcIixcbiAgXCJSRVNURUVNXCI6XCJcIixcbiAgXCJSRVNURUVNX1RFWFRcIjpcIlBva3VkIG7Em2tkbyByZXN0ZWVtdWplIHbDocWhIHDFmcOtc3DEm3ZlaywgZG9zdGFuZXRlIG96bsOhbWVuw60uXCIsXG4gIFwiQ09ORklHVVJBVElPTlNcIjpcIktvbmZpZ3VyYWNlXCIsXG4gIFwiVk9USU5HXCI6XCJIbGFzb3bDoW7DrVwiLFxuICBcIlZPVElOR19URVhUXCI6XCJWw6FoYSBobGFzdSBuZWJvIHByb2NlbnRvIG92bGl2xYh1amUgaGxhc292YWPDrSBzw61sdSBhcGxpa2FjZSwgdGFrxb5lIG3Fr8W+ZXRlIHJlZ3Vsb3ZhdCB2w73FoWkgb2RtxJtueSB2YcWhZWhvIGhsYXNvdsOhbsOtLiA8YnIvPjxici8+PGI+UG96bsOhbWthOjwvYj4gVG8gb3ZsaXZuw60gdsOhaHUgaGxhc3UvcHJvY2VudG8gaSBwxZlpIGhsYXNvdsOhbsOtIHByb3RpIGEgamUgdG8gcGxhdG7DqSB2IGNlbMOpIGFwbGlrYWNpLlwiLFxuICBcIlNFUlZFUlwiOlwiXCIsXG4gIFwiU0VSVkVSX1RFWFRcIjpcIkRvcG9ydcSNZW7DqVwiLFxuICBcIlNBVkVfQ0hBTkdFU1wiOlwiVWxvxb5pdCB6bcSbbnlcIixcbiAgXCJWT1RFUlNfSU5GT1wiOlwiSW5mb3JtYWNlIG8gdm9sacSNaVwiLFxuICBcIldFTENPTUVfQkFDS1wiOlwiVsOtdGVqdGUgenDEm3QhXCIsXG4gIFwiTE9HSU5fMVwiOlwiUHJvIHBva3JhxI1vdsOhbsOtIHNlIHDFmWlobGHFoXRlIHN2w71tIHXFvml2YXRlbHNrw71tIGptw6luZW0gYSBoZXNsZW0uXCIsXG4gIFwiTE9HSU5fMlwiOlwiT2Rlc8OtbGFjw60ga2zDrcSNIGplIHVyxI1lbiBwcm8gdnlzdGF2b3ZhbsOtIHDFmcOtc3DEm3Zrxa8sIGtvbWVudMOhxZllLCBobGFzb3bDoW7DrSwgc2xlZG92w6Fuw60uXCIsXG4gIFwiTE9HSU5fM1wiOlwiQWt0aXZuw60ga2zDrcSNIGplIHVyxI1lbiBwcm8gcMWZZXZvZHkgYSBha3R1YWxpemFjaSBwcm9maWxvdsOpaG8gb2Jyw6F6a3UuXCIsXG4gIFwiTE9HSU5fNFwiOlwiVcW+aXZhdGVsb3Z5IHDFmWlobGHFoW92YWPDrSDDumRhamUganNvdSBkcsW+ZW55IGxva8OhbG7EmyB2IHDFmcOtc3Ryb2ppLiBQbyBvZGhsw6HFoWVuw60ganNvdSBvZHN0cmFuxJtueSFcIixcbiAgXCJET05UX0hBVkVcIjpcIk5lbcOhdGUgw7rEjWV0P1wiLFxuICBcIlNJR05fVVBfTk9XXCI6XCJaxZlpxI90ZSBzaSDDusSNZXRcIixcbiAgXCJDQU5DRUxcIjpcIlpydcWhaXRcIixcbiAgXCJBRFZBTkNFRFwiOlwiUG9rcm/EjWlsw71cIixcbiAgXCJBQ1RJVkVfUFJJS0VZXCI6XCJBa3Rpdm7DrSBzb3Vrcm9tw70ga2zDrcSNXCIsXG4gIFwiUE9TVElOR19QUklLRVlcIjpcIk9kZXPDrWxhY8OtIHNvdWtyb23DvSBrbMOtxI1cIixcbiAgXCJNQVNURVJfUEFTU1wiOlwiSGxhdm7DrSBoZXNsb1wiLFxuICBcIlVTRVJOQU1FXCI6XCJVxb5pdmF0ZWxza8OpIGptw6lub1wiLFxuICBcIkNBUkRfVklFV1wiOlwiWm9icmF6ZW7DrSBrYXJ0YVwiLFxuICBcIkNPTVBBQ1RfVklFV1wiOlwiWm9icmF6ZW7DrSBrb21wYWt0XCIsXG4gIFwiU0VBUkNIXCI6XCJIbGVkYXRcIixcbiAgXCJTVUJNSVRfQV9TVE9SWVwiOlwiVmxvxb4gxI1sw6FuZWtcIixcbiAgXCJSRVBMWVRPXCI6XCJPZHBvdsSbenRlXCIsXG4gIFwiUE9TVFwiOlwiT2Rlc2xhdFwiLFxuICBcIlBSRVZJRVdcIjpcIk7DoWhsZWRcIixcbiAgXCJERUZBVUxUXCI6XCJOYXN0YXZlbsOtIDUwJSAvIDUwJVwiLFxuICBcIlBPV0VSVVBcIjpcIjEwMCUgU3RlZW0gUG93ZXJcIixcbiAgXCJERUNMSU5FX1BBWU9VVFwiOlwiT2Rtw610bm91IHbDvXBsYXR1XCIsXG4gIFwiU0FWRV9GT1JfTEFURVJcIjpcIlVzY2hvdmF0IG5hIHBvemTEm2ppXCIsXG4gIFwiQ0xFQVJcIjpcIlZ5xI1pc3RpdFwiLFxuICBcIlBPU1RfQ09OVEVOVFwiOlwiT2Rlc2xhdCBvYnNhaFwiLFxuICBcIkNPTU1FTlRfQ09OVEVOVFwiOlwiS29tZW50b3ZhdCBvYnNhaFwiLFxuICBcIlRJVExFXCI6XCJOYWRwaXNcIixcbiAgXCJUQUdTXCI6XCLFoHTDrXRreVwiLFxuICBcIk5PVF9NQVRDSFwiOlwiTmVzaG9kdWplIHNlXCIsXG4gIFwiQ09ORklSTV9QSU5cIjpcIlBvdHZyxI90ZSBQSU5cIixcbiAgXCJJTkNPUlJFQ1RcIjpcIk5lc3Byw6F2bsO9XCIsXG4gIFwiT1BFTklOR19QT1NUXCI6XCLDunZvZG7DrSBwxZnDrXNwxJt2ZWtcIixcbiAgXCJTRVRfUElOXCI6XCJOYXN0YXZ0ZSBQSU5cIixcbiAgXCJFTlRFUl9QSU5cIjpcIlZsb8W+dGUgUElOXCIsXG4gIFwiQVJFX1lPVV9TVVJFXCI6XCJVcsSNaXTEmz9cIixcbiAgXCJSRUJMT0dfVEVYVFwiOlwiUmVzdGVlbSBqZSBuZXZyYXRuw70sIHDFmWVqZXRlIHNpIHBva3JhxI1vdmF0P1wiLFxuICBcIkJST0FEQ0FTVF9FUlJPUlwiOlwiQ2h5YmEgb2Rlc2zDoW7DrSwgemt1c3RlIHpub3Z1IVwiLFxuICBcIlNVQ0NFU1NcIjpcIsOac3DEm2NoXCIsXG4gIFwiUkVCTE9HR0VEX1BPU1RcIjpcIlJlYmxvZ292YW7DvSBwxZnDrXNwxJt2ZWshXCIsXG4gIFwiTE9HSU5fRkFJTFwiOlwiUMWZaWhsw6HFoWVuw60gc2VsaGFsbyEgVWppc3TEm3RlIHNlLCDFvmUganN0ZSBzZSBwxZlpaGzDoXNpbGkgaGxhdm7DrW0gaGVzbGVtLCBuZWJvIMW+ZSBqc3RlIHDFmWkgcMWZaWhsw6HFoWVuw60gemFkYWxpIE9kZXPDrWxhY8OtIGtsw63EjSwgcG9rdWQganN0ZSB6dm9saWxpIFBva3JvxI1pbMO9IHJlxb5pbS5cIixcbiAgXCJMT0dJTl9GQUlMX0FcIjpcIlDFmWlobMOhxaFlbsOtIHNlbGhhbG8hIFVqaXN0xJt0ZSBzZSwgxb5lIGpzdGUgc2UgcMWZaWhsw6FzaWxpIGhsYXZuw61tIGhlc2xlbSwgbmVibyDFvmUganN0ZSBwxZlpIHDFmWlobMOhxaFlbsOtIHphZGFsaSBBa3Rpdm7DrSBrbMOtxI0sIHBva3VkIGpzdGUgenZvbGlsaSBQb2tyb8SNaWzDvSByZcW+aW0uXCIsXG4gIFwiV0FSTklOR1wiOlwiVsO9c3RyYWhhXCIsXG4gIFwiVk9URV9GT1JfV0lUTkVTU1wiOlwiSGxhc292w6Fuw60gbyBzdsSbZGPDrWNoXCIsXG4gIFwiVk9URURfRk9SX1dJVE5FU1NcIjpcIkhsYXNvdmFsIHBybyBzdsSbZGthXCIsXG4gIFwiQUdPXCI6XCJwxZllZFwiLFxuICBcIkZST01fTk9XXCI6XCJvZCB0ZcSPXCIsXG4gIFwiU0VDU1wiOlwidnRlxZlpbnlcIixcbiAgXCJBX01JTlwiOlwibWludXRhXCIsXG4gIFwiTUlOU1wiOlwibWludXR5XCIsXG4gIFwiQU5fSE9VUlwiOlwiaG9kaW5hXCIsXG4gIFwiSE9VUlNcIjpcImhvZGlueVwiLFxuICBcIkFfREFZXCI6XCJkZW5cIixcbiAgXCJEQVlTXCI6XCJkbnlcIixcbiAgXCJBX01PTlRIXCI6XCJtxJtzw61jXCIsXG4gIFwiTU9OVEhTXCI6XCJtxJtzw61jZVwiLFxuICBcIkFfWUVBUlwiOlwicm9rXCIsXG4gIFwiWUVBUlNcIjpcInJva3lcIixcbiAgXCJNSU5fUkVBRFwiOlwiXCIsXG4gIFwiRE9XTlZPVEVfRkxBR1wiOlwiSGxhc3VqdGUgcHJvdGkgbmVibyBvem5hxI10ZSBqYWtvIHrDoXZhZG7DqVwiLFxuICBcIkNBUFRVUkVfUElDVFVSRVwiOlwiWmFjaHnFpXRlIG9icsOhemVrXCIsXG4gIFwiU0VMRUNUX1BJQ1RVUkVcIjpcIlZ5YmVydGUgb2Jyw6F6ZWtcIixcbiAgXCJTRVRfQ1VTVE9NX1VSTFwiOlwiTmFzdGF2dGUgesOha2F6bmlja8OpIFVSTFwiLFxuICBcIklOU0VSVF9QSUNUVVJFXCI6XCJWbG/FvnRlIG9icsOhemVrXCIsXG4gIFwiRVJST1JcIjpcIkNoeWJhXCIsXG4gIFwiVVBMT0FEX0VSUk9SXCI6XCJOYWhyYWp0ZSBjaHlidVwiLFxuICBcIkNBTUVSQV9DQU5DRUxMRURcIjpcIkZvdG9hcGFyw6F0IHpydcWhZW5cIixcbiAgXCJTRVRfVVJMXCI6XCJOYXN0YXZ0ZSBVUkxcIixcbiAgXCJESVJFQ1RfTElOS19QSUNUVVJFXCI6XCJQxZnDrW3DvSBvZGtheiBuYSBvYnLDoXpla1wiLFxuICBcIkNPTU1FTlRfU1VCTUlUVEVEXCI6XCJLb21lbnTDocWZIHZsb8W+ZW4hXCIsXG4gIFwiREVMRVRFX0NPTU1FTlRcIjpcIk1hesOhbsOtIGtvbWVudMOhxZllIGplIG5ldnJhdG7DqS4uLlwiLFxuICBcIkRFTEVURURfQ09NTUVOVFwiOlwiT2RzdHJhbsSbbsO9IGtvbWVudMOhxZlcIixcbiAgXCJVUExPQURJTkdfUElDVFVSRVwiOlwiTmFocsOhdsOhbsOtIG9icsOhemt1XCIsXG4gIFwiVVBMT0FEX0NPTVBMRVRFRFwiOlwiTmFocsOhdsOhbsOtIGhvdG92b1wiLFxuICBcIlVQTE9BRF9GQUlMRURcIjpcIk5haHLDoXbDoW7DrSBzZWxoYWxvXCIsXG4gIFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6XCJIZXNsbyBuZWJvIGptw6lubyDDusSNdHUgYnlsbyBuZXNwcsOhdm7DqVwiLFxuICBcIklORk9cIjpcIlwiLFxuICBcIlFSX1RFWFRcIjpcIlFSIGvDs2QgdW3DrXN0xJt0ZSBkbyBvYmxhc3RpIHBybyBza2VuXCIsXG4gIFwiQkFMQU5DRV9URVhUXCI6XCJVamlzdMSbdGUgc2UsIMW+ZSBtw6F0ZSBkb3N0YXRlxI1uw70gesWvc3RhdGVrIHBybyB0cmFuc2FrY2khXCIsXG4gIFwiTk9ORVhJU1RfVVNFUlwiOlwiVcW+aXZhdGVsLCBrdGVyw6ltdSBzZSBzbmHFvsOtdGUgcMWZZXbDqXN0IGZvbmR5IG5lZXhpc3R1amUhXCIsXG4gIFwiVFJBTlNGRVJfVEVYVFwiOlwiSnN0ZSBzaSBqaXN0aSwgxb5lIHNpIHDFmWVqZXRlIHByb3bDqXN0IHDFmWV2b2Q/XCIsXG4gIFwiQ09ORklSTUFUSU9OXCI6XCJQb3R2cnplbsOtXCIsXG4gIFwiVFhfQlJPQURDQVNURURcIjpcIlRyYW5zYWtjZSBqZSBvZGVzw61sw6FuYVwiLFxuICBcIkZFRURcIjpcIlpkcm9qXCIsXG4gIFwiVFJFTkRJTkdcIjpcIlYgdHJlbmR1XCIsXG4gIFwiSE9UXCI6XCLFvWhhdsOpXCIsXG4gIFwiTkVXXCI6XCJOb3bDqVwiLFxuICBcIlBST01PVEVEXCI6XCJQcm9wYWdvdmFuw6lcIixcbiAgXCJWT1RFU1wiOlwiSGxhc3lcIixcbiAgXCJQQVlPVVRcIjpcIlbDvXBsYXRhXCIsXG4gIFwiQ09NTUVOVFNcIjpcIktvbWVudMOhxZllXCIsXG4gIFwiVFJFTkRJTkdfMzBcIjpcIlYgdHJlbmR1IHBvIDMwIGRuw61cIixcbiAgXCJTT1JUX1BPU1RfQllcIjpcIlJvenTFmcOtZGl0IHDFmcOtc3DEm3ZreSBkbGVcIixcbiAgXCJQQVlPVVRfQ1lDTEVcIjpcIkN5a2x1cyB2w71wbGF0eVwiLFxuICBcIlBPVEVOVElBTF9QQVlPVVRcIjpcIlBvdGVuY2nDoWxuw60gdsO9cGxhdGFcIixcbiAgXCJQQVNUX1BBWU9VVFwiOlwiTWludWzDoSB2w71wbGF0YVwiLFxuICBcIkFVVEhPUl9QQVlPVVRcIjpcIkF1dG9yc2vDoSBvZG3Em25hXCIsXG4gIFwiQ1VSQVRJT05fUEFZT1VUXCI6XCJLdXLDoXRvcnNrw6Egb2RtxJtuYVwiLFxuICBcIlBPU1RfU1VCTUlUVEVEXCI6XCLEjGzDoW5layBqZSBvZGVzbMOhbiFcIixcbiAgXCJQT1NUX0xBVEVSXCI6XCJVc2Nob3ZhdCBwcm8gcG96ZMSbasWhw60gb2Rlc2zDoW7DrSFcIixcbiAgXCJTQVZFRFwiOlwiVWxvxb5lbsO9XCIsXG4gIFwiQ0xFQVJFRFwiOlwiVnnEjWnFoXTEm25vXCIsXG4gIFwiRkxBR0dJTkdfVEVYVFwiOlwiT3puYcSNZW7DrSBwxZnDrXNwxJt2a3UgemEgesOhdmFkbsO9IG3Fr8W+ZSBvZGVicmF0IG9kbcSbbnkgYSB1xI1pbml0IHRlbnRvIG1hdGVyacOhbCBtw6luxJsgdmlkaXRlbG7DvW0uPGJyPjxicj5Ub3RvIG96bmHEjWVuw60gYnkgbcSbbG8gYsO9dCBwb3XFvml0byBuYSBuw6FzbGVkdWrDrWPDrTogPHVsPjxsaT5wb2R2b2QgbmVibyBwbGFnacOhdG9yc3R2w608L2xpPjxsaT5wcm9qZXZ5IG5lbsOhdmlzdGkgbmVibyBpbnRlcm5ldG92w6kgdHJvbG92w6Fuw608L2xpPjxsaT56w6FtxJtybsSbIGNoeWJuw6Ega2F0ZWdvcml6YWNlIG9ic2FodSBuZWJvIHNwYW08L2xpPjwvdWw+XCIsXG4gIFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6XCJMaW1pdCBwb8W+YWRhdmvFryBkb3Nhxb5lbi4gWmtvbnRyb2x1anRlIG9zdGF0bsOtIHRyZW5keS/FoXTDrXRreSFcIixcbiAgXCJQT1NUX0lTX1VOQk9PS01BUktcIjpcIlDFmcOtc3DEm3ZlayBqZSBvZHN0cmFuxJtuIHplIHrDoWxvxb5layFcIixcbiAgXCJQT1NUX0lTX0JPT0tNQVJLXCI6XCJQxZnDrXNwxJt2ZWsgamUgcMWZaWTDoW4gZG8gesOhbG/FvmVrIVwiLFxuICBcIlJFU0VUXCI6XCJSZXNldG92YXRcIixcbiAgXCJNT0RJRllfUElDVFVSRVwiOlwiVXByYXZpdCBwcm9maWxvdsO9IG9icsOhemVrXCIsXG4gIFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjpcIlVwcmF2aXQgdGl0dWxuw60gb2Jyw6F6ZWtcIixcbiAgXCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjpcIlphZGVqdGUgQWt0aXZuw60gc291a3JvbcO9IGtsw63EjSwgcG9rdWQganN0ZSB2eWJyYWxpIHBva3JvxI1pbMO9IG3Ds2QgcMWZw61zdHVwdSFcIixcbiAgXCJSRVNFVF9QSUNUVVJFX1RFWFRcIjpcIlTDrW10byByZXNldHVqZXRlIHByb2ZpbG92w70gb2Jyw6F6ZWsgdcW+aXZhdGVsZSFcIixcbiAgXCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjpcIlTDrW10byByZXNldHVqZXRlIHRpdHVsbsOtIG9icsOhemVrIHXFvml2YXRlbGUhXCIsXG4gIFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjpcIkFrdHVhbGl6YWNlIHNlcnZlcnUgdnnFvmFkdWplIHJlc3RhcnQhXCIsXG4gIFwiU0VUVElOR1NfVVBEQVRFRFwiOlwiTmFzdGF2ZW7DrSBqc291IGFrdHVhbGl6b3bDoW5hLlwiLFxuICBcIkxBTkdVQUdFU1wiOlwiSmF6eWt5XCIsXG4gIFwiTEFOR1VBR0VTX1RFWFRcIjpcIlpkZSBtxa/FvmV0ZSB6bcSbbml0IGphenlrIGFwbGlrYWNlLlwiLFxuICBcIkxPR0lOX1RPX1hcIjpcIlRhdG8gb3BlcmFjZSB2ecW+YWR1amUgcMWZaWhsw6HFoWVuw60gdcW+aXZhdGVsZSBobGF2bsOtbSBoZXNsZW0sIEFrdGl2bsOtbS9PZGVzw61sYWPDrW0ga2zDrcSNZW0uIFByb3PDrW0gcMWZaWhsYcWhdGUgc2UgYSBvcGFrdWp0ZSBwb2t1cy5cIixcbiAgXCJHQUxMRVJZXCI6XCJHYWxlcmllXCIsXG4gIFwiVFJBTlNMQVRJT05TXCI6XCJQxZllbG/FvmlsaVwiLFxuICBcIlNIQVJFXCI6XCJBa2NpZVwiLFxuICBcIk1BUktFVFBMQUNFXCI6XCJUcmhcIixcbiAgXCJFWENIQU5HRVwiOlwiQnVyemFcIixcbiAgXCJEUkFGVFNcIjpcIktvbmNlcHR5XCIsXG4gIFwiUE9TVF9JU19VTkRSQUZUXCI6XCJQxZnDrXNwxJt2ZWsgamUgeiBrb25jZXB0xa8gb2RzdHJhbsSbbiAhXCIsXG4gIFwiUE9TVF9JU19EUkFGVFwiOlwiUMWZw61zcMSbdmVrIGplIHDFmWlkw6FuIGRvIGtvbmNlcHTFryFcIixcbiAgXCJTV0lQRV9MRUZUXCI6XCJQcm8gem9icmF6ZW7DrSBtb8W+bm9zdMOtIHDFmWVqZcSPIHZsZXZvXCIsXG4gIFwiTUFOQUdFXCI6XCJTcHJhdm92YXRcIixcbiAgXCJJTUFHRV9SRU1PVkVEXCI6XCJPYnJheiBqZSBvZHN0cmFuxJtuXCIsXG4gIFwiQ09QWVwiOlwiS29ww61yb3ZhdFwiLFxuICBcIk5PX0lNQUdFXCI6XCJEb3N1ZCBqc3RlIG5lbmFocsOhbCDFvsOhZG7DvSBvYnJhei5cIixcbiAgXCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOlwiUHJvIG9ibm92ZW7DrSB6YXTDoWhuaSBkb2zFr1wiLFxuICBcIkVYVEVSTkFMX0FQUFNcIjpcIkV4dGVybsOtIGFwbGlrYWNlXCIsXG4gIFwiUExVR0lOU1wiOlwiUMWZw61kYXZuw6kgbW9kdWx5XCIsXG4gIFwiU1VHR0VTVFwiOlwiTsOhdnJoXCIsXG4gIFwiQ09NSU5HX1NPT05cIjpcIkppxb4gYnJ6eSBjaHlzdMOhbWVcIixcbiAgXCJDSEFJTlwiOlwiXCIsXG4gIFwiQ0hBSU5fVEVYVFwiOlwiXCIsXG4gIFwiQ1VSUkVOQ1lcIjpcIlwiLFxuICBcIkNVUlJFTkNZX1RFWFRcIjpcIlwiLFxuICBcIkFCT1VUXzExXCI6XCJcIixcbiAgXCJGT1VOREVSXCI6XCJcIixcbiAgXCJBRERfQUNDT1VOVFwiOlwiXCIsXG4gIFwiUExBVEZPUk1cIjpcIlwiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIkhPTUVcIjpcIlN0YXJ0c2VpdGVcIixcbiAgXCJMT0dJTlwiOlwiQW5tZWxkZW5cIixcbiAgXCJMT0dPVVRcIjpcIkFibWVsZGVuXCIsXG4gIFwiUFJPRklMRVwiOlwiUHJvZmlsXCIsXG4gIFwiRk9MTE9XXCI6XCJGb2xnZW5cIixcbiAgXCJCT09LTUFSS1NcIjpcIkxlc2V6ZWljaGVuXCIsXG4gIFwiVFJBTlNGRVJcIjpcIsOcYmVydHJhZ2VuXCIsXG4gIFwiTUFSS0VUXCI6XCJNYXJrdFwiLFxuICBcIlNFVFRJTkdTXCI6XCJFaW5zdGVsbHVuZ2VuXCIsXG4gIFwiQUJPVVRcIjpcIkluZm9cIixcbiAgXCJBQk9VVF8xXCI6XCJkaWUgUGxhdHRmb3JtLCBiZWkgZGVyIGplZGVyIGbDvHIgc2VpbmUgSW5oYWx0ZSB2ZXJnw7x0ZXQgd2lyZCFcIixcbiAgXCJBQk9VVF8yXCI6XCJ3aXJkIHVudGVyc3TDvHR6dCBkdXJjaCBkaWUge3twbGF0Zm9ybW5hbWV9fSBQbGF0dGZvcm0uIEFud2VuZHVuZyBlcnN0ZWxsdCB2b25cIixcbiAgXCJBQk9VVF8zXCI6XCJ1bmQgaXN0IGVpbmUgbW9iaWxlIE9wZW4gU291cmNlIEFud2VuZHVuZywgZGllIGR1cmNoIGRpZSBDb21tdW5pdHkgdW50ZXJzdMO8dHp0IHdpcmQuIERpZSBBbndlbmR1bmcgZXJsYXVidCBkZW4gWnVncmlmZiBhdWYgZGllIEluaGFsdGUgZsO8ciBkYXMgTGVzZW4sIEtvbW1lbnRpZXJlbiwgQWJzdGltbWVuLCBQb3N0ZW4sIMOcYmVydHJhZ2VuIHZvbiBFaW5rw7xuZnRlbiBldGMuIERpZSBGdW5rdGlvbmVuIHdlcmRlbiBkdXJjaCBkaWUge3twbGF0Zm9ybW5hbWV9fSBCbG9ja2NoYWluIHVuZCB7e3NpdGVuYW1lfX0gYmVyZWl0Z2VzdGVsbHQuXCIsXG4gIFwiQUJPVVRfNFwiOlwiMS4gRGllIEFud2VuZHVuZyBncmVpZnQgbmllbWFscyBhdWYgSWhyZSBNaXR0ZWwgenUuXCIsXG4gIFwiQUJPVVRfNVwiOlwiMi4gRGllIEFud2VuZHVuZyBudXR6dCBlaW4gQ2xpZW50LWJhc2llcnRlcyBTaWNoZXJoZWl0c2tvbnplcHQsIGRhc3MgYXVmIFNjaGzDvHNzZWxuIGJhc2llcnQsIGRpZSBsb2thbCB2b3JoYW5kZW4gc2luZCB1bmQgbmllbWFscyBhbiBlaW5lbiBTZXJ2ZXIgw7xiZXJ0cmFnZW4gd2VyZGVuLlwiLFxuICBcIkFCT1VUXzZcIjpcIjMuIERpZSBBbndlbmR1bmcgYmlldGV0IGVpbiBzaW1wbGVzLCBhdHRyYWt0aXZlcyBJbnRlcmZhY2UuXCIsXG4gIFwiQUJPVVRfN1wiOlwiNC4gRGllIEFud2VuZHVuZyBmcmFndCBuaWVtYWxzIG5hY2ggcGVyc8O2bmxpY2hlbiBEYXRlbi5cIixcbiAgXCJBQk9VVF84XCI6XCJHb29kLUthcm1hIGFscyBaZXVnZSBhYnN0aW1tZW5cIixcbiAgXCJBQk9VVF85XCI6XCJLb250YWt0L0ZlZWRiYWNrOlwiLFxuICBcIkFCT1VUXzEwXCI6XCJXZWl0ZXJlIEluZm9ybWF0aW9uZW46XCIsXG4gIFwiUkVNT1ZFXCI6XCJFbnRmZXJuZW5cIixcbiAgXCJNQVJLRVRfVklFV1wiOlwiTWFya3RhbnNpY2h0XCIsXG4gIFwiUFJJQ0VcIjpcIlByZWlzXCIsXG4gIFwiQU1PVU5UXCI6XCJNZW5nZVwiLFxuICBcIlRPVEFMXCI6XCJHZXNhbXRcIixcbiAgXCJOT09SREVSU1wiOlwiS2VpbmUgb2ZmZW5lbiBPcmRlclwiLFxuICBcIkRBVEVcIjpcIkRhdHVtXCIsXG4gIFwiQlVZXCI6XCJLYXVmZW5cIixcbiAgXCJTRUxMXCI6XCJWZXJrYXVmZW5cIixcbiAgXCJPUEVOXCI6XCJPZmZlblwiLFxuICBcIkhJU1RPUllcIjpcIkhpc3RvcmllXCIsXG4gIFwiRk9MTE9XX0JBQ0tcIjpcIkViZW5mYWxscyBmb2xnZW5cIixcbiAgXCJGT0xMT1dFRFwiOlwiU2llIGZvbGdlbiBudW4gZGllc2VtIE51dHplclwiLFxuICBcIlVORk9MTE9XXCI6XCJOaWNodCBtZWhyIGZvbGdlblwiLFxuICBcIkZPTExPV0lOR1wiOlwiU2llIGZvbGdlbiBkaWVzZW0gTnV0emVyXCIsXG4gIFwiRk9MTE9XRVJTXCI6XCJQZXJzb25lbiwgZGllIElobmVuIGZvbGdlblwiLFxuICBcIlNFQVJDSF9GT0xMT1dFUlNcIjpcIkR1cmNoc3VjaGVuIGRlciBOdXR6ZXIsIGRpZSBJaG5lbiBmb2xnZW5cIixcbiAgXCJTRUFSQ0hfRk9MTE9XSU5HXCI6XCJEdXJjaHN1Y2hlbiBkZXIgTnV0emVyLCBkZW5lbiBTaWUgZm9sZ2VuXCIsXG4gIFwiQllcIjpcInZvblwiLFxuICBcIklOXCI6XCJpblwiLFxuICBcIk1FTlVcIjpcIk1lbsO8XCIsXG4gIFwiQk9PS01BUktcIjpcIkxlc2V6ZWljaGVuXCIsXG4gIFwiUkVCTE9HXCI6XCJSZWJsb2dcIixcbiAgXCJVUFZPVEVcIjpcIlVwdm90ZVwiLFxuICBcIkRPV05WT1RFXCI6XCJEb3dudm90ZVwiLFxuICBcIlVOVk9URV9ET1dOVk9URURcIjpcIkRvd252b3RlIGVudGZlcm5lblwiLFxuICBcIlVOVk9URV9VUFZPVEVEXCI6XCJVcHZvdGUgZW50ZmVybmVuXCIsXG4gIFwiUkVQTFlcIjpcIkFudHdvcnRlblwiLFxuICBcIkVESVRcIjpcIkVkaXRpZXJlblwiLFxuICBcIlBPU1RfMVwiOlwiTmFjaCBsaW5rcyB3aXNjaGVuIHVtIEtvbW1lbnRhcmUgenUgc2VoZW5cIixcbiAgXCJQT1NUXzJcIjpcIkF1ZiBLb21tZW50YXJlIHRpcHBlbiB1bSBkZXNzZW4gQW50d29ydGVuIHp1IHNlaGVuXCIsXG4gIFwiT1BUSU9OU1wiOlwiT3B0aW9uZW5cIixcbiAgXCJSRVNURUVNRURfQllcIjpcIlJlc3RlZW1lZCB2b25cIixcbiAgXCJOT1RISU5HX0hFUkVcIjpcIkhpZXIgZ2lidCBlcyBub2NoIG5pY2h0cyB6dSBzZWhlbi4uLlwiLFxuICBcIkJBTEFOQ0VTXCI6XCJLb250b3N0YW5kXCIsXG4gIFwiUFJPRklMRV8xXCI6XCJ7e3BsYXRmb3JtbmFtZX19LCBoYW5kZWxiYXJlIFRva2VucyBkaWUgenUgamVkZXIgWmVpdCDDvGJlcnRyYWdlbiB3ZXJkZW4ga8O2bm5lbi4ge3twbGF0Zm9ybW5hbWV9fSBrYW5uIGluIHt7cGxhdGZvcm1wb3dlcn19IGtvbnZlcnRpZXJ0IHdlcmRlbi4gRGllc2VyIFByb3plc3MgaGVpw590IFxcXCJwb3dlcmluZyB1cFxcXCIuXCIsXG4gIFwiUFJPRklMRV8yXCI6XCJ7e3BsYXRmb3JtcG93ZXJ9fSwgdG9rZW5zIGRpZSBzaWNoIGF1dG9tYXRpc2NoIHZlcm1laHJlbiwgd2VubiBTaWUgYmVzZXNzZW4gd2VyZGVuIHVuZCBiZWVpbmZsdXNzZW4sIHdpZSB2aWVsIElocmUgU3RpbW1lIHdlcnQgaXN0LiBEZXN0byBtZWhyIFNpZSBiZXNpdHplbiwgZGVzdG8gbWVociBFaW5mbHVzcyBoYXQgSWhyZSBTdGltbWUuXCIsXG4gIFwiUFJPRklMRV8zXCI6XCJUb2tlbnMgbWl0IGVpbmVtIFdlcnQgdm9uIGV0d2Ege3twbGF0Zm9ybXN1bml0fX0gaW4ge3twbGF0Zm9ybW5hbWV9fS5cIixcbiAgXCJFU1RJTUFURURfVkFMVUVcIjpcIkdlc2Now6R0enRlciBXZXJ0XCIsXG4gIFwiUFJPRklMRV80XCI6XCJEZXIgZ2VzY2jDpHR6dGUgV2VydCBiYXNpZXJ0IGF1ZiBlaW5lbSA3LVRhZ2UtRHVyY2hzY2huaXR0c3dlcnQgdm9uIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG4gIFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOlwiVHJhbnNha3Rpb25zIEhpc3RvcmllXCIsXG4gIFwiUE9TVElOR1wiOlwiQmVpdHJhZ1wiLFxuICBcIlBST0ZJTEVfNVwiOlwiRGVyIFxcXCJwb3N0aW5nIGtleVxcXCIgd2lyZCBmw7xyIGRhcyBWZXLDtmZmZW50bGljaGVuIHVuZCBBYnN0aW1tZW4gYmVuw7Z0aWd0LiBFciBzb2xsdGUgc2ljaCB2b20gXFxcImFjdGl2ZSBrZXlcXFwiIHVuZCB2b20gXFxcIm93bmVyIGtleVxcXCIgdW50ZXJzY2hlaWRlbi5cIixcbiAgXCJPV05FUlwiOlwiQmVzaXR6ZXJcIixcbiAgXCJQUk9GSUxFXzZcIjpcIkRlciBcXFwib3duZXIga2V5XFxcIiBpc3QgZGVyIEhhdXB0c2NobMO8c3NlbCBmw7xyIGRlbiBBY2NvdW50IHVuZCB3aXJkIGJlbsO2dGlndCwgdW0gYW5kZXJlIFNjaGzDvHNzZWwgenUgw6RuZGVybi4gRGVyIFxcXCJwcml2YXRlIGtleVxcXCIgb2RlciBkYXMgUGFzc3dvcnQgc29sbHRlbiBudXIgb2ZmbGluZSB2ZXJmw7xnYmFyIHNlaW4uXCIsXG4gIFwiQUNUSVZFXCI6XCJBa3RpdlwiLFxuICBcIlBST0ZJTEVfN1wiOlwiRGVyIFxcXCJhY3RpdmUga2V5XFxcIiB3aXJkIGJlbnV0enQsIHVtIMOcYmVydHJhZ3VuZ2VuIGR1cmNoenVmw7xocmVuIG9kZXIgR2Vib3RlIGF1ZiBkZW0gTWFya3QgenUgcGxhdHppZXJlbi5cIixcbiAgXCJNRU1PXCI6XCJOb3RpelwiLFxuICBcIlBST0ZJTEVfOFwiOlwiRGVyIFxcXCJtZW1vIGtleVxcXCIgd2lyZCBiZW7DtnRpZ3QsIHVtIE1lbW9zIHp1IGxlc2VuIHVuZCB6dSBzcGVpY2hlcm4uXCIsXG4gIFwiQkxPR1wiOlwiQmxvZ1wiLFxuICBcIlBPU1RTXCI6XCJCZWl0csOkZ2VcIixcbiAgXCJSRVBMSUVTXCI6XCJBbnR3b3J0ZW5cIixcbiAgXCJXQUxMRVRcIjpcIkJyaWVmdGFzY2hlXCIsXG4gIFwiVEFHXCI6XCJUYWdcIixcbiAgXCJVU0VSXCI6XCJCZW51dHplclwiLFxuICBcIkNMT1NFXCI6XCJTY2hsaWXDn2VuXCIsXG4gIFwiVE9cIjpcIkVtcGbDpG5nZXJcIixcbiAgXCJBU1NFVFwiOlwiWnVzYXR6XCIsXG4gIFwiU0VORFwiOlwiU2VuZGVuXCIsXG4gIFwiU0VDVVJJVFlcIjpcIlNpY2hlcmhlaXRcIixcbiAgXCJBVkFJTEFCTEVcIjpcIlZlcmbDvGdiYXJcIixcbiAgXCJQVUJMSUNfTUVNT1wiOlwiw5ZmZmVudGxpY2hlIE5vdGl6XCIsXG4gIFwiVE9fREVTQ1wiOlwiQmVudXR6ZXIgei5CLiBnb29kLWthcm1hXCIsXG4gIFwiUElOX0NPREVcIjpcIlBpblwiLFxuICBcIlBJTl9URVhUXCI6XCJEZXIgUElOIGRpZW50IGRlciBTaWNoZXJoZWl0IGRlciBBbndlbmR1bmcsIHNvd2llIGRlcmVuIERhdGVuLiA8YnIvPjxici8+PGI+SGlud2Vpczo8L2I+IE5hY2ggQWt0aXZpZXJ1bmcgc3RlaGVuIG1heGltYWwgNCBBbm1lbGRldmVyc3VjaGUgenVyIFZlcmbDvGd1bmcuIERhbmFjaCB3ZXJkZW4gZGllIERhdGVuIGRlcyBha3R1ZWxsIGFuZ2VtZWxkZXRlbiBOdXR6ZXJzIGdlbMO2c2NodCB1bmQgZGllIEFud2VuZHVuZyBrYW5uIHdpZWRlciBub3JtYWwgZ2VudXR6dCB3ZXJkZW4uXCIsXG4gIFwiTk9USUZJQ0FUSU9OU1wiOlwiQmVuYWNocmljaHRpZ3VuZ2VuXCIsXG4gIFwiVk9URV9URVhUXCI6XCJTaWUgd2VyZGVuIGluZm9ybWllcnQsIHNvYmFsZCBqZW1hbmQgZsO8ciBJaHJlIEJlaXRyw6RnZSBhYmdlc3RpbW10IGhhdCEgPGJyLz4gPGI+SGlud2Vpczo8L2I+IERpZSBOb3RpZmlrYXRpb24gZ2lidCBhdWZzY2hsdXNzIMO8YmVyIGRpZSBBcnQgZGVyIEFic3RpbW11bmcgKFBvc2l0aXYsIE5lZ2F0aXYsIHdpZWRlciBlbnRmZXJudCkgdW5kIGRpZSBHZXdpY2h0dW5nIGRlciBTdGltbWUuXCIsXG4gIFwiVk9URVwiOlwiQWJzdGltbWVuXCIsXG4gIFwiQ09NTUVOVF9URVhUXCI6XCJTaWUgd2VyZGVuIGluZm9ybWllcnQsIHNvYmFsZCBqZW1hbmQgYXVmIElocmUgQmVpdHLDpGdlIG9kZXIgS29tbWVudGFyZSBhbnR3b3J0ZXQhPGJyLz4gPGI+SGlud2Vpczo8L2I+IFNpZSB3ZXJkZW4gYXVjaCBiZWltIMOEbmRlcm4gZWluZXMgQmVpdHJhZ3MvS29tbWVudGFycyBlcm5ldXQgaW5mb3JtaWVydC5cIixcbiAgXCJDT01NRU5UXCI6XCJLb21tZW50YXJcIixcbiAgXCJGT0xMT1dfVEVYVFwiOlwiU2llIHdlcmRlbiBiZW5hY2hyaWNodGlndCwgc29iYWxkIElobmVuIGplbWFuZCBmb2xndCBvZGVyIG5pY2h0IG1laHIgZm9sZ3QhXCIsXG4gIFwiTUVOVElPTlNcIjpcIkVyd8OkaG51bmdlblwiLFxuICBcIk1FTlRJT05TX1RFWFRcIjpcIlNpZSB3ZXJkZW4gYmVuYWNocmljaHRpZ3QsIHNvYmFsZCBTaWUgdm9uIGplbWFuZGVuIGluIEtvbW1lbnRhcmVuIG9kZXIgQmVpdHJhZ2VuIGVyd8OkaG50IHdlcmRlbiFcIixcbiAgXCJSRVNURUVNXCI6XCJSZXN0ZWRcIixcbiAgXCJSRVNURUVNX1RFWFRcIjpcIlNpZSB3ZXJkZW4gYmVuYWNocmljaHRpZ3Qgc29iYWxkIGplbWFuZCBJaHJlbiBQb3N0IGVybmV1dCB2ZXLDtmZmZW50bGljaHQgaGF0IVwiLFxuICBcIkNPTkZJR1VSQVRJT05TXCI6XCJFaW5zdGVsbHVuZ2VuXCIsXG4gIFwiVk9USU5HXCI6XCJBYnN0aW1tdW5nXCIsXG4gIFwiVk9USU5HX1RFWFRcIjpcIkRhcyBHZXdpY2h0IC8gZGVyIHByb3plbnR1YWxlIEFudGVpbCBkZXIgU3RpbW1lIGJlZWluZmx1c3N0IGRpZSBNZW5nZSBkZXIgVmVyZ8O8dHVuZyBmw7xyIGRlbiBBdXRvci4gPGJyLz48YnIvPjxiPkhpbndlaXM6PC9iPiBEaWVzZSBFaW5zdGVsbHVuZyDDpG5kZXJ0IGF1Y2ggZGllIEdld2ljaHR1bmcvIGRlbiBwcm96ZW50dWFsZW4gQW50ZWlsIGbDvHIgbmVnYXRpdmUgU3RpbW1lbi4gRGllc2UgRWluc3RlbGx1bmcgd2lyZCBpbiBkZXIgZ2VzYW10ZW4gQW53ZW5kdW5nIHZlcndlbmRldC5cIixcbiAgXCJTRVJWRVJcIjpcIlNlcnZlclwiLFxuICBcIlNFUlZFUl9URVhUXCI6XCJFbXBmb2hsZW5cIixcbiAgXCJTQVZFX0NIQU5HRVNcIjpcIsOEbmRlcnVuZ2VuIHNwZWljaGVyblwiLFxuICBcIlZPVEVSU19JTkZPXCI6XCJBYnN0aW1tdW5nc2luZm9ybWF0aW9uZW5cIixcbiAgXCJXRUxDT01FX0JBQ0tcIjpcIldpbGxrb21tZW4genVyw7xjayFcIixcbiAgXCJMT0dJTl8xXCI6XCJNZWxkZW4gU2llIHNpY2ggbWl0IElocmVtIEJlbnV0emVybmFtZW4gdW5kIFBhc3N3b3J0IGFuLCB1bSBmb3J0enVmYWhyZW4uXCIsXG4gIFwiTE9HSU5fMlwiOlwiRGVyIFxcXCJQb3N0aW5nIGtleVxcXCIgd2lyZCBmw7xyIGRhcyBWZXLDtmZmZW50bGljaGVuIHZvbiBCZWl0cmFnZW4sIEtvbW1lbnRhcmVuIHVuZCBBYnN0aW1tdW5nZW4sIHNvd2llIGRlbSBGb2xnZW4gdm9uIE51dHplcm4gYmVuw7Z0aWd0LlwiLFxuICBcIkxPR0lOXzNcIjpcIkRlciBcXFwiQWN0aXZlIGtleVxcXCIgd2lyZCBmw7xyIGRpZSDDnGJlcnRyYWd1bmcgdW5kIGRhcyBha3R1YWxpc2llcmVuIGRlcyBQcm9maWxiaWxkcyBiZW7DtnRpZ3QuXCIsXG4gIFwiTE9HSU5fNFwiOlwiWnVnYW5nc2RhdGVuIHdlcmRlbiBsb2NhbCBpbSBHZXLDpHQgZ2VzcGVpY2hlcnQgdW5kIG5hY2ggZGVtIExvZ291dCBnZWzDtnNjaHQhXCIsXG4gIFwiRE9OVF9IQVZFXCI6XCJOb2NoIGtlaW5lbiBBY2NvdW50P1wiLFxuICBcIlNJR05fVVBfTk9XXCI6XCJKZXR6dCByZWdpc3RyaWVyZW5cIixcbiAgXCJDQU5DRUxcIjpcIkFiYnJlY2hlblwiLFxuICBcIkFEVkFOQ0VEXCI6XCJFcndlaXRlcnRcIixcbiAgXCJBQ1RJVkVfUFJJS0VZXCI6XCJBa3RpdmVyIHByaXZhdGVyIFp1Z2FuZ3NzY2hsw7xzc2VsXCIsXG4gIFwiUE9TVElOR19QUklLRVlcIjpcIlByaXZhdGVyIFp1Z2FuZ3NzY2hsw7xzc2VsIGbDvHIgZGFzIFZlcsO2ZmZlbnRsaWNoZW4gdm9uIEluaGFsdGVuXCIsXG4gIFwiTUFTVEVSX1BBU1NcIjpcIk1hc3Rlci0gL0hhdXB0LVBhc3N3b3J0XCIsXG4gIFwiVVNFUk5BTUVcIjpcIkJlbnV0emVybmFtZVwiLFxuICBcIkNBUkRfVklFV1wiOlwiS2FydGVuLUFuc2ljaHRcIixcbiAgXCJDT01QQUNUX1ZJRVdcIjpcIktvbXBha3RhbnNpY2h0XCIsXG4gIFwiU0VBUkNIXCI6XCJTdWNoZW5cIixcbiAgXCJTVUJNSVRfQV9TVE9SWVwiOlwiQmVpdHJhZyBlcnN0ZWxsZW5cIixcbiAgXCJSRVBMWVRPXCI6XCJBbnR3b3J0ZW5cIixcbiAgXCJQT1NUXCI6XCJWZXLDtmZmZW50bGljaGVuXCIsXG4gIFwiUFJFVklFV1wiOlwiVm9yc2NoYXVcIixcbiAgXCJERUZBVUxUXCI6XCJTdGFuZGFyZCA1MCUgLyA1MCVcIixcbiAgXCJQT1dFUlVQXCI6XCJQb3dlciBlcmjDtmhlbiBtaXQgMTAwJVwiLFxuICBcIkRFQ0xJTkVfUEFZT1VUXCI6XCJBdWYgZGllIEF1c3phaGx1bmcgdmVyemljaHRlblwiLFxuICBcIlNBVkVfRk9SX0xBVEVSXCI6XCJGw7xyIGVpbmVuIHNww6R0ZXJlbiBaZWl0cHVua3Qgc3BlaWNoZXJuXCIsXG4gIFwiQ0xFQVJcIjpcIkzDllNDSEVOXCIsXG4gIFwiUE9TVF9DT05URU5UXCI6XCJJbmhhbHQgdmVyw7ZmZmVudGxpY2hlblwiLFxuICBcIkNPTU1FTlRfQ09OVEVOVFwiOlwiSW5oYWx0IGtvbW1lbnRpZXJlblwiLFxuICBcIlRJVExFXCI6XCJUaXRlbFwiLFxuICBcIlRBR1NcIjpcIlRhZ3NcIixcbiAgXCJOT1RfTUFUQ0hcIjpcIktFSU5FIMOcQkVSRUlOU1RJTU1VTkdcIixcbiAgXCJDT05GSVJNX1BJTlwiOlwiUElOIGJlc3TDpHRpZ2VuXCIsXG4gIFwiSU5DT1JSRUNUXCI6XCJGQUxTQ0hcIixcbiAgXCJPUEVOSU5HX1BPU1RcIjpcIsO2ZmZuZSBCZWl0cmFnXCIsXG4gIFwiU0VUX1BJTlwiOlwiU2V0emVuIFNpZSBJaHJlbiBQSU5cIixcbiAgXCJFTlRFUl9QSU5cIjpcIkJpdHRlIGdlYmVuIFNpZSBJaHJlbiBQSU4gZWluXCIsXG4gIFwiQVJFX1lPVV9TVVJFXCI6XCJTaW5kIFNpZSBzaWNoZXI/XCIsXG4gIFwiUkVCTE9HX1RFWFRcIjpcIkRhcyBuZXUgdmVyw7ZmZmVudGxpY2hlbiBrYW5uIG5pY2h0IHLDvGNrZ8OkbmdpZyBnZW1hY2h0IHdlcmRlbiwgd29sbGVuIFNpZSB3ZWl0ZXIgbWFjaGVuP1wiLFxuICBcIkJST0FEQ0FTVF9FUlJPUlwiOlwiRmVobGVyIGJlaW0gdmVyw7ZmZmVudGxpY2hlbiwgYml0dGUgdmVyc3VjaGVuIFNpZSBlcyBlcm5ldXQhXCIsXG4gIFwiU1VDQ0VTU1wiOlwiRXJmb2xncmVpY2hcIixcbiAgXCJSRUJMT0dHRURfUE9TVFwiOlwiTmV1IHZlcsO2ZmZlbnRsaWNodCFcIixcbiAgXCJMT0dJTl9GQUlMXCI6XCJBbm1lbGR1bmcgZmVobGdlc2NobGFnZW4hIEJpdHRlIHN0ZWxsZW4gU2llIHNpY2ggc2ljaGVyLCBkYXNzIFNpZSBkYXMgTWFzdGVyLVBhc3N3b3J0IG9kZXIsIGbDvHIgZGVuIGVyd2VpdGVydGVuIEFubWVsZGUtTW9kdXMsIGRlbiBiZXJlaXRnZXN0ZWxsdGVuIFxcXCJBY3RpdmUgcHJpdmF0ZSBrZXlcXFwiIHZlcndlbmRlbi5cIixcbiAgXCJMT0dJTl9GQUlMX0FcIjpcIkFubWVsZHVuZyBmZWhsZ2VzY2hsYWdlbiEgQml0dGUgc3RlbGxlbiBTaWUgc2ljaCBzaWNoZXIsIGRhc3MgU2llIGRhcyBNYXN0ZXItUGFzc3dvcnQgb2RlciwgZsO8ciBkZW4gZXJ3ZWl0ZXJ0ZW4gQW5tZWxkZS1Nb2R1cywgZGVuIGJlcmVpdGdlc3RlbGx0ZW4gXFxcIkFjdGl2ZSBwcml2YXRlIGtleVxcXCIgdmVyd2VuZGVuLlwiLFxuICBcIldBUk5JTkdcIjpcIldhcm51bmdcIixcbiAgXCJWT1RFX0ZPUl9XSVRORVNTXCI6XCJGw7xyIGVpbmVuIFdpdG5lc3MgYWJzdGltbWVuXCIsXG4gIFwiVk9URURfRk9SX1dJVE5FU1NcIjpcIkVyZm9sZ3JlaWNoIGbDvHIgZWluZW4gV2l0bmVzcyBhYmdlc3RpbW10XCIsXG4gIFwiQUdPXCI6XCJzZWl0XCIsXG4gIFwiRlJPTV9OT1dcIjpcImFiIGpldHp0XCIsXG4gIFwiU0VDU1wiOlwiU2VrdW5kZW5cIixcbiAgXCJBX01JTlwiOlwiZWluZSBNaW51dGVcIixcbiAgXCJNSU5TXCI6XCJNaW51dGVuXCIsXG4gIFwiQU5fSE9VUlwiOlwiZWluZSBTdHVuZGVcIixcbiAgXCJIT1VSU1wiOlwiU3R1bmRlblwiLFxuICBcIkFfREFZXCI6XCJlaW5lbiBUYWdcIixcbiAgXCJEQVlTXCI6XCJUYWdlXCIsXG4gIFwiQV9NT05USFwiOlwiZWluZW4gTW9uYXRcIixcbiAgXCJNT05USFNcIjpcIk1vbmF0ZVwiLFxuICBcIkFfWUVBUlwiOlwiZWluIEphaHJcIixcbiAgXCJZRUFSU1wiOlwiSmFocmVcIixcbiAgXCJNSU5fUkVBRFwiOlwibWluLiBsZXNlblwiLFxuICBcIkRPV05WT1RFX0ZMQUdcIjpcIk5lZ2F0aXYgYmV3ZXJ0ZW4gb2RlciBtYXJraWVyZW5cIixcbiAgXCJDQVBUVVJFX1BJQ1RVUkVcIjpcIkJpbGQgYXVmbmVobWVuXCIsXG4gIFwiU0VMRUNUX1BJQ1RVUkVcIjpcIkJpbGQgYXVzd8OkaGxlblwiLFxuICBcIlNFVF9DVVNUT01fVVJMXCI6XCJFaWdlbmUgVVJMXCIsXG4gIFwiSU5TRVJUX1BJQ1RVUkVcIjpcIkJpbGQgZWluZsO8Z2VuXCIsXG4gIFwiRVJST1JcIjpcIkZlaGxlclwiLFxuICBcIlVQTE9BRF9FUlJPUlwiOlwiVXBsb2FkIGZlaGxnZXNjaGxhZ2VuXCIsXG4gIFwiQ0FNRVJBX0NBTkNFTExFRFwiOlwiS2FtZXJhIGdlc2NobG9zc2VuXCIsXG4gIFwiU0VUX1VSTFwiOlwiVVJMIHNldHplblwiLFxuICBcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjpcIkRpcmVrdGVyIExpbmsgenVtIEJpbGRcIixcbiAgXCJDT01NRU5UX1NVQk1JVFRFRFwiOlwiS29tbWVudGFyIGFiZ2VnZWJlbiFcIixcbiAgXCJERUxFVEVfQ09NTUVOVFwiOlwiR2Vsw7ZzY2h0ZSBLb21tZW50YXJlIGvDtm5uZW4gbmljaHQgd2lkZXJoZXJnZXN0ZWxsdCB3ZXJkZW4uLi5cIixcbiAgXCJERUxFVEVEX0NPTU1FTlRcIjpcIktvbW1lbnRhciBnZWzDtnNjaHRcIixcbiAgXCJVUExPQURJTkdfUElDVFVSRVwiOlwiQmlsZCB3aXJkIGhvY2hnZWxhZGVuXCIsXG4gIFwiVVBMT0FEX0NPTVBMRVRFRFwiOlwiSG9jaGxhZGVuIGFiZ2VzY2hsb3NzZW5cIixcbiAgXCJVUExPQURfRkFJTEVEXCI6XCJIb2NobGFkZW4gZmVobGdlc2NobGFnZW5cIixcbiAgXCJQQVNTV09SRF9JTkNPUlJFQ1RcIjpcIlBhc3N3b3J0IG9kZXIgQmVudXR6ZXJuYW1lIG5pY2h0IGtvcnJla3RcIixcbiAgXCJJTkZPXCI6XCJJbmZvcm1hdGlvblwiLFxuICBcIlFSX1RFWFRcIjpcIlBsYXR6aWVyZW4gU2llIGVpbmVuIFFSIGNvZGUgaW5uZXJoYWxiIGRlcyBCZXJlaWNoc1wiLFxuICBcIkJBTEFOQ0VfVEVYVFwiOlwiU3RlbGxlbiBTaWUgc2ljaGVyLCBkYXNzIFNpZSDDvGJlciBhdXNyZWljaGVuZGUgTWl0dGVsIHZlcmbDvGdlbiFcIixcbiAgXCJOT05FWElTVF9VU0VSXCI6XCJTaWUgdmVyZsO8Z2VuIG5pY2h0IMO8YmVyIGF1c3JlaWNoZW5kZSBNaXR0ZWwgZsO8ciBkaWVzZSBBa3Rpb24hXCIsXG4gIFwiVFJBTlNGRVJfVEVYVFwiOlwiV29sbGVuIFNpZSB3aXJrbGljaCDDvGJlcnRyYWdlbj9cIixcbiAgXCJDT05GSVJNQVRJT05cIjpcIkJlc3TDpHRpZ3VuZ2VuXCIsXG4gIFwiVFhfQlJPQURDQVNURURcIjpcIkRpZSBUcmFuc2FrdGlvbiB3dXJkZSDDvGJlcnRyYWdlblwiLFxuICBcIkZFRURcIjpcIkZlZWRcIixcbiAgXCJUUkVORElOR1wiOlwiSW0gVHJlbmRcIixcbiAgXCJIT1RcIjpcIkJlbGllYnRcIixcbiAgXCJORVdcIjpcIk5ldVwiLFxuICBcIlBST01PVEVEXCI6XCJCZXdvcmJlblwiLFxuICBcIlZPVEVTXCI6XCJTdGltbWVuXCIsXG4gIFwiUEFZT1VUXCI6XCJBdXN6YWhsdW5nXCIsXG4gIFwiQ09NTUVOVFNcIjpcIktvbW1lbnRhcmVcIixcbiAgXCJUUkVORElOR18zMFwiOlwiU2VpdCAzMCBUYWdlbiBpbSBUcmVuZFwiLFxuICBcIlNPUlRfUE9TVF9CWVwiOlwiU29ydGllcmVuIGRlciBQb3N0cyBuYWNoOlwiLFxuICBcIlBBWU9VVF9DWUNMRVwiOlwiQXVzemFobHVuZ3NrcmVpc2xhdWZcIixcbiAgXCJQT1RFTlRJQUxfUEFZT1VUXCI6XCJWb3JhdXNzaWNodGxpY2hlIEF1c3phaGx1bmdlblwiLFxuICBcIlBBU1RfUEFZT1VUXCI6XCJWZXJnYW5nZW5lIEF1c3phaGx1bmdlblwiLFxuICBcIkFVVEhPUl9QQVlPVVRcIjpcIkF1c3phaGx1bmcgYW4gZGVuIEF1dG9yXCIsXG4gIFwiQ1VSQVRJT05fUEFZT1VUXCI6XCJLdXJhdGlvbnNhdXN6YWhsdW5nZW5cIixcbiAgXCJQT1NUX1NVQk1JVFRFRFwiOlwiUG9zdCB3dXJkZSB2ZXLDtmZmZW50bGljaHQhXCIsXG4gIFwiUE9TVF9MQVRFUlwiOlwiUG9zdHMgenVyIHNww6R0ZXJlbiBWZXLDtmZmZW50bGljaHVuZyFcIixcbiAgXCJTQVZFRFwiOlwiR2VzcGVpY2hlcnRcIixcbiAgXCJDTEVBUkVEXCI6XCJHZWxlZXJ0XCIsXG4gIFwiRkxBR0dJTkdfVEVYVFwiOlwiRGFzIG1hcmtpZXJlbiBlaW5lcyBQb3N0cyBrYW5uIHp1bSBWZXJsdXN0IGRlciBWZXJnw7x0dW5nIGbDvGhyZW4gdW5kIHZlcnJpbmdlcnQgZGllIFNpY2h0YmFya2VpdCBkZXMgUG9zdHMuPGJyPjxicj5TaWUgc29sbHRlbiBQb3N0cyBudXIgdW50ZXIgbWFya2llcmVuLCB3ZW5uIGVpbmVyIGRlciBmb2xnZW5kZW4gUHVua3RlIHp1dHJpZmZ0OiA8dWw+PGxpPkJldHJ1ZyBvZGVyIFBsYWdpYXQ8L2xpPjxsaT5WdWxnw6RyZSBBdXNkcnVja2Ugb2RlciBcXFwiVHJvbGxpbmdcXFwiPC9saT48bGk+TXV0d2lsbGlnIGZhbHNjaCBrYXRlZ29yaXNpZXJ0IG9kZXIgU3BhbTwvbGk+PC91bD5cIixcbiAgXCJSRVFVRVNUX0xJTUlUX1RFWFRcIjpcIk1heGltYWxlIEFuemFobCB2b24gQW5mcmFnZW4gZXJyZWljaHQuIEJpdHRlIHNjaGF1ZW4gU2llIHNpY2ggYW5kZXJlIHRyZW5kL3RhZ3MgYW4hXCIsXG4gIFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6XCJQb3N0IHZvbiBkZW4gTGVzZXplaWNoZW4gZW50ZmVybnQhXCIsXG4gIFwiUE9TVF9JU19CT09LTUFSS1wiOlwiUG9zdCB6dSBkZW4gTGVzZXplaWNoZW4gaGluenVnZWbDvGd0IVwiLFxuICBcIlJFU0VUXCI6XCJadXLDvGNrc2V0emVuXCIsXG4gIFwiTU9ESUZZX1BJQ1RVUkVcIjpcIlByb2ZpbGJpbGQgw6RuZGVyblwiLFxuICBcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6XCJUaXRlbGJpbGQgw6RuZGVyblwiLFxuICBcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOlwiQml0dGUgdHJhZ2VuIFNpZSBkZW4gXFxcIkFjdGl2ZSBwcml2YXRlIGtleVxcXCIgZWluLCB3ZW5uIFNpZSBkZW4gZXJ3ZWl0ZXJ0ZW4gTG9naW4gTW9kdXMgZ2V3w6RobHQgaGFiZW4hXCIsXG4gIFwiUkVTRVRfUElDVFVSRV9URVhUXCI6XCJadXLDvGNrc2V0emVuIGRlcyBQcm9maWxiaWxkc1wiLFxuICBcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOlwiWnVyw7xja3NldHplbiBkZXMgVGl0ZWxiaWxkcy5cIixcbiAgXCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOlwiQXVmZ3J1bmQgZWluZXMgU2VydmVydXBkYXRlcyBtdXNzIGVpbiBkaWUgQW53ZW5kdW5nIG5ldWdlc3RhcnRldCB3ZXJkZW4hXCIsXG4gIFwiU0VUVElOR1NfVVBEQVRFRFwiOlwiRWluc3RlbGx1bmdlbiBha3R1YWxpc2llcnQhXCIsXG4gIFwiTEFOR1VBR0VTXCI6XCJTcHJhY2hlblwiLFxuICBcIkxBTkdVQUdFU19URVhUXCI6XCJIaWVyIGthbm4gZGllIFNwcmFjaGUgZGVyIEFud2VuZHVuZyBnZcOkbmRlcnQgd2VyZGVuLlwiLFxuICBcIkxPR0lOX1RPX1hcIjpcIkbDvHIgZGllIGdld8O8bnNjaHRlIE9wZXJhdGlvbiBtw7xzc2VuIFNpZSBhbmdlbWVsZGV0IHNlaW4uIEJpdHRlIG1lbGRlbiBTaWUgc2ljaCBtaXQgSWhyZW0gUGFzc3dvcnQgb2RlciBkZW0gXFxcImFjdGl2ZS9wb3N0aW5nXFxcIi1TY2hsw7xzc2VsIHNlaW5cIixcbiAgXCJHQUxMRVJZXCI6XCJHYWxsZXJpZVwiLFxuICBcIlRSQU5TTEFUSU9OU1wiOlwiTWl0d2lya2VuZGUgYW4gZGVyIMOcYmVyc2V0enVuZ1wiLFxuICBcIlNIQVJFXCI6XCJUZWlsZW5cIixcbiAgXCJNQVJLRVRQTEFDRVwiOlwiTWFya3RwbGF0elwiLFxuICBcIkVYQ0hBTkdFXCI6XCJCw7Zyc2VcIixcbiAgXCJEUkFGVFNcIjpcIkVudHfDvHJmZVwiLFxuICBcIlBPU1RfSVNfVU5EUkFGVFwiOlwiQmVpdHJhZyBhdXMgRW50d8O8cmZlbiBlbnRmZXJudCFcIixcbiAgXCJQT1NUX0lTX0RSQUZUXCI6XCJCZWl0cmFnIHp1IEVudHfDvHJmZW4gaGluenVnZWbDvGd0IVwiLFxuICBcIlNXSVBFX0xFRlRcIjpcIkxpbmtzIHdpc2NoZW4gZsO8ciBPcHRpb25lblwiLFxuICBcIk1BTkFHRVwiOlwiVmVyd2FsdGVuXCIsXG4gIFwiSU1BR0VfUkVNT1ZFRFwiOlwiQmlsZCBlbnRmZXJudFwiLFxuICBcIkNPUFlcIjpcIktvcGllcmVuXCIsXG4gIFwiTk9fSU1BR0VcIjpcIlNpZSBoYWJlbiBub2NoIGtlaW4gRm90byBob2NoZ2VsYWRlbiFcIixcbiAgXCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOlwiTmFjaCB1bnRlbiB6aWVoZW4genVtIGFrdHVhbGlzaWVyZW5cIixcbiAgXCJFWFRFUk5BTF9BUFBTXCI6XCJFeHRlcm5lIEFwcHNcIixcbiAgXCJQTFVHSU5TXCI6XCJQbHVnLUluc1wiLFxuICBcIlNVR0dFU1RcIjpcIlZvcnNjaGxhZ2VuXCIsXG4gIFwiQ09NSU5HX1NPT05cIjpcIktvbW10IGJhbGRcIixcbiAgXCJDSEFJTlwiOlwiQ2hhaW5cIixcbiAgXCJDSEFJTl9URVhUXCI6XCJIaWVyIGthbm5zdCBkdSBkaWUgQmxvY2tjaGFpbiBvZGVyIGRpZSBTdGFuZGFyZHBsYXR0Zm9ybSB3ZWNoc2Vsbi5cIixcbiAgXCJDVVJSRU5DWVwiOlwiV8OkaHJ1bmdcIixcbiAgXCJDVVJSRU5DWV9URVhUXCI6XCJIaWVyIGvDtm5uZW4gU2llIElocmUgU3RhbmRhcmR3w6RocnVuZyDDpG5kZXJuLiBTaWUgc2VoZW4gYWxsIElocmUgVmVyZGllbnN0ZSBmw7xyIEJlaXRyw6RnZSAvIEtvbW1lbnRhcmUgaW4gZGllc2VyIFN0YW5kYXJkd8OkaHJ1bmcuXCIsXG4gIFwiQUJPVVRfMTFcIjpcIjxicj48Yj5GZWF0dXJlIExpc3RlPC9iPjxicj4tIFp1Z2FuZyBlcmhhbHRlbiB6dSBlaW56aWdhcnRpZ2VuIEFydGlrZWxuIGFsbCBkZXIgVGhlbWVuZ2ViaWV0ZSwgZGllIFNpZSBnZXJuZSBsZXNlbiBtw7ZjaHRlbi48YnI+LSBJbnRlcmFnaWVyZW4gU2llIG1pdCBkZW4gQXV0b3JlbiwgaW4gZGVtIFNpZSBkaWUgQmVpdHLDpGdlIGtvbW1lbnRpZXJlbiB1bmQgbWl0IGFuZGVyZW4gZGlza3V0aWVyZW4uPGJyPi0gU3RpbW1lbiBTaWUgZsO8ciBBcnRpa2VsIHVtIEF1dG9yZW4genUgYmVsb2huZW4gdW5kIHNlbGJzdCBDdXJhdGlvbiBSZXdhcmRzIHp1IHZlcmRpZW5lbi48YnI+LSBWZXLDtmZmZW50bGljaGVuIFNpZSBJaHJlIEFydGlrZWwsIEJsb2cgUG9zdHMsIGRpZSBrb3N0ZW5sb3MgZ2Vob3N0ZWQgd2VyZGVuIHVuZCBlcmhhbHRlbiBTaWUgRW50Z2VsdCBmw7xyIEludGVyYWdpZXJlbiB1bmQgZ2V3aW5uZW4gU2llIHp1c8OkdHpsaWNoIEFuaMOkbmdlciBmw7xyIElocmUgSW5oYWx0ZS48YnI+LSBTY2hyZWliZW4gU2llIEFydGlrZWwgdm9uIHVudGVyd2Vncy4gU3BlaWNoZXJuIFNpZSBlaW5lIFZpZWx6YWhsIHZvbiBFbnR3w7xyZmVuIHVtIGRpZXNlIHNww6R0ZXIgenUgdmVyw7ZmZmVudGxpY2hlbi48YnI+LSBCb29rbWFya2VuIFNpZSBJaHJlIExpZWJsaW5nc2FydGlrZWwsIHVtIGRpZXNlIHNww6R0ZXIgenUgbGVzZW4uPGJyPi0gRWlubmFobWVuIHRhdXNjaGVuIG9kZXIgYXVzemFobGVuLjxicj4tIMOcYmVyd2Vpc2VuIFNpZSBHdXRoYWJlbiBhbiBBdXRvcmVuLCBOdXR6ZXIsIEZyZXVuZGUsIEFuaMOkbmdlciwgZXRjLjxicj4tIEZvbGdlbiBTaWUgaW50ZXJlc3NhbnRlbiBBdXRvcmVuLCBCbG9nZ2Vybi48YnI+LSBEdXJjaHN1Y2hlbiBTaWUgSW5oYWx0ZSBJaHJlciBGb2xsb3dlciB1bmQgQXV0b3Jlbi48YnI+LSBFcmhhbHRlbiBTaWUgQmVuYWNocmljaHRpZ3VuZ2VuIHZvbiBJaHJlbiBGb2xsb3dlciB1bmQgRGlza3Vzc2lvbmVuLCBhbiBkZW5lbiBTaWUgdGVpbGdlbm9tbWVuIGhhYmVuLjxicj4tIFN1Y2hlbiBTaWUgaW50ZXJlc3NhbnRlIFRhZ3MgLyBLYXRlZ29yaWVuIGFsbGVyIEFydGlrZWwgdW5kIEF1dG9yZW4uPGJyPi0gUGVyc29uYWxpc2llcmVuIFNpZSBJaHJlIFByb2ZpbC48YnI+LSBWaWVsZSBuZXVlIEZlYXR1cmVzIHdlcmRlbiBkZW1uw6RjaHN0IHZvcmdlc3RlbGx0Ljxicj48YnI+PGI+U2ljaGVyaGVpdDwvYj48YnI+MS4gQXBwIGhhdCBrZWluZW4gWnVncmlmZiBhdWYgSWhyZSBFaW5uYWhtZW4uPGJyPjIuIEFwcCBiaWV0ZW4gZWluZmxpZcOfdC1zaWRlIFNpY2hlcmhlaXRzLU1vZGVsbCBtaXQgcHJpdmF0ZW4gU2NobMO8c3NlbG4sIGRpZSBsb2thbCBnZWhvc3RldCB1bmQgbmllbWFscyBhbiBhbmRlcmUgU2VydmVyIGdlc2NoaWNrdCB3ZXJkZW4uIFNpZSBzaW5kIGxlZGlnbGljaCBkYWbDvHIgdmVyYW50d29ydGxpY2ggSWhyZSBQYXNzd29ydCB6dSBzaWNoZXJuLjxicj4zLiBEaWUgQXBwIGJpZXRldCBzaW1wbGVzIE51dHplciBJbnRlcmZhY2UgdW5kIGF0dHJha3RpdmUgVXNlciBFcmZhaHJ1bmdlbjxicj40LiBEaWUgQXBwIGJlaW5oYWx0ZXQgZWluZSB6dXPDpHR6bGljaGUgU2ljaGVyaGVpdHNlYmVuZSBkdXJjaCBlaW5lbiBQaW4tQ29kZTxicj48YnI+ZVN0ZWVtIHVudGVyc3TDvHR6IGRpZSBQbGF0dGZvcm1lbiBTdGVlbSBzb3dpZSBHb2xvcy48YnI+XCIsXG4gIFwiRk9VTkRFUlwiOlwiR3LDvG5kZXIgdW5kIGxlaXRlbmRlciBFbnR3aWNrbGVyXCIsXG4gIFwiQUREX0FDQ09VTlRcIjpcIkFjY291bnQgaGluenVmw7xnZW5cIixcbiAgXCJQTEFURk9STVwiOlwiUGxhdHRmb3JtXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiSE9NRVwiOlwiaG9tXCIsXG4gIFwiTE9HSU5cIjpcImxnaW5cIixcbiAgXCJMT0dPVVRcIjpcImxnb290dVwiLFxuICBcIlBST0ZJTEVcIjpcInBvcmZsaVwiLFxuICBcIkZPTExPV1wiOlwiZmx1d1wiLFxuICBcIkJPT0tNQVJLU1wiOlwiYmt1bWFrcnpcIixcbiAgXCJUUkFOU0ZFUlwiOlwidGFybnNlZnJcIixcbiAgXCJNQVJLRVRcIjpcIm1yYWt0ZVwiLFxuICBcIlNFVFRJTkdTXCI6XCJzdGV0aWduelwiLFxuICBcIkFCT1VUXCI6XCJhYnV0XCIsXG4gIFwiQUJPVVRfMVwiOlwid2VyIGFueW9uIGNuYSBlcmFuIHJ3YXJkeiBmZXIgdGhpciBjbnRudCFcIixcbiAgXCJBQk9VVF8yXCI6XCJpeiBwd2VyZWQgYmkge3twbGF0Zm9ybW5hbWV9fSBwYWx0ZnJvbS4gYXBwIGl6IGNyYXRlZCBiaVwiLFxuICBcIkFCT1VUXzNcIjpcImFuZCBpdCBpeiBvcG4tc3JjLCBjbW91bnRpIGRpcnZuZSBtYmlsIHByamN0LiBpdCBvZmZlenIgY250bnQgYWNjZXpzIGZlciByZG5nLCBjb2VtbnRuZywgdnRvaWduLCBwc3RuZywgdGFybnNlZnIgZXJhbmlnbnosIGV0Yy4gZnRyeiBvZmZlcmVkIGJpIHt7cGxhdGZvcm1uYW1lfX0gYmxja2NoaW4gYW5kIHt7c2l0ZW5hbWV9fS5cIixcbiAgXCJBQk9VVF80XCI6XCIxLiBhcHAgbnZlciBhY2NlenMgb3IgaGxvZCBvdG5vIHVlc3IgZm5kei5cIixcbiAgXCJBQk9VVF81XCI6XCIyLiBhcHAgb2ZmZXpyIGEgY2xudC1zaWQgc2NldXJ0aSBtZGVsLCB3dGloIHBpcnZ0YSBreWV6IGhzb3RkZSBsY29haWwgYW5kIG52ZXIgc25ldCB0dSBhbmkgc3J2cnouXCIsXG4gIFwiQUJPVVRfNlwiOlwiMy4gYXBwIG9mZmV6ciBzbXBsLCBhdHJ0YWNpdiB1ZXNyIGluZXRyZmN6IGFuZCBleHBybmN6LlwiLFxuICBcIkFCT1VUXzdcIjpcIjQuIGFwcCBudmVyIHJxZXVyaSB1c3J6IHR1IGlucHQgYW5pIHByZXNvYW5sIGluZnJtYXRuLlwiLFxuICBcIkFCT1VUXzhcIjpcInZvdCBnb29kLWthcm1hIGF6IHdpdG5zZXpcIixcbiAgXCJBQk9VVF85XCI6XCJrb250YWt0L2ZlZGJhazpcIixcbiAgXCJBQk9VVF8xMFwiOlwibXVyIGluZjpcIixcbiAgXCJSRU1PVkVcIjpcInJtb3ZcIixcbiAgXCJNQVJLRVRfVklFV1wiOlwibXJha3RlIHZlaXdcIixcbiAgXCJQUklDRVwiOlwicGlyY1wiLFxuICBcIkFNT1VOVFwiOlwiYW9tdXRuXCIsXG4gIFwiVE9UQUxcIjpcInR0YWxcIixcbiAgXCJOT09SREVSU1wiOlwibm8gb2VwbiBvZHJlenIgZmVyXCIsXG4gIFwiREFURVwiOlwiZGF0XCIsXG4gIFwiQlVZXCI6XCJidWlcIixcbiAgXCJTRUxMXCI6XCJzZWxcIixcbiAgXCJPUEVOXCI6XCJvZXBuXCIsXG4gIFwiSElTVE9SWVwiOlwiaHN0clwiLFxuICBcIkZPTExPV19CQUNLXCI6XCJmbHV3IGJha1wiLFxuICBcIkZPTExPV0VEXCI6XCJmbG93ZWRcIixcbiAgXCJVTkZPTExPV1wiOlwidW5mb2xvd1wiLFxuICBcIkZPTExPV0lOR1wiOlwiZmxvb3duaWdcIixcbiAgXCJGT0xMT1dFUlNcIjpcImZsb293cmV6XCIsXG4gIFwiU0VBUkNIX0ZPTExPV0VSU1wiOlwic2FlcmhjIGZsb293cmV6XCIsXG4gIFwiU0VBUkNIX0ZPTExPV0lOR1wiOlwic2FlcmhjIGZsb293bmlnXCIsXG4gIFwiQllcIjpcImJpXCIsXG4gIFwiSU5cIjpcIlwiLFxuICBcIk1FTlVcIjpcIm1uZXVcIixcbiAgXCJCT09LTUFSS1wiOlwiYmttcmtcIixcbiAgXCJSRUJMT0dcIjpcInJiZWxnb1wiLFxuICBcIlVQVk9URVwiOlwidXB2dFwiLFxuICBcIkRPV05WT1RFXCI6XCJkd252b3RcIixcbiAgXCJVTlZPVEVfRE9XTlZPVEVEXCI6XCJ1bnZ0IGRvbnd2b2VkXCIsXG4gIFwiVU5WT1RFX1VQVk9URURcIjpcInVudnQgdXB2b2VkXCIsXG4gIFwiUkVQTFlcIjpcInJwbGlcIixcbiAgXCJFRElUXCI6XCJlaWR0XCIsXG4gIFwiUE9TVF8xXCI6XCJzaXdwIGxmZXQgb24gY21lbnR6IHR1IGMgb3B0aW56XCIsXG4gIFwiUE9TVF8yXCI6XCJ0YXAgb24gY21lbnR6IHR1IGMgc3ViLWNtbnR6XCIsXG4gIFwiT1BUSU9OU1wiOlwib3B0aW56XCIsXG4gIFwiUkVTVEVFTUVEX0JZXCI6XCJyc2V0ZWVtZCBiaVwiLFxuICBcIk5PVEhJTkdfSEVSRVwiOlwibnRobmcgaGlyLCB5ZXQuLi5cIixcbiAgXCJCQUxBTkNFU1wiOlwiYmxhbmN6XCIsXG4gIFwiUFJPRklMRV8xXCI6XCJ7e3BsYXRmb3JtbmFtZX19LCB0cmFlZGJhbCAkJCBkYXQgY24gYiB0cm5zZnJlZCBhbnl0aWVtLiB7e3BsYXRmb3JtbmFtZX19IGNuIGIgY292bmVyZWQgMiB7e3BsYXRmb3JtcG93ZXJ9fSBpbiBhIHByY3N6IGNsZWQgcHdvZXJuaWcgdXAuXCIsXG4gIFwiUFJPRklMRV8yXCI6XCJ7e3BsYXRmb3JtcG93ZXJ9fSwgaWZubHVuZWMgJCQgZGF0IGVybiBtdXIgcHdlciBmZXIgaGxkbmcgbG5vZyB0aWVtIGFuZCB2b3RpZ24gb24gcG9zdHouIHRlaCBtdXIgdSBob2xkeiB0ZWggbXVyIHUgY25hIGlmbmx1bmVjIG90aGVyeiByd2FyZHogYW5kIGVybiByd2FyZHogZmVyIGFjY3VyYXQgdm90aWduLlwiLFxuICBcIlBST0ZJTEVfM1wiOlwiJCQgd3J0aCBhYnV0IHt7cGxhdGZvcm1zdW5pdH19IG9mIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG4gIFwiRVNUSU1BVEVEX1ZBTFVFXCI6XCJlc2l0bWFlZCB2bGF1XCIsXG4gIFwiUFJPRklMRV80XCI6XCJ0ZWggZXNpdG1hZWQgdmxhdSBpeiBic2VkIG9uIGEgNyBkYWkgYWV2cmdhIHZsYXUgb2Yge3twbGF0Zm9ybW5hbWV9fS5cIixcbiAgXCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6XCJ0cmFuc2FjdG4gaHN0clwiLFxuICBcIlBPU1RJTkdcIjpcInBzdG5nXCIsXG4gIFwiUFJPRklMRV81XCI6XCJ0ZWggcHN0bmcga2VpIGl6IHVlc2QgZmVyIHBzdG5nIGFuZCB2dG9pZ24uIGl0IHNvaHVkbCBiIGRpZmZlcm50IGZydW0gdGVoIGFjdHYgYW5kIG93bnIga3llei5cIixcbiAgXCJPV05FUlwiOlwib3duclwiLFxuICBcIlBST0ZJTEVfNlwiOlwidGVoIG93bnIga2VpIGl6IHRlaCBtc2F0cmUga2VpIGZlciB0ZWggYWNjb250IGFuZCBpeiBycWV1aWVyZCB0dSBjaG5nIHRlaCBvdGhyIGt5ZXouIHRlaCBwaXJ2dGEga2VpIG9yIHBzYXN3cm9kIGZlciB0ZWggb3duciBrZWkgc29odWRsIGIga3BldCBvZmZsbmkgYXogbWN1aCBheiBwc3NibC5cIixcbiAgXCJBQ1RJVkVcIjpcImFjdHZcIixcbiAgXCJQUk9GSUxFXzdcIjpcInRlaCBhY3R2IGtlaSBpeiB1ZXNkIHR1IG1hZWsgdHJuYXNmcnogYW5kIHBhbGMgb2RyZXpyIGluIHRlaCBpdG5lcmFubCBtcmFrdGUuXCIsXG4gIFwiTUVNT1wiOlwibW1lb1wiLFxuICBcIlBST0ZJTEVfOFwiOlwidGVoIG1tZW8ga2VpIGl6IHVlc2QgdHUgY3JhdCBhbmQgcmFlZCBtbW96LlwiLFxuICBcIkJMT0dcIjpcImJvbGdcIixcbiAgXCJQT1NUU1wiOlwicHN0elwiLFxuICBcIlJFUExJRVNcIjpcInJwbGllc1wiLFxuICBcIldBTExFVFwiOlwid2xldFwiLFxuICBcIlRBR1wiOlwidGFnZ1wiLFxuICBcIlVTRVJcIjpcInVlc3JcIixcbiAgXCJDTE9TRVwiOlwiY29sc1wiLFxuICBcIlRPXCI6XCJ0b1wiLFxuICBcIkFTU0VUXCI6XCJhc3N0XCIsXG4gIFwiU0VORFwiOlwic25kXCIsXG4gIFwiU0VDVVJJVFlcIjpcInNjZXVydGlcIixcbiAgXCJBVkFJTEFCTEVcIjpcImFhdmlsYmFsXCIsXG4gIFwiUFVCTElDX01FTU9cIjpcInBidWxjaSBtbWVvXCIsXG4gIFwiVE9fREVTQ1wiOlwidWVzciBlLmcuIGdvb2Qta2FybWFcIixcbiAgXCJQSU5fQ09ERVwiOlwicGluIGNvZFwiLFxuICBcIlBJTl9URVhUXCI6XCJwaW4gY29kIGhscHogeXUgdHUgc2N1ciBhcHAgYW5kIHVyIGR0YWEuIDxici8+PGJyLz48Yj5ub3RlOjwvYj4gb25jIGVuYmxlZCwgeXUgaGV2IG1heCA0IHRpcnogdHUgdW5saywgaWYgeXUgZnJndCBwaW4gb3IgZmlhbCwgYXBwIHdpbCBybW92IGxnb2dkZSBpbiB1ZXNyIGR0YWEuIHl1IGNuYSByLWVsb2lnbiBhbmQgY250biB1c25nIGFwcC5cIixcbiAgXCJOT1RJRklDQVRJT05TXCI6XCJub3RpZmlrYXRpb256XCIsXG4gIFwiVk9URV9URVhUXCI6XCJ5dSB3aWwgZ2V0IG5vdGZpa2F0aW4gd2VobiBzbW9lbm8gdnRveiB1ciBjbnRudCEgPGJyLz4gPGI+bnQ6PC9iPiBub3RpZmlrYXRpb256IGljbmxkdSB2dG9pZ24gd2llZ3RoIGF6IHdlbCBpbiBhbHJ0IG1lc3NpZy4gKGIgaXQgdXB2dCwgZHdudm90LCB1bnZ0KS5cIixcbiAgXCJWT1RFXCI6XCJ2b3RcIixcbiAgXCJDT01NRU5UX1RFWFRcIjpcInl1IHdpbCBnZXQgbm90ZmlrYXRpbiB3ZWhuIHNtb2VubyBjbWVudHogb24gdXIgcHN0eiBvciBrb21lbnRzITxici8+IDxiPm50OjwvYj4gbm90aWZpa2F0aW9ueiBpY25sZHUgd2VobiBzbW9lbm8gPGI+ZHRzPC9iPiB0aGlyIGNtZW50eiBheiB3ZWwuXCIsXG4gIFwiQ09NTUVOVFwiOlwiY21vZXRuXCIsXG4gIFwiRk9MTE9XX1RFWFRcIjpcInl1IHdpbCBnZXQgbm90ZmlrYXRpbiB3ZWhuIHNtb2VubyBmbHV3IG9yIHVuZm9sb3cgeXUhXCIsXG4gIFwiTUVOVElPTlNcIjpcIm1uZXRpbm96XCIsXG4gIFwiTUVOVElPTlNfVEVYVFwiOlwieXUgd2lsIGdldCBub3RmaWthdGluIHdlaG4gc21vZW5vIG1uZXRpbm96IHl1IGluIHRoaXIgcHN0L2NtbnQhXCIsXG4gIFwiUkVTVEVFTVwiOlwicmVzdGVtZVwiLFxuICBcIlJFU1RFRU1fVEVYVFwiOlwieXUgd2lsIGdldCBub3RmaWthdGluIHdlaG4gc21vZW5vIHJzdG16IHVyIHBzb3QhXCIsXG4gIFwiQ09ORklHVVJBVElPTlNcIjpcImtvbmZndXJhdG9uelwiLFxuICBcIlZPVElOR1wiOlwidnRvaWduXCIsXG4gIFwiVk9USU5HX1RFWFRcIjpcInZvdCB3aWVndGggb3IgcGVjcmVuYWcgYWZmZWN0eiB2dG9pZ24gcHdlciBvbiBhcHAsIHNvIHl1IGNuYSByZ3VsYXQgdXIgdnRvaWduIHJ3ZWFkci4gPGJyLz48YnIvPjxiPm5vdGU6PC9iPiBkaXogd2lsIGNobmcgdnRvaWduIHdlaWdodC9wZXJjZW50YWcgZmVyIGR3bnZ0aW5nIGF6IHdlbCBhbmQgaXQgaXogZXZyZXl3ZXIgb24gYXBwXCIsXG4gIFwiU0VSVkVSXCI6XCJzcmV2cmVcIixcbiAgXCJTRVJWRVJfVEVYVFwiOlwicmNtbmRlZFwiLFxuICBcIlNBVkVfQ0hBTkdFU1wiOlwic2F2IGNhaG56Z1wiLFxuICBcIlZPVEVSU19JTkZPXCI6XCJ2dG9lenIgaWZub1wiLFxuICBcIldFTENPTUVfQkFDS1wiOlwid2xjdW0gYmFrIVwiLFxuICBcIkxPR0lOXzFcIjpcInNnaW4gaW4gd3RpaCB1ciB1c3JuYW0gYW5kIHBzYXN3cm9kIHR1IGNudG4uXCIsXG4gIFwiTE9HSU5fMlwiOlwicHN0bmcga2VpIGl6IHVlc2QgZmVyIHBzb3QsIGNtb2V0biwgdm90LCBmbHV3LlwiLFxuICBcIkxPR0lOXzNcIjpcImFjdHYga2VpIGl6IHVlc2QgZmVyIHRybmFzZnJ6IGFuZCBwb3JmbGkgcGNpdHJ1IHVwZHQuXCIsXG4gIFwiTE9HSU5fNFwiOlwidWVzciBjcmRudGFseiBhciBrcGV0IGxjb2FpbCBvbiB0ZWggZHZpYy4gdW9wbiBsZ29vdHUgY3JkbnRhbHogYXIgcm1vdmVkIVwiLFxuICBcIkRPTlRfSEFWRVwiOlwiZG50IGhldiBhbiBhY2NvbnQ/XCIsXG4gIFwiU0lHTl9VUF9OT1dcIjpcInNnaW4gdXAgbm93XCIsXG4gIFwiQ0FOQ0VMXCI6XCJjbmFjbGVcIixcbiAgXCJBRFZBTkNFRFwiOlwiYXZkYW5lY2RcIixcbiAgXCJBQ1RJVkVfUFJJS0VZXCI6XCJhY3R2IHBpcnZ0YSBrZWlcIixcbiAgXCJQT1NUSU5HX1BSSUtFWVwiOlwicHN0bmcgcGlydnRhIGtlaVwiLFxuICBcIk1BU1RFUl9QQVNTXCI6XCJtYXN0ci9tYW4gcHNhc3dyb2RcIixcbiAgXCJVU0VSTkFNRVwiOlwidXNybmFtXCIsXG4gIFwiQ0FSRF9WSUVXXCI6XCJjcmFkIHZlaXdcIixcbiAgXCJDT01QQUNUX1ZJRVdcIjpcImNtcGN0IHZlaXdcIixcbiAgXCJTRUFSQ0hcIjpcInNhZXJoY1wiLFxuICBcIlNVQk1JVF9BX1NUT1JZXCI6XCJzYnVtdGkgYSBzdHJpXCIsXG4gIFwiUkVQTFlUT1wiOlwicnBsaSB0dVwiLFxuICBcIlBPU1RcIjpcInBzb3RcIixcbiAgXCJQUkVWSUVXXCI6XCJwcnZld1wiLFxuICBcIkRFRkFVTFRcIjpcImRmYWx0IDUwJSAvIDUwJVwiLFxuICBcIlBPV0VSVVBcIjpcInB3ZXIgdXAgMTAwJVwiLFxuICBcIkRFQ0xJTkVfUEFZT1VUXCI6XCJkY2VsbmkgcHlhb3R1XCIsXG4gIFwiU0FWRV9GT1JfTEFURVJcIjpcInNhdiBmZXIgbHRlclwiLFxuICBcIkNMRUFSXCI6XCJcIixcbiAgXCJQT1NUX0NPTlRFTlRcIjpcInBzb3QgY250bnRcIixcbiAgXCJDT01NRU5UX0NPTlRFTlRcIjpcImNtb2V0biBjbnRudFwiLFxuICBcIlRJVExFXCI6XCJ0dGlsXCIsXG4gIFwiVEFHU1wiOlwidGVnelwiLFxuICBcIk5PVF9NQVRDSFwiOlwibm90IG10Y2hcIixcbiAgXCJDT05GSVJNX1BJTlwiOlwiY25mcm0gcGluXCIsXG4gIFwiSU5DT1JSRUNUXCI6XCJcIixcbiAgXCJPUEVOSU5HX1BPU1RcIjpcIm9wbm5nIHBzb3RcIixcbiAgXCJTRVRfUElOXCI6XCJzZXQgcGluXCIsXG4gIFwiRU5URVJfUElOXCI6XCJlbnRyIHBpblwiLFxuICBcIkFSRV9ZT1VfU1VSRVwiOlwiYXIgeXUgc3VyP1wiLFxuICBcIlJFQkxPR19URVhUXCI6XCJyc2V0bWUgaXogaXJ2cnNibCwgZHUgeXUgd2FuYW4gdHUgY250bj9cIixcbiAgXCJCUk9BRENBU1RfRVJST1JcIjpcImJyYW9kY3N0IGVvcnIsIHRyaSBhZ24hXCIsXG4gIFwiU1VDQ0VTU1wiOlwic2Njc3pcIixcbiAgXCJSRUJMT0dHRURfUE9TVFwiOlwicmVsYm9nZWQgcHNvdCFcIixcbiAgXCJMT0dJTl9GQUlMXCI6XCJsZ2luIGZpYWxkZSEgcGx6IG1hZWsgc3VyIHl1IGhldiBsZ29nZGUgaW4gd3RpaCBtc2F0cmUgcHNhc3dyb2Qgb3IgcG9ydmllZGQgcHN0bmcgcGlydnRhIGtlaSBvbiBsZ2luIGlmIHl1IGhldiBjdWhzZGUgYXZkYW5lY2QgbW9kLlwiLFxuICBcIkxPR0lOX0ZBSUxfQVwiOlwibGdpbiBmaWFsZGUhIHBseiBtYWVrIHN1ciB5dSBoZXYgbGdvZ2RlIGluIHd0aWggbXNhdHJlIHBzYXN3cm9kIG9yIHBvcnZpZWRkIGFjdHYgcGlydnRhIGtlaSBvbiBsZ2luIGlmIHl1IGhldiBjb2hzbmUgYXZkYW5lY2QgbW9kLlwiLFxuICBcIldBUk5JTkdcIjpcIndybm5nXCIsXG4gIFwiVk9URV9GT1JfV0lUTkVTU1wiOlwidnRvaWduIGZlciB3dG5zelwiLFxuICBcIlZPVEVEX0ZPUl9XSVRORVNTXCI6XCJ2dGVkIGZlciB3dG5zelwiLFxuICBcIkFHT1wiOlwiXCIsXG4gIFwiRlJPTV9OT1dcIjpcImZydW0gbm93XCIsXG4gIFwiU0VDU1wiOlwic2VjelwiLFxuICBcIkFfTUlOXCI6XCJcIixcbiAgXCJNSU5TXCI6XCJtaW56XCIsXG4gIFwiQU5fSE9VUlwiOlwiYW4gaHJ6XCIsXG4gIFwiSE9VUlNcIjpcImhyelwiLFxuICBcIkFfREFZXCI6XCJhIGRhaVwiLFxuICBcIkRBWVNcIjpcImR5YXpcIixcbiAgXCJBX01PTlRIXCI6XCJhIG1udGhcIixcbiAgXCJNT05USFNcIjpcIm1ub3R6aFwiLFxuICBcIkFfWUVBUlwiOlwiYSB5YWVyXCIsXG4gIFwiWUVBUlNcIjpcInlhcnpcIixcbiAgXCJNSU5fUkVBRFwiOlwibWluIHJhZWRcIixcbiAgXCJET1dOVk9URV9GTEFHXCI6XCJkd252b3Qgb3IgZmFsZ1wiLFxuICBcIkNBUFRVUkVfUElDVFVSRVwiOlwiY3BhdHJ1IHBjaXR1clwiLFxuICBcIlNFTEVDVF9QSUNUVVJFXCI6XCJzaWxlY3QgcGNpdHVyXCIsXG4gIFwiU0VUX0NVU1RPTV9VUkxcIjpcInNldCBjc3V0bW8gdXJsXCIsXG4gIFwiSU5TRVJUX1BJQ1RVUkVcIjpcImlzbmV0ciBwY2l0cnVcIixcbiAgXCJFUlJPUlwiOlwiZW9yclwiLFxuICBcIlVQTE9BRF9FUlJPUlwiOlwidWxwb2RhIGVvcnJcIixcbiAgXCJDQU1FUkFfQ0FOQ0VMTEVEXCI6XCJjbWFlYXIgY25hY2VlbGRcIixcbiAgXCJTRVRfVVJMXCI6XCJzZXQgdXJsXCIsXG4gIFwiRElSRUNUX0xJTktfUElDVFVSRVwiOlwiZHJpZXRjIHdlYiBsbmlrIGZlciB0ZWggcGNpdHJ1XCIsXG4gIFwiQ09NTUVOVF9TVUJNSVRURURcIjpcImNtb2V0biBpeiBzdW1iaXRlZCFcIixcbiAgXCJERUxFVEVfQ09NTUVOVFwiOlwiZGxlZXRuaWcgY21lbnR6IGFyIGlydnJzYmwuLi5cIixcbiAgXCJERUxFVEVEX0NPTU1FTlRcIjpcImRsZXRlZCBjbW9ldG5cIixcbiAgXCJVUExPQURJTkdfUElDVFVSRVwiOlwidXBvbGFkbmcgcGNpdHJ1XCIsXG4gIFwiVVBMT0FEX0NPTVBMRVRFRFwiOlwidWxwb2RhIGNvcG1sZWVkXCIsXG4gIFwiVVBMT0FEX0ZBSUxFRFwiOlwidWxwb2RhIGZpYWxkZVwiLFxuICBcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOlwidGVoIHBzYXN3cm9kIG9yIGFjY29udCBuYW0gd2F6IGljbm9yY2V0XCIsXG4gIFwiSU5GT1wiOlwiaWZub1wiLFxuICBcIlFSX1RFWFRcIjpcInBhbGMgYSBxciBjb2QgaW5zZCB0ZWggc2FjbiBhZXJhXCIsXG4gIFwiQkFMQU5DRV9URVhUXCI6XCJtYWVrIHN1ciB5dSBoZXYgZW9udWhnICQkIGZlciB0cmFuc2FjdG4hXCIsXG4gIFwiTk9ORVhJU1RfVVNFUlwiOlwidWVzciB5dSBhciB0eXJpZ24gdHUgdGFybnNlZnIgJCQsIGRzbid0IGV4c3QhXCIsXG4gIFwiVFJBTlNGRVJfVEVYVFwiOlwiYXIgeXUgc3VyIHl1IHdhbmFuIHR1IHRhcm5zZWZyP1wiLFxuICBcIkNPTkZJUk1BVElPTlwiOlwia29uZnJtYXRpblwiLFxuICBcIlRYX0JST0FEQ0FTVEVEXCI6XCJ0cmFuc2FjdG4gaXogYnJhZGNhc3RkXCIsXG4gIFwiRkVFRFwiOlwiZmVkXCIsXG4gIFwiVFJFTkRJTkdcIjpcInRlcm5kbmlnXCIsXG4gIFwiSE9UXCI6XCJob3RcIixcbiAgXCJORVdcIjpcIm5ld1wiLFxuICBcIlBST01PVEVEXCI6XCJwb3Jtb2V0ZFwiLFxuICBcIlZPVEVTXCI6XCJ2dG96XCIsXG4gIFwiUEFZT1VUXCI6XCJweWFvdHVcIixcbiAgXCJDT01NRU5UU1wiOlwiY21lbnR6XCIsXG4gIFwiVFJFTkRJTkdfMzBcIjpcInRlcm5kbmlnIGZlciAzMCBkeWF6XCIsXG4gIFwiU09SVF9QT1NUX0JZXCI6XCJzcm90IHBzdHogYnk6XCIsXG4gIFwiUEFZT1VUX0NZQ0xFXCI6XCJweWFvdHUgY2N5bFwiLFxuICBcIlBPVEVOVElBTF9QQVlPVVRcIjpcInBvZXRudGFsIHB5YW90dVwiLFxuICBcIlBBU1RfUEFZT1VUXCI6XCJwc2F0IHB5YW90dVwiLFxuICBcIkFVVEhPUl9QQVlPVVRcIjpcImF0dWhybyBweWFvdHVcIixcbiAgXCJDVVJBVElPTl9QQVlPVVRcIjpcImNydWF0b2luIHB5YW90dVwiLFxuICBcIlBPU1RfU1VCTUlUVEVEXCI6XCJwc290IGl6IHN1bWJpdGVkIVwiLFxuICBcIlBPU1RfTEFURVJcIjpcInBzb3QgZmVyIGx0ZXIgc2Jtc3NvbiFcIixcbiAgXCJTQVZFRFwiOlwic3ZlZFwiLFxuICBcIkNMRUFSRURcIjpcImNsYXJlZFwiLFxuICBcIkZMQUdHSU5HX1RFWFRcIjpcImZhbGdnbmlnIGEgcHNvdCBjbmEgcm1vdiByd2FyZHogYW5kIG1hZWsgZGl6IG10YWVyYWlsIGxzZXogdmlzaWJsZS48YnI+PGJyPnRoIGZhbGcgc29odWRsIGIgdWVzZCBmZXIgdGVoIGZvb2x3aWc6IDx1bD48bGk+ZnJhdXQgb3IgcGxhZ2lhcmlzbTwvbGk+PGxpPmhhdCBzcGNoIG9yIGl0bmVyZW50IHRyb2xpbmc8L2xpPjxsaT5pbnRlbnRpb25hbCBtc2thdGVnb3J6ZWQgY250bnQgb3Igc3BhbTwvbD48L3VsPlwiLFxuICBcIlJFUVVFU1RfTElNSVRfVEVYVFwiOlwicnF1c3QgbG1pdCByY2hlZC4gY2VoayBvdXQgb3RociB0cm5kL3RlZ3ohXCIsXG4gIFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6XCJwc290IGl6IHJtb3ZlZCBmcnVtIGJrdW1ha3J6IVwiLFxuICBcIlBPU1RfSVNfQk9PS01BUktcIjpcInBzb3QgaXogYWRkZCB0dSBia3VtYWtyeiFcIixcbiAgXCJSRVNFVFwiOlwicnNldFwiLFxuICBcIk1PRElGWV9QSUNUVVJFXCI6XCJjaG5nIHBvcmZsaSBwY2l0cnVcIixcbiAgXCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOlwiY2huZyBjdmVyIHBjaXRydVwiLFxuICBcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOlwicGx6IHBvcnZkaSBhY3R2IHBpcnZ0YSBrZWkgaWYgeXUgaGV2IGNvaHNuZSBhdmRhbmVjZCBsZ2luIG1vZCFcIixcbiAgXCJSRVNFVF9QSUNUVVJFX1RFWFRcIjpcImRpeiB3aWwgcnNldCB1ZXNyIHBvcmZsaSBwY2l0cnVcIixcbiAgXCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjpcImRpeiB3aWwgcnNldCB1ZXNyIGN2ZXIgcGNpdHJ1XCIsXG4gIFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjpcInNyZXZyZSB1cGR0IHJxdXJ6IHJzdHJ0IVwiLFxuICBcIlNFVFRJTkdTX1VQREFURURcIjpcInN0ZXRpZ256IGFyIHVwZGF0ZWQhXCIsXG4gIFwiTEFOR1VBR0VTXCI6XCJsbmFndWdhelwiLFxuICBcIkxBTkdVQUdFU19URVhUXCI6XCJoaXIgeXUgY25hIGNobmcgbG5nYWcgb2YgdGVoIGFwcC5cIixcbiAgXCJMT0dJTl9UT19YXCI6XCJkaXogb3ByZWF0b24gcnF1cnogdWVzciB0dSBiIGxnb2dkZSBpbiB3dGloIG1pYW4gcHNhc3dyb2QsIGFrdHZlL3Bvc3RuZyBrZWkuIHBseiBsZ2luIGFuZCB0cmkgYWduLlwiLFxuICBcIkdBTExFUllcIjpcImdsYWVpclwiLFxuICBcIlRSQU5TTEFUSU9OU1wiOlwidHJhbnNsYXRuIGtvbnRyYnV0cnpcIixcbiAgXCJTSEFSRVwiOlwic2hyZVwiLFxuICBcIk1BUktFVFBMQUNFXCI6XCJtcmFrdGUgcGFsY1wiLFxuICBcIkVYQ0hBTkdFXCI6XCJleGNobmdcIixcbiAgXCJEUkFGVFNcIjpcImRhcmZ6dFwiLFxuICBcIlBPU1RfSVNfVU5EUkFGVFwiOlwicHNvdCBpeiBybW92ZWQgZnJ1bSBkYXJmenQhXCIsXG4gIFwiUE9TVF9JU19EUkFGVFwiOlwicHNvdCBpeiBhZGRkIHR1IGRhcmZ6dCFcIixcbiAgXCJTV0lQRV9MRUZUXCI6XCJzaXdwIGxmZXQgdHUgYyBvcHRpbnpcIixcbiAgXCJNQU5BR0VcIjpcIm1uYWdcIixcbiAgXCJJTUFHRV9SRU1PVkVEXCI6XCJpYW1nIGl6IHJtb3ZlZFwiLFxuICBcIkNPUFlcIjpcImNwb2lcIixcbiAgXCJOT19JTUFHRVwiOlwieXUgaGV2IG5vdCB1bHBvYWVkZCBhbmkgaWFtZywgeWV0IVwiLFxuICBcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6XCJwdWwgZHdvbiB0dSByZnJzaFwiLFxuICBcIkVYVEVSTkFMX0FQUFNcIjpcImV0eGVyYW5sIGFwcHpcIixcbiAgXCJQTFVHSU5TXCI6XCJwbGduelwiLFxuICBcIlNVR0dFU1RcIjpcInNnZ3N0XCIsXG4gIFwiQ09NSU5HX1NPT05cIjpcImNtb2lnbiBzdW5cIixcbiAgXCJDSEFJTlwiOlwiY2hpblwiLFxuICBcIkNIQUlOX1RFWFRcIjpcImhpciB5dSBjbmEgY2huZyBibGNrY2hpbiBvciBkZmFsdCBwYWx0ZnJvbS5cIixcbiAgXCJDVVJSRU5DWVwiOlwiXCIsXG4gIFwiQ1VSUkVOQ1lfVEVYVFwiOlwiXCIsXG4gIFwiQUJPVVRfMTFcIjpcIlwiLFxuICBcIkZPVU5ERVJcIjpcIlwiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIkhPTUVcIjpcIs6Rz4HPh865zrrOrlwiLFxuICBcIkxPR0lOXCI6XCLOlc6vz4POv860zr/PglwiLFxuICBcIkxPR09VVFwiOlwizpHPgM6/z4PPjc69zrTOtc+DzrdcIixcbiAgXCJQUk9GSUxFXCI6XCLOoM+Bzr/Phs6vzrtcIixcbiAgXCJGT0xMT1dcIjpcIs6RzrrOv867zr/Pjc64zrfPg861XCIsXG4gIFwiQk9PS01BUktTXCI6XCLOo861zrvOuc60zr/OtM61zq/Ous+EzrXPglwiLFxuICBcIlRSQU5TRkVSXCI6XCLOnM61z4TOsc+Gzr/Pgc6sXCIsXG4gIFwiTUFSS0VUXCI6XCLOkc69z4TOsc67zrHOus+Ezq7Pgc65zr9cIixcbiAgXCJTRVRUSU5HU1wiOlwizqHPhc64zrzOr8+DzrXOuc+CXCIsXG4gIFwiQUJPVVRcIjpcIs6jz4fOtc+EzrnOus6sXCIsXG4gIFwiQUJPVVRfMVwiOlwiz4zPgM6/z4Ugzr8gzrrOsc64zq3Ovc6xz4IgzrzPgM6/z4HOtc6vIM69zrEgzrrOtc+BzrTOr8+DzrXOuSDOsc+Azr/Ou86xzrLOrc+CIM6xz4DPjCDPhM6/IM+AzrXPgc65zrXPh8+MzrzOtc69z4wgz4TOv8+FIVwiLFxuICBcIkFCT1VUXzJcIjpcIs61zq/Ovc6xzrkgzrLOsc+DzrnPg868zq3Ovc6/IM+Dz4TOt869IM+AzrvOsc+Ez4bPjM+BzrzOsSB7e3BsYXRmb3JtbmFtZX19LiDOlM63zrzOuc6/z4XPgc6zzq/OsSDOtc+GzrHPgc68zr/Os86uz4IgzrHPgM+MXCIsXG4gIFwiQUJPVVRfM1wiOlwizrrOsc65IM61zq/Ovc6xzrkgzrHOvc6/zrnPh8+Ez4zPgiDOus+OzrTOuc66zrHPgiwgzrrOsc+EzrXPhc64z4XOvc+MzrzOtc69zr/PgiDOsc+Az4wgz4TOt869IM66zr/Ouc69z4zPhM63z4TOsS7OoM+Bzr/Pg8+Gzq3Pgc61zrksIM+Az4HPjM+DzrLOsc+Dzrcgz4POtSDPgM61z4HOuc61z4fPjM68zrXOvc6/IM6zzrnOsSDOsc69zqzOs869z4nPg863LCDPg8+Hzr/Ou865zrHPg868z4wsIM+Izq7Phs65z4POtywgzrHOvc6sz4HPhM63z4POtywgzrzOtc+EzrHPhs6/z4HOrCDOsc+Azr/Ou86xzrLPjs69LCDOus+EzrsuIM60z4XOvc6xz4TPjM+EzrfPhM61z4Igz4TOuc+CIM6/z4DOv86vzrXPgiDPgM+Bzr/Pg8+Gzq3Pgc61zrkgz4TOvyB7e3BsYXRmb3JtbmFtZX19IGJsb2NrY2hhaW4gzrrOsc65IM+Ezr8ge3tzaXRlbmFtZX19LlwiLFxuICBcIkFCT1VUXzRcIjpcIjEuIM6XIM61z4bOsc+BzrzOv86zzq4gzrTOtc69IM6tz4fOtc65IM+Azr/PhM6tIM+Az4HPjM+DzrLOsc+Dzrcgzr/Pjc+EzrUgzrrPgc6xz4TOrM61zrkgz4TOsSDOus61z4bOrM67zrHOuc6xIM+Ez4nOvSDPh8+BzrfPg8+Ez47OvS5cIixcbiAgXCJBQk9VVF81XCI6XCIyLiDOlyDOtc+GzrHPgc68zr/Os86uIM+Az4HOv8+Dz4bOrc+BzrXOuSDOrc69zrEgzrzOv869z4TOrc67zr8gzrHPg8+GzrHOu861zq/Osc+CIM6xz4DPjCDPhM63zr0gz4DOu861z4XPgc6sIM+Ezr/PhSDPhM61z4HOvM6xz4TOuc66zr/PjSDPhM6/z4Ugz4fPgc6uz4PPhM63LCDOvM61IM+EzrEgzrnOtM65z4nPhM65zrrOrCDOus67zrXOuc60zrnOrCDOvc6xIFxcXCLPhs65zrvOv86+zrXOvc6/z43Ovc+EzrHOuVxcXCIgz4TOv8+AzrnOus6sIM+Hz4nPgc6vz4Igz4DOv8+Ezq0gzr3OsSDOsc+Azr/Pg8+Ezq3Ou867zr/Ovc+EzrHOuSDPg861IM6/z4DOv865zr/OtM6uz4DOv8+EzrUgzrTOuc6xzrrOv868zrnPg8+Ezq4uXCIsXG4gIFwiQUJPVVRfNlwiOlwiMy4gzpcgzrXPhs6xz4HOvM6/zrPOriDPgM+Bzr/Pg8+Gzq3Pgc61zrkgzrHPgM67z4wgzrrOsc65IM61zrvOus+Fz4PPhM65zrrPjCDPgM61z4HOuc6yzqzOu867zr/OvSDPh8+Bzq7Pg863z4IgzrrOsc65IM61zrzPgM61zrnPgc6vzrHPgi5cIixcbiAgXCJBQk9VVF83XCI6XCI0LCDOlyDOtc+GzrHPgc68zr/Os86uIM60zrXOvSDOuM6xIM62zrfPhM6uz4POtc65IM+Azr/PhM6tIM+Az4HOv8+Dz4nPgM65zrrOrc+CIM+AzrvOt8+Bzr/Phs6/z4HOr861z4IuXCIsXG4gIFwiQUJPVVRfOFwiOlwizqjOrs+GzrnPg861IGdvb2Qta2FybWEgzrPOuc6xIHdpdG5lc3NcIixcbiAgXCJBQk9VVF85XCI6XCLOlc+AzrnOus6/zrnOvc+Jzr3Or86xL86gzrHPgc6xz4TOt8+Bzq7Pg861zrnPglwiLFxuICBcIkFCT1VUXzEwXCI6XCLOoM61z4HOuc+Dz4PPjM+EzrXPgc61z4Igz4DOu863z4HOv8+Gzr/Pgc6vzrXPgjpcIixcbiAgXCJSRU1PVkVcIjpcIs6Rz4DOv868zqzOus+Bz4XOvc+DzrdcIixcbiAgXCJNQVJLRVRfVklFV1wiOlwizpXPgM6/z4DPhM61zq/OsSDOkc6zzr/Pgc6sz4JcIixcbiAgXCJQUklDRVwiOlwizqTOuc68zq5cIixcbiAgXCJBTU9VTlRcIjpcIs6gzr/Pg8+MXCIsXG4gIFwiVE9UQUxcIjpcIs6jz43Ovc6/zrvOv1wiLFxuICBcIk5PT1JERVJTXCI6XCLOlM61zr0gz4XPgM6sz4HPh86/z4XOvSDOsc69zr/Ouc+Hz4TOrc+CIM61zr3PhM6/zrvOrc+CIM6zzrnOsVwiLFxuICBcIkRBVEVcIjpcIs6XzrzOtc+Bzr/OvM63zr3Or86xXCIsXG4gIFwiQlVZXCI6XCLOkc6zzr/Pgc6sXCIsXG4gIFwiU0VMTFwiOlwizqDPjs67zrfPg863XCIsXG4gIFwiT1BFTlwiOlwizobOvc6/zrnOs868zrFcIixcbiAgXCJISVNUT1JZXCI6XCLOmc+Dz4TOv8+BzrnOus+MXCIsXG4gIFwiRk9MTE9XX0JBQ0tcIjpcIs6Rzr3Osc+DzrrPjM+AzrfPg863XCIsXG4gIFwiRk9MTE9XRURcIjpcIs6RzrrOv867zr/Phc64zrXOr8+CXCIsXG4gIFwiVU5GT0xMT1dcIjpcIs6czrcgzrHOus6/zrvOv8+FzrjOtc6vz4JcIixcbiAgXCJGT0xMT1dJTkdcIjpcIs6RzrrOv867zr/Phc64zrXOr8+CXCIsXG4gIFwiRk9MTE9XRVJTXCI6XCLOo861IM6xzrrOv867zr/Phc64zr/Pjc69XCIsXG4gIFwiU0VBUkNIX0ZPTExPV0VSU1wiOlwizqjOrM6+zrUgz4DOv865zr/OuSDPg861IM6xzrrOv867zr/Phc64zr/Pjc69XCIsXG4gIFwiU0VBUkNIX0ZPTExPV0lOR1wiOlwizqjOrM6+zrUgz4DOv865zr/Phc+CIM6xzrrOv867zr/Phc64zrXOr8+CXCIsXG4gIFwiQllcIjpcIs6xz4DPjFwiLFxuICBcIklOXCI6XCLPg861XCIsXG4gIFwiTUVOVVwiOlwizprOsc+EzqzOu86/zrPOv8+CIM61z4DOuc67zr/Os8+Ozr1cIixcbiAgXCJCT09LTUFSS1wiOlwizqPOtc67zrnOtM6/zrTOtc6vzrrPhM63z4JcIixcbiAgXCJSRUJMT0dcIjpcIs6Rzr3Osc60zrfOvM6/z4POr861z4XPg863XCIsXG4gIFwiVVBWT1RFXCI6XCLOmM61z4TOuc66zq4gz4jOrs+Gzr/PglwiLFxuICBcIkRPV05WT1RFXCI6XCLOkc+Bzr3Ot8+EzrnOus6uIM+Izq7Phs6/z4JcIixcbiAgXCJVTlZPVEVfRE9XTlZPVEVEXCI6XCLOlc+AzrHOvc6tz4bOtc+BzrUgzpHPgc69zrfPhM65zrrOrC3PiM63z4bOuc+DzrzOrc69zr9cIixcbiAgXCJVTlZPVEVfVVBWT1RFRFwiOlwizpXPgM6xzr3Orc+GzrXPgc61IM6YzrXPhM65zrrOrC3PiM63z4bOuc+DzrzOrc69zr9cIixcbiAgXCJSRVBMWVwiOlwizpHPgM6szr3PhM63z4POt1wiLFxuICBcIkVESVRcIjpcIs6Vz4DOtc6+zrXPgc6zzrHPg86vzrFcIixcbiAgXCJQT1NUXzFcIjpcIs6jz43Pgc61IM6xz4HOuc+Dz4TOtc+Bzqwgz4TOsSDPg8+Hz4zOu865zrEgzrPOuc6xIM69zrEgzrTOtc65z4IgzrXPgM65zrvOv86zzq3PglwiLFxuICBcIlBPU1RfMlwiOlwizpHOus6/z43OvM+AzrEgz4TOsSDPg8+Hz4zOu865zrEgzrPOuc6xIM69zrEgzrTOtc65z4Igz4XPgM+MLc+Dz4fPjM67zrnOsVwiLFxuICBcIk9QVElPTlNcIjpcIs6Vz4DOuc67zr/Os86tz4JcIixcbiAgXCJSRVNURUVNRURfQllcIjpcIs6Rzr3Osc60zrfOvM6/z4POr861z4XPg863IM6xz4DPjFwiLFxuICBcIk5PVEhJTkdfSEVSRVwiOlwizqTOr8+Azr/PhM6xIM61zrTPjiwgzrHOus+MzrzOsS4uLlwiLFxuICBcIkJBTEFOQ0VTXCI6XCLOlM65zrHOuM6tz4POuc68zrFcIixcbiAgXCJQUk9GSUxFXzFcIjpcInt7cGxhdGZvcm1uYW1lfX0sIM60zrnOsc+Az4HOsc6zzrzOsc+EzrXPjc+DzrnOvM61z4IgzrzOrM+BzrrOtc+CLCDPgM6/z4UgzrzPgM6/z4HOv8+Nzr0gzr3OsSDOvM61z4TOsc+GzrXPgc64zr/Pjc69IM6/z4DOv865zrHOtM6uz4DOv8+EzrUgz4PPhM65zrPOvM6uLiB7e3BsYXRmb3JtbmFtZX19IM68z4DOv8+Bzr/Pjc69IM69zrEgzrzOtc+EzrHPhM+BzrHPgM6/z43OvSDPg861IHt7cGxhdGZvcm1wb3dlcn19IM68zq3Pg8+JIM68zq/Osc+CIM60zrnOsc60zrnOus6xz4POr86xz4Igz4DOv8+FIM6/zr3Ov868zqzOts61z4TOsc65IHBvd2VyaW5nIHVwLiBcIixcbiAgXCJQUk9GSUxFXzJcIjpcInt7cGxhdGZvcm1wb3dlcn19LCDOvM6sz4HOus61z4IgzrXPgM65z4HPgc6/zq7PgiDPgM6/z4UgzrzPgM6/z4HOv8+Nzr0gzr3OsSDOsc+Azr/Ous+Ezq7Pg86/z4XOvSDPgM61z4HOuc+Dz4PPjM+EzrXPgc63IM60z43Ovc6xzrzOtywgzrrPgc6xz4TPjs69z4TOsc+CIM+EzrnPgiDOvM6xzrrPgc6/z4DPgc+MzrjOtc+DzrzOsSDOus6xzrkgz4jOt8+Gzq/Ots6/zr3PhM6xz4IgzrHOvc6xz4HPhM6uz4POtc65z4IuIM6Mz4POtc+CIM+AzrXPgc65z4PPg8+Mz4TOtc+BzrXPgiDOrc+HzrXOuSDPg8+EzrfOvSDOus6xz4TOv8+Hzq4gz4TOv8+FIM66zqzPgM6/zrnOv8+CLCDPhM+Mz4POvyDPgM61z4HOuc+Dz4PPjM+EzrXPgc6/IM68z4DOv8+BzrXOryDOvc6xIM61z4DOt8+BzrXOrM+DzrXOuSDPhM65z4IgzrHOvM6/zrnOss6tz4IgzqzOu867z4nOvSDOrM67zrvOsSDOus6xzrkgz4TOuc+CIM60zrnOus6tz4Igz4TOv8+FLlwiLFxuICBcIlBST0ZJTEVfM1wiOlwizpzOrM+BzrrOtc+CIM6xzr7Or86xz4Igz4DOtc+Bzq/PgM6/z4Uge3twbGF0Zm9ybXN1bml0fX0gz4TOv8+FIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG4gIFwiRVNUSU1BVEVEX1ZBTFVFXCI6XCLOkc6+zq/OsSDOus6xz4TOrCDOtc66z4TOr868zrfPg863IFwiLFxuICBcIlBST0ZJTEVfNFwiOlwizpcgzrHOvs6vzrEgzrrOsc+EzqwgzrXOus+Ezq/OvM63z4POtyDOtc6vzr3Osc65IM6yzrHPg865z4POvM6tzr3OtyDPg8+Ezr/OvSDOtc6yzrTOv868zrHOtM65zrHOr86/IM68zq3Pg86/IM+Mz4HOvyDPhM6/z4V7e3BsYXRmb3JtbmFtZX19LlwiLFxuICBcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjpcIs6Zz4PPhM6/z4HOuc66z4wgzqPPhc69zrHOu867zrHOs8+Ozr1cIixcbiAgXCJQT1NUSU5HXCI6XCLOkc69zqzPgc+EzrfPg863XCIsXG4gIFwiUFJPRklMRV81XCI6XCLOnyDOus+JzrTOuc66z4zPgiDOtM63zrzOv8+Dzq/Otc+Fz4POt8+CIM+Hz4HOt8+DzrnOvM6/z4DOv865zrXOr8+EzrHOuSDOs865zrEgzrTOt868zr/Pg865zrXPjc+DzrXOuc+CIM66zrHOuSDPhM63zr0gzrTPhc69zrHPhM+Mz4TOt8+EzrEgzrHPgM+MzrTOv8+DzrfPgiDPiM6uz4bOv8+FLiDOmM6xIM+Az4HOrc+AzrXOuSDOvc6xIM61zq/Ovc6xzrkgzrTOuc6xz4bOv8+BzrXPhM65zrrPjM+CIM6xz4DPjCDPhM6/zr0gXFxcIs61zr3Otc+BzrPPjFxcXCIgzrrPic60zrnOus+MIM66zrHOuSDPhM6/IM66z4nOtM65zrrPjCBcXFwizrnOtM65zr/Ous+EzrfPg86vzrHPglxcXCIuXCIsXG4gIFwiT1dORVJcIjpcIs6ZzrTOuc6/zrrPhM6uz4TOt8+CXCIsXG4gIFwiUFJPRklMRV82XCI6XCLOpM6/IM66zrvOtc65zrTOryDOuc60zrnOv866z4TOt8+Dzq/Osc+CIM61zq/Ovc6xzrkgz4TOvyDOus61zr3PhM+BzrnOus+MIM66zrvOtc65zrTOryDPhM6/z4UgzrvOv86zzrHPgc65zrHPg868zr/PjSDOus6xzrkgzrHPgM6xzrnPhM61zq/PhM6xzrkgzrPOuc6xIM69zrEgzrHOu867zqzOvs61zrkgz4zOu86xIM+EzrEgz4XPgM+MzrvOv865z4DOsSDOus67zrXOuc60zrnOrC4gzpjOsSDPgM+Bzq3PgM61zrkgzr3OsSDOus+BzrHPhM6sz4TOtSDOtc66z4TPjM+CIM+Dz43Ovc60zrXPg863z4Igz4TOvyDOuc60zrnPic+EzrnOus+MIM66zrvOtc65zrTOryDOriDOus+JzrTOuc66z4wgz4TOv8+FIM66zrvOtc65zrTOuc6/z40gzrnOtM65zr/Ous+EzrfPg86vzrHPgiDPjM+Dzr8gzrHPhc+Ez4wgzrXOr869zrHOuSDOtM+Fzr3Osc+Ez4zOvS5cIixcbiAgXCJBQ1RJVkVcIjpcIs6Vzr3Otc+BzrPPjFwiLFxuICBcIlBST0ZJTEVfN1wiOlwizqTOvyDOtc69zrXPgc6zz4wgzrrOu861zrnOtM6vIM+Hz4HOt8+DzrnOvM6/z4DOv865zrXOr8+EzrHOuSDOs865zrEgzrXOvM6yzqzPg868zrHPhM6xIM66zrHOuSDOtc69z4TOv867zq3PgiDOsc6zzr/Pgc6xz4DPic67zrfPg865z47OvSDPg8+Ezr8gzrXPg8+Jz4TOtc+BzrnOus+MIM6xzr3PhM6xzrvOu86xzrrPhM6uz4HOuc6/LlwiLFxuICBcIk1FTU9cIjpcIs6azrvOtc65zrTOuSAtIM6czrfOvc+FzrzOrM+Ez4nOvVwiLFxuICBcIlBST0ZJTEVfOFwiOlwizqTOvyDOms67zrXOuc60zq8gzpzOt869z4XOvM6sz4TPic69IM+Hz4HOt8+DzrnOvM6/z4DOv865zrXOr8+EzrHOuSDOs865zrEgzrTOt868zrnOv8+Fz4HOs86vzrEgzrrOsc65IM6xzr3OrM6zzr3Pic+DzrcgzrzOt869z4XOvM6sz4TPic69LlwiLFxuICBcIkJMT0dcIjpcIs6Zz4PPhM6/zrvPjM6zzrnOv1wiLFxuICBcIlBPU1RTXCI6XCLOkc69zrHPgc+Ezq7Pg861zrnPglwiLFxuICBcIlJFUExJRVNcIjpcIs6Rz4DOsc69z4TOrs+DzrXOuc+CXCIsXG4gIFwiV0FMTEVUXCI6XCLOoM6/z4HPhM6/z4bPjM67zrlcIixcbiAgXCJUQUdcIjpcIs6Vz4TOuc66zq3PhM6xXCIsXG4gIFwiVVNFUlwiOlwizqfPgc6uz4PPhM63z4JcIixcbiAgXCJDTE9TRVwiOlwizprOu861zq/Pg865zrzOv1wiLFxuICBcIlRPXCI6XCLOo861XCIsXG4gIFwiQVNTRVRcIjpcIs6azrXPhs6szrvOsc65zr9cIixcbiAgXCJTRU5EXCI6XCLOkc+Azr/Pg8+Ezr/Ou86uXCIsXG4gIFwiU0VDVVJJVFlcIjpcIs6Rz4PPhs6szrvOtc65zrFcIixcbiAgXCJBVkFJTEFCTEVcIjpcIs6UzrnOsc64zq3Pg865zrzOv1wiLFxuICBcIlBVQkxJQ19NRU1PXCI6XCLOlM63zrzPjM+DzrnOvyDOvM6uzr3Phc68zrFcIixcbiAgXCJUT19ERVNDXCI6XCLOp8+Bzq7Pg8+EzrfPgiDPgC7PhyBnb29kLWthcm1hXCIsXG4gIFwiUElOX0NPREVcIjpcIs6az4nOtM65zrrPjM+CIFBJTlwiLFxuICBcIlBJTl9URVhUXCI6XCLOms+JzrTOuc66z4zPgiBQSU4gz4POtSDOss6/zrfOuM6szrXOuSDOvc6xIM6xz4PPhs6xzrvOr8+DzrXOuc+CIM+EzrfOvSDOtc+GzrHPgc68zr/Os86uIM66zrHOuSDPhM6xIM60zrXOtM6/zrzOrc69zrEgz4POv8+FLiA8YnIvPjxici8+PGI+zqPOt868zrXOr8+Jz4POtzo8L2I+IM6Gz4DOsc6+IM66zrHOuSDOtc69zrXPgc6zzr/PgM6/zrnOt864zrXOrywgzq3Ph861zrnPgiBtYXggNCDPgM+Bzr/Pg8+AzqzOuM61zrnOtc+CIM6zzrnOsSDOvs61zrrOu861zq/OtM+JzrzOsS4gzpHOvSDOvs61z4fOrM+DzrXOuc+CIM+Ezr/OvSDOus+JzrTOuc66z4wgUElOIM6uIM6xz4DOv8+Ez43Ph861zrnPgiwgzrcgzrXPhs6xz4HOvM6/zrPOriDOuM6xIM66zrHPhM6xz4HOs86uz4POtc65IM+EzrEgz4PPhM6/zrnPh861zq/OsSDOtc65z4PPjM60zr/PhSDPhM6/z4Ugz4fPgc6uz4PPhM63Ls6cz4DOv8+BzrXOr8+CIM69zrEgzr7Osc69zqwgz4PPhc69zrTOtc64zrXOr8+CIM66zrHOuSDOvc6xIM+Dz4XOvc61z4fOr8+DzrXOuc+CIM69zrEgz4fPgc63z4POuc68zr/PgM6/zrnOtc6vz4Igz4TOt869IM61z4bOsc+BzrzOv86zzq4uXCIsXG4gIFwiTk9USUZJQ0FUSU9OU1wiOlwizpXOuc60zr/PgM6/zrnOrs+DzrXOuc+CXCIsXG4gIFwiVk9URV9URVhUXCI6XCLOmM6xIM67zqzOss61zrnPgiDOtc65zrTOv8+Azr/Or863z4POtyDPjM+EzrHOvSDOus6sz4DOv865zr/PgiDPiM63z4bOr8+DzrXOuSDPhM63zr0gzrHOvc6sz4HPhM63z4POtyDPg86/z4UuIDxici8+IDxiPs6jzrfOvM61zq/Pic+Dzrc6PC9iPiDOn865IM61zrnOtM6/z4DOv865zq7Pg861zrnPgiDPg8+FzrzPgM61z4HOuc67zrHOvM6yzqzOvc6/z4XOvSDPhM63zr0gzrLOsc+Bz43PhM63z4TOsSDPhM63z4Igz4jOrs+Gzr/PhSDOus6xzrjPjs+CIM61z4DOr8+DzrfPgiDPg861IM6tzrrPhM6xzrrPhM6xIM68zrfOvc+NzrzOsc+EzrEuICjOuM61z4TOuc66zq4gz4jOrs+Gzr8sIM6xz4HOvc63z4TOuc66zq4gz4jOrs+Gzr8sIM6xz4DPjC3PiM6uz4bOuc+DzrcpLlwiLFxuICBcIlZPVEVcIjpcIs6ozq7Phs+Jzr1cIixcbiAgXCJDT01NRU5UX1RFWFRcIjpcIs6YzrEgzrvOrM6yzrXOuc+CIM61zrnOtM6/z4DOv86vzrfPg863IM+Mz4TOsc69IM66zqzPgM6/zrnOv8+CIM+Dz4fOv867zrnOrM+DzrXOuSDOsc69zrHPgc+Ezq7Pg861zrnPgiDOtyDPg8+Hz4zOu865zrEgz4POv8+FITxici8+IDxiPs6jzrfOvM61zq/Pic+Dzrc6PC9iPiDOn865IM61zrnOtM6/z4DOv865zq7Pg861zrnPgiDPg8+FzrzPgM61z4HOuc67zrHOvM6yzqzOvc6/zr3PhM6xzrkgzrHOus+MzrzOsSDOus6xzrkgz4zPhM6xzr0gzrrOrM+Azr/Ouc6/z4IgPGI+zrXPgM61zr7Otc+BzrPOsc+Dz4TOtc6vPC9iPiDPhM6xIM+Dz4fPjM67zrnOsSDPhM6/z4UuXCIsXG4gIFwiQ09NTUVOVFwiOlwizqPPh86/zrvOr8+Jzr1cIixcbiAgXCJGT0xMT1dfVEVYVFwiOlwizpjOsSDOu86szrLOtc65z4IgzrXOuc60zr/PgM6/zq/Ot8+Dzrcgz4zPhM6xzr0gzrrOrM+Azr/Ouc6/z4Igz4POtSDOsc66zr/Ou86/z4XOuM6uz4POtc65IM6uIM+AzqzPiM61zrkgzr3OsSDPg861IM6xzrrOv867zr/Phc64zrXOry5cIixcbiAgXCJNRU5USU9OU1wiOlwizpXPgM65z4POt868zqzOvc+DzrXPic69XCIsXG4gIFwiTUVOVElPTlNfVEVYVFwiOlwizpjOsSDOu86szrLOtc65z4IgzrXOuc60zr/PgM6/zq/Ot8+Dzrcgz4zPhM6xzr0gzrrOrM+Azr/Ouc6/z4Igz4POtSDOsc69zrHPhs6tz4HOtc65IM+DzrUgzrHOvc6sz4HPhM63z4POty/Pg8+Hz4zOu865z4wgz4TOv8+FLlwiLFxuICBcIlJFU1RFRU1cIjpcIs6Rzr3Osc60zrfOvM6/z4POuc61z43Pg861z4nOvVwiLFxuICBcIlJFU1RFRU1fVEVYVFwiOlwizpjOsSDOu86szrLOtc65z4IgzrXOuc60zr/PgM6/zq/Ot8+Dzrcgz4zPhM6xzr0gzrrOrM+Azr/Ouc6/z4IgzrHOvc6xzrTOt868zr/Pg865zrXPjc+DzrXOuSDOsc69zqzPgc+EzrfPg86uIM+Dzr/PhS5cIixcbiAgXCJDT05GSUdVUkFUSU9OU1wiOlwizqHPhc64zrzOr8+DzrXOuc+CXCIsXG4gIFwiVk9USU5HXCI6XCLOqM63z4bOv8+Gzr/Pgc6vzrFcIixcbiAgXCJWT1RJTkdfVEVYVFwiOlwiXFxcIs6SzqzPgc6/z4JcXFwiIM+Izq7Phs6/z4Ugzq4gz4DOv8+Dzr/Pg8+Ez4wgzrXPgM63z4HOtc6szrbOtc65IM+EzrfOvSDOuc+Dz4fPjc+CIM+Izq7Phs6/z4Ugz4PPhM63zr0gzrXPhs6xz4HOvM6/zrPOriwgz47Pg8+EzrUgzr3OsSDPgc+FzrjOvM6vzrbOtc65z4Igz4TOuc+CIM6xz4DOv867zrHOss6tz4Igz4jOrs+Gz4nOvSA8YnIvPjxici8+PGI+zqPOt868zrXOr8+Jz4POtzo8L2I+IM6Rz4XPhM+MIM64zrEgzrHOu867zqzOvs61zrkgz4TOvyBcXFwizrLOrM+Bzr/PglxcXCIvz4DOv8+Dzr/Pg8+Ez4wgz4jOrs+Gzr/PhSDOs865zrEgzr3OsSDPiM63z4bOr8+DzrXOuc+CIM61z4DOr8+DzrfPgiDOsc+Bzr3Ot8+EzrnOus6sIM66zrHOuSDOuM6xIM65z4PPh8+NzrXOuSDPgM6xzr3PhM6/z40gz4PPhM63zr0gzrXPhs6xz4HOvM6/zrPOrlwiLFxuICBcIlNFUlZFUlwiOlwizpTOuc6xzrrOv868zrnPg8+Ezq7PglwiLFxuICBcIlNFUlZFUl9URVhUXCI6XCLOoM+Bzr/PhM61zrnOvc+MzrzOtc69zrFcIixcbiAgXCJTQVZFX0NIQU5HRVNcIjpcIs6Rz4DOv864zq7Ous61z4XPg863IM6RzrvOu86xzrPPjs69XCIsXG4gIFwiVk9URVJTX0lORk9cIjpcIs6gzrvOt8+Bzr/Phs6/z4HOr861z4Igz4jOt8+Gzr/Phs+Mz4HOv8+FXCIsXG4gIFwiV0VMQ09NRV9CQUNLXCI6XCLOms6xzrvPjs+CIM6uz4HOuM61z4Igzr7Osc69zqwhXCIsXG4gIFwiTE9HSU5fMVwiOlwizqPPhc69zrTOrc+Dzr/PhSDOvM61IM+Ezr8gz4zOvc6/zrzOsSDPh8+Bzq7Pg8+EzrcgzrrOsc65IM66z4nOtM65zrrPjCDOs865zrEgzr3OsSDPg8+Fzr3Otc+Hzq/Pg861zrnPgi5cIixcbiAgXCJMT0dJTl8yXCI6XCLOpM6/IM66zrvOtc65zrTOryDOtM63zrzOv8+Dzq/Otc+Fz4POt8+CIM+Hz4HOt8+DzrnOvM6/z4DOv865zrXOr8+EzrHOuSDOs865zrEgzrHOvc6sz4HPhM63z4POtywgz4PPh86/zrvOuc6xz4POvM+MLCDPiM6uz4bOvyDOus6xzrkgz4TOt869IM60z4XOvc6xz4TPjM+EzrfPhM6xIM69zrEgzrHOus6/zrvOv8+FzrjOrs+DzrXOuc+CIM66zqzPgM6/zrnOv869LlwiLFxuICBcIkxPR0lOXzNcIjpcIs6kzr8gzrXOvc61z4HOs8+MIM66zrvOtc65zrTOryDPh8+BzrfPg865zrzOv8+Azr/Ouc61zq/PhM6xzrkgzrPOuc6xIM68zrXPhM6xz4bOv8+Bzq3PgiDOus6xzrkgzrHOu867zrHOs86uIM+Gz4nPhM6/zrPPgc6xz4bOr86xz4Igz4TOv8+FIM+Az4HOv8+Gzq/Ouy5cIixcbiAgXCJMT0dJTl80XCI6XCLOpM6xIM+Dz4TOv865z4fOtc6vzrEgz4fPgc6uz4PPhM63IM6xz4DOv864zrfOus61z43Ov869z4TOsc65IM+Dz4TOtyDPg8+Fz4POus61z4XOriDPhM6/z4DOuc66zqwuIM6azrHPhM6sIM+EzrfOvSDOtM65zqzPgc66zrXOuc6xIM6xz4DOv8+Dz43Ovc60zrXPg863z4Igz4TOsSDPg8+Ezr/Ouc+HzrXOr86xIM60zrnOsc6zz4HOrM+Gzr/Ovc+EzrHOuS5cIixcbiAgXCJET05UX0hBVkVcIjpcIs6UzrXOvSDOrc+HzrXOuc+CIM67zr/Os86xz4HOuc6xz4POvM+MP1wiLFxuICBcIlNJR05fVVBfTk9XXCI6XCLOms6szr3OtSDOtc6zzrPPgc6xz4bOriDPhM+Oz4HOsVwiLFxuICBcIkNBTkNFTFwiOlwizpHOus+Nz4HPic+DzrdcIixcbiAgXCJBRFZBTkNFRFwiOlwizpPOuc6xIM+Az4HOv8+Hz4nPgc63zrzOrc69zr/Phc+CXCIsXG4gIFwiQUNUSVZFX1BSSUtFWVwiOlwizpXOvc61z4HOs8+MIM65zrTOuc+Jz4TOuc66z4wgzrrOu861zrnOtM6vXCIsXG4gIFwiUE9TVElOR19QUklLRVlcIjpcIs6ZzrTOuc+Jz4TOuc66z4wgzrrOu861zrnOtM6vIM60zrfOvM6/z4POr861z4XPg863z4JcIixcbiAgXCJNQVNURVJfUEFTU1wiOlwizprPhc+Bzq/Pic+CL86gz4HPic+EzrXPjc+Jzr0gzrrPic60zrnOus+Mz4JcIixcbiAgXCJVU0VSTkFNRVwiOlwizozOvc6/zrzOsSDOp8+BzrfPg8+EzrdcIixcbiAgXCJDQVJEX1ZJRVdcIjpcIs6gz4HOv86yzr/Ou86uIM+DzrUgzprOsc+Bz4TOrc67zrXPglwiLFxuICBcIkNPTVBBQ1RfVklFV1wiOlwizqPPhc69zrXPgM+Ez4XOs868zq3Ovc63IM6gz4HOv86yzr/Ou86uXCIsXG4gIFwiU0VBUkNIXCI6XCLOkc69zrHOts6uz4TOt8+DzrdcIixcbiAgXCJTVUJNSVRfQV9TVE9SWVwiOlwizp7Otc66zq/Ovc6xIM6xzr3OrM+Bz4TOt8+DzrdcIixcbiAgXCJSRVBMWVRPXCI6XCLOkc+AzqzOvc+EzrfPg861IM+DzrVcIixcbiAgXCJQT1NUXCI6XCLOkc69zqzPgc+EzrfPg861XCIsXG4gIFwiUFJFVklFV1wiOlwizqDPgc6/zrXPgM65z4POus+Mz4DOt8+DzrdcIixcbiAgXCJERUZBVUxUXCI6XCLOoM+Bzr/Otc+AzrnOu86/zrPOriA1MCUgLyA1MCVcIixcbiAgXCJQT1dFUlVQXCI6XCLOkc+Nzr7Ot8+DzrcgzpnPg8+Hz43Ov8+CIDEwMCVcIixcbiAgXCJERUNMSU5FX1BBWU9VVFwiOlwizpHPgM+Mz4HPgc65z4jOtyDOkc+Azr/Ou86xzrLPjs69XCIsXG4gIFwiU0FWRV9GT1JfTEFURVJcIjpcIs6RzqDOn86YzonOms6VzqXOo86VIM6TzpnOkSDOkc6hzpPOn86kzpXOoc6RXCIsXG4gIFwiQ0xFQVJcIjpcIs6azpHOmM6RzqHOmc6jzpzOkVwiLFxuICBcIlBPU1RfQ09OVEVOVFwiOlwizpHOvc6sz4HPhM63z4POtyDPgM61z4HOuc61z4fOv868zq3Ovc6/z4VcIixcbiAgXCJDT01NRU5UX0NPTlRFTlRcIjpcIs6jz4fOv867zq/Osc+DzrUgz4DOtc+BzrnOtc+Hz4zOvM61zr3Ov1wiLFxuICBcIlRJVExFXCI6XCLOpM6vz4TOu86/z4JcIixcbiAgXCJUQUdTXCI6XCLOlc+EzrnOus6tz4TOtc+CXCIsXG4gIFwiTk9UX01BVENIXCI6XCLOlM6VIM6jzqXOnM6gzorOoM6kzpXOmVwiLFxuICBcIkNPTkZJUk1fUElOXCI6XCLOlc+AzrnOss61zrLOsc6vz4nPg861IFBJTlwiLFxuICBcIklOQ09SUkVDVFwiOlwizpvOkc6dzpjOkc6jzpzOlc6dzp9cIixcbiAgXCJPUEVOSU5HX1BPU1RcIjpcIs6Gzr3Ov865zr7OtSDOkc69zqzPgc+EzrfPg863XCIsXG4gIFwiU0VUX1BJTlwiOlwizozPgc65z4POtSBQSU5cIixcbiAgXCJFTlRFUl9QSU5cIjpcIs6VzrnPg86xzrPPic6zzq4gUElOXCIsXG4gIFwiQVJFX1lPVV9TVVJFXCI6XCLOlc6vz4POsc65IM+Dzq/Os86/z4XPgc6/z4I/XCIsXG4gIFwiUkVCTE9HX1RFWFRcIjpcIs6XIM6xzr3Osc60zrfOvM6/z4POr861z4XPg863IM61zq/Ovc6xzrkgzrzOtyDOsc69zrHPg8+Ez4HOrc+IzrnOvM63LCDOuM6tzrvOtc65z4Igzr3OsSDPg8+Fzr3Otc+Hzq/Pg861zrnPgj9cIixcbiAgXCJCUk9BRENBU1RfRVJST1JcIjpcIs6bzqzOuM6/z4IgzrzOtc+EzqzOtM6/z4POt8+CLCDPgM+Bzr/Pg8+AzqzOuM63z4POtSDOvs6xzr3OrCFcIixcbiAgXCJTVUNDRVNTXCI6XCLOlc+AzrnPhM+Fz4fOrc+CXCIsXG4gIFwiUkVCTE9HR0VEX1BPU1RcIjpcIs6Rzr3Osc60zrfOvM6/z4POuc61z4XOvM6tzr3OtyDOsc69zqzPgc+EzrfPg863IVwiLFxuICBcIkxPR0lOX0ZBSUxcIjpcIs6XIM+Dz43Ovc60zrXPg863IM6xz4DOrc+Ez4XPh861ISDOoM6xz4HOsc66zrHOu8+OIM61zr7Osc66z4HOuc6yz47Pg8+EzrUgzrHOvSDPg8+Fzr3OtM61zrjOrs66zrHPhM61IM68zrUgz4TOv869IM66z4XPgc6vz4nPgiDOus+JzrTOuc66z4wgzq4gzrTPjs+DzrHPhM61IM+Ezr8gzrnOtM65z4nPhM65zrrPjCDOus67zrXOuc60zq8gzrTOt868zr/Pg86vzrXPhc+DzrfPgiDPjM+EzrHOvSDOtc+AzrnOu86tzr7Osc+EzrUgz4PPjc69zrTOtc+DzrcgzrPOuc6xIM+Az4HOv8+Hz4nPgc63zrzOrc69zr/Phc+CLlwiLFxuICBcIkxPR0lOX0ZBSUxfQVwiOlwizpcgz4PPjc69zrTOtc+DzrcgzrHPgM6tz4TPhc+HzrUhIM6gzrHPgc6xzrrOsc67z44gzrXOvs6xzrrPgc65zrLPjs+Dz4TOtSDOsc69IM+Dz4XOvc60zrXOuM6uzrrOsc+EzrUgzrzOtSDPhM6/zr0gzrrPhc+Bzq/Pic+CIM66z4nOtM65zrrPjCDOriDOtM+Oz4POsc+EzrUgz4TOvyDOtc69zrXPgc6zz4wgzrrOu861zrnOtM6vIM60zrfOvM6/z4POr861z4XPg863z4Igz4zPhM6xzr0gzrXPgM65zrvOrc6+zrHPhM61IM+Dz43Ovc60zrXPg863IM6zzrnOsSDPgM+Bzr/Ph8+Jz4HOt868zq3Ovc6/z4XPgi5cIixcbiAgXCJXQVJOSU5HXCI6XCLOoM+Bzr/Otc65zrTOv8+Azr/Or863z4POt1wiLFxuICBcIlZPVEVfRk9SX1dJVE5FU1NcIjpcIs6ozq7Phs65z4POtSDOs865zrEgd2l0bmVzc1wiLFxuICBcIlZPVEVEX0ZPUl9XSVRORVNTXCI6XCLOqM63z4bOr8+Dz4TOt866zrUgzrPOuc6xIHdpdG5lc3NcIixcbiAgXCJBR09cIjpcIs+Az4HOuc69XCIsXG4gIFwiRlJPTV9OT1dcIjpcIs6xz4DPjCDPhM+Oz4HOsVwiLFxuICBcIlNFQ1NcIjpcIs60zrXPhc+ELlwiLFxuICBcIkFfTUlOXCI6XCLPhM6/IM67zrXPgM+Ez4xcIixcbiAgXCJNSU5TXCI6XCLOu861z4DPhM6sXCIsXG4gIFwiQU5fSE9VUlwiOlwizrzOr86xIM+Oz4HOsVwiLFxuICBcIkhPVVJTXCI6XCLPjs+BzrXPglwiLFxuICBcIkFfREFZXCI6XCLOvM6vzrEgzrfOvM6tz4HOsVwiLFxuICBcIkRBWVNcIjpcIs68zq3Pgc61z4JcIixcbiAgXCJBX01PTlRIXCI6XCLOrc69zrEgzrzOrs69zrFcIixcbiAgXCJNT05USFNcIjpcIs68zq7Ovc61z4JcIixcbiAgXCJBX1lFQVJcIjpcIs6tzr3OsSDPh8+Bz4zOvc6/XCIsXG4gIFwiWUVBUlNcIjpcIs+Hz4HPjM69zrnOsVwiLFxuICBcIk1JTl9SRUFEXCI6XCLOu861z4DPhM6sIM6xzr3OrM6zzr3Pic+DzrfPglwiLFxuICBcIkRPV05WT1RFX0ZMQUdcIjpcIs6ozq7Phs65z4POtSDOsc+Bzr3Ot8+EzrnOus6sIM6uIM66zqzOvc61IEZsYWdcIixcbiAgXCJDQVBUVVJFX1BJQ1RVUkVcIjpcIs6Rz4DOv864zrHOvc6sz4TOuc+DzrUgzqbPic+Ezr/Os8+BzrHPhs6vzrFcIixcbiAgXCJTRUxFQ1RfUElDVFVSRVwiOlwizpXPgM6tzrvOtc6+zrUgzqbPic+Ezr/Os8+BzrHPhs6vzrFcIixcbiAgXCJTRVRfQ1VTVE9NX1VSTFwiOlwizprOsc64z4zPgc65z4POtSDPgM+Bzr/Pg86xz4HOvM6/z4POvM6tzr3OvyBVUkxcIixcbiAgXCJJTlNFUlRfUElDVFVSRVwiOlwizpXOuc+Dzq7Os86xzrPOtSDOps+Jz4TOv86zz4HOsc+Gzq/OsVwiLFxuICBcIkVSUk9SXCI6XCLOm86szrjOv8+CXCIsXG4gIFwiVVBMT0FEX0VSUk9SXCI6XCLOm86szrjOv8+CIM6xz4DOv8+Dz4TOv867zq7PglwiLFxuICBcIkNBTUVSQV9DQU5DRUxMRURcIjpcIs6azqzOvM61z4HOsSDOkc66z4XPgc+OzrjOt866zrVcIixcbiAgXCJTRVRfVVJMXCI6XCLOms6xzrjPjM+BzrnPg861IFVSTFwiLFxuICBcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjpcIs6GzrzOtc+Dzr/PgiDPg8+Nzr3OtM61z4POvM6/z4IgzrPOuc6xIM+EzrfOvSDPhs+Jz4TOv86zz4HOsc+Gzq/OsVwiLFxuICBcIkNPTU1FTlRfU1VCTUlUVEVEXCI6XCLOpM6/IM+Dz4fPjM67zrnOvyDPhc+Azr/Oss67zq7OuM63zrrOtSFcIixcbiAgXCJERUxFVEVfQ09NTUVOVFwiOlwizpcgzrTOuc6xzrPPgc6xz4bOriDPg8+Hzr/Ou86vz4nOvSDOtc6vzr3Osc65IM68zrcgzrHOvc6xz4PPhM+Bzq3PiM65zrzOty4uLlwiLFxuICBcIkRFTEVURURfQ09NTUVOVFwiOlwizpTOuc6xzrPPgc6xzrzOvM6tzr3OvyDPg8+Hz4zOu865zr9cIixcbiAgXCJVUExPQURJTkdfUElDVFVSRVwiOlwizpHPgM6/z4PPhM6/zrvOriDOps+Jz4TOv86zz4HOsc+Gzq/Osc+CXCIsXG4gIFwiVVBMT0FEX0NPTVBMRVRFRFwiOlwizpHPgM6/z4PPhM6/zrvOriDOn867zr/Ous67zrfPgc+OzrjOt866zrVcIixcbiAgXCJVUExPQURfRkFJTEVEXCI6XCLOkc+Azr/Pg8+Ezr/Ou86uIM6Rz4DOrc+Ez4XPh861XCIsXG4gIFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6XCLOnyDOus+JzrTOuc66z4zPgiDOriDPhM6/IM+Mzr3Ov868zrEgzrvOv86zzrHPgc65zrHPg868zr/PjSDOrs+EzrHOvSDOu86xzr3OuM6xz4POvM6tzr3Ov1wiLFxuICBcIklORk9cIjpcIs6gzrvOt8+Bzr/Phs6/z4HOr861z4JcIixcbiAgXCJRUl9URVhUXCI6XCLOpM6/z4DOv864zq3PhM63z4POtSDOrc69zrEgUVIgzrrPic60zrnOus+MIM+Dz4TOt869IM+Ezr/PgM6/zrjOtc+Dzq/OsSDPg86sz4HPic+DzrfPglwiLFxuICBcIkJBTEFOQ0VfVEVYVFwiOlwizpXOvs6xzrrPgc6vzrLPic+DzrUgz4zPhM65IM6tz4fOtc65z4IgzrTOuc6xzrjOrc+DzrnOvM6xIM66zrXPhs6szrvOsc65zrEgzrPOuc6xIM+Dz4XOvc6xzrvOu86xzrPOriFcIixcbiAgXCJOT05FWElTVF9VU0VSXCI6XCLOnyDPh8+Bzq7Pg8+EzrfPgiDPgM6/z4Ugz4DPgc6/z4PPgM6xzrjOtc6vz4Igzr3OsSDOvM61z4TOsc+Gzq3Pgc61zrnPgiDOus61z4bOrM67zrHOuc6xLCDOtM61zr0gz4XPgM6sz4HPh861zrkhXCIsXG4gIFwiVFJBTlNGRVJfVEVYVFwiOlwizpXOr8+Dz4TOtSDPg86vzrPOv8+Fz4HOv8+CIM+Mz4TOuSDOuM6tzrvOtc+EzrUgzr3OsSDOus6szr3Otc+EzrUgzrzOtc+EzrHPhs6/z4HOrD9cIixcbiAgXCJDT05GSVJNQVRJT05cIjpcIs6Vz4DOuc6yzrXOss6xzq/Pic+DzrdcIixcbiAgXCJUWF9CUk9BRENBU1RFRFwiOlwizpcgz4PPhc69zrHOu867zrHOs86uIM68zrXPhM6xzrTPjM64zrfOus61XCIsXG4gIFwiRkVFRFwiOlwizpHOvc6xz4HPhM6uz4POtc65z4IgzrHPgM+MIM+Hz4HOrs+Dz4TOtc+CIM+Azr/PhSDOsc66zr/Ou86/z4XOuM61zq/PglwiLFxuICBcIlRSRU5ESU5HXCI6XCLOlM63zrzOv8+GzrnOu86tz4PPhM61z4HOtc+CIM6xzr3Osc+Bz4TOrs+DzrXOuc+CXCIsXG4gIFwiSE9UXCI6XCLOkc69zrHPgc+Ezq7Pg861zrnPgiDOvM61IM+Fz4jOt867zq4gzrTPgc6xz4PPhM63z4HOuc+Mz4TOt8+EzrFcIixcbiAgXCJORVdcIjpcIs6gz4HPjM+Dz4bOsc+EzrXPgiDOsc69zrHPgc+Ezq7Pg861zrnPglwiLFxuICBcIlBST01PVEVEXCI6XCLOoM+Bzr/Pic64zr/Pjc68zrXOvc6xXCIsXG4gIFwiVk9URVNcIjpcIs6SzqzPg863IM+Izq7Phs+Jzr1cIixcbiAgXCJQQVlPVVRcIjpcIs6SzqzPg863IM6xz4DOv860zr/Ph8+Ozr1cIixcbiAgXCJDT01NRU5UU1wiOlwizpLOrM+Dzrcgz4PPh86/zrvOr8+Jzr1cIixcbiAgXCJUUkVORElOR18zMFwiOlwizpTOt868zr/Phs65zrvOrc+Dz4TOtc+BzrXPgiDOsc69zrHPgc+Ezq7Pg861zrnPgiAzMCDOt868zrXPgc+Ozr1cIixcbiAgXCJTT1JUX1BPU1RfQllcIjpcIs6kzrHOvs65zr3PjM68zrfPg863IM6yzqzPg863OlwiLFxuICBcIlBBWU9VVF9DWUNMRVwiOlwizprPjc66zrvOv8+CIM+AzrvOt8+Bz4nOvM6uz4JcIixcbiAgXCJQT1RFTlRJQUxfUEFZT1VUXCI6XCLOoM65zrjOsc69zq3PgiDOkc+Azr/OtM6/z4fOrc+CXCIsXG4gIFwiUEFTVF9QQVlPVVRcIjpcIs6gzrHOu86xzrnPjM+EzrXPgc61z4IgzpHPgM6/zrTOv8+Hzq3PglwiLFxuICBcIkFVVEhPUl9QQVlPVVRcIjpcIs6Rz4DOv860zr/Ph86tz4IgzqPPhc6zzrPPgc6xz4bOrc6xXCIsXG4gIFwiQ1VSQVRJT05fUEFZT1VUXCI6XCLOkc+Azr/OtM6/z4fOrc+CIM6xz4DPjCBDdXJhdGlvblwiLFxuICBcIlBPU1RfU1VCTUlUVEVEXCI6XCLOlyDOsc69zqzPgc+EzrfPg863IM+Fz4DOv86yzrvOrs64zrfOus61IVwiLFxuICBcIlBPU1RfTEFURVJcIjpcIs6Rzr3OrM+Bz4TOt8+DzrcgzrPOuc6xIM68zrXOu867zr/Ovc+EzrnOus6uIM66zr/Ouc69zr/PgM6/zq/Ot8+DzrchXCIsXG4gIFwiU0FWRURcIjpcIs6Rz4DOv864zrfOus61z43PhM63zrrOtVwiLFxuICBcIkNMRUFSRURcIjpcIs6jzrLOrs+Dz4TOt866zrVcIixcbiAgXCJGTEFHR0lOR19URVhUXCI6XCLOms6xz4TOsc+IzrfPhs6vzrbOv869z4TOsc+CIM68zrnOsSDOsc69zqzPgc+EzrfPg863IM68z4DOv8+BzrXOryDOvc6xIM+EzrfPgiDOsc+GzrHOuc+Bzq3Pg861zrkgzrHOvM6/zrnOss6tz4IgzrrOsc65IM69zrEgz4TOt869IM66zqzOvc61zrkgzrvOuc6zz4zPhM61z4HOvyDOv8+BzrHPhM6uLjxicj48YnI+IM6XIM66zrHPhM6xz4jOrs+GzrnPg863IM64zrEgzq3PgM+BzrXPgM61IM69zrEgz4fPgc63z4POuc68zr/PgM6/zrnOtc6vz4TOsc65IM6zzrnOsTogPHVsPjxsaT7Okc+AzqzPhM63IM6uIM66zrvOv8+Azq4gz4DOvc61z4XOvM6xz4TOuc66z47OvSDOtM65zrrOsc65z47OvM6xz4TPic69PC9saT48bGk+zqXOss+BzrnPg8+EzrnOus6uIM6zzrvPjs+Dz4POsSDOus6xzrkgVHJvbGxpbmc8L2xpPjxsaT7Olc+DzrrOtc68zrzOrc69zrcgz4TOv8+Azr/OuM6tz4TOt8+Dzrcgz4POtSDOu86szrjOv8+CIM66zrHPhM63zrPOv8+Bzq/OsSDPgM61z4HOuc61z4fOv868zq3Ovc6/z4Ugzq4gU3BhbTwvbGk+PC91bD5cIixcbiAgXCJSRVFVRVNUX0xJTUlUX1RFWFRcIjpcIs6kzr8gzrHOr8+EzrfOvM6xIM6tz4bPhM6xz4POtSDPg8+Ezr8gz4zPgc65zr8gz4TOv8+FLiDOlc67zq3Os86+z4TOtSDOrM67zrvOtc+CIM61z4TOuc66zq3PhM61z4IvzrrOsc+EzrfOs86/z4HOr861z4JcIixcbiAgXCJQT1NUX0lTX1VOQk9PS01BUktcIjpcIs6XIM6xzr3OrM+Bz4TOt8+DzrcgzrHPgM6/zrzOsc66z4HPjc69zrjOt866zrUgzrHPgM+MIM+Ezr/Phc+CIM+DzrXOu865zrTOv860zrXOr866z4TOtc+CIVwiLFxuICBcIlBPU1RfSVNfQk9PS01BUktcIjpcIs6XIM6xzr3OrM+Bz4TOt8+Dzrcgz4DPgc6/z4PPhM6tzrjOt866zrUgz4PPhM6/z4XPgiDPg861zrvOuc60zr/OtM61zq/Ous+EzrXPgiFcIixcbiAgXCJSRVNFVFwiOlwizpXPgM6xzr3Osc+Gzr/Pgc6sIM6xz4HPh865zrrPjs69IM+Bz4XOuM68zq/Pg861z4nOvVwiLFxuICBcIk1PRElGWV9QSUNUVVJFXCI6XCLOlc+AzrXOvs61z4HOs86xz4POr86xIM6mz4nPhM6/zrPPgc6xz4bOr86xz4IgzqDPgc6/z4bOr867XCIsXG4gIFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjpcIs6Vz4DOtc6+zrXPgc6zzrHPg86vzrEgz4bPic+Ezr/Os8+BzrHPhs6vzrHPgiDPgM+Bzr/Phs6vzrtcIixcbiAgXCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjpcIs6gzrHPgc6xzrrOsc67z44gzrTPjs+DzrUgzpXOvc61z4HOs8+ML0FjdGl2ZSDOuc60zrnPic+EzrnOus+MIM66zrvOtc65zrTOryDOtc6szr0gzrXPgM6tzrvOtc6+zrXPgiDPg8+Nzr3OtM61z4POtyDOs865zrEgz4DPgc6/z4fPic+BzrfOvM6tzr3Ov8+Fz4IhXCIsXG4gIFwiUkVTRVRfUElDVFVSRV9URVhUXCI6XCLOkc+Fz4TPjCDOuM6xIM66zqzOvc61zrkgzrXPgM6xzr3Osc+Gzr/Pgc6sIM+EzrfPgiDPhs+Jz4TOv86zz4HOsc+Gzq/Osc+CIM+Ezr/PhSDPgM+Bzr/Phs6vzrtcIixcbiAgXCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjpcIs6Rz4XPhM+MIM64zrEgzrXPgM6xzr3Osc+Gzq3Pgc61zrkgz4TOt869IM61zrnOus+Mzr3OsSDPh8+Bzq7Pg8+EzrdcIixcbiAgXCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOlwizpcgzrHOvc6xzrLOrM64zrzOuc+Dzrcgz4TOv8+FIM60zrnOsc66zr/OvM65z4PPhM6uIM6xz4DOsc65z4TOtc6vIM61z4DOsc69zrXOus66zq/Ovc63z4POtyFcIixcbiAgXCJTRVRUSU5HU19VUERBVEVEXCI6XCLOn865IM+Bz4XOuM68zq/Pg861zrnPgiDOtc69zrXPgc6zzr/PgM6/zrnOrs64zrfOus6xzr0hXCIsXG4gIFwiTEFOR1VBR0VTXCI6XCLOk867z47Pg8+DzrXPglwiLFxuICBcIkxBTkdVQUdFU19URVhUXCI6XCLOlc60z44gzrzPgM6/z4HOtc6vz4Igzr3OsSDOsc67zrvOrM6+zrXOuc+CIM+EzrfOvSDOs867z47Pg8+DzrEgz4TOt8+CIM61z4bOsc+BzrzOv86zzq7Pgi5cIixcbiAgXCJMT0dJTl9UT19YXCI6XCLOkc+Fz4TOriDOtyDOu861zrnPhM6/z4XPgc6zzq/OsSDOsc+AzrHOuc+EzrXOryDOvyDPh8+Bzq7Pg8+EzrfPgiDOvc6xIM61zq/Ovc6xzrkgz4PPhc69zrTOtc60zrXOvM6tzr3Ov8+CIM68zrUgz4TOv869IM66z4XPgc65z47PgiDOus+JzrTOuc66z4wgYWN0aXZlL3Bvc3Rpbmcga2V5Ls6gzrHPgc6xzrrOsc67z44gz4PPhc69zrTOrc+Dzr/PhSDOus6xzrkgz4DPgc6/z4PPgM6szrjOt8+DzrUgzr7Osc69zqwuXCIsXG4gIFwiR0FMTEVSWVwiOlwizojOus64zrXPg863XCIsXG4gIFwiVFJBTlNMQVRJT05TXCI6XCLOo8+Fzr3PhM61zrvOtc+Dz4TOrc+CIM68zrXPhM6sz4bPgc6xz4POt8+CXCIsXG4gIFwiU0hBUkVcIjpcIs6czr/Ouc+BzqzPg86/z4VcXG5cIixcbiAgXCJNQVJLRVRQTEFDRVwiOlwizpHOs86/z4HOrFwiLFxuICBcIkVYQ0hBTkdFXCI6XCLOkc69z4TOsc67zrvOsc66z4TOrs+BzrnOv1wiLFxuICBcIkRSQUZUU1wiOlwizqDPgc+Mz4fOtc65z4HOsVwiLFxuICBcIlBPU1RfSVNfVU5EUkFGVFwiOlwizpcgzrTOt868zr/Pg86vzrXPhc+DzrcgzrHPhs6xzrnPgc6tzrjOt866zrUgzrHPgM+MIM+Ezr8gz4DPgc+Mz4fOtc65z4HOv1wiLFxuICBcIlBPU1RfSVNfRFJBRlRcIjpcIs6XIM60zrfOvM6/z4POr861z4XPg863IM+Az4HOv8+Dz4TOrc64zrfOus61IM+Dz4TOvyDPgM+Bz4zPh861zrnPgc6/XCIsXG4gIFwiU1dJUEVfTEVGVFwiOlwizqPPjc+BzrUgzrHPgc65z4PPhM6tz4HOsSDOs865zrEgzr3OsSDOtM61zrnPgiDPhM65z4IgzrXPgM65zrvOv86zzq3PglwiLFxuICBcIk1BTkFHRVwiOlwizpTOuc6xz4fOtc6vz4HOt8+DzrdcIixcbiAgXCJJTUFHRV9SRU1PVkVEXCI6XCLOlyDOtc65zrrPjM69zrEgzrHPhs6xzrnPgc6tzrjOt866zrVcIixcbiAgXCJDT1BZXCI6XCLOkc69z4TOuc6zz4HOsc+Gzq5cIixcbiAgXCJOT19JTUFHRVwiOlwizpTOtc69IM6tz4fOtc65z4IgzrHOvc61zrLOrM+DzrXOuSDOtc65zrrPjM69zrEgzrHOus+MzrzOsVwiLFxuICBcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6XCLOo8+Nz4HPhM61IM+Az4HOv8+CIM+EzrEgzrrOrM+Ez4kgzrPOuc6xIM6xzr3Osc69zq3Pic+DzrdcIixcbiAgXCJFWFRFUk5BTF9BUFBTXCI6XCLOlc6+z4nPhM61z4HOuc66zq3PgiDOtc+GzrHPgc68zr/Os86tz4JcIixcbiAgXCJQTFVHSU5TXCI6XCLOoM+Bz4zPg864zrXPhM6xXCIsXG4gIFwiU1VHR0VTVFwiOlwizqDPgc+Mz4TOtc65zr3OtVwiLFxuICBcIkNPTUlOR19TT09OXCI6XCLOiM+Bz4fOtc+EzrHOuSDPg8+Nzr3PhM6/zrzOsVwiLFxuICBcIkNIQUlOXCI6XCLOkc67z4XPg86vzrTOsVwiLFxuICBcIkNIQUlOX1RFWFRcIjpcIs6VzrTPjiDOvM+Azr/Pgc61zq/PgiDOvc6xIM6xzrvOu86szr7Otc65z4Igz4TOt869IM6xzrvPhc+Dzq/OtM6xIM+Ez4nOvSDOvM+AzrvOv866IM6uIM+EzrfOvSDPgM+Bzr/Otc+AzrnOu861zrPOvM6tzr3OtyDPgM67zrHPhM+Gz4zPgc68zrEuXCIsXG4gIFwiQ1VSUkVOQ1lcIjpcIs6dz4zOvM65z4POvM6xXCIsXG4gIFwiQ1VSUkVOQ1lfVEVYVFwiOlwizpXOtM+OIM68z4DOv8+BzrXOr8+EzrUgzr3OsSDOsc67zrvOrM6+zrXPhM61IM+Ezr8gz4DPgc6/zrXPgM65zrvOtc6zzrzOrc69zr8gz4POsc+CIM69z4zOvM65z4POvM6xLiDOmM6xIM60zrXOr8+EzrUgz4TOt869IM6xzr3PhM6xzrzOv865zrLOriDPhM63z4IgzrHOvc6sz4HPhM63z4POt8+CL8+Dz4fOv867zq/Ov8+FIM+DzrHPgiDPg861IM6xz4XPhM+MIM+Ezr8gzr3PjM68zrnPg868zrEuXCIsXG4gIFwiQUJPVVRfMTFcIjpcIjxicj48Yj7Om86vz4PPhM6xIM68zrUgz4TOsSDPh86xz4HOsc66z4TOt8+BzrnPg8+EzrnOus6sPC9iPiA8YnI+Lc6gz4HPjM+DzrLOsc+Dzrcgz4POtSDOvM6/zr3Osc60zrnOus6sIM6sz4HOuM+BzrEgz4POtSDOv8+Azr/Ouc6/zrTOrs+Azr/PhM61IM64zq3OvM6xIM+DzrHPgiDOtc69zrTOuc6xz4bOrc+BzrXOuS4gPGJyPiAtzqDOu863z4POr86xz4POtSDPg8+FzrPOs8+BzrHPhs61zq/PgiDPg8+Hzr/Ou865zqzOts6/zr3PhM6xz4IsIM+Dz4XOts63z4TPjs69z4TOsc+CIM64zq3OvM6xz4TOsS4gPGJyPi3OqM6uz4bOuc+DzrUgzrHOvc6xz4HPhM6uz4POtc65z4Igz47Pg8+EzrUgzr3OsSDOsc69z4TOsc68zrXOuc+GzrjOv8+Nzr0gz4PPhc6zzrPPgc6xz4bOtc6vz4IgzrrOsc65IM66zq3Pgc60zrnPg861IM6xzr3PhM6xzrzOv865zrLOrc+CIM61z4DOuc68zq3Ou861zrnOsc+CLiA8YnI+Lc6UzrfOvM6/z4POr861z4XPg861IM+EzrEgzqzPgc64z4HOsSDPg86/z4UsIM6xzr3OrM+Bz4TOt8+DzrUgz4DOv8+Dz4QgzrrOsc65IM+GzrnOu86/zr7Orc69zrfPg861IM+EzrEgzrTPic+BzrXOrM69IM66zrHOuM+Oz4IgzrXPgM6vz4POt8+CIM67zqzOss61IM6xzr3PhM6xzrzOv865zrLOrc+CIM+Dz4XOvM68zrXPhM6tz4fOv869z4TOsc+CIM66zrHOuSDOus61z4HOtM6vzrbOv869z4TOsc+CIM6/z4DOsc60zr/Pjc+CLiA8YnI+Lc6Tz4HOrM+IzrUgzqzPgc64z4HOsSDOus6xzrggzr/OtM+Mzr0gzrrOsc65IM6xz4DOv864zq7Ous61z4XPg861IM+Azr/Ou867zrHPgM67zqwgz4DPgc+Mz4fOtc65z4HOsSDPgM6/z4PPhCDOs865zrEgzrzOtc67zrvOv869z4TOuc66zq4gzrTOt868zr/Pg86vzrXPhc+DzrcuIDxicj4tzpLOrM67zrUgz4POtc67zrnOtM6/zrTOtc6vzrrPhM61z4Igz4POtSDOsc6zzrHPgM63zrzOrc69zrEgzqzPgc64z4HOsSDOs865zrEgzr3OsSDPhM6xIM60zrnOsc6yzqzPg861z4TOtSDOsc+BzrPPjM+EzrXPgc6xLiA8YnI+LUV4Y2hhbmdlIM6uIM69zrEgzrXOvs6xz4HOs8+Fz4HPjs+DzrXPhM61IM+EzrEgzrrOrc+BzrTOtyDPg86xz4IuIDxicj4tzqPPhM61zq/Ou861z4TOtSDPhM6xIM+Hz4HOrs68zrHPhM6sIM+DzrHPgiDPg861IM+Dz4XOs86zz4HOsc+GzrXOr8+CIM6uIM+Ezr/Phc+CIM+Hz4HOrs+Dz4TOtc+CLCDPhM6/z4XPgiDPhs6vzrvOv8+Fz4IsIM+Ezr/Phc+CIM6/z4DOsc60zr/Pjc+CLCDOus67z4AgPGJyPi3Osc66zr/Ou86/z4XOuM6/z43OvSDOtc69zrTOuc6xz4bOrc+Bzr/Phc+DzrXPgiDPg8+FzrPOs8+BzrHPhs6tz4nOvSwgYmxvZ2dlcnMuIDxicj4gLc6Rzr3Osc62zq7PhM63z4POtyDPg86xz4Igzr/PgM6xzrTOv8+Nz4IgzrrOsc65IM+Dz4XOs86zz4HOsc+GzrXOr8+CIM+Azr/PhSDOsc66zr/Ou86/z4XOuM6/z43OvS4gPGJyPi3OoM6sz4HPhM61IM61zrnOtM6/z4DOv865zq7Pg861zrnPgiDOvc6xIM68zrXOr869zrXPhM61IM+DzrUgzrXPgM6xz4bOriDOvM6xzrbOryDPg86xz4Igzr/OuSDOv8+AzrHOtM6/zq8gzrrOsc65IM6/zrkgz4PPhc62zrfPhM6uz4POtc65z4Igz4POsc+CIM61zq/Ovc6xzrkgz4DOv8+FIM61zrzPgM67zq3Ous6/zr3PhM6xzrkgaW4uIDxicj4tzpHOvc6xzrbOrs+EzrfPg863IM6zzrnOsSDOtc69zrTOuc6xz4bOrc+Bzr/Phc+DzrXPgiDOtc+EzrnOus6tz4TOtc+CL866zrHPhM63zrPOv8+Bzq/Otc+CIM6sz4HOuM+Bz4nOvSwgz4PPhc69z4TOrM66z4TOtc+CLiA8YnI+IC3Olc6+zrHPhM6/zrzOr866zrXPhc+Dzrcgz4TOv8+FIM+Az4HOv8+Gzq/OuyDPg86xz4IuIDxicj4tzqDOv867zrvOrCDPgM61z4HOuc+Dz4PPjM+EzrXPgc6xIM+HzrHPgc6xzrrPhM63z4HOuc+Dz4TOuc66zqwgzrPOvc+Jz4HOr8+DzrzOsc+EzrEgzrPOuc6xIM69zrEgzq3Pgc64zrXOuS4gPGJyPjxicj48Yj7Okc+Dz4bOsc67zrXOr86xz4I8L2I+IDxicj4xLiBBcHAgz4DOv8+Ezq0gz4DPgc+Mz4POss6xz4POtyDOriDOvc6xIM66z4HOsc+Ezq7Pg86/z4XOvSDPhM6xIM66zrXPhs6szrvOsc65zrEgz4TOv8+FIM+Hz4HOrs+Dz4TOty4gPGJyPjIuIGFwcCDPgM+Bzr/Pg8+Gzq3Pgc61zrkgzq3Ovc6xIM68zr/Ovc+Ezq3Ou86/IM+AzrvOtc+Fz4HOrM+CIM+Az4HOv86zz4HOrM68zrzOsc+Ezr/Pgi3PgM61zrvOrM+EzrcgzrHPg8+GzrHOu861zq/Osc+CLCDOvM61IM65zrTOuc+Jz4TOuc66zqwgzrrOu861zrnOtM65zqwgz4bOuc67zr/Ovs61zr3Ov8+Nzr3PhM6xzrkgz4TOv8+AzrnOus6sIM66zrHOuSDPgM6/z4TOrSDOvc6xIM6xz4DOv8+Dz4TOrc67zrvOv869z4TOsc65IM+DzrUgz4zOu86/z4XPgiDPhM6/z4XPgiDOtM65zrHOus6/zrzOuc+Dz4TOrc+CLCDOtc6vz4PPhM61IM+Fz4DOtc+NzrjPhc69zr/OuSDOs865zrEgz4TOtyDOtM63zrzOuc6/z4XPgc6zzq/OsSDOsc69z4TOuc6zz4HOrM+Gz4nOvSDOsc+Dz4bOsc67zrXOr86xz4Igz4TOv8+Fz4IgzrrPic60zrnOus6/z43PgiDPgM+Bz4zPg86yzrHPg86uz4Igz4POsc+CLiA8YnI+My4gYXBwIM+Az4HOv8+Dz4bOrc+BzrXOuSDOsc+AzrvOriwgzrXOu866z4XPg8+EzrnOus6uIM+Hz4HOrs+Dz4TOtyDOtM65zrHPg8+Fzr3OtM6tz4POtc65z4IgzrrOsc65IM61zrzPgM61zrnPgc6vzrXPgiA8YnI+NC4gzpcgzrXPhs6xz4HOvM6/zrPOriDPgM+Bzr/Pg8+Gzq3Pgc61zrkgzrXPgM65z4DOu86tzr/OvSDPg8+Ez4HPjs68zrEgz4TOt8+CIM6xz4PPhs6szrvOtc65zrHPgiDOvM61IM66z4nOtM65zrrPjCBwaW4gPGJyPjxicj7Otc66z4TOr868zrfPg863IM+Fz4DOv8+Dz4TOt8+Bzq/Ots61zrkgz4DOu86xz4TPhs+Mz4HOvM61z4IgU3RlZW0gzrrOsc65IEdvbG9zLiA8YnI+XCIsXG4gIFwiRk9VTkRFUlwiOlwizpnOtM+Bz4XPhM6uz4IgzrrOsc65IM61z4DOuc66zrXPhs6xzrvOrs+CIM+Az4HOv86zz4HOsc68zrzOsc+EzrnPg8+Ezq7PglwiLFxuICBcIkFERF9BQ0NPVU5UXCI6XCLOoM+Bzr/Pg864zq7Ous63IM67zr/Os86xz4HOuc6xz4POvM6/z41cIixcbiAgXCJQTEFURk9STVwiOlwizqDOu86xz4TPhs+Mz4HOvM6xXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcIkhvbWVcIixcblx0XCJMT0dJTlwiOiBcIkxvZ2luXCIsXG5cdFwiTE9HT1VUXCI6IFwiTG9nb3V0XCIsXG5cdFwiUFJPRklMRVwiOiBcIlByb2ZpbGVcIixcblx0XCJGT0xMT1dcIjogXCJGb2xsb3dcIixcblx0XCJCT09LTUFSS1NcIjogXCJCb29rbWFya3NcIixcblx0XCJUUkFOU0ZFUlwiOiBcIlRyYW5zZmVyXCIsXG5cdFwiTUFSS0VUXCI6IFwiTWFya2V0XCIsXG5cdFwiU0VUVElOR1NcIjogXCJTZXR0aW5nc1wiLFxuXHRcIkFCT1VUXCI6IFwiQWJvdXRcIixcblx0XCJBQk9VVF8xXCI6IFwid2hlcmUgYW55b25lIGNhbiBlYXJuIHJld2FyZHMgZm9yIHRoZWlyIGNvbnRlbnQhXCIsXG5cdFwiQUJPVVRfMlwiOiBcImlzIHNvY2lhbCBhcHBsaWNhdGlvbiB3aGVyZSB5b3UgZ2V0IHBhaWQgZm9yIGJsb2dnaW5nLCBjb21tZW50aW5nIGFuZCBjdXJhdGluZy5cIixcblx0XCJBQk9VVF8zXCI6IFwiYW5kIGl0IGlzIG9wZW4tc291cmNlLCBjb21tdW5pdHkgZHJpdmVuIG1vYmlsZSBwcm9qZWN0LiBJdCBvZmZlcnMgY29udGVudCBhY2Nlc3MgZm9yIHJlYWRpbmcsIGNvbW1lbnRpbmcsIHZvdGluZywgcG9zdGluZywgdHJhbnNmZXIgZWFybmluZ3MsIGV0Yy4gZmVhdHVyZXMgb2ZmZXJlZCBieSB7e3BsYXRmb3JtbmFtZX19IGJsb2NrY2hhaW4gYW5kIHt7c2l0ZW5hbWV9fS5cIixcblx0XCJBQk9VVF80XCI6IFwiMS4gQXBwIG5ldmVyIGFjY2VzcyBvciBob2xkIG9udG8gdXNlciBmdW5kcy5cIixcblx0XCJBQk9VVF81XCI6IFwiMi4gQXBwIG9mZmVycyBhIGNsaWVudC1zaWRlIHNlY3VyaXR5IG1vZGVsLCB3aXRoIHByaXZhdGUga2V5cyBob3N0ZWQgbG9jYWxseSBhbmQgbmV2ZXIgc2VudCB0byBhbnkgc2VydmVycy5cIixcblx0XCJBQk9VVF82XCI6IFwiMy4gQXBwIG9mZmVycyBzaW1wbGUsIGF0dHJhY3RpdmUgdXNlciBpbnRlcmZhY2VzIGFuZCBleHBlcmllbmNlcy5cIixcblx0XCJBQk9VVF83XCI6IFwiNC4gQXBwIG5ldmVyIHJlcXVpcmUgdXNlcnMgdG8gaW5wdXQgYW55IHBlcnNvbmFsIGluZm9ybWF0aW9uLlwiLFxuXHRcIkFCT1VUXzhcIjogXCJWb3RlIGdvb2Qta2FybWEgYXMgd2l0bmVzc1wiLFxuXHRcIkFCT1VUXzlcIjogXCJDb250YWN0L0ZlZWRiYWNrOlwiLFxuXHRcIkFCT1VUXzEwXCI6IFwiTW9yZSBpbmZvOlwiLFxuXHRcIlJFTU9WRVwiOiBcIlJlbW92ZVwiLFxuXHRcIk1BUktFVF9WSUVXXCI6IFwiTWFya2V0IFZpZXdcIixcblx0XCJQUklDRVwiOiBcIlByaWNlXCIsXG5cdFwiQU1PVU5UXCI6IFwiQW1vdW50XCIsXG5cdFwiVE9UQUxcIjogXCJUb3RhbFwiLFxuXHRcIk5PT1JERVJTXCI6IFwiTm8gb3BlbiBvcmRlcnMgZm9yXCIsXG5cdFwiREFURVwiOiBcIkRhdGVcIixcblx0XCJCVVlcIjogXCJCdXlcIixcblx0XCJTRUxMXCI6IFwiU2VsbFwiLFxuXHRcIk9QRU5cIjogXCJPcGVuXCIsXG5cdFwiSElTVE9SWVwiOiBcIkhpc3RvcnlcIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcIkZvbGxvdyBiYWNrXCIsXG5cdFwiRk9MTE9XRURcIjogXCJGb2xsb3dlZFwiLFxuXHRcIlVORk9MTE9XXCI6IFwiVW5mb2xsb3dcIixcblx0XCJGT0xMT1dJTkdcIjogXCJGb2xsb3dpbmdcIixcblx0XCJGT0xMT1dFUlNcIjogXCJGb2xsb3dlcnNcIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwiU2VhcmNoIGZvbGxvd2Vyc1wiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCJTZWFyY2ggZm9sbG93aW5nXCIsXG5cdFwiQllcIjogXCJieVwiLFxuXHRcIklOXCI6IFwiaW5cIixcblx0XCJNRU5VXCI6IFwiTWVudVwiLFxuXHRcIkJPT0tNQVJLXCI6IFwiQm9va21hcmtcIixcblx0XCJSRUJMT0dcIjogXCJSZWJsb2dcIixcblx0XCJVUFZPVEVcIjogXCJVcHZvdGVcIixcblx0XCJET1dOVk9URVwiOiBcIkRvd252b3RlXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIlVudm90ZSBEb3dudm90ZWRcIixcblx0XCJVTlZPVEVfVVBWT1RFRFwiOiBcIlVudm90ZSB1cHZvdGVkXCIsXG5cdFwiUkVQTFlcIjogXCJSZXBseVwiLFxuXHRcIkVESVRcIjogXCJFZGl0XCIsXG5cdFwiUE9TVF8xXCI6IFwiU3dpcGUgbGVmdCBvbiBjb21tZW50cyB0byBzZWUgb3B0aW9uc1wiLFxuXHRcIlBPU1RfMlwiOiBcIlRhcCBvbiBjb21tZW50cyB0byBzZWUgc3ViLWNvbW1lbnRzXCIsXG5cdFwiT1BUSU9OU1wiOiBcIk9wdGlvbnNcIixcblx0XCJSRVNURUVNRURfQllcIjogXCJSZWJsb2dnZWQgYnlcIixcblx0XCJGT0xMT1dcIjogXCJGb2xsb3dcIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCJOb3RoaW5nIGhlcmUsIHlldC4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwiQmFsYW5jZXNcIixcblx0XCJQUk9GSUxFXzFcIjogXCJ7e3BsYXRmb3JtbmFtZX19LCB0cmFkZWFibGUgdG9rZW5zIHRoYXQgbWF5IGJlIHRyYW5zZmVycmVkIGF0IGFueXRpbWUuIHt7cGxhdGZvcm1uYW1lfX0gY2FuIGJlIGNvbnZlcnRlZCB0byB7e3BsYXRmb3JtcG93ZXJ9fSBpbiBhIHByb2Nlc3MgY2FsbGVkIHBvd2VyaW5nIHVwLlwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn19LCBpbmZsdWVuY2UgdG9rZW5zIHRoYXQgZWFybiBtb3JlIHBvd2VyIGZvciBob2xkaW5nIGxvbmcgdGVybSBhbmQgdm90aW5nIG9uIHBvc3RzLiBUaGUgbW9yZSBvbmUgaG9sZHMgdGhlIG1vcmUgb25lIGNhbiBpbmZsdWVuY2Ugb3RoZXLigJlzIHJld2FyZHMgYW5kIGVhcm4gcmV3YXJkcyBmb3IgYWNjdXJhdGUgdm90aW5nLlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcIlRva2VucyB3b3J0aCBhYm91dCB7e3BsYXRmb3Jtc3VuaXR9fSBvZiB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcIkVzdGltYXRlZCBWYWx1ZVwiLFxuXHRcIlBST0ZJTEVfNFwiOiBcIlRoZSBlc3RpbWF0ZWQgdmFsdWUgaXMgYmFzZWQgb24gYSA3IGRheSBhdmVyYWdlIHZhbHVlIG9mIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcIlRyYW5zYWN0aW9uIEhpc3RvcnlcIixcblx0XCJQT1NUSU5HXCI6IFwiUG9zdGluZ1wiLFxuXHRcIlBST0ZJTEVfNVwiOiBcIlRoZSBwb3N0aW5nIGtleSBpcyB1c2VkIGZvciBwb3N0aW5nIGFuZCB2b3RpbmcuIEl0IHNob3VsZCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgYWN0aXZlIGFuZCBvd25lciBrZXlzLlwiLFxuXHRcIk9XTkVSXCI6IFwiT3duZXJcIixcblx0XCJQUk9GSUxFXzZcIjogXCJUaGUgb3duZXIga2V5IGlzIHRoZSBtYXN0ZXIga2V5IGZvciB0aGUgYWNjb3VudCBhbmQgaXMgcmVxdWlyZWQgdG8gY2hhbmdlIHRoZSBvdGhlciBrZXlzLiBUaGUgcHJpdmF0ZSBrZXkgb3IgcGFzc3dvcmQgZm9yIHRoZSBvd25lciBrZXkgc2hvdWxkIGJlIGtlcHQgb2ZmbGluZSBhcyBtdWNoIGFzIHBvc3NpYmxlLlwiLFxuXHRcIkFDVElWRVwiOiBcIkFjdGl2ZVwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcIlRoZSBhY3RpdmUga2V5IGlzIHVzZWQgdG8gbWFrZSB0cmFuc2ZlcnMgYW5kIHBsYWNlIG9yZGVycyBpbiB0aGUgaW50ZXJuYWwgbWFya2V0LlwiLFxuXHRcIk1FTU9cIjogXCJNZW1vXCIsXG5cdFwiUFJPRklMRV84XCI6IFwiVGhlIG1lbW8ga2V5IGlzIHVzZWQgdG8gY3JlYXRlIGFuZCByZWFkIG1lbW9zLlwiLFxuXHRcIkJMT0dcIjogXCJCbG9nXCIsXG5cdFwiUE9TVFNcIjogXCJQb3N0c1wiLFxuXHRcIlJFUExJRVNcIjogXCJSZXBsaWVzXCIsXG5cdFwiV0FMTEVUXCI6IFwiV2FsbGV0XCIsXG5cdFwiVEFHXCI6IFwiVGFnXCIsXG5cdFwiVVNFUlwiOiBcIlVzZXJcIixcblx0XCJDTE9TRVwiOiBcIkNsb3NlXCIsXG5cdFwiVVNFUlwiOiBcIlVzZXJcIixcblx0XCJUT1wiOiBcIlRvXCIsXG5cdFwiQVNTRVRcIjogXCJBc3NldFwiLFxuXHRcIlNFTkRcIjogXCJTZW5kXCIsXG5cdFwiU0VDVVJJVFlcIjogXCJTZWN1cml0eVwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcIkF2YWlsYWJsZVwiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwiUHVibGljIE1lbW9cIixcblx0XCJUT19ERVNDXCI6IFwiVXNlciBlLmcuIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIlBpbiBDb2RlXCIsXG5cdFwiUElOX1RFWFRcIjogXCJQSU4gY29kZSBoZWxwcyB5b3UgdG8gc2VjdXJlIGFwcCBhbmQgeW91ciBkYXRhLiA8YnIvPjxici8+PGI+Tm90ZTo8L2I+IE9uY2UgZW5hYmxlZCwgeW91IGhhdmUgbWF4IDQgdHJpZXMgdG8gdW5sb2NrLCBpZiB5b3UgZm9yZ290IHBpbiBvciBmYWlsLCBhcHAgd2lsbCByZW1vdmUgbG9nZ2VkIGluIHVzZXIgZGF0YS4gWW91IGNhbiByZS1sb2dpbiBhbmQgY29udGludWUgdXNpbmcgYXBwLlwiLFxuXHRcIk5PVElGSUNBVElPTlNcIjogXCJOb3RpZmljYXRpb25zXCIsXG5cdFwiVk9URV9URVhUXCI6IFwiWW91IHdpbGwgZ2V0IG5vdGlmaWNhdGlvbiB3aGVuIHNvbWVvbmUgdm90ZXMgeW91ciBjb250ZW50ISA8YnIvPiA8Yj5Ob3RlOjwvYj4gTm90aWZpY2F0aW9ucyBpbmNsdWRlIHZvdGluZyB3ZWlnaHQgYXMgd2VsbCBpbiBhbGVydCBtZXNzYWdlLiAoYmUgaXQgdXAtdm90ZSwgZG93bi12b3RlLCB1bi12b3RlKS5cIixcblx0XCJWT1RFXCI6IFwiVm90ZVwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcIllvdSB3aWxsIGdldCBub3RpZmljYXRpb24gd2hlbiBzb21lb25lIGNvbW1lbnRzIG9uIHlvdXIgcG9zdHMgb3IgY29tbWVudHMhPGJyLz4gPGI+Tm90ZTo8L2I+IE5vdGlmaWNhdGlvbnMgaW5jbHVkZSB3aGVuIHNvbWVvbmUgPGI+ZWRpdHM8L2I+IHRoZWlyIGNvbW1lbnRzIGFzIHdlbGwuXCIsXG5cdFwiQ09NTUVOVFwiOiBcIkNvbW1lbnRcIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcIllvdSB3aWxsIGdldCBub3RpZmljYXRpb24gd2hlbiBzb21lb25lIEZvbGxvdyBvciBVbmZvbGxvdyB5b3UhXCIsXG5cdFwiTUVOVElPTlNcIjogXCJNZW50aW9uc1wiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCJZb3Ugd2lsbCBnZXQgbm90aWZpY2F0aW9uIHdoZW4gc29tZW9uZSBtZW50aW9ucyB5b3UgaW4gdGhlaXIgcG9zdC9jb21tZW50IVwiLFxuXHRcIlJFU1RFRU1cIjogXCJSZWJsb2dcIixcblx0XCJSRVNURUVNX1RFWFRcIjogXCJZb3Ugd2lsbCBnZXQgbm90aWZpY2F0aW9uIHdoZW4gc29tZW9uZSByZWJsb2dzIHlvdXIgcG9zdCFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIkNvbmZpZ3VyYXRpb25zXCIsXG5cdFwiVk9USU5HXCI6IFwiVm90aW5nXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCJWb3RlIHdlaWdodCBvciBwZXJjZW50YWdlIGFmZmVjdHMgdm90aW5nIHBvd2VyIG9uIGFwcCwgc28geW91IGNhbiByZWd1bGF0ZSB5b3VyIHZvdGluZyByZXdhcmQuIDxici8+PGJyLz48Yj5Ob3RlOjwvYj4gVGhpcyB3aWxsIGNoYW5nZSB2b3Rpbmcgd2VpZ2h0L3BlcmNlbnRhZ2UgZm9yIGRvd252b3RpbmcgYXMgd2VsbCBhbmQgaXQgaXMgZXZlcnl3aGVyZSBvbiBhcHBcIixcblx0XCJTRVJWRVJcIjogXCJTZXJ2ZXJcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcIlJlY29tbWVuZGVkXCIsXG5cdFwiU0FWRV9DSEFOR0VTXCI6IFwiU2F2ZSBDaGFuZ2VzXCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCJWb3RlcnMgaW5mb1wiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcIldlbGNvbWUgYmFjayFcIixcblx0XCJMT0dJTl8xXCI6IFwiU2lnbiBpbiB3aXRoIHlvdXIgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIHRvIGNvbnRpbnVlLlwiLFxuXHRcIkxPR0lOXzJcIjogXCJQb3N0aW5nIGtleSBpcyB1c2VkIGZvciBwb3N0LCBjb21tZW50LCB2b3RlLCBmb2xsb3cuXCIsXG5cdFwiTE9HSU5fM1wiOiBcIkFjdGl2ZSBrZXkgaXMgdXNlZCBmb3IgdHJhbnNmZXJzIGFuZCBwcm9maWxlIHBpY3R1cmUgdXBkYXRlLlwiLFxuXHRcIkxPR0lOXzRcIjogXCJVc2VyIGNyZWRlbnRpYWxzIGFyZSBrZXB0IGxvY2FsbHkgb24gdGhlIGRldmljZS4gVXBvbiBMb2dvdXQgY3JlZGVudGlhbHMgYXJlIHJlbW92ZWQhXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwiRG9uJ3QgaGF2ZSBhbiBhY2NvdW50P1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwiU2lnbiB1cCBub3dcIixcblx0XCJDQU5DRUxcIjogXCJDYW5jZWxcIixcblx0XCJBRFZBTkNFRFwiOiBcIkFkdmFuY2VkXCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcIkFjdGl2ZSBwcml2YXRlIGtleVwiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwiUG9zdGluZyBwcml2YXRlIGtleVwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwiTWFzdGVyL21haW4gcGFzc3dvcmRcIixcblx0XCJVU0VSTkFNRVwiOiBcIlVzZXJuYW1lXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwiQ2FyZCB2aWV3XCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwiQ29tcGFjdCB2aWV3XCIsXG5cdFwiU0VBUkNIXCI6IFwiU2VhcmNoXCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCJTdWJtaXQgYSBzdG9yeVwiLFxuXHRcIlJFUExZVE9cIjogXCJSZXBseSB0b1wiLFxuXHRcIlBPU1RcIjogXCJQb3N0XCIsXG5cdFwiUFJFVklFV1wiOiBcIlByZXZpZXdcIixcblx0XCJERUZBVUxUXCI6IFwiRGVmYXVsdCA1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwiUG93ZXIgVXAgMTAwJVwiLFxuXHRcIkRFQ0xJTkVfUEFZT1VUXCI6IFwiRGVjbGluZSBQYXlvdXRcIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIlNBVkUgRk9SIExBVEVSXCIsXG5cdFwiQ0xFQVJcIjogXCJDTEVBUlwiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcIlBvc3QgY29udGVudFwiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcIkNvbW1lbnQgY29udGVudFwiLFxuXHRcIlRJVExFXCI6IFwiVGl0bGVcIixcblx0XCJUQUdTXCI6IFwiVGFnc1wiLFxuXHRcIk5PVF9NQVRDSFwiOiBcIk5PVCBNQVRDSFwiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwiQ29uZmlybSBQSU5cIixcblx0XCJJTkNPUlJFQ1RcIjogXCJJTkNPUlJFQ1RcIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCJvcGVuaW5nIHBvc3RcIixcblx0XCJTRVRfUElOXCI6IFwiU2V0IFBJTlwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcIkVudGVyIFBJTlwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcIkFyZSB5b3Ugc3VyZT9cIixcblx0XCJSRUJMT0dfVEVYVFwiOiBcIlJlYmxvZyBpcyBpcnJldmVyc2libGUsIGRvIHlvdSB3YW50IHRvIGNvbnRpbnVlP1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcIkJyb2FkY2FzdCBlcnJvciwgdHJ5IGFnYWluIVwiLFxuXHRcIlNVQ0NFU1NcIjogXCJTdWNjZXNzXCIsXG5cdFwiUkVCTE9HR0VEX1BPU1RcIjogXCJSZWJsb2dnZWQgcG9zdCFcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwiTG9naW4gZmFpbGVkISBQbGVhc2UgbWFrZSBzdXJlIHlvdSBoYXZlIGxvZ2dlZCBpbiB3aXRoIG1hc3RlciBwYXNzd29yZCBvciBwcm92aWRlZCBQb3N0aW5nIHByaXZhdGUga2V5IG9uIExvZ2luIGlmIHlvdSBoYXZlIGNob29zZWQgQWR2YW5jZWQgbW9kZS5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCJMb2dpbiBmYWlsZWQhIFBsZWFzZSBtYWtlIHN1cmUgeW91IGhhdmUgbG9nZ2VkIGluIHdpdGggbWFzdGVyIHBhc3N3b3JkIG9yIHByb3ZpZGVkIEFjdGl2ZSBwcml2YXRlIGtleSBvbiBMb2dpbiBpZiB5b3UgaGF2ZSBjaG9zZW4gQWR2YW5jZWQgbW9kZS5cIixcblx0XCJXQVJOSU5HXCI6IFwiV2FybmluZ1wiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCJWb3RpbmcgZm9yIHdpdG5lc3NcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcIlZvdGVkIGZvciB3aXRuZXNzXCIsXG5cdFwiQUdPXCI6IFwiYWdvXCIsXG5cdFwiRlJPTV9OT1dcIjogXCJmcm9tIG5vd1wiLFxuXHRcIlNFQ1NcIjogXCJzZWNzXCIsXG5cdFwiQV9NSU5cIjogXCJhIG1pblwiLFxuXHRcIk1JTlNcIjogXCJtaW5zXCIsXG5cdFwiQU5fSE9VUlwiOiBcImFuIGhyXCIsXG5cdFwiSE9VUlNcIjogXCJocnNcIixcblx0XCJBX0RBWVwiOiBcImEgZGF5XCIsXG5cdFwiREFZU1wiOiBcImRheXNcIixcblx0XCJBX01PTlRIXCI6IFwiYSBtb250aFwiLFxuXHRcIk1PTlRIU1wiOiBcIm1vbnRoc1wiLFxuXHRcIkFfWUVBUlwiOiBcImEgeWVhclwiLFxuXHRcIllFQVJTXCI6IFwieWVhcnNcIixcblx0XCJNSU5fUkVBRFwiOiBcIm1pbiByZWFkXCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcIkRvd252b3RlIG9yIEZsYWdcIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCJDYXB0dXJlIFBpY3R1cmVcIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcIlNlbGVjdCBQaWN0dXJlXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCJTZXQgQ3VzdG9tIFVSTFwiLFxuXHRcIklOU0VSVF9QSUNUVVJFXCI6IFwiSW5zZXJ0IFBpY3R1cmVcIixcblx0XCJFUlJPUlwiOiBcIkVycm9yXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwiVXBsb2FkIEVycm9yXCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcIkNhbWVyYSBDYW5jZWxsZWRcIixcblx0XCJTRVRfVVJMXCI6IFwiU2V0IFVSTFwiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCJEaXJlY3Qgd2ViIGxpbmsgZm9yIHRoZSBwaWN0dXJlXCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCJDb21tZW50IGlzIHN1Ym1pdHRlZCFcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcIkRlbGV0aW5nIGNvbW1lbnRzIGFyZSBpcnJldmVyc2libGUuLi5cIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCJEZWxldGVkIGNvbW1lbnRcIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcIlVwbG9hZGluZyBQaWN0dXJlXCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcIlVwbG9hZCBDb21wbGV0ZWRcIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwiVXBsb2FkIEZhaWxlZFwiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcIlRoZSBwYXNzd29yZCBvciBhY2NvdW50IG5hbWUgd2FzIGluY29ycmVjdFwiLFxuXHRcIklORk9cIjogXCJJbmZvXCIsXG5cdFwiUVJfVEVYVFwiOiBcIlBsYWNlIGEgUVIgY29kZSBpbnNpZGUgdGhlIHNjYW4gYXJlYVwiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcIk1ha2Ugc3VyZSB5b3UgaGF2ZSBlbm91Z2ggYmFsYW5jZSBmb3IgdHJhbnNhY3Rpb24hXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcIlVzZXIgeW91IGFyZSB0cnlpbmcgdG8gdHJhbnNmZXIgZnVuZCwgZG9lc24ndCBleGlzdCFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIHRyYW5zZmVyP1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcIkNvbmZpcm1hdGlvblwiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwiVHJhbnNhY3Rpb24gaXMgYnJvYWRjYXN0ZWRcIixcblx0XCJGRUVEXCI6IFwiRmVlZFwiLFxuXHRcIlRSRU5ESU5HXCI6IFwiVHJlbmRpbmdcIixcblx0XCJIT1RcIjogXCJIb3RcIixcblx0XCJORVdcIjogXCJOZXdcIixcblx0XCJQUk9NT1RFRFwiOiBcIlByb21vdGVkXCIsXG5cdFwiVk9URVNcIjogXCJWb3Rlc1wiLFxuXHRcIlBBWU9VVFwiOiBcIlBheW91dFwiLFxuXHRcIkNPTU1FTlRTXCI6IFwiQ29tbWVudHNcIixcblx0XCJUUkVORElOR18zMFwiOiBcIlRyZW5kaW5nIGZvciAzMCBkYXlzXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwiU29ydCBQb3N0cyBCeTpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCJQYXlvdXQgQ3ljbGVcIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwiUG90ZW50aWFsIFBheW91dFwiLFxuXHRcIlBBU1RfUEFZT1VUXCI6IFwiUGFzdCBQYXlvdXRcIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwiQXV0aG9yIFBheW91dFwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIkN1cmF0aW9uIFBheW91dFwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwiUG9zdCBpcyBzdWJtaXR0ZWQhXCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcIlBvc3QgZm9yIGxhdGVyIHN1Ym1pc3Npb24hXCIsXG5cdFwiU0FWRURcIjogXCJTYXZlZFwiLFxuXHRcIkNMRUFSRURcIjogXCJDbGVhcmVkXCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIkZsYWdnaW5nIGEgcG9zdCBjYW4gcmVtb3ZlIHJld2FyZHMgYW5kIG1ha2UgdGhpcyBtYXRlcmlhbCBsZXNzIHZpc2libGUuPGJyPjxicj5UaGUgZmxhZyBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIGZvbGxvd2luZzogPHVsPjxsaT5GcmF1ZCBvciBQbGFnaWFyaXNtPC9saT48bGk+SGF0ZSBTcGVlY2ggb3IgSW50ZXJuZXQgVHJvbGxpbmc8L2xpPjxsaT5JbnRlbnRpb25hbCBtaXNjYXRlZ29yaXplZCBjb250ZW50IG9yIFNwYW08L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwiUmVxdWVzdCBsaW1pdCByZWFjaGVkLiBDaGVjayBvdXQgb3RoZXIgdHJlbmQvdGFncyFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCJQb3N0IGlzIHJlbW92ZWQgZnJvbSBib29rbWFya3MhXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIlBvc3QgaXMgYWRkZWQgdG8gYm9va21hcmtzIVwiLFxuXHRcIlJFU0VUXCI6IFwiUmVzZXRcIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcIk1vZGlmeSBQcm9maWxlIFBpY3R1cmVcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcIk1vZGlmeSBDb3ZlciBQaWN0dXJlXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwiUGxlYXNlIHByb3ZpZGUgQWN0aXZlIHByaXZhdGUga2V5IGlmIHlvdSBoYXZlIGNob3NlbiBBZHZhbmNlZCBsb2dpbiBtb2RlIVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcIlRoaXMgd2lsbCByZXNldCB1c2VyIHByb2ZpbGUgcGljdHVyZVwiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcIlRoaXMgd2lsbCByZXNldCB1c2VyIGNvdmVyIHBpY3R1cmVcIixcblx0XCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOiBcIlNlcnZlciB1cGRhdGUgcmVxdWlyZXMgUmVzdGFydCFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwiU2V0dGluZ3MgYXJlIHVwZGF0ZWQhXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwiTGFuZ3VhZ2VzXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCJIZXJlIHlvdSBjYW4gY2hhbmdlIGxhbmd1YWdlIG9mIHRoZSBhcHAuXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIlRoaXMgb3BlcmF0aW9uIHJlcXVpcmVzIHVzZXIgdG8gYmUgbG9nZ2VkIGluIHdpdGggbWFpbiBwYXNzd29yZCwgYWN0aXZlL3Bvc3Rpbmcga2V5LiBQbGVhc2UgbG9naW4gYW5kIHRyeSBhZ2Fpbi5cIixcblx0XCJHQUxMRVJZXCI6IFwiR2FsbGVyeVwiLFxuXHRcIlRSQU5TTEFUSU9OU1wiOiBcIlRyYW5zbGF0aW9uIGNvbnRyaWJ1dG9yc1wiLFxuXHRcIlNIQVJFXCI6IFwiU2hhcmVcIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcIk1hcmtldCBQbGFjZVwiLFxuXHRcIkVYQ0hBTkdFXCI6IFwiRXhjaGFuZ2VcIixcblx0XCJEUkFGVFNcIjogXCJEcmFmdHNcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCJQb3N0IGlzIHJlbW92ZWQgZnJvbSBkcmFmdHMhXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcIlBvc3QgaXMgYWRkZWQgdG8gZHJhZnRzIVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCJTd2lwZSBsZWZ0IHRvIHNlZSBvcHRpb25zXCIsXG5cdFwiTUFOQUdFXCI6IFwiTWFuYWdlXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcIkltYWdlIGlzIHJlbW92ZWRcIixcblx0XCJDT1BZXCI6IFwiQ29weVwiLFxuXHRcIk5PX0lNQUdFXCI6IFwiWW91IGhhdmUgbm90IHVwbG9hZGVkIGFueSBpbWFnZSwgeWV0IVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwiUHVsbCBkb3duIHRvIHJlZnJlc2hcIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwiRXh0ZXJuYWwgQXBwc1wiLFxuXHRcIlBMVUdJTlNcIjogXCJQbHVnaW5zXCIsXG5cdFwiU1VHR0VTVFwiOiBcIlN1Z2dlc3RcIixcblx0XCJDT01JTkdfU09PTlwiOiBcIkNvbWluZyBzb29uXCIsXG5cdFwiQ0hBSU5cIjogXCJDaGFpblwiLFxuXHRcIkNIQUlOX1RFWFRcIjogXCJIZXJlIHlvdSBjYW4gY2hhbmdlIGJsb2NrY2hhaW4gb3IgZGVmYXVsdCBwbGF0Zm9ybS5cIixcblx0XCJDVVJSRU5DWVwiOiBcIkN1cnJlbmN5XCIsXG5cdFwiQ1VSUkVOQ1lfVEVYVFwiOiBcIkhlcmUgeW91IGNhbiBjaGFuZ2UgeW91ciBkZWZhdWx0IGN1cnJlbmN5LiBZb3Ugd2lsbCBzZWUgcG9zdC9jb21tZW50IHJld2FyZCB2YWx1ZSBpbiB0aGlzIGN1cnJlbmN5LlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPkZlYXR1cmUgbGlzdDwvYj48YnI+LSBBY2Nlc3MgdW5pcXVlIGFydGljbGVzIGluIGFueSBzdWJqZWN0IHlvdSBhcmUgaW50ZXJlc3RlZCByZWFkaW5nLjxicj4tIEVuZ2FnZSB3aXRoIGF1dGhvcnMgYnkgY29tbWVudGluZywgZGlzY3Vzc2luZyB0b3BpY3MuPGJyPi0gVm90aW5nIGZvciBwb3N0cyB0byByZXdhcmQgYXV0aG9yIGFzIHdlbGwgYXMgZWFybiBjdXJhdGlvbiByZXdhcmQuPGJyPi0gUHVibGlzaCB5b3VyIGFydGljbGVzLCBibG9nIHBvc3RzIGFuZCBob3N0IHRoZW0gZm9yIGZyZWUgYW5kIGVhcm4gcmV3YXJkcyBieSBlbmdhZ2luZyBhbmQgZ2FpbiBmb2xsb3dlcnMuPGJyPi0gV3JpdGUgYXJ0aWNsZXMgb24gZ28sIHNhdmUgbXVsdGlwbGUgZHJhZnRzIG9mIHRoZSBwb3N0IGZvciBsYXRlciBwdWJsaWNhdGlvbi48YnI+LSBCb29rbWFyayBmYXZvcml0ZSBhcnRpY2xlcyB0byByZWFkIGxhdGVyLjxicj4tIEV4Y2hhbmdlIG9yIGNhc2ggb3V0IHlvdXIgZWFybmluZ3MuPGJyPi0gU2VuZCB5b3VyIGZ1bmRzIHRvIGFueSBhdXRob3JzIG9yIHVzZXJzLCBmcmllbmRzLCBmb2xsb3dlcnMsIGV0Yy48YnI+LSBGb2xsb3cgaW50ZXJlc3RpbmcgYXV0aG9ycywgYmxvZ2dlcnMuPGJyPi0gU2VhcmNoIHlvdXIgZm9sbG93ZXJzIGFuZCBhdXRob3JzIHlvdSBhcmUgZm9sbG93aW5nLjxicj4tIEdldCBub3RpZmljYXRpb25zIHRvIHN0YXkgaW4gdG91Y2ggd2l0aCB5b3VyIGZvbGxvd2VycyBhbmQgZGlzY3Vzc2lvbnMgeW91IGFyZSBpbnZvbHZlZCBpbi48YnI+LSBTZWFyY2ggZm9yIGludGVyZXN0aW5nIHRhZ3MvY2F0ZWdvcmllcyBvZiBhcnRpY2xlcywgYXV0aG9ycy48YnI+LSBQZXJzb25hbGl6ZSB5b3VyIHByb2ZpbGUuPGJyPi0gTWFueSBtb3JlIGZlYXR1cmVzIHRvIGNvbWUuPGJyPjxicj48Yj5TZWN1cml0eTwvYj48YnI+MS4gQXBwIG5ldmVyIGFjY2VzcyBvciBob2xkIG9udG8gdXNlciBmdW5kcy48YnI+Mi4gQXBwIG9mZmVyIGEgY2xpZW50LXNpZGUgc2VjdXJpdHkgbW9kZWwsIHdpdGggcHJpdmF0ZSBrZXlzIGhvc3RlZCBsb2NhbGx5IGFuZCBuZXZlciBzZW50IHRvIGFueSBzZXJ2ZXJzLCB5b3UgYXJlIHJlc3BvbnNpYmxlIHRvIGJhY2tpbmcgdXAgeW91ciBwYXNzd29yZHMuPGJyPjMuIEFwcCBvZmZlcnMgc2ltcGxlLCBhdHRyYWN0aXZlIHVzZXIgaW50ZXJmYWNlcyBhbmQgZXhwZXJpZW5jZXM8YnI+NC4gQXBwIG9mZmVycyBleHRyYSBsYXllciBvZiBzZWN1cml0eSB3aXRoIHBpbi1jb2RlPGJyPjxicj5lU3RlZW0gc3VwcG9ydHMgU3RlZW0gYW5kIEdvbG9zIHBsYXRmb3Jtcy48YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcIkZvdW5kZXIgYW5kIExlYWQgZGV2ZWxvcGVyXCIsXG5cdFwiQUREX0FDQ09VTlRcIjogXCJBZGQgYWNjb3VudFwiLFxuXHRcIlBMQVRGT1JNXCI6IFwiUGxhdGZvcm1cIlxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIkhPTUVcIjpcIkluaWNpb1wiLFxuICBcIkxPR0lOXCI6XCJJbmljaWFyIFNlc2nDs25cIixcbiAgXCJMT0dPVVRcIjpcIkNlcnJhciBTZXNpw7NuXCIsXG4gIFwiUFJPRklMRVwiOlwiUGVyZmlsXCIsXG4gIFwiRk9MTE9XXCI6XCJTZWd1aXJcIixcbiAgXCJCT09LTUFSS1NcIjpcIk1hcmNhZG9yZXNcIixcbiAgXCJUUkFOU0ZFUlwiOlwiVHJhbnNmZXJpclwiLFxuICBcIk1BUktFVFwiOlwiTWVyY2Fkb1wiLFxuICBcIlNFVFRJTkdTXCI6XCJBanVzdGVzXCIsXG4gIFwiQUJPVVRcIjpcIkFjZXJjYSBkZVwiLFxuICBcIkFCT1VUXzFcIjpcImRvbmRlIHRvZG8gZWwgbXVuZG8gcHVlZGUgb2J0ZW5lciBnYW5hbmNpYXMgcG9yIHN1IGNvbnRlbmlkb1wiLFxuICBcIkFCT1VUXzJcIjpcInByb3Zpc3RvIHBvciBsYSBwbGF0YWZvcm1hIHt7cGxhdGZvcm1uYW1lfX0uIEFwcCBjcmVhZGEgcG9yXCIsXG4gIFwiQUJPVVRfM1wiOlwiZXMgdW4gcHJveWVjdG8gZGUgbcOzdmlsIGltcHVsc2FkbyBwb3IgbGEgY29tdW5pZGFkLCBkZSBjw7NkaWdvIGFiaWVydG8uIE9mcmVjZSBhY2Nlc28gYWwgY29udGVuaWRvIHBhcmEgc3UgbGVjdHVyYSwgY29tZW50YXJpb3MsIHZvdG9zLCBwdWJsaWNhY2lvbmVzLCB0cmFuc2ZlcmVuY2lhIGRlIGdhbmFuY2lhcywgZXRjOyBjYXJhY3RlcsOtc3RpY2FzIG9mcmVjaWRhcyBwb3IgbGEgY2FkZW5hIGRlIGJsb3F1ZXMge3twbGF0Zm9ybW5hbWV9fSB5IHt7c2l0ZW5hbWV9fS5cIixcbiAgXCJBQk9VVF80XCI6XCIxLiBMYSBBcHAgbnVuY2EgYWNjZWRlIG8gcmV0aWVuZSBmb25kb3MgZGUgbG9zIHVzdWFyaW9zLlwiLFxuICBcIkFCT1VUXzVcIjpcIjIuIExhIEFwcCBvZnJlY2UgdW4gbW9kZWxvIGRlIHNlZ3VyaWRhZCBkZWwgY2xpZW50ZSBjb24gY29udHJhc2XDsWFzIHByaXZhZGFzIGFsbWFjZW5hZGFzIGxvY2FsbWVudGUgeSBxdWUgbm8gc29uIG51bmNhIGVudmlhZGFzIGEgbmluZ8O6biBzZXJ2aWRvci5cIixcbiAgXCJBQk9VVF82XCI6XCIzLiBMYSBBcHAgb2ZyZWNlIHVuYSBleHBlcmllbmNpYSB5IHVuYSBpbnRlcmZheiBzaW1wbGUgeSBhdHJhY3RpY2EuXCIsXG4gIFwiQUJPVVRfN1wiOlwiNC4gTGEgQXBwIG51bmNhIHBpZGUgcXVlIGxvcyB1c3VhcmlvcyBpbnRyb2R1emNhbiBuaW5ndW5hIGluZm9ybWFjacOzbiBwZXJzb25hbC5cIixcbiAgXCJBQk9VVF84XCI6XCJWb3RhIGEgZ29vZC1rYXJtYSBjb21vIHRlc3RpZ29cIixcbiAgXCJBQk9VVF85XCI6XCJDb250YWN0by9TdWdlcmVuY2lhc1wiLFxuICBcIkFCT1VUXzEwXCI6XCJNw6FzIGluZm9ybWFjacOzblwiLFxuICBcIlJFTU9WRVwiOlwiRWxpbWluYXJcIixcbiAgXCJNQVJLRVRfVklFV1wiOlwiVmlzdGEgZGUgTWVyY2Fkb1wiLFxuICBcIlBSSUNFXCI6XCJQcmVjaW9cIixcbiAgXCJBTU9VTlRcIjpcIkNhbnRpZGFkXCIsXG4gIFwiVE9UQUxcIjpcIlwiLFxuICBcIk5PT1JERVJTXCI6XCJTaW4gw7NyZGVuZXMgYWJpZXJ0YXMgcGFyYVwiLFxuICBcIkRBVEVcIjpcIkZlY2hhXCIsXG4gIFwiQlVZXCI6XCJDb21wcmFyXCIsXG4gIFwiU0VMTFwiOlwiVmVuZGVyXCIsXG4gIFwiT1BFTlwiOlwiQWJyaXJcIixcbiAgXCJISVNUT1JZXCI6XCJIaXN0b3JpYWxcIixcbiAgXCJGT0xMT1dfQkFDS1wiOlwiRGV2b2x2ZXIgU2VndWltaWVudG9cIixcbiAgXCJGT0xMT1dFRFwiOlwiU2VndWlkb1wiLFxuICBcIlVORk9MTE9XXCI6XCJEZWphciBkZSBTZWd1aXJcIixcbiAgXCJGT0xMT1dJTkdcIjpcIlNpZ3VpZW5kb1wiLFxuICBcIkZPTExPV0VSU1wiOlwiU2VndWlkb3Jlc1wiLFxuICBcIlNFQVJDSF9GT0xMT1dFUlNcIjpcIkJ1c2NhciBzZWd1aWRvcmVzXCIsXG4gIFwiU0VBUkNIX0ZPTExPV0lOR1wiOlwiQnVzY2FyIHNlZ3VpZG9zXCIsXG4gIFwiQllcIjpcInBvclwiLFxuICBcIklOXCI6XCJlblwiLFxuICBcIk1FTlVcIjpcIk1lbsO6XCIsXG4gIFwiQk9PS01BUktcIjpcIk1hcmNhZG9yXCIsXG4gIFwiUkVCTE9HXCI6XCJSZWJsb2d1ZWFyXCIsXG4gIFwiVVBWT1RFXCI6XCJWb3RvIFBvc2l0aXZvXCIsXG4gIFwiRE9XTlZPVEVcIjpcIlZvdG8gTmVnYXRpdm9cIixcbiAgXCJVTlZPVEVfRE9XTlZPVEVEXCI6XCJEZXNoYWNlciBWb3RvIE5lZ2F0aXZvXCIsXG4gIFwiVU5WT1RFX1VQVk9URURcIjpcIkRlc2hhY2VyIFZvdG8gUG9zaXRpdm9cIixcbiAgXCJSRVBMWVwiOlwiUmVzcG9uZGVyXCIsXG4gIFwiRURJVFwiOlwiRWRpdGFyXCIsXG4gIFwiUE9TVF8xXCI6XCJEZXNsaXphIGEgbGEgaXpxdWllcmRhIGVuIGxvcyBjb21lbnRhcmlvcyBwYXJhIHZlciBsYXMgb3BjaW9uZXNcIixcbiAgXCJQT1NUXzJcIjpcIlB1bHNhIGVuIGxvcyBjb21lbnRhcmlvcyBwYXJhIHZlciBsb3Mgc3ViY29tZW50YXJpb3NcIixcbiAgXCJPUFRJT05TXCI6XCJPcGNpb25lc1wiLFxuICBcIlJFU1RFRU1FRF9CWVwiOlwiUmVzdGVlbWVkIHBvclwiLFxuICBcIk5PVEhJTkdfSEVSRVwiOlwiTmFkYSBwb3IgYXF1w60gYcO6bi4uLlwiLFxuICBcIkJBTEFOQ0VTXCI6XCJTYWxkb3NcIixcbiAgXCJQUk9GSUxFXzFcIjpcInt7cGxhdGZvcm1uYW1lfX0sIGZpY2hhcyBjb21lcmNpYWJsZXMgcXVlIHB1ZWRlbiBzZXIgdHJhbnNmZXJpZGFzIGVuIGN1YWxxdWllciBtb21lbnRvLiB7e3BsYXRmb3JtbmFtZX19IHB1ZWRlbiBzZXIgY29udmVydGlkYXMgYSB7e3BsYXRmb3JtcG93ZXJ9fSBlbiB1biBwcm9jZXNvIGxsYW1hZG8gcG93ZXIgdXAuXCIsXG4gIFwiUFJPRklMRV8yXCI6XCJ7e3BsYXRmb3JtcG93ZXJ9fSwgZmljaGFzIGRlIGluZmx1ZW5jaWEgcXVlIGNvbnNpZ3VlbiBtw6FzIHBvZGVyIHBvciBtYW50ZW5lcmxhcyBhIGxhcmdvIHBsYXpvIHkgdm90YXIgZW4gbG9zIHBvc3RzLiBDdWFudGFzIG3DoXMgdGVuZ2FzIG3DoXMgaW5mbHVlbmNpYSB0ZW5kcsOhcyBlbiBsYXMgcmVjb21wZW5zYXMgcXVlIGxlIGRhcyBhbCByZXN0byBkZSB1c3VhcmlvcyB5IG3DoXMgcmVjb21wZW5zYXMgb2J0ZW5kcsOhcyBwb3IgdHVzIHZvdG9zLlwiLFxuICBcIlBST0ZJTEVfM1wiOlwiVmFsb3IgZGUgbGFzIGZpY2hhcyB7e3BsYXRmb3Jtc3VuaXR9fSBkZSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuICBcIkVTVElNQVRFRF9WQUxVRVwiOlwiVmFsb3IgRXN0aW1hZG9cIixcbiAgXCJQUk9GSUxFXzRcIjpcIkVsIHZhbG9yIGVzdGltYWRvIHNlIGJhc2EgZW4gdW4gdmFsb3IgcHJvbWVkaW8gZGUgNyBkw61hcyBkZSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuICBcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjpcIkhpc3RvcmlhbCBkZSBUcmFuc2FjY2lvbmVzXCIsXG4gIFwiUE9TVElOR1wiOlwiUHVibGljYWNpw7NuXCIsXG4gIFwiUFJPRklMRV81XCI6XCJMYSBjbGF2ZSBkZSBwdWJsaWNhY2nDs24gZXMgdXRpbGl6YWRhIHBhcmEgcHVibGljYXIgeSB2b3Rhci4gVGllbmUgcXVlIHNlciBkaWZlcmVudGUgYSBsYSBjbGF2ZSBhY3RpdmEgeSBhIGxhIGNsYXZlIGRlIHByb3BpZXRhcmlvLlwiLFxuICBcIk9XTkVSXCI6XCJQcm9waWV0YXJpb1wiLFxuICBcIlBST0ZJTEVfNlwiOlwiTGEgY2xhdmUgZGUgcHJvcGlldGFyaW8gZXMgbGEgY2xhdmUgbWFlc3RyYSBkZSBsYSBjdWVudGEgeSBzZSByZXF1aWVyZSBwYXJhIGNhbWJpYXIgbGFzIG90cmFzIGNsYXZlcy4gTGEgY2xhdmUgbyBjb250cmFzZcOxYSBwcml2YWRhIGRlIGxhIGNsYXZlIGRlIHByb3BpZXRhcmlvIGRlYmVyw61hIHNlciBtYW50ZW5pZGEgXFxcIm9mZmxpbmVcXFwiIHRhbnRvIGNvbW8gc2VhIHBvc2libGUuXCIsXG4gIFwiQUNUSVZFXCI6XCJBY3RpdmFcIixcbiAgXCJQUk9GSUxFXzdcIjpcIkxhIGNsYXZlIGFjdGl2YSBzZSB1dGlsaXphIHBhcmEgaGFjZXIgdHJhbnNmZXJlbmNpYXMgeSBoYWNlciBwZWRpZG9zIGVuIGVsIG1lcmNhZG8gaW50ZXJuby5cIixcbiAgXCJNRU1PXCI6XCJNZW1vcsOhbmR1bVwiLFxuICBcIlBST0ZJTEVfOFwiOlwiTGEgY2xhdmUgZGUgbWVtb3LDoW5kdW1zIHNlIHV0aWxpemEgcGFyYSBjcmVhciB5IGxlZXIgbWVtb3LDoW5kdW1zLlwiLFxuICBcIkJMT0dcIjpcIlwiLFxuICBcIlBPU1RTXCI6XCJQdWJsaWNhY2lvbmVzXCIsXG4gIFwiUkVQTElFU1wiOlwiUmVzcHVlc3Rhc1wiLFxuICBcIldBTExFVFwiOlwiTW9uZWRlcm9cIixcbiAgXCJUQUdcIjpcIkV0aXF1ZXRhXCIsXG4gIFwiVVNFUlwiOlwiVXN1YXJpb1wiLFxuICBcIkNMT1NFXCI6XCJDZXJyYXJcIixcbiAgXCJUT1wiOlwiQVwiLFxuICBcIkFTU0VUXCI6XCJQb3Nlc2nDs24gZGUgQ2FwaXRhbFwiLFxuICBcIlNFTkRcIjpcIkVudmlhclwiLFxuICBcIlNFQ1VSSVRZXCI6XCJTZWd1cmlkYWRcIixcbiAgXCJBVkFJTEFCTEVcIjpcIkRpc3BvbmlibGVcIixcbiAgXCJQVUJMSUNfTUVNT1wiOlwiTWVtb3LDoW5kdW0gUMO6YmxpY29cIixcbiAgXCJUT19ERVNDXCI6XCJVc3VhcmlvIGVqLiBnb29kLWthcm1hXCIsXG4gIFwiUElOX0NPREVcIjpcIkPDs2RpZ28gUGluXCIsXG4gIFwiUElOX1RFWFRcIjpcIkVsIGPDs2RpZ28gUElOIHRlIGF5dWRhIGEgZGFyIHNlZ3VyaWRhZCBhIGxhIGFwcCB5IGEgdHVzIGRhdG9zLlxcbjxici8+PGJyLz48Yj5Ob3RhOjwvYj4gVW5hIHZleiBhY3RpdmFkbywgdGllbmVzIHVuIG3DoXhpbW8gZGUgNCBpbnRlbnRvcyBwYXJhIGRlc2Jsb3F1ZWFybG87IHNpIHRlIG9sdmlkYXMgZGUgdHUgcGluIG8gZmFsbGFzLCBsYSBhcHAgZWxpbWluYXLDoSBsb3MgcmVnaXN0cm9zIGVuIGxvcyBkYXRvcyBkZSB1c3VhcmlvLiBQdWVkZXMgdm9sdmVyIGEgaW5pY2lhciBzZXNpw7NuIHkgY29udGludWFyIHVzYW5kbyBsYSBhcHAuXCIsXG4gIFwiTk9USUZJQ0FUSU9OU1wiOlwiTm90aWZpY2FjaW9uZXNcIixcbiAgXCJWT1RFX1RFWFRcIjpcIlJlY2liaXLDoXMgdW5hIG5vdGlmaWNhY2nDs24gY3VhbmRvIGFsZ3VpZW4gdm90ZSB0dSBjb250ZW5pZG8hIDxici8+IDxiPk5vdGE6PC9iPiBMYXMgbm90aWZpY2FjaW9uZXMgaW5jbHV5ZW4gdGFtYmnDqW4gZWwgcGVzbyBkZSBsYSB2b3RhY2nDs24gZW4gZWwgbWVuc2FqZSBkZSBhbGVydGEuICh5YSBzZWEgcG9yIHZvdGFjacOzbiBwb3NpdGl2YSwgdm90YWNpw7NuIG5lZ2F0aXZhLCBkZXNoYWNlciB2b3RhY2nDs24pLlwiLFxuICBcIlZPVEVcIjpcIlZvdGFyXCIsXG4gIFwiQ09NTUVOVF9URVhUXCI6XCJSZWNpYmlyw6FzIHVuYSBub3RpZmljYWNpw7NuIGN1YW5kbyBhbGd1aWVuIGNvbWVudGUgZW4gdHVzIHB1YmxpY2FjaW9uZXMgbyBjb21lbnRhcmlvcyE8YnIvPiA8Yj5Ob3RlOjwvYj4gTGFzIG5vdGlmaWNhY2lvbmVzIGluY2x1eWVuIGN1YW5kbyBhbGd1aWVuIDxiPmVkaXRhPC9iPiBzdXMgY29tZW50YXJpb3MgdGFtYmnDqW4uXCIsXG4gIFwiQ09NTUVOVFwiOlwiQ29tZW50YXJcIixcbiAgXCJGT0xMT1dfVEVYVFwiOlwiUmVjaWJpcsOhcyB1bmEgbm90aWZpY2FjacOzbiBjdWFuZG8gYWxndWllbiB0ZSBzaWdhIG8gdGUgZGVqZSBkZSBzZWd1aXIhXCIsXG4gIFwiTUVOVElPTlNcIjpcIk1lbmNpb25lc1wiLFxuICBcIk1FTlRJT05TX1RFWFRcIjpcIlJlY2liaXLDoXMgdW5hIG5vdGlmaWNhY2nDs24gY3VhbmRvIGFsZ3VpZW4gdGUgbWVuY2lvbmUgZW4gc3UgcHVibGljYWNpw7NuL2NvbWVudGFyaW8hXCIsXG4gIFwiUkVTVEVFTVwiOlwiXCIsXG4gIFwiUkVTVEVFTV9URVhUXCI6XCJSZWNpYmlyw6FzIHVuYSBub3RpZmljYWNpw7NuIGN1YW5kbyBhbGd1aWVuIGhhZ2EgcmVzdGVlbSBhIHR1IHB1YmxpY2FjacOzblwiLFxuICBcIkNPTkZJR1VSQVRJT05TXCI6XCJDb25maWd1cmFjaW9uZXNcIixcbiAgXCJWT1RJTkdcIjpcIlZvdG9cIixcbiAgXCJWT1RJTkdfVEVYVFwiOlwiRWwgcGVzbyBvIHBvcmNlbnRhamUgZGVsIHZvdG8gYWZlY3RhIGFsIHBvZGVyIGRlIHZvdGFjacOzbiBlbiBsYSBhcHAsIGRlIHRhbCBtYW5lcmEgcXVlIHB1ZWRlcyByZWd1bGFyIHR1IHJlY29tcGVuc2EgZGUgdm90YWNpw7NuLiA8YnIvPjxici8+PGI+Tm90YTo8L2I+IEVzdG8gY2FtYmlhcsOhIHRhbWJpw6luIGVsIHBlc28vcG9yY2VudGFqZSBkZWwgdm90byBhIGxhIGhvcmEgZGUgaGFjZXIgdW4gdm90byBuZWdhdGl2b1wiLFxuICBcIlNFUlZFUlwiOlwiU2Vydmlkb3JcIixcbiAgXCJTRVJWRVJfVEVYVFwiOlwiUmVjb21lbmRhZG9cIixcbiAgXCJTQVZFX0NIQU5HRVNcIjpcIkd1YXJkYXIgQ2FtYmlvc1wiLFxuICBcIlZPVEVSU19JTkZPXCI6XCJJbmZvIGRlIHZvdGFudGVzXCIsXG4gIFwiV0VMQ09NRV9CQUNLXCI6XCJCaWVudmVuaWRvIVwiLFxuICBcIkxPR0lOXzFcIjpcIlJlZ8Otc3RyYXRlIGNvbiB0dSBub21icmUgZGUgdXN1YXJpbyB5IGNvbnRyYXNlw7FhIHBhcmEgY29udGludWFyLlwiLFxuICBcIkxPR0lOXzJcIjpcIkxhIGNsYXZlIGRlIHB1YmxpY2FjacOzbiBzZSB1c2EgcGFyYSBwdWJsaWNhciwgY29tZW50YXIsIHZvdGFyLCBzZWd1aXIuXCIsXG4gIFwiTE9HSU5fM1wiOlwiTGEgY2xhdmUgYWN0aXZhIHNlIHVzYSBwYXJhIGxhcyB0cmFuc2ZlcmVuY2lhcyB5IGxhIGFjdHVhbGl6YWNpw7NuIGRlIGxhIGZvdG8gZGUgcGVyZmlsLlwiLFxuICBcIkxPR0lOXzRcIjpcIkxhcyBjcmVkZW5jaWFsZXMgZGVsIHVzdWFyaW8gc2UgZ3VhcmRhbiBsb2NhbG1lbnRlIGVuIGVsIGRpc3Bvc2l0aXZvLiBBbCBjZXJyYXIgbGEgc2VzacOzbiBsYXMgY3JlZGVuY2lhbGVzIHNvbiBlbGltaW5hZGFzIVwiLFxuICBcIkRPTlRfSEFWRVwiOlwiTm8gdGllbmVzIHVuYSBjdWVudGE/XCIsXG4gIFwiU0lHTl9VUF9OT1dcIjpcIlJlZ8Otc3RyYXRlIGFob3JhXCIsXG4gIFwiQ0FOQ0VMXCI6XCJDYW5jZWxhclwiLFxuICBcIkFEVkFOQ0VEXCI6XCJBdmFuemFkb1wiLFxuICBcIkFDVElWRV9QUklLRVlcIjpcIkNsYXZlIGFjdGl2YSBwcml2YWRhXCIsXG4gIFwiUE9TVElOR19QUklLRVlcIjpcIkNsYXZlIGRlIHB1YmxpY2FjacOzbiBwcml2YWRhXCIsXG4gIFwiTUFTVEVSX1BBU1NcIjpcIkNvbnRyYXNlw7FhIG1hZXN0cmEvcHJpbmNpcGFsXCIsXG4gIFwiVVNFUk5BTUVcIjpcIk5vbWJyZSBkZSBVc3VhcmlvXCIsXG4gIFwiQ0FSRF9WSUVXXCI6XCJWaXN0YSBkZSBjYXNpbGxhc1wiLFxuICBcIkNPTVBBQ1RfVklFV1wiOlwiVmlzdGEgY29tcGFjdGFcIixcbiAgXCJTRUFSQ0hcIjpcIkJ1c2NhclwiLFxuICBcIlNVQk1JVF9BX1NUT1JZXCI6XCJQdWJsaWNhciB1biBhcnTDrWN1bG9cIixcbiAgXCJSRVBMWVRPXCI6XCJSZXNwb25kZXIgYVwiLFxuICBcIlBPU1RcIjpcIlB1YmxpY2FyXCIsXG4gIFwiUFJFVklFV1wiOlwiUHJldmlzdWFsaXphY2nDs25cIixcbiAgXCJERUZBVUxUXCI6XCJQb3IgZGVmZWN0byA1MCUgLyA1MCVcIixcbiAgXCJQT1dFUlVQXCI6XCJQb3RlbmNpYWNpw7NuIDEwMCVcIixcbiAgXCJERUNMSU5FX1BBWU9VVFwiOlwiUmVjaGF6YXIgUGFnb1wiLFxuICBcIlNBVkVfRk9SX0xBVEVSXCI6XCJHVUFSREFSIFBBUkEgTcOBUyBUQVJERVwiLFxuICBcIkNMRUFSXCI6XCJCT1JSQVJcIixcbiAgXCJQT1NUX0NPTlRFTlRcIjpcIlB1YmxpY2FyIGNvbnRlbmlkb1wiLFxuICBcIkNPTU1FTlRfQ09OVEVOVFwiOlwiQ29tZW50YXIgY29udGVuaWRvXCIsXG4gIFwiVElUTEVcIjpcIlTDrXR1bG9cIixcbiAgXCJUQUdTXCI6XCJFdGlxdWV0YXNcIixcbiAgXCJOT1RfTUFUQ0hcIjpcIk5PIENPSU5DSURFXCIsXG4gIFwiQ09ORklSTV9QSU5cIjpcIkNvbmZpcm1hciBQSU5cIixcbiAgXCJJTkNPUlJFQ1RcIjpcIklOQ09SUkVDVE9cIixcbiAgXCJPUEVOSU5HX1BPU1RcIjpcIlBvc3QgaW5pY2lhbFwiLFxuICBcIlNFVF9QSU5cIjpcIkVzdGFibGVjZXIgUElOXCIsXG4gIFwiRU5URVJfUElOXCI6XCJJbnRyb2R1Y2lyIFBJTlwiLFxuICBcIkFSRV9ZT1VfU1VSRVwiOlwiRXN0w6FzIHNlZ3Vybz9cIixcbiAgXCJSRUJMT0dfVEVYVFwiOlwiUmVzdGVlbWVhciBlcyBpcnJldmVyc2libGUsIHF1aWVyZXMgY29udGludWFyP1wiLFxuICBcIkJST0FEQ0FTVF9FUlJPUlwiOlwiRXJyb3IgZGUgdHJhbnNtaXNpw7NuLCBpbnTDqW50YWxvIGRlIG51ZXZvIVwiLFxuICBcIlNVQ0NFU1NcIjpcIkNvbnNlZ3VpZG9cIixcbiAgXCJSRUJMT0dHRURfUE9TVFwiOlwiUHVibGljYWNpw7NuIFJlYmxvZ3VlYWRhXCIsXG4gIFwiTE9HSU5fRkFJTFwiOlwiSW5pY2lvIGRlIHNlc2nDs24gZmFsbGlkbyEgUG9yIGZhdm9yIGFzZWfDunJhdGUgZGUgcXVlIGhhcyBpbmljaWFkbyBzZXNpw7NuIGNvbiB0dSBjb250cmFzZcOxYSBtYWVzdHJhIG8gY29uIGxhIGNsYXZlIGRlIFB1YmxpY2FjacOzbiBwcml2YWRhIHByb3BvcmNpb25hZGEgZW4gZWwgYXBhcnRhZG8gSW5pY2lhciBTZXNpw7NuIHNpIGVsZWdpc3RlIGVsIE1vZG8gQXZhbnphZG8uXCIsXG4gIFwiTE9HSU5fRkFJTF9BXCI6XCJJbmljaW8gZGUgc2VzacOzbiBmYWxsaWRvISBQb3IgZmF2b3IgYXNlZ8O6cmF0ZSBkZSBxdWUgaGFzIGluaWNpYWRvIHNlc2nDs24gY29uIHR1IGNvbnRyYXNlw7FhIG1hZXN0cmEgbyBjb24gbGEgY2xhdmUgQWN0aXZhIHByaXZhZGEgZW4gZWwgYXBhcnRhZG8gSW5pY2lhciBTZXNpw7NuIHNpIGVsZWdpc3RlIGVsIE1vZG8gQXZhbnphZG8uXCIsXG4gIFwiV0FSTklOR1wiOlwiQWR2ZXJ0ZW5jaWFcIixcbiAgXCJWT1RFX0ZPUl9XSVRORVNTXCI6XCJWb3RhciBhIHRlc3RpZ29cIixcbiAgXCJWT1RFRF9GT1JfV0lUTkVTU1wiOlwiVm90YWRvIGEgdGVzdGlnb1wiLFxuICBcIkFHT1wiOlwiaGFjZVwiLFxuICBcIkZST01fTk9XXCI6XCJkZXNkZSBhaG9yYVwiLFxuICBcIlNFQ1NcIjpcInNlZ3VuZG9zXCIsXG4gIFwiQV9NSU5cIjpcInVuIG1pbnV0b1wiLFxuICBcIk1JTlNcIjpcIm1pbnV0b3NcIixcbiAgXCJBTl9IT1VSXCI6XCJ1bmEgaG9yYVwiLFxuICBcIkhPVVJTXCI6XCJob3Jhc1wiLFxuICBcIkFfREFZXCI6XCJ1biBkw61hXCIsXG4gIFwiREFZU1wiOlwiZMOtYXNcIixcbiAgXCJBX01PTlRIXCI6XCJ1biBtZXNcIixcbiAgXCJNT05USFNcIjpcIm1lc2VzXCIsXG4gIFwiQV9ZRUFSXCI6XCJ1biBhw7FvXCIsXG4gIFwiWUVBUlNcIjpcImHDsW9zXCIsXG4gIFwiTUlOX1JFQURcIjpcIm1pbnV0b3MgZGUgbGVjdHVyYVwiLFxuICBcIkRPV05WT1RFX0ZMQUdcIjpcIlZvdGFyIE5lZ2F0aXZhbWVudGUgbyBNYXJjYXIgQ29tbyBJbmFwcm9waWFkb1wiLFxuICBcIkNBUFRVUkVfUElDVFVSRVwiOlwiVG9tYXIgZm90b1wiLFxuICBcIlNFTEVDVF9QSUNUVVJFXCI6XCJTZWxlY2Npb25hciBJbWFnZW5cIixcbiAgXCJTRVRfQ1VTVE9NX1VSTFwiOlwiRXN0YWJsZWNlciBVUkwgcGVyc29uYWxpemFkYVwiLFxuICBcIklOU0VSVF9QSUNUVVJFXCI6XCJJbnNlcnRhciBJbWFnZW5cIixcbiAgXCJFUlJPUlwiOlwiXCIsXG4gIFwiVVBMT0FEX0VSUk9SXCI6XCJFcnJvciBhbCBDYXJnYXJcIixcbiAgXCJDQU1FUkFfQ0FOQ0VMTEVEXCI6XCJDw6FtYXJhIENhbmNlbGFkYVwiLFxuICBcIlNFVF9VUkxcIjpcIkVzdGFibGVjZXIgVVJMXCIsXG4gIFwiRElSRUNUX0xJTktfUElDVFVSRVwiOlwiRW5sYWNlIHdlYiBkaXJlY3RvIGEgbGEgaW1hZ2VuXCIsXG4gIFwiQ09NTUVOVF9TVUJNSVRURURcIjpcIkVsIGNvbWVudGFyaW8gc2UgaGEgZW50cmVnYWRvIVwiLFxuICBcIkRFTEVURV9DT01NRU5UXCI6XCJFbGltaW5hciBjb21lbnRhcmlvcyBlcyBpcnJldmVyc2libGUuLi5cIixcbiAgXCJERUxFVEVEX0NPTU1FTlRcIjpcIkVsaW1pbmFyIGNvbWVudGFyaW9cIixcbiAgXCJVUExPQURJTkdfUElDVFVSRVwiOlwiU3ViaWVuZG8gSW1hZ2VuXCIsXG4gIFwiVVBMT0FEX0NPTVBMRVRFRFwiOlwiU3ViaWRhIENvbXBsZXRhZGFcIixcbiAgXCJVUExPQURfRkFJTEVEXCI6XCJMYSBzdWJpZGEgaGEgZmFsbGFkb1wiLFxuICBcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOlwiTGEgY29udHJhc2XDsWEgbyBlbCBub21icmUgZGUgY3VlbnRhIHNvbiBpbmNvcnJlY3Rvc1wiLFxuICBcIklORk9cIjpcIkluZm9ybWFjacOzblwiLFxuICBcIlFSX1RFWFRcIjpcIkNvbG9jYSBlbCBjw7NkaWdvIFFSIGRlbnRybyBkZSBsYSB6b25hIGRlIGVzY2FuZW9cIixcbiAgXCJCQUxBTkNFX1RFWFRcIjpcIkFzZWfDunJhdGUgZGUgcXVlIHRpZW5lcyBzdWZpY2llbnRlIHNhbGRvIHBhcmEgbGEgdHJhbnNhY2Npw7NuIVwiLFxuICBcIk5PTkVYSVNUX1VTRVJcIjpcIkVsIHVzdWFyaW8gYWwgcXVlIGVzdMOhcyBpbnRlbnRhbmRvIHRyYW5zZmVyaXIgZm9uZG9zIG5vIGV4aXN0ZSFcIixcbiAgXCJUUkFOU0ZFUl9URVhUXCI6XCJFc3TDoXMgc2VndXJvIGRlIHF1ZSBxdWllcmVzIGhhY2VyIGxhIHRyYW5zZmVyZW5jaWE/XCIsXG4gIFwiQ09ORklSTUFUSU9OXCI6XCJDb25maXJtYWNpw7NuXCIsXG4gIFwiVFhfQlJPQURDQVNURURcIjpcIlRyYW5zYWNjacOzbiB0cmFuc21pdGlkYVwiLFxuICBcIkZFRURcIjpcIkluaWNpb1wiLFxuICBcIlRSRU5ESU5HXCI6XCJUZW5kZW5jaWFzXCIsXG4gIFwiSE9UXCI6XCJDYWxpZW50ZVwiLFxuICBcIk5FV1wiOlwiTnVldm9cIixcbiAgXCJQUk9NT1RFRFwiOlwiUHJvbW9jaW9uYWRvXCIsXG4gIFwiVk9URVNcIjpcIlZvdG9zXCIsXG4gIFwiUEFZT1VUXCI6XCJQYWdvXCIsXG4gIFwiQ09NTUVOVFNcIjpcIkNvbWVudGFyaW9zXCIsXG4gIFwiVFJFTkRJTkdfMzBcIjpcIlNpZW5kbyBUZW5kZW5jaWEgZHVyYW50ZSAzMCBkw61hc1wiLFxuICBcIlNPUlRfUE9TVF9CWVwiOlwiT3JkZW5hciBQdWJsaWNhY2lvbmVzIFBvclwiLFxuICBcIlBBWU9VVF9DWUNMRVwiOlwiQ2ljbG8gZGUgUGFnb1wiLFxuICBcIlBPVEVOVElBTF9QQVlPVVRcIjpcIlBhZ28gUG90ZW5jaWFsXCIsXG4gIFwiUEFTVF9QQVlPVVRcIjpcIlBhZ28gUGFzYWRvXCIsXG4gIFwiQVVUSE9SX1BBWU9VVFwiOlwiUGFnbyBkZSBBdXRvclwiLFxuICBcIkNVUkFUSU9OX1BBWU9VVFwiOlwiUGFnbyBkZSBDdXJhY2nDs25cIixcbiAgXCJQT1NUX1NVQk1JVFRFRFwiOlwiTGEgcHVibGljYWNpw7NuIGZ1ZSBlbnZpYWRhIVwiLFxuICBcIlBPU1RfTEFURVJcIjpcIlB1YmxpY2FjacOzbiBwYXJhIHBvc3RlcmlvciBwcmVzZW50YWNpw7NuIVwiLFxuICBcIlNBVkVEXCI6XCJHdWFyZGFkb1wiLFxuICBcIkNMRUFSRURcIjpcIkJvcnJhZG9cIixcbiAgXCJGTEFHR0lOR19URVhUXCI6XCJNYXJjYXIgY29tbyBpbmFwcm9waWFkYSB1bmEgcHVibGljYWNpw7NuIHB1ZWRlIGVsaW1pbmFyIGxhcyByZWNvbXBlbnNhcyB5IGhhY2VyIHF1ZSBlbCBtYXRlcmlhbCBtYXJjYWRvIHNlYSBtZW5vcyB2aXNpYmxlLjxicj48YnI+IE1hcmNhciBjb21vIGluYXByb3BpYWRvIGRlYmUgdXRpbGl6YXJzZSBlbiBsb3Mgc2lndWllbnRlcyBjYXNvczogPHVsPjxsaT5GcmF1ZGUgbyBQbGFnaW88L2xpPjxsaT5EaXNjdXJzb3MgZGUgT2RpbyBvIEFjdGl0dWRlcyBkZSBQcm92b2NhY2nDs24geSBNb2xlc3RpYSBDb25zdGFudGVzPC9saT48bGk+Q29udGVuaWRvIGNhdGVncml6YWRvIG1hbCBpbnRlbmNpb25hZGFtZW50ZSBvIFNwYW08L2xpPjwvdWw+XCIsXG4gIFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6XCJMw61taXRlIGRlIHNvbGljaXR1ZCBhbGNhbnphZG8uIFJldmlzYSBvdHJhcyBldGlxdWV0YXMvdGVuZGVuY2lhcyFcIixcbiAgXCJQT1NUX0lTX1VOQk9PS01BUktcIjpcIlB1YmxpY2FjacOzbiBlbGltaW5hZGEgZGUgbG9zIG1hcmNhZG9yZXMhXCIsXG4gIFwiUE9TVF9JU19CT09LTUFSS1wiOlwiUHVibGljYWNpw7NuIGHDsWFkaWRhIGEgbWFyY2Fkb3JlcyFcIixcbiAgXCJSRVNFVFwiOlwiUmVpbmljaWFyXCIsXG4gIFwiTU9ESUZZX1BJQ1RVUkVcIjpcIk1vZGlmaWNhciBGb3RvIGRlIFBlcmZpbFwiLFxuICBcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6XCJNb2RpZmljYXIgRm90byBkZSBQb3J0YWRhXCIsXG4gIFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6XCJQb3IgZmF2b3IgcHJvcG9yY2lvbmEgbGEgY2xhdmUgQWN0aXZhIHByaXZhZGEgc2kgaGFzIGVsZWdpZG8gZWwgbW9kbyBkZSBJbmljaW8gZGUgU2VzacOzbiBBdmFuemFkbyFcIixcbiAgXCJSRVNFVF9QSUNUVVJFX1RFWFRcIjpcIkVzdG8gcmVpbmljaWFyw6EgbGEgZm90byBkZSBwZXJmaWwgZGVsIHVzdWFyaW9cIixcbiAgXCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjpcIkVzdG8gcmVpbmljaWFyw6EgbGEgZm90byBkZSBwb3J0YWRhIGRlbCB1c3VhcmlvXCIsXG4gIFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjpcIkxhIGFjdHVhbGl6YWNpw7NuIGRlbCBzZXJ2aWRvciByZXF1aWVyZSB1biByZWluaWNpbyFcIixcbiAgXCJTRVRUSU5HU19VUERBVEVEXCI6XCJBanVzdGVzIGFjdHVhbGl6YWRvcyFcIixcbiAgXCJMQU5HVUFHRVNcIjpcIklkaW9tYXNcIixcbiAgXCJMQU5HVUFHRVNfVEVYVFwiOlwiQXF1w60gcHVlZGVzIGNhbWJpYXIgZWwgaWRpb21hIGRlIGxhIGFwcFwiLFxuICBcIkxPR0lOX1RPX1hcIjpcIkVzdGEgb3BlcmFjacOzbiByZXF1aWVyZSBxdWUgZWwgdXN1YXJpbyBpbmljaWUgc2VzacOzbiBjb24gbGEgY29udHJhc2XDsWEgbWFlc3RyYS9wcmluY2lwYWwsIGNsYXZlIGFjdGl2YS9wdWJsaWNhci4gUG9yIGZhdm9yIGluaWNpYSBzZXNpw7NuIHkgdnVlbHZlIGEgaW50ZW50YXJsby5cIixcbiAgXCJHQUxMRVJZXCI6XCJHYWxlcsOtYVwiLFxuICBcIlRSQU5TTEFUSU9OU1wiOlwiQ29sYWJvcmFkb3JlcyBkZSB0cmFkdWNjaW9uZXNcIixcbiAgXCJTSEFSRVwiOlwiQ29tcGFydGlyXCIsXG4gIFwiTUFSS0VUUExBQ0VcIjpcIk1lcmNhZG9cIixcbiAgXCJFWENIQU5HRVwiOlwiQ2FtYmlvXCIsXG4gIFwiRFJBRlRTXCI6XCJCb3JyYWRvcmVzXCIsXG4gIFwiUE9TVF9JU19VTkRSQUZUXCI6XCLCoUxhIHB1YmxpY2FjacOzbiBzZSBoYSBlbGltaW5hZG8gZGUgYm9ycmFkb3JlcyFcIixcbiAgXCJQT1NUX0lTX0RSQUZUXCI6XCLCoUxhIHB1YmxpY2FjacOzbiBzZSBoYSBhw7FhZGlkbyBhIGJvcnJhZG9yZXMhXCIsXG4gIFwiU1dJUEVfTEVGVFwiOlwiRGVzbGljZSBoYWNpYSBsYSBpenF1aWVyZGEgcGFyYSB2ZXIgbGFzIG9wY2lvbmVzXCIsXG4gIFwiTUFOQUdFXCI6XCJHZXN0aW9uYXJcIixcbiAgXCJJTUFHRV9SRU1PVkVEXCI6XCJMYSBmb3RvIHNlIGhhIGVsaW1pbmFkb1wiLFxuICBcIkNPUFlcIjpcIkNvcGlhclwiLFxuICBcIk5PX0lNQUdFXCI6XCLCoUHDum4gbm8gaGFzIHN1YmlkbyBuaW5ndW5hIGZvdG8hXCIsXG4gIFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjpcIlRpcmUgaGFjaWEgYWJham8gcGFyYSBhY3R1YWxpemFyXCIsXG4gIFwiRVhURVJOQUxfQVBQU1wiOlwiQXBwcyBleHRlcm5hc1wiLFxuICBcIlBMVUdJTlNcIjpcIlwiLFxuICBcIlNVR0dFU1RcIjpcIlN1Z2VyaXJcIixcbiAgXCJDT01JTkdfU09PTlwiOlwiTXV5IHByb250b1wiLFxuICBcIkNIQUlOXCI6XCJcIixcbiAgXCJDSEFJTl9URVhUXCI6XCJBcXXDrSBwdWVkZXMgY2FtYmlhciBsYSBibG9ja2NoYWluIG8gbGEgcGxhdGFmb3JtYSBwb3IgZGVmZWN0by5cIixcbiAgXCJDVVJSRU5DWVwiOlwiXCIsXG4gIFwiQ1VSUkVOQ1lfVEVYVFwiOlwiXCIsXG4gIFwiQUJPVVRfMTFcIjpcIlwiLFxuICBcIkZPVU5ERVJcIjpcIlwiLFxuICBcIkFERF9BQ0NPVU5UXCI6XCJcIixcbiAgXCJQTEFURk9STVwiOlwiXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiSE9NRVwiOlwiQWNjdWVpbFwiLFxuICBcIkxPR0lOXCI6XCJDb25uZXhpb25cIixcbiAgXCJMT0dPVVRcIjpcIkTDqWNvbm5leGlvblwiLFxuICBcIlBST0ZJTEVcIjpcIlByb2ZpbFwiLFxuICBcIkZPTExPV1wiOlwiU3VpdnJlXCIsXG4gIFwiQk9PS01BUktTXCI6XCJTaWduZXRzXCIsXG4gIFwiVFJBTlNGRVJcIjpcIlRyYW5zZmVydFwiLFxuICBcIk1BUktFVFwiOlwiTWFyY2jDqVwiLFxuICBcIlNFVFRJTkdTXCI6XCJQYXJhbcOodHJlc1wiLFxuICBcIkFCT1VUXCI6XCJBIHByb3Bvc1wiLFxuICBcIkFCT1VUXzFcIjpcIm/DuSBuJ2ltcG9ydGUgcXVpIHBldXQgZ2FnbmVyIGRlcyByw6ljb21wZW5zZXMgcG91ciBzb24gY29udGVudSFcIixcbiAgXCJBQk9VVF8yXCI6XCJlc3Qgc3VwcG9ydMOpIHBhciBsYSBwbGF0ZS1mb3JtZSB7e3BsYXRmb3JtbmFtZX19LiBBcHBsaWNhdGlvbiBjcsOpw6llIHBhclwiLFxuICBcIkFCT1VUXzNcIjpcIklsIHMnYWdpdCBkJ3VuIHByb2pldCBwb3VyIGxhIGNvbW11bmF1dMOpIG1vYmlsZSBldCBpbCBlc3Qgb3Blbi1zb3VyY2UuIElsIG9mZnJlIHVuIGFjY8OocyBwb3VyIGxpcmUsIGNvbW1lbnRlciwgdm90ZXIsIHBvc3RlciwgYWZmaWNoZXIgbGUgdHJhbnNmZXJ0IGRlIHLDqWNvbXBlbnNlLCBldGMuIFRvdXRlcyBsZXMgZm9uY3Rpb25uYWxpdMOpcyBvZmZlcnRlcyBwYXIge3tzaXRlbmFtZX19IGV0IGxhIGJsb2NrY2hhaW4ge3twbGF0Zm9ybW5hbWV9fS5cIixcbiAgXCJBQk9VVF80XCI6XCIxLiBMJ2FwcGxpY2F0aW9uIG4nYSBqYW1haXMgYWNjw6hzIGF1eCBmb25kcyBkZSBsJ3V0aWxpc2F0ZXVyLlwiLFxuICBcIkFCT1VUXzVcIjpcIjIuIEwnYXBwbGljYXRpb24gb2ZmcmUgdW4gbW9kw6hsZSBkZSBzw6ljdXJpdMOpIMOgIHNlcyBjbGllbnQsIGF2ZWMgZGVzIGNsw6lzIHByaXbDqWVzIGjDqWJlcmfDqWVzIGxvY2FsZW1lbnQgZXQgamFtYWlzIGVudm95w6llcyDDoCBhdWN1biBzZXJ2ZXVycy5cIixcbiAgXCJBQk9VVF82XCI6XCIzLiBMJ2FwcGxpY2F0aW9uIG9mZnJlIHVuZSBpbnRlcmZhY2Ugc2ltcGxlIGV0IGRlcyBleHDDqXJpZW5jZXMgYXR0cmF5YW50ZXMgYXV4IHV0aWxpc2F0ZXVycy5cIixcbiAgXCJBQk9VVF83XCI6XCI0LiBMJ2FwcGxpY2F0aW9uIG5lIGRlbWFuZGUgamFtYWlzIMOgIGNlIHF1ZSBsZXMgdXRpbGlzYXRldXJzIHNhaXNpc3NlbnQgZGVzIGluZm9ybWF0aW9ucyBwZXJzb25uZWxsZXMuXCIsXG4gIFwiQUJPVVRfOFwiOlwiVm90ZXogcG91ciBnb29kLWthcm1hIGNvbW1lIHTDqW1vaW5cIixcbiAgXCJBQk9VVF85XCI6XCJDb250YWN0L1LDqWFjdGlvbjpcIixcbiAgXCJBQk9VVF8xMFwiOlwiUGx1cyBkJ2luZm9zOlwiLFxuICBcIlJFTU9WRVwiOlwiU3VwcHJpbWVyXCIsXG4gIFwiTUFSS0VUX1ZJRVdcIjpcIlZ1ZSBkdSBtYXJjaMOpXCIsXG4gIFwiUFJJQ0VcIjpcIlByaXhcIixcbiAgXCJBTU9VTlRcIjpcIk1vbnRhbnRcIixcbiAgXCJUT1RBTFwiOlwiXCIsXG4gIFwiTk9PUkRFUlNcIjpcIlBhcyBkJ29yZHJlcyBvdXZlcnRzIHBvdXJcIixcbiAgXCJEQVRFXCI6XCJcIixcbiAgXCJCVVlcIjpcIkFjaGF0XCIsXG4gIFwiU0VMTFwiOlwiVmVudGVcIixcbiAgXCJPUEVOXCI6XCJPdXZlcnRcIixcbiAgXCJISVNUT1JZXCI6XCJIaXN0b3JpcXVlXCIsXG4gIFwiRk9MTE9XX0JBQ0tcIjpcIlN1aXZyZVwiLFxuICBcIkZPTExPV0VEXCI6XCJBYm9ubsOpXCIsXG4gIFwiVU5GT0xMT1dcIjpcIkTDqXNhYm9ubmVyXCIsXG4gIFwiRk9MTE9XSU5HXCI6XCJcIixcbiAgXCJGT0xMT1dFUlNcIjpcIlwiLFxuICBcIlNFQVJDSF9GT0xMT1dFUlNcIjpcIkNoZXJjaGVyIGZvbGxvd2Vyc1wiLFxuICBcIlNFQVJDSF9GT0xMT1dJTkdcIjpcIkNoZXJjaGVyIGZvbGxvd2luZ1wiLFxuICBcIkJZXCI6XCJwYXJcIixcbiAgXCJJTlwiOlwiZGFuc1wiLFxuICBcIk1FTlVcIjpcIlwiLFxuICBcIkJPT0tNQVJLXCI6XCJTaWduZXRcIixcbiAgXCJSRUJMT0dcIjpcIlwiLFxuICBcIlVQVk9URVwiOlwiXCIsXG4gIFwiRE9XTlZPVEVcIjpcIlwiLFxuICBcIlVOVk9URV9ET1dOVk9URURcIjpcIlJldGlyZXIgRG93bnZvdGVcIixcbiAgXCJVTlZPVEVfVVBWT1RFRFwiOlwiUmV0aXJlciBVcHZvdGVcIixcbiAgXCJSRVBMWVwiOlwiUsOpcG9uZHJlXCIsXG4gIFwiRURJVFwiOlwiRWRpdGVyXCIsXG4gIFwiUE9TVF8xXCI6XCJHbGlzc2VyIHZlcnMgbGEgZ2F1Y2hlIHN1ciBsZXMgY29tbWVudGFpcmVzIHBvdXIgdm9pciBsZXMgb3B0aW9uc1wiLFxuICBcIlBPU1RfMlwiOlwiQXBwdXlleiBzdXIgbGVzIGNvbW1lbnRhaXJlcyBwb3VyIHZvaXIgbGVzIHNvdXMtY29tbWVudGFpcmVzXCIsXG4gIFwiT1BUSU9OU1wiOlwiXCIsXG4gIFwiUkVTVEVFTUVEX0JZXCI6XCJSZXN0ZWVtIHBhclwiLFxuICBcIk5PVEhJTkdfSEVSRVwiOlwiUmllbiBpY2kgZW5jb3JlLi4uXCIsXG4gIFwiQkFMQU5DRVNcIjpcIlNvbGRlc1wiLFxuICBcIlBST0ZJTEVfMVwiOlwiTGVzIHt7cGxhdGZvcm1uYW1lfX0sIGpldG9ucyBuw6lnb2NpYWJsZXMgcXVpIHBldXZlbnQgw6p0cmUgdHJhbnNmw6lyw6lzIMOgIHRvdXQgbW9tZW50LiBMZSB7e3BsYXRmb3JtbmFtZX19IHBldXQgw6p0cmUgY29udmVydGkgZW4ge3twbGF0Zm9ybXBvd2VyfX0gZGFucyB1biBwcm9jZXNzdXMgYXBwZWzDqSBwb3dlci11cC5cIixcbiAgXCJQUk9GSUxFXzJcIjpcInt7cGxhdGZvcm1wb3dlcn19LCBqZXRvbnMgZCdpbmZsdWVuY2UsIHZvdXMgZ2FnbmV6IHBsdXMgZGUgU3RlZW0gUG93ZXIgZW4gbGUgY29uY2VydmFudCDDoCBsb25nIHRlcm1lIGV0IGVuIHZvdGFudCBzdXIgbGVzIHBvc3Rlcy4gUGx1cyBvbiBsZSBjb25zZXJ2ZSwgcGx1cyBvbiBhIGQnaW5mbHVlbmNlIHN1ciBsZXMgcsOpY29tcGVuc2VzIGRlcyBhdXRyZXMgZXQgZGFucyBsJ29idGVudGlvbiBkZSByw6ljb21wZW5zZSBwb3VyIHVuIHZvdGUgZW4gcGFydGljdWxpZXIuXCIsXG4gIFwiUFJPRklMRV8zXCI6XCJKZXRvbnMgZCd1bmUgdmFsZXVyIGQnZW52aXJvbiB7e3BsYXRmb3Jtc3VuaXR9fSBkZSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuICBcIkVTVElNQVRFRF9WQUxVRVwiOlwiVmFsZXVyIGVzdGltw6llXCIsXG4gIFwiUFJPRklMRV80XCI6XCJMYSB2YWxldXIgZXN0aW3DqWUgZXN0IGNhbGN1bMOpZSBzdXIgdW5lIG1veWVubmUgZGUgMy41IGpvdXJzIGRlIGxhIHZhbGV1ciBkdSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuICBcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjpcIkhpc3RvcmlxdWUgZGVzIFRyYW5zYWN0aW9uc1wiLFxuICBcIlBPU1RJTkdcIjpcIlBvc3RlXCIsXG4gIFwiUFJPRklMRV81XCI6XCJMYSBjbMOpIGRlIHBvc3QgZXN0IHV0aWxpc8OpZSBwb3VyIHBvc3RlciBldCB2b3Rlci4gRWxsZSBkb2l0IMOqdHJlIGRpZmbDqXJlbnRlIGRlcyBjbMOpcyBhY3RpdmVzIGV0IHByb3ByacOpdGFpcmVzLlwiLFxuICBcIk9XTkVSXCI6XCJQcm9wcmnDqXRhaXJlXCIsXG4gIFwiUFJPRklMRV82XCI6XCJMYSBjbMOpIHByb3ByacOpdGFpcmUgZXN0IGxhIGNsw6kgcHJpbmNpcGFsZSBkdSBjb21wdGUgZXQgZXN0IHJlcXVpc2UgcG91ciBjaGFuZ2VyIGxlcyBhdXRyZXMgY2zDqXMuIExhIGNsw6kgcHJpdsOpZSBvdSBsZSBtb3QgZGUgcGFzc2UgZGUgbGEgY2zDqSBwcm9wcmnDqXRhaXJlIGRvaXZlbnQgw6p0cmUgbWlzIGhvcnMgbGlnbmUgYXV0YW50IHF1ZSBwb3NzaWJsZS5cIixcbiAgXCJBQ1RJVkVcIjpcIlwiLFxuICBcIlBST0ZJTEVfN1wiOlwiTGEgY2zDqSBhY3RpdmUgZXN0IHV0aWxpc8OpZSBwb3VyIGVmZmVjdHVlciBkZXMgdHJhbnNmZXJ0cyBldCBwYXNzZXIgZGVzIG9yZHJlcyBkYW5zIGxlIG1hcmNow6kgaW50w6lyaWV1ci5cIixcbiAgXCJNRU1PXCI6XCJNw6ltb1wiLFxuICBcIlBST0ZJTEVfOFwiOlwiTGEgY2zDqSBtw6ltbyBwZXJtZXQgZGUgY3LDqWVyIGV0IGRlIGxpcmUgZGVzIG3DqW1vcy5cIixcbiAgXCJCTE9HXCI6XCJcIixcbiAgXCJQT1NUU1wiOlwiXCIsXG4gIFwiUkVQTElFU1wiOlwiUsOpcG9uc2VzXCIsXG4gIFwiV0FMTEVUXCI6XCJQb3J0ZWZldWlsbGVcIixcbiAgXCJUQUdcIjpcIlwiLFxuICBcIlVTRVJcIjpcIlV0aWxpc2F0ZXVyXCIsXG4gIFwiQ0xPU0VcIjpcIkZlcm1lclwiLFxuICBcIlRPXCI6XCLDoFwiLFxuICBcIkFTU0VUXCI6XCJUeXBlXCIsXG4gIFwiU0VORFwiOlwiRW52b3llclwiLFxuICBcIlNFQ1VSSVRZXCI6XCJTw6ljdXJpdMOpXCIsXG4gIFwiQVZBSUxBQkxFXCI6XCJEaXNwb25pYmxlXCIsXG4gIFwiUFVCTElDX01FTU9cIjpcIk3DqW1vIHB1YmxpcXVlXCIsXG4gIFwiVE9fREVTQ1wiOlwiVXRpbGlzYXRldXIgcGFyIGV4LiBnb29kLWthcm1hXCIsXG4gIFwiUElOX0NPREVcIjpcIkNvZGUgUElOXCIsXG4gIFwiUElOX1RFWFRcIjpcIkxlIGNvZGUgUElOIHZvdXMgYWlkZSDDoCBzw6ljdXJpc2VyIGwnYXBwbGljYXRpb24gZXQgdm9zIGRvbm7DqWVzLiA8YnIvPjxici8+PGI+Tm90ZTo8L2I+IFVuZSBmb2lzIGFjdGl2w6ksIHZvdXMgYXZleiA0IHRlbnRhdGl2ZXMgbWF4aW11bSBwb3VyIGTDqXZlcnJvdWlsbGVyLCBzaSB2b3VzIGF2ZXogb3VibGnDqSBsZSBwaW4gb3Ugc2kgdm91cyDDqWNob3VleiwgbCdhcHBsaWNhdGlvbiBzdXBwcmltZXJhIGxlcyBkb25uw6llcyB1dGlsaXNhdGV1ciBlbnJlZ2lzdHLDqWVzLiBWb3VzIHBvdXZleiB2b3VzIHJlY29ubmVjdGVyIGV0IGNvbnRpbnVlciDDoCB1dGlsaXNlciBsJ2FwcGxpY2F0aW9uLlwiLFxuICBcIk5PVElGSUNBVElPTlNcIjpcIlwiLFxuICBcIlZPVEVfVEVYVFwiOlwiVm91cyByZWNldnJleiB1bmUgbm90aWZpY2F0aW9uIHF1YW5kIHF1ZWxxdSd1biB2b3RlcmEgcG91ciB1biBkZXMgdm9zIGNvbnRlbnVzISA8YnIvPiA8Yj5Ob3RlOjwvYj4gTGVzIG5vdGlmaWNhdGlvbnMgaW5jbHVlbnQgbGUgcG9pZHMgZHUgdm90ZSBkYW5zIGxlIG1lc3NhZ2UgZCdhbGVydGUuIChRdSdpbCBzJ2FnaXNzZSBkJ3VuIHVwdm90ZSwgZCcgdW4gZG93bnZvdGUgb3UgZCd1biB2b3RlIHJldGlyw6kpLlwiLFxuICBcIlZPVEVcIjpcIlwiLFxuICBcIkNPTU1FTlRfVEVYVFwiOlwiVm91cyByZWNldnJleiB1bmUgbm90aWZpY2F0aW9uIHF1YW5kIHF1ZWxxdSd1biBjb21tZW50ZXJhIHVuIGRlcyB2b3MgcG9zdHMgb3UgdW4gZGUgdm9zIGNvbW1lbnRhaXJlcyE8YnIvPiA8Yj5Ob3RlOjwvYj4gTGVzIG5vdGlmaWNhdGlvbnMgaW5jbHVlbnQgcXVhbmQgcXVlbHF1J3VuIDxiPsOpZGl0ZTwvYj4gc2VzIHByb3ByZXMgY29tbWVudGFpcmVzIGF1c3NpLlwiLFxuICBcIkNPTU1FTlRcIjpcIkNvbW1lbnRhaXJlXCIsXG4gIFwiRk9MTE9XX1RFWFRcIjpcIlZvdXMgcmVjZXZyZXogdW5lIG5vdGlmaWNhdGlvbiBxdWFuZCBxdWVscXUndW4gcydhYm9ubmVyYSBvdSBzZSBkw6lzYWJvbm5lcmEgZGUgdm91cyFcIixcbiAgXCJNRU5USU9OU1wiOlwiXCIsXG4gIFwiTUVOVElPTlNfVEVYVFwiOlwiVm91cyByZWNldnJleiB1bmUgbm90aWZpY2F0aW9uIHF1YW5kIHF1ZWxxdSd1biB2b3VzIG1lbnRpb25uZXJhIGRhbnMgdW4gcG9zdC9jb21tZW50YWlyZSFcIixcbiAgXCJSRVNURUVNXCI6XCJcIixcbiAgXCJSRVNURUVNX1RFWFRcIjpcIlZvdXMgcmVjZXZyZXogdW5lIG5vdGlmaWNhdGlvbiBxdWFuZCBxdWVscXUndW4gcmVzdGVlbSB2b3RyZSBwb3N0IVwiLFxuICBcIkNPTkZJR1VSQVRJT05TXCI6XCJcIixcbiAgXCJWT1RJTkdcIjpcIlZvdGVcIixcbiAgXCJWT1RJTkdfVEVYVFwiOlwiTGUgcG9pZHMgb3UgbGUgcG91cmNlbnRhZ2UgZHUgdm90ZSBhZmZlY3RlIGxlIHBvdXZvaXIgZGUgdm90ZSBkYW5zIGwnYXBwbGljYXRpb24sIGRlIHRlbGxlIG1hbmnDqHJlIHZvdXMgcG91dmV6IHLDqWdsZXIgdm90cmUgcsOpY29tcGVuc2UgZGUgdm90ZS4gPGJyLz48YnIvPjxiPk5vdGU6PC9iPiBDZWxhIGNoYW5nZXJhIGxlIHBvaWRzL3BvdXJjZW50YWdlIGR1IHZvdGUgcG91ciBsZSBkb3dudm90ZSBwYXJ0b3V0IGRhbnMgbCdhcHBsaWNhdGlvblwiLFxuICBcIlNFUlZFUlwiOlwiU2VydmV1clwiLFxuICBcIlNFUlZFUl9URVhUXCI6XCJSZWNvbW1hbmTDqVwiLFxuICBcIlNBVkVfQ0hBTkdFU1wiOlwiU2F1dmVnYXJkZXIgbGVzIGNoYW5nZW1lbnRzXCIsXG4gIFwiVk9URVJTX0lORk9cIjpcIkluZm8gdm90ZVwiLFxuICBcIldFTENPTUVfQkFDS1wiOlwiQmllbnZlbnVlIMOgIG5vdXZlYXUhXCIsXG4gIFwiTE9HSU5fMVwiOlwiQ29ubmVjdGV6LXZvdXMgYXZlYyB2b3RyZSBub20gZCd1dGlsaXNhdGV1ciBldCB2b3RyZSBtb3QgZGUgcGFzc2UgcG91ciBjb250aW51ZXIuXCIsXG4gIFwiTE9HSU5fMlwiOlwiTGEgY2zDqSBkZSBwb3N0cyBlc3QgdXRpbGlzw6llIHBvdXIgcG9zdGVyLCBjb21tZW50ZXIsIHZvdGVyLCBzdWl2cmUuXCIsXG4gIFwiTE9HSU5fM1wiOlwiTGEgY2zDqSBhY3RpdmUgZXN0IHV0aWxpc8OpZSBwb3VyIGxlcyB0cmFuc2ZlcnRzIGV0IGxhIG1pc2Ugw6Agam91ciBkZSBsJ2ltYWdlIGRlIHByb2ZpbC5cIixcbiAgXCJMT0dJTl80XCI6XCJMZXMgaW5mb3JtYXRpb25zIGQnaWRlbnRpZmljYXRpb24gZGUgbCd1dGlsaXNhdGV1ciBzb250IGNvbnNlcnbDqWVzIGxvY2FsZW1lbnQgc3VyIHZvdHJlIGFwcGFyZWlsLiBMb3JzIGRlIGxhIGTDqWNvbm5leGlvbiBlbGxlcyBzb250IHN1cHByaW3DqWVzIVwiLFxuICBcIkRPTlRfSEFWRVwiOlwiUGFzIGVuY29yZSBkZSBjb21wdGU/XCIsXG4gIFwiU0lHTl9VUF9OT1dcIjpcIkVucmVnaXN0cmV6LXZvdXMgbWFpbnRlbmFudFwiLFxuICBcIkNBTkNFTFwiOlwiU3VwcHJpbWVyXCIsXG4gIFwiQURWQU5DRURcIjpcIkF2YW5jw6lcIixcbiAgXCJBQ1RJVkVfUFJJS0VZXCI6XCJDbMOpIHByaXbDqWUgYWN0aXZlXCIsXG4gIFwiUE9TVElOR19QUklLRVlcIjpcIkNsw6kgcHJpdsOpZSBkZSBwb3N0c1wiLFxuICBcIk1BU1RFUl9QQVNTXCI6XCJNb3QgZGUgcGFzc2UgcHJpbmNpcGFsXCIsXG4gIFwiVVNFUk5BTUVcIjpcIk5vbSBkJ3V0aWxpc2F0ZXVyXCIsXG4gIFwiQ0FSRF9WSUVXXCI6XCJWdWUgdGh1aWxlXCIsXG4gIFwiQ09NUEFDVF9WSUVXXCI6XCJWdWUgY29tcGFjdGVcIixcbiAgXCJTRUFSQ0hcIjpcIlJlY2hlcmNoZXJcIixcbiAgXCJTVUJNSVRfQV9TVE9SWVwiOlwiUHJvcG9zZXIgdW4gcG9zdFwiLFxuICBcIlJFUExZVE9cIjpcIlLDqXBvbmRyZSDDoFwiLFxuICBcIlBPU1RcIjpcIlwiLFxuICBcIlBSRVZJRVdcIjpcIkFwZXLDp3VcIixcbiAgXCJERUZBVUxUXCI6XCJQYXIgZMOpZmF1dCA1MCUgLyA1MCVcIixcbiAgXCJQT1dFUlVQXCI6XCJcIixcbiAgXCJERUNMSU5FX1BBWU9VVFwiOlwiUmVmdXNlciBsZSBwYXllbWVudFwiLFxuICBcIlNBVkVfRk9SX0xBVEVSXCI6XCJTYXV2ZWdhcmRlciBwb3VyIHBsdXMgdGFyZFwiLFxuICBcIkNMRUFSXCI6XCJFZmZhY2VyXCIsXG4gIFwiUE9TVF9DT05URU5UXCI6XCJQb3N0ZXIgbGUgY29udGVudVwiLFxuICBcIkNPTU1FTlRfQ09OVEVOVFwiOlwiQ29tbWVudGVyXCIsXG4gIFwiVElUTEVcIjpcIlRpdHJlXCIsXG4gIFwiVEFHU1wiOlwiXCIsXG4gIFwiTk9UX01BVENIXCI6XCJQYXMgZGUgY29uY29yZGFuY2VcIixcbiAgXCJDT05GSVJNX1BJTlwiOlwiQ29uZmlybWVyIFBJTlwiLFxuICBcIklOQ09SUkVDVFwiOlwiXCIsXG4gIFwiT1BFTklOR19QT1NUXCI6XCJPdXZlcnR1cmUgZHUgcG9zdFwiLFxuICBcIlNFVF9QSU5cIjpcIkNvbmZpZ3VyZXIgUElOXCIsXG4gIFwiRU5URVJfUElOXCI6XCJFbnRyZXIgUElOXCIsXG4gIFwiQVJFX1lPVV9TVVJFXCI6XCJWb3VzIMOqdGVzIHN1cj9cIixcbiAgXCJSRUJMT0dfVEVYVFwiOlwiUmVzdGVlbSBlc3QgaXJyw6l2ZXJzaWJsZSwgdm91bGV6LXZvdXMgY29udGludWVyP1wiLFxuICBcIkJST0FEQ0FTVF9FUlJPUlwiOlwiRXJyZXVyIGRlIGRpZmZ1c2lvbiwgZXNzYXllciDDoCBub3V2ZWF1IVwiLFxuICBcIlNVQ0NFU1NcIjpcIlLDqXVzc2l0ZVwiLFxuICBcIlJFQkxPR0dFRF9QT1NUXCI6XCJQb3N0IHJlYmxvZ8OpIVwiLFxuICBcIkxPR0lOX0ZBSUxcIjpcIkVjaGVjIGRlIGxhIGNvbm5leGlvbiEgVmV1aWxsZXogdm91cyBhc3N1cmVyIGQnYXZvaXIgb3V2ZXJ0IHVuZSBzZXNzaW9uIGF2ZWMgbGUgbW90IGRlIHBhc3NlIHByaW5jaXBhbCBvdSB2b3RyZSBjbMOpIHByaXbDqWUgZGUgcG9zdCBzaSB2b3VzIGF2ZXogY2hvaXNpIGxlIG1vZGUgYXZhbmPDqS5cIixcbiAgXCJMT0dJTl9GQUlMX0FcIjpcIsOJY2hlYyBkZSBsYSBjb25uZXhpb24hIFZldWlsbGV6IHZvdXMgYXNzdXJlciBkJ2F2b2lyIG91dmVydCB1bmUgc2Vzc2lvbiBhdmVjIGxlIG1vdCBkZSBwYXNzZSBwcmluY2lwYWwgb3UgYXZvaXIgZm91cm5pIHVuZSBjbMOpIHByaXbDqWUgYWN0aXZlIGxvcnMgZGUgbGEgY29ubmV4aW9uIHNpIHZvdXMgYXZleiBjaG9pc2kgbGUgbW9kZSBBdmFuY8OpLlwiLFxuICBcIldBUk5JTkdcIjpcIkF0dGVudGlvblwiLFxuICBcIlZPVEVfRk9SX1dJVE5FU1NcIjpcIlZvdGUgcG91ciB0w6ltb2luXCIsXG4gIFwiVk9URURfRk9SX1dJVE5FU1NcIjpcImEgdm90w6kgcG91ciB0w6ltb2luXCIsXG4gIFwiQUdPXCI6XCJkZXB1aXNcIixcbiAgXCJGUk9NX05PV1wiOlwiw6AgcGFydGlyIGRlIG1haW50ZW5hbnRcIixcbiAgXCJTRUNTXCI6XCJTZWNvbmRlc1wiLFxuICBcIkFfTUlOXCI6XCJ1bmUgbWluXCIsXG4gIFwiTUlOU1wiOlwiXCIsXG4gIFwiQU5fSE9VUlwiOlwidW5lIGhldXJlXCIsXG4gIFwiSE9VUlNcIjpcImhcIixcbiAgXCJBX0RBWVwiOlwidW4gam91clwiLFxuICBcIkRBWVNcIjpcImpvdXJzXCIsXG4gIFwiQV9NT05USFwiOlwidW4gbW9pc1wiLFxuICBcIk1PTlRIU1wiOlwibW9pc1wiLFxuICBcIkFfWUVBUlwiOlwidW5lIGFubsOpZVwiLFxuICBcIllFQVJTXCI6XCJhbm7DqWVzXCIsXG4gIFwiTUlOX1JFQURcIjpcIm1pbiB0ZW1wcyBsZWN0dXJlXCIsXG4gIFwiRE9XTlZPVEVfRkxBR1wiOlwiRG93bnZvdGVcIixcbiAgXCJDQVBUVVJFX1BJQ1RVUkVcIjpcIkNhcHR1cmVyIEltYWdlXCIsXG4gIFwiU0VMRUNUX1BJQ1RVUkVcIjpcIlPDqWxlY3Rpb25uZXIgSW1hZ2VcIixcbiAgXCJTRVRfQ1VTVE9NX1VSTFwiOlwiQ29uZmlndXJlciBVUkwgcGVyc29ubmFsaXPDqWVcIixcbiAgXCJJTlNFUlRfUElDVFVSRVwiOlwiSW5zw6lyZXIgSW1hZ2VcIixcbiAgXCJFUlJPUlwiOlwiRXJyZXVyXCIsXG4gIFwiVVBMT0FEX0VSUk9SXCI6XCJFcnJldXIgdMOpbMOpY2hhcmdlbWVudFwiLFxuICBcIkNBTUVSQV9DQU5DRUxMRURcIjpcIkNhbcOpcmEgc3VwcHJpbcOpZVwiLFxuICBcIlNFVF9VUkxcIjpcIkNvbmZpZ3VyZXIgVVJMXCIsXG4gIFwiRElSRUNUX0xJTktfUElDVFVSRVwiOlwiTGllbiBkaXJlY3QgcG91ciBsJ2ltYWdlXCIsXG4gIFwiQ09NTUVOVF9TVUJNSVRURURcIjpcIkNvbW1lbnRhaXJlIGVudm95w6khXCIsXG4gIFwiREVMRVRFX0NPTU1FTlRcIjpcIkxhIHN1cHByZXNzaW9uIGRlcyBjb21tZW50YWlyZXMgZXN0IGlycsOpdmVyc2libGUuXCIsXG4gIFwiREVMRVRFRF9DT01NRU5UXCI6XCJDb21tZW50YWlyZSBzdXBwcmltw6lcIixcbiAgXCJVUExPQURJTkdfUElDVFVSRVwiOlwiVMOpbMOpY2hhcmdlbWVudCBkZSBsJ2ltYWdlXCIsXG4gIFwiVVBMT0FEX0NPTVBMRVRFRFwiOlwiVMOpbMOpY2hhcmdlbWVudCB0ZXJtaW7DqVwiLFxuICBcIlVQTE9BRF9GQUlMRURcIjpcIlTDqWzDqWNoYXJnZW1lbnQgw6ljaG91w6lcIixcbiAgXCJQQVNTV09SRF9JTkNPUlJFQ1RcIjpcIk1vdCBkZSBwYXNzZSBvdSBub20gZCd1dGlsaXNhdGV1ciBpbmNvcnJlY3RcIixcbiAgXCJJTkZPXCI6XCJcIixcbiAgXCJRUl9URVhUXCI6XCJQbGFjZXIgbGUgUVIgY29kZSBkYW5zIGxhIHpvbmUgZGUgc2NhblwiLFxuICBcIkJBTEFOQ0VfVEVYVFwiOlwiU295ZXogc3VyIGQnYXZvaXIgdW4gc29sZGUgc3VmZmlzYW50IHBvdXIgbGEgdHJhbnNhY3Rpb24hXCIsXG4gIFwiTk9ORVhJU1RfVVNFUlwiOlwiTCd1dGlsaXNhdGV1ciBhdXF1ZWwgdm91cyBlc3NheWV6IGQnZW52b3llciBkZXMgZm9uZHMgbidleGlzdGUgcGFzIVwiLFxuICBcIlRSQU5TRkVSX1RFWFRcIjpcIkV0ZXMtdm91cyBzdXIgZGUgdm91bG9pciB0cmFuc2bDqXJlcj9cIixcbiAgXCJDT05GSVJNQVRJT05cIjpcIlwiLFxuICBcIlRYX0JST0FEQ0FTVEVEXCI6XCJMYSB0cmFuc2FjdGlvbiBlc3QgZGlmZnVzw6llXCIsXG4gIFwiRkVFRFwiOlwiU3VpdmlzXCIsXG4gIFwiVFJFTkRJTkdcIjpcIlRlbmRhbmNlXCIsXG4gIFwiSE9UXCI6XCJcIixcbiAgXCJORVdcIjpcIk5vdXZlYXVcIixcbiAgXCJQUk9NT1RFRFwiOlwiUHJvbXVcIixcbiAgXCJWT1RFU1wiOlwiXCIsXG4gIFwiUEFZT1VUXCI6XCJQYWllbWVudFwiLFxuICBcIkNPTU1FTlRTXCI6XCJDb21tZW50YWlyZXNcIixcbiAgXCJUUkVORElOR18zMFwiOlwiVGVuZGFuY2UgZGVwdWlzIDMwIGpvdXJzXCIsXG4gIFwiU09SVF9QT1NUX0JZXCI6XCJDbGFzc2VyIHBvc3RzIHBhcjpcIixcbiAgXCJQQVlPVVRfQ1lDTEVcIjpcIkN5Y2xlIGRlIFBhaWVtZW50XCIsXG4gIFwiUE9URU5USUFMX1BBWU9VVFwiOlwiUGFpZW1lbnQgcG90ZW50aWVsXCIsXG4gIFwiUEFTVF9QQVlPVVRcIjpcIlBhaWVtZW50IHBhc3PDqVwiLFxuICBcIkFVVEhPUl9QQVlPVVRcIjpcIlBhaWVtZW50IGF1dGV1clwiLFxuICBcIkNVUkFUSU9OX1BBWU9VVFwiOlwiUGFpZW1lbnQgdm90ZXNcIixcbiAgXCJQT1NUX1NVQk1JVFRFRFwiOlwiUG9zdCBlbnZvecOpIVwiLFxuICBcIlBPU1RfTEFURVJcIjpcIlNvdW1ldHRyZSBsZSBwb3N0IHBsdXMgdGFyZCFcIixcbiAgXCJTQVZFRFwiOlwiU2F1dmVnYXJkw6lcIixcbiAgXCJDTEVBUkVEXCI6XCJTdXBwcmltw6lcIixcbiAgXCJGTEFHR0lOR19URVhUXCI6XCJEb3dudm90ZSB1biBwb3N0IHBldXQgZW5sZXZlciBsZXMgcsOpY29tcGVuc2VzIGV0IHJlbmRyZSBjZWx1aS1jaSBtb2lucyB2aXNpYmxlLjxicj48YnI+TGUgRG93bnZvdGUgZGV2cmFpdCDDqnRyZSB1dGlsaXPDqSBwb3VyIGNlY2k6IDx1bD48bGk+RnJhdWRlIG91IFBsYWdpYXJpc21lPC9saT48bGk+VHJvbGxzIG91IGRpc2NvdXJzIGRlIGhhaW5lPC9saT48bGk+Q29udGVudSBpbmFwcHJvcHJpw6kgaW50ZW50aW9ubmVsIG91IFNwYW08L2xpPjwvdWw+XCIsXG4gIFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6XCJMaW1pdGUgYXR0ZWludGUuIETDqWNvdXZyZXogZCdhdXRyZXMgdGFncy90ZW5kYW5jZXMhXCIsXG4gIFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6XCJQb3N0IGVubGV2w6kgZGVzIHNpZ25ldHMhXCIsXG4gIFwiUE9TVF9JU19CT09LTUFSS1wiOlwiUG9zdCBham91dMOpIGF1IHNpZ25ldHMhXCIsXG4gIFwiUkVTRVRcIjpcIlLDqWluaXRpYWxpc2VyXCIsXG4gIFwiTU9ESUZZX1BJQ1RVUkVcIjpcIk1vZGlmaWVyIGwnaW1hZ2UgZHUgcHJvZmlsXCIsXG4gIFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjpcIk1vZGlmaWVyIGwnaW1hZ2UgZGUgY291dmVydHVyZVwiLFxuICBcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOlwiU1ZQLCB2ZXVpbGxleiBpbmRpcXVlciBsYSBjbMOpIHByaXbDqWUgYWN0aXZlIHNpIHZvdXMgYXZleiBjaG9pc2kgbGUgbW9kZSBkZSBjb25uZXhpb24gYXZhbmPDqS5cIixcbiAgXCJSRVNFVF9QSUNUVVJFX1RFWFRcIjpcIkNlY2kgdmEgcsOpaW5pdGlhbGlzZXIgbCdpbWFnZSBwcm9maWwgZGUgbCd1dGlsaXNhdGV1clwiLFxuICBcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOlwiQ2VjaSB2YSByw6lpbml0aWFsaXNlciBsJ2ltYWdlIGRlIGNvdXZlcnR1cmUgZGUgbCd1dGlsaXNhdGV1clwiLFxuICBcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6XCJMYSBtaXNlIMOgIGpvdXIgZHUgc2VydmV1ciBuw6ljZXNzaXRlIHVuIHJlZMOpbWFycmFnZSFcIixcbiAgXCJTRVRUSU5HU19VUERBVEVEXCI6XCJQYXJhbcOodHJlcyBtaXMgw6Agam91ciFcIixcbiAgXCJMQU5HVUFHRVNcIjpcIkxhbmd1ZXNcIixcbiAgXCJMQU5HVUFHRVNfVEVYVFwiOlwiVm91cyBwb3V2ZXogY2hhbmdlciBpY2kgbGEgbGFuZ3VlIGRlIGwnYXBwbGljYXRpb25cIixcbiAgXCJMT0dJTl9UT19YXCI6XCJDZXR0ZSBvcMOpcmF0aW9uIHJlcXVpZXJ0IHF1ZSBsJ3V0aWxpc2F0ZXVyIHNvaXQgY29ubmVjdMOpIGF2ZWMgbGUgbW90IGRlIHBhc3NlIHByaW5jaXBhbCwgbGEgY2zDqSBkZSBwb3N0L2Nsw6kgYWN0aXZlLiBWZXVpbGxleiB2b3VzIGNvbm5lY3RlciBldCByw6llc3NheWVyLlwiLFxuICBcIkdBTExFUllcIjpcIkdhbGxlcmllXCIsXG4gIFwiVFJBTlNMQVRJT05TXCI6XCJDb250cmlidXRldXJzIGRlIHRyYWR1Y3Rpb25cIixcbiAgXCJTSEFSRVwiOlwiUGFydGFnZVwiLFxuICBcIk1BUktFVFBMQUNFXCI6XCJNYXJjaMOpXCIsXG4gIFwiRVhDSEFOR0VcIjpcIkVjaGFuZ2VcIixcbiAgXCJEUkFGVFNcIjpcIkJyb3VpbGxvbnNcIixcbiAgXCJQT1NUX0lTX1VORFJBRlRcIjpcIlBvc3Qgc3VwcHJpbcOpIGRlcyBicm91aWxsb25zIVwiLFxuICBcIlBPU1RfSVNfRFJBRlRcIjpcIlBvc3QgYWpvdXTDqSBhdXggYnJvdWlsbG9ucyFcIixcbiAgXCJTV0lQRV9MRUZUXCI6XCJHbGlzc2VyIHZlcnMgbGEgZ2F1Y2hlIHBvdXIgdm9pciBsZXMgb3B0aW9uc1wiLFxuICBcIk1BTkFHRVwiOlwiR8OpcmVyXCIsXG4gIFwiSU1BR0VfUkVNT1ZFRFwiOlwiSW1hZ2UgZW5sZXbDqWVcIixcbiAgXCJDT1BZXCI6XCJjb3Bpw6lcIixcbiAgXCJOT19JTUFHRVwiOlwiVm91cyBuJ2F2ZXogcGFzIGVuY29yZSB0w6lsw6ljaGFyZ2VyIGQnaW1hZ2VzIHBvdXIgbGUgbW9tZW50IVwiLFxuICBcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6XCJUaXJleiB2ZXJzIGxlIGJhcyBwb3VyIHJhZnJhw65jaGlyXCIsXG4gIFwiRVhURVJOQUxfQVBQU1wiOlwiQXBwcyBleHRlcm5lXCIsXG4gIFwiUExVR0lOU1wiOlwiXCIsXG4gIFwiU1VHR0VTVFwiOlwiU3VnZ2VzdGlvblwiLFxuICBcIkNPTUlOR19TT09OXCI6XCJCaWVudMO0dFwiLFxuICBcIkNIQUlOXCI6XCJcIixcbiAgXCJDSEFJTl9URVhUXCI6XCJJY2kgdm91cyBwb3V2ZXogY2hhbmdlciBwb3VyIGxhIGJsb2NrY2hhaW4gb3UgbGEgcGxhdGUtZm9ybWUgcGFyIGTDqWZhdXQuXCIsXG4gIFwiQ1VSUkVOQ1lcIjpcIlwiLFxuICBcIkNVUlJFTkNZX1RFWFRcIjpcIlwiLFxuICBcIkFCT1VUXzExXCI6XCJcIixcbiAgXCJGT1VOREVSXCI6XCJcIixcbiAgXCJBRERfQUNDT1VOVFwiOlwiXCIsXG4gIFwiUExBVEZPUk1cIjpcIlwiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIkhPTUVcIjpcItei157XldeTINeU15HXmdeqXCIsXG4gIFwiTE9HSU5cIjpcIteb16DXmdeh15RcIixcbiAgXCJMT0dPVVRcIjpcIteZ16bXmdeQ15RcIixcbiAgXCJQUk9GSUxFXCI6XCLXpNeo15XXpNeZ15xcIixcbiAgXCJGT0xMT1dcIjpcItec16LXp9eV15FcIixcbiAgXCJCT09LTUFSS1NcIjpcIteh15nXnteg15nXldeqXCIsXG4gIFwiVFJBTlNGRVJcIjpcIteU16LXkdeo15RcIixcbiAgXCJNQVJLRVRcIjpcItep15XXp1wiLFxuICBcIlNFVFRJTkdTXCI6XCLXkNek16nXqNeV15nXldeqXCIsXG4gIFwiQUJPVVRcIjpcItee15nXk9eiXCIsXG4gIFwiQUJPVVRfMVwiOlwi157Xp9eV150g16nXkdeVINeb15wg15DXl9eTINeZ15vXldecINec15TXqNeV15XXmdeXINeR15bXm9eV16og15TXqteb16DXmdedINep15zXlSFcIixcbiAgXCJBQk9VVF8yXCI6XCLXnteV16TXotecINei15wg15nXk9eZIHt7cGxhdGZvcm1uYW1lfX0uINeU15DXpNeZ15zXp9em15nXlCDXoNeb16rXkdeUINei15wg15nXk9eZXCIsXG4gIFwiQUJPVVRfM1wiOlwi15XXlNeV15Ag16TXqteV15csINeV157Xldeg16Ig16LXnCDXmdeT15kg15TXp9eU15nXnNeULiDXlNeV15Ag157XpteZ16Ig15LXmdep15Qg15zXp9eo15nXkNeULCDXnNeb16rXmdeR16og16rXkteV15HXldeqLCDXnNec15nXmden15nXnSwg15zXlNei15HXqNeqINeb16HXpNeZ150g15XXm9eVJy4g15TXpNei15XXnNeV16og157Xldem16LXldeqINei15wg15nXk9eZINeU15HXnNeV16fXpifXmdeZ158g16nXnCB7e3BsYXRmb3JtbmFtZX19INeV16LXnCDXmdeT15kge3tzaXRlbmFtZX19XCIsXG4gIFwiQUJPVVRfNFwiOlwiMS4g15zXkNek15zXmden16bXmdeUINeQ15nXnyDXkteZ16nXlCDXnNeb16HXpNeZ150g16nXnCDXlNee16nXqtee16kuXCIsXG4gIFwiQUJPVVRfNVwiOlwiMi4g15TXkNek15zXmden16bXmdeUINeU15nXkCDXkdeY15XXl9eULCDXm9ep15TXp9eV15Mg15TXpNeo15jXmSDXqdee15XXqCDXnten15XXnteZ16og15XXnNeQINeg16nXnNeXINec16nXqNeq15nXnSDXl9eZ16bXldeg15nXmdedLlwiLFxuICBcIkFCT1VUXzZcIjpcIjMuINeU15DXpNec15nXp9em15nXlCDXntem15nXoteUINeS15nXqdeUINek16nXldeY15Qg15XXoNeV15fXlCDXnNee16nXqtee16kuXCIsXG4gIFwiQUJPVVRfN1wiOlwiNC4g15TXkNek15zXmden16bXmdeUINec15Ag157Xkden16nXqiDXntee16nXqtee16nXmdedINee15nXk9eiINek16jXmNeZLlwiLFxuICBcIkFCT1VUXzhcIjpcIteU16bXkdeZ16LXlSDXnC1nb29kLWthcm1hINeR16rXldeoINei15NcIixcbiAgXCJBQk9VVF85XCI6XCLXpteV16gg16fXqdeoXCIsXG4gIFwiQUJPVVRfMTBcIjpcItee15nXk9eiINeg15XXodejOlwiLFxuICBcIlJFTU9WRVwiOlwi15TXodeo15RcIixcbiAgXCJNQVJLRVRfVklFV1wiOlwi16bXpNeUINeR16nXldenXCIsXG4gIFwiUFJJQ0VcIjpcItee15fXmdeoXCIsXG4gIFwiQU1PVU5UXCI6XCLXm9ee15XXqlwiLFxuICBcIlRPVEFMXCI6XCLXodeaINeU15vXnFwiLFxuICBcIk5PT1JERVJTXCI6XCLXkNeZ158g15TXltee16DXldeqINek16rXldeX15XXqiDXoteR15XXqFwiLFxuICBcIkRBVEVcIjpcIteq15DXqNeZ15pcIixcbiAgXCJCVVlcIjpcIten16DXmdeZ15RcIixcbiAgXCJTRUxMXCI6XCLXnteb15nXqNeUXCIsXG4gIFwiT1BFTlwiOlwi16TXqteZ15fXlFwiLFxuICBcIkhJU1RPUllcIjpcIteU15nXodeY15XXqNeZ15RcIixcbiAgXCJGT0xMT1dfQkFDS1wiOlwi15zXoten15XXkVwiLFxuICBcIkZPTExPV0VEXCI6XCLXoteV16fXkVwiLFxuICBcIlVORk9MTE9XXCI6XCLXnNeU16TXodeZ16cg15zXoten15XXkVwiLFxuICBcIkZPTExPV0lOR1wiOlwi16LXlden15FcIixcbiAgXCJGT0xMT1dFUlNcIjpcItei15XXp9eR15nXnVwiLFxuICBcIlNFQVJDSF9GT0xMT1dFUlNcIjpcIteX15nXpNeV16kg15HXoteV16fXkdeZ150g15DXl9eo15nXmVwiLFxuICBcIlNFQVJDSF9GT0xMT1dJTkdcIjpcIteX15nXpNeV16kg15HXnteZINep15DXoNeZINei15XXp9eRINeQ15fXqNeZ15VcIixcbiAgXCJCWVwiOlwi16LXnCDXmdeT15lcIixcbiAgXCJJTlwiOlwi15HXqteV15pcIixcbiAgXCJNRU5VXCI6XCLXqtek16jXmdeYXCIsXG4gIFwiQk9PS01BUktcIjpcIteh15nXnteg15nXlFwiLFxuICBcIlJFQkxPR1wiOlwi16LXqdeVINeo15nXkdec15XXklwiLFxuICBcIlVQVk9URVwiOlwi15zXmdeZ16dcIixcbiAgXCJET1dOVk9URVwiOlwi15DXoNec15nXmdenXCIsXG4gIFwiVU5WT1RFX0RPV05WT1RFRFwiOlwi15HXmdeY15XXnCDXkNeg15zXmdeZ16dcIixcbiAgXCJVTlZPVEVfVVBWT1RFRFwiOlwi15HXmdeY15XXnCDXnNeZ15nXp1wiLFxuICBcIlJFUExZXCI6XCLXnNeU16nXmdeRXCIsXG4gIFwiRURJVFwiOlwi16LXqNeZ15vXlFwiLFxuICBcIlBPU1RfMVwiOlwi15TXl9ec16cg15DXqiDXlNeq15LXldeUINep157XkNec15Qg15zXptek15nXmdeUINeR15DXpNep16jXldeZ15XXqlwiLFxuICBcIlBPU1RfMlwiOlwi15zXl9elINei15wg16rXkteV15HXlCDXm9eT15kg15zXqNeQ15XXqiDXqteq15kt16rXkteV15HXldeqXCIsXG4gIFwiT1BUSU9OU1wiOlwi15DXpNep16jXldeZ15XXqlwiLFxuICBcIlJFU1RFRU1FRF9CWVwiOlwi16LXqdeVINeo15nXodeY15nXnVwiLFxuICBcIk5PVEhJTkdfSEVSRVwiOlwi15DXmdefINek15Qg15vXnNeV150g16LXk9eZ15nXny4uLlwiLFxuICBcIkJBTEFOQ0VTXCI6XCLXm9eh16TXmdedXCIsXG4gIFwiUFJPRklMRV8xXCI6XCJ7e3BsYXRmb3JtbmFtZX19LCDXnteY15HXoteV16og16nXoNeZ16rXoNeZ150g15zXlNei15HXqNeUINeR15vXnCDXoteqLiDXoNeZ16rXnyDXnNeU157XmdeoIHt7cGxhdGZvcm1uYW1lfX0g15wte3twbGF0Zm9ybXBvd2VyfX0g15HXoteW16jXqiDXqteU15zXmdeaINep16DXp9eo15Ag16TXkNeV15XXqC3XkNekLlwiLFxuICBcIlBST0ZJTEVfMlwiOlwie3twbGF0Zm9ybXBvd2VyfX0sINee15jXkdei15XXqiDXlNep16TXoteUINep157Xldeh15nXpNeZ150g15zXm9edINeb15XXlyDXkdeU16bXkdei15QuINeb15vXnCDXqdeZ16kg15zXm9edINeZ15XXqteoLCDXqteV15vXnNeZINec15TXqdek15nXoiDXmdeV16rXqCDXotecINeU16rXqdec15XXnSDXqdecINek15XXodeY15nXnSDXldeq15XXm9ec15Ug15zXlNeo15XXldeZ15cg16jXldeV15fXmdedINeS15PXldec15nXnSDXmdeV16rXqCDXkdeU16bXkdei15QuXCIsXG4gIFwiUFJPRklMRV8zXCI6XCLXnteY15HXoteV16og16nXqdeV15nXmdedIHt7cGxhdGZvcm1zdW5pdH19INep15wge3twbGF0Zm9ybW5hbWV9fS5cIixcbiAgXCJFU1RJTUFURURfVkFMVUVcIjpcItei16jXmiDXnteV16LXqNeaXCIsXG4gIFwiUFJPRklMRV80XCI6XCLXlNei16jXmiDXl9eV16nXkSDXotecINeZ15PXmSDXntee15XXpteiINee15fXmdeo15nXnSDXkS03INeU15nXnteZ150g15TXkNeX16jXldeg15nXnSDXqdecIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG4gIFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOlwi15TXmdeh15jXldeo15nXmdeqINek16LXldec15XXqlwiLFxuICBcIlBPU1RJTkdcIjpcIteU16LXnNeQ16og16TXldeh15hcIixcbiAgXCJQUk9GSUxFXzVcIjpcItee16TXqteXINeU16TXldeh15jXmdedINeg15XXoteTINec15vXqteZ15HXqiDXpNeV16HXmNeZ150g15XXnNec15nXmden15nXnS4g16LXnNeZ15Ug15zXlNeZ15XXqiDXqdeV16DXlCDXnteU157XpNeq15cg15TXpNei15nXnCDXldee157XpNeq15cg15TXntep16rXntepLlwiLFxuICBcIk9XTkVSXCI6XCLXkdei15zXmdedXCIsXG4gIFwiUFJPRklMRV82XCI6XCLXntek16rXlyDXlNee16nXqtee16kg15TXldeQINeU157XpNeq15cg15TXqNeQ16nXmSDXnNeX16nXkdeV158g15XXlNeV15Ag16DXl9eV16Ug16LXnCDXnteg16og15zXqdeg15XXqiDXntek16rXl9eV16og15DXl9eo15nXnS4g15TXntek16rXlyDXlNek16jXmNeZINeQ15Ug15TXodeZ16HXnteQINec16fXkdec16og157XpNeq15cg15TXntep16rXntepINeX15nXmdeR15nXnSDXnNeU15nXldeqINep157Xldeo15nXnSDXnteX15XXpSDXnNeQ16rXqC5cIixcbiAgXCJBQ1RJVkVcIjpcItek16LXmdecXCIsXG4gIFwiUFJPRklMRV83XCI6XCLXlNee16TXqteXINeU16TXoteZ15wg16DXldei15Mg15zXkdeZ16bXldeiINeU15HXqNeV16og15vXodek15nXnSDXldec15HXmdem15XXoiDXlNeW157XoNeV16og15HXqdeV16cg15TXpNeg15nXnteZLlwiLFxuICBcIk1FTU9cIjpcIteU16LXqNeUXCIsXG4gIFwiUFJPRklMRV84XCI6XCLXntek16rXlyDXlNeq15bXmdeb15nXqNedINeg15XXoteTINec15vXqteZ15HXqiDXlden16jXmdeQ16og16rXlteb15nXqNeZ150uXCIsXG4gIFwiQkxPR1wiOlwi15HXnNeV15JcIixcbiAgXCJQT1NUU1wiOlwi16TXldeh15jXmdedXCIsXG4gIFwiUkVQTElFU1wiOlwi16rXkteV15HXldeqXCIsXG4gIFwiV0FMTEVUXCI6XCLXkNeo16DXp1wiLFxuICBcIlRBR1wiOlwi15jXkNeS15nXnVwiLFxuICBcIlVTRVJcIjpcItee16nXqtee16lcIixcbiAgXCJDTE9TRVwiOlwi16HXkteV16hcIixcbiAgXCJUT1wiOlwi15DXnFwiLFxuICBcIkFTU0VUXCI6XCLXoNeb16FcIixcbiAgXCJTRU5EXCI6XCLXnNep15zXldeXXCIsXG4gIFwiU0VDVVJJVFlcIjpcIteR15jXmdeX15XXqlwiLFxuICBcIkFWQUlMQUJMRVwiOlwi16TXoNeV15lcIixcbiAgXCJQVUJMSUNfTUVNT1wiOlwi15TXoteo15Qg16TXldee15HXmdeqXCIsXG4gIFwiVE9fREVTQ1wiOlwi157Xqdeq157XqSwg15zXk9eV15LXnteQIGdvb2Qta2FybWFcIixcbiAgXCJQSU5fQ09ERVwiOlwi16fXldeTXCIsXG4gIFwiUElOX1RFWFRcIjpcIten15XXkyDXoteV15bXqCDXnNeb150g15zXkNeR15jXlyDXkNeqINeU15DXpNeZ15zXp9em15nXlCDXldeQ16og15TXnteZ15PXoiDXqdec15vXnS4g15TXoteo15Q6INeR16jXkteiINep15TXldek16LXnCwg15DXpNep16gg15zXoNeh15XXqiDXnNek16rXldeXINei15MgNCDXpNei157XmdedLiDXkNedINep15vXl9eq150g15DXqiDXlNen15XXkywg15TXkNek15zXmden16bXmdeUINeq157Xl9enINeQ16og15TXnteZ15PXoiDXqdecINeU157Xqdeq157XqS4g16rXldeb15wg15zXlNeZ15vXoNehINee15fXk9epINeV15zXlNep16rXntepINeR15DXpNec15nXp9em15nXlC5cIixcbiAgXCJOT1RJRklDQVRJT05TXCI6XCLXlNeV15PXoteV16pcIixcbiAgXCJWT1RFX1RFWFRcIjpcIteq16fXkdeV15wg15TXldeT16LXlCDXm9ep157Xmdep15TXlSDXmdei16nXlCDXnNeb150g15zXmdeZ16chINeU16LXqNeUOiDXlNeU15XXk9ei15XXqiDXmdeb15zXnNeVINeS150g15DXqiDXntep16fXnCDXlNec15nXmdenICjXkdeZ158g15DXnSDXnNeZ15nXpywg15DXoNec15nXmdenLCDXkNeVINeR15nXmNeV15wg15zXmdeZ16cpLlwiLFxuICBcIlZPVEVcIjpcItec15TXpteR15nXolwiLFxuICBcIkNPTU1FTlRfVEVYVFwiOlwi16rXp9eR15zXlSDXlNeV15PXoteUINeb16nXnteZ16nXlNeVINeZ15LXmdeRINec16TXldeh15jXmdedINeQ15Ug15zXqteS15XXkdeV16og16nXnNeb150hINeU16LXqNeUOiDXqten15HXnNeVINeU15XXk9ei15Qg15LXnSDXm9ep157Xmdep15TXlSDXmdei16jXldeaINeQ16og15TXqteS15XXkdeUINep15zXlS5cIixcbiAgXCJDT01NRU5UXCI6XCLXqteS15XXkdeUXCIsXG4gIFwiRk9MTE9XX1RFWFRcIjpcIteq16fXkdecINeU15XXk9ei15Qg15vXqdee15nXqdeU15Ug15nXoten15XXkSDXkNeVINeZ16TXodeZ16cg15zXoten15XXkSDXkNeX16jXmdeaIVwiLFxuICBcIk1FTlRJT05TXCI6XCLXqteW15vXldeo15nXnVwiLFxuICBcIk1FTlRJT05TX1RFWFRcIjpcIteq16fXkdecINeU15XXk9ei15Qg15vXqdee15nXqdeU15Ug15nXlteb15nXqCDXkNeV16rXmiDXkdek15XXodeYINeQ15Ug15HXqteS15XXkdeUIVwiLFxuICBcIlJFU1RFRU1cIjpcIteo15nXodeY15nXmdedXCIsXG4gIFwiUkVTVEVFTV9URVhUXCI6XCLXqten15HXnNeVINeU15XXk9ei15Qg15vXqdee15nXqdeU15Ug15nXotep15Qg16jXmdeh15jXmdedINec16TXldeh15gg16nXnNeb150hXCIsXG4gIFwiQ09ORklHVVJBVElPTlNcIjpcIten15XXoNek15nXkteV16jXpteZ15XXqlwiLFxuICBcIlZPVElOR1wiOlwi15TXpteR16LXldeqXCIsXG4gIFwiVk9USU5HX1RFWFRcIjpcItee16nXp9ecINeU15zXmdeZ16cg16DXldeq158g15zXm9edINec16nXnNeV15gg15HXkteV15PXnCDXlNeS157XldecINep16rXp9eR15zXlS4g15TXoteo15Q6INek16LXldec15Qg15bXlSDXqtep16DXlCDXktedINeQ16og15TXntep16fXnCDXoteR15XXqCDXkNeg15zXmdeZ16dcIixcbiAgXCJTRVJWRVJcIjpcItep16jXqlwiLFxuICBcIlNFUlZFUl9URVhUXCI6XCLXnteV157XnNelXCIsXG4gIFwiU0FWRV9DSEFOR0VTXCI6XCLXnNep157XldeoINep15nXoNeV15nXmdedXCIsXG4gIFwiVk9URVJTX0lORk9cIjpcItee15nXk9eiINei15wg157XpteR15nXoteZ151cIixcbiAgXCJXRUxDT01FX0JBQ0tcIjpcIteR16jXldeb15nXnSDXlNep15HXmdedIVwiLFxuICBcIkxPR0lOXzFcIjpcIteU15nXm9eg16HXlSDXkdei15bXqNeqINep150g15TXntep16rXntepINeV15TXodeZ16HXnteQINei15wg157XoNeqINec15TXntep15nXmi5cIixcbiAgXCJMT0dJTl8yXCI6XCLXntek16rXlyDXlNek15XXodeY15nXnSDXoNeV16LXkyDXnNeb16rXmdeR16og16TXldeh15jXmdedINeV16rXkteV15HXldeqLCDXldec15zXmdeZ16fXmdedLlwiLFxuICBcIkxPR0lOXzNcIjpcIteU157XpNeq15cg15TXpNei15nXnCDXoNeV16LXkyDXnNeU16LXkdeo15XXqiDXldec16LXk9eb15XXnyDXqtee15XXoNeqINeU16TXqNeV16TXmdecLlwiLFxuICBcIkxPR0lOXzRcIjpcIteU157XmdeT16Ig16LXnCDXlNee16nXqtee16kg16nXnteV16gg157Xp9eV157XmdeqINei15wg15TXnteb16nXmdeoLiDXm9ep157Xqteg16rXp9eZ150g15TXnteZ15PXoiDXoNee15fXpyFcIixcbiAgXCJET05UX0hBVkVcIjpcIteQ15nXnyDXnNeb150g15fXqdeR15XXnyDXntep16rXntepP1wiLFxuICBcIlNJR05fVVBfTk9XXCI6XCLXlNeo16nXnteVINei15vXqdeZ15VcIixcbiAgXCJDQU5DRUxcIjpcIteR15nXmNeV15xcIixcbiAgXCJBRFZBTkNFRFwiOlwi157Xqten15PXnVwiLFxuICBcIkFDVElWRV9QUklLRVlcIjpcItee16TXqteXINek16LXmdecXCIsXG4gIFwiUE9TVElOR19QUklLRVlcIjpcItee16TXqteXINek15XXodeY15nXnVwiLFxuICBcIk1BU1RFUl9QQVNTXCI6XCLXntek16rXlyDXqNeQ16nXmVwiLFxuICBcIlVTRVJOQU1FXCI6XCLXqdedINee16nXqtee16lcIixcbiAgXCJDQVJEX1ZJRVdcIjpcIteq16bXldeS16og15vXqNeY15nXodeZ151cIixcbiAgXCJDT01QQUNUX1ZJRVdcIjpcIteq16bXldeS15Qg16fXldee16TXp9eY15nXqlwiLFxuICBcIlNFQVJDSFwiOlwi15fXmdek15XXqVwiLFxuICBcIlNVQk1JVF9BX1NUT1JZXCI6XCLXm9eq15HXlSDXpNeV16HXmFwiLFxuICBcIlJFUExZVE9cIjpcIteU16nXmdeR15Ug15wtXCIsXG4gIFwiUE9TVFwiOlwi16TXldeh15hcIixcbiAgXCJQUkVWSUVXXCI6XCLXqtem15XXkteUINee16fXk9eZ157XlFwiLFxuICBcIkRFRkFVTFRcIjpcIteR16jXmdeo16og157Xl9eT15ogNTAlIC8gNTAlXCIsXG4gIFwiUE9XRVJVUFwiOlwi16TXkNeV15XXqC3XkNekIDEwMCVcIixcbiAgXCJERUNMSU5FX1BBWU9VVFwiOlwi16HXqNeR15Ug15zXqtep15zXldedXCIsXG4gIFwiU0FWRV9GT1JfTEFURVJcIjpcItep157XqNeVINec157XkNeV15fXqCDXmdeV16rXqFwiLFxuICBcIkNMRUFSXCI6XCLXoNeZ16fXldeZXCIsXG4gIFwiUE9TVF9DT05URU5UXCI6XCLXqteV15vXnyDXlNek15XXodeYXCIsXG4gIFwiQ09NTUVOVF9DT05URU5UXCI6XCLXqteV15vXnyDXlNeq15LXldeR15RcIixcbiAgXCJUSVRMRVwiOlwi15vXldeq16jXqlwiLFxuICBcIlRBR1NcIjpcIteY15DXkteZ151cIixcbiAgXCJOT1RfTUFUQ0hcIjpcItec15Ag157XqteQ15nXnVwiLFxuICBcIkNPTkZJUk1fUElOXCI6XCLXkNep16gg16fXldeTXCIsXG4gIFwiSU5DT1JSRUNUXCI6XCLXqdeS15XXmVwiLFxuICBcIk9QRU5JTkdfUE9TVFwiOlwi16TXldeq15cg16TXldeh15hcIixcbiAgXCJTRVRfUElOXCI6XCLXp9eR16LXlSDXp9eV15NcIixcbiAgXCJFTlRFUl9QSU5cIjpcIteU15bXmdeg15Ug16fXldeTXCIsXG4gIFwiQVJFX1lPVV9TVVJFXCI6XCLXkdeY15XXl9eZ150/XCIsXG4gIFwiUkVCTE9HX1RFWFRcIjpcIteQ15kg15DXpNep16gg15zXkdeY15wg16jXmdeh15jXmdedLCDXqteo16bXlSDXnNeU157XqdeZ15o/XCIsXG4gIFwiQlJPQURDQVNUX0VSUk9SXCI6XCLXkdei15nXmdeqINeq16fXqdeV16jXqiwg16DXodeUINep15XXkSFcIixcbiAgXCJTVUNDRVNTXCI6XCLXlNem15zXl9eUXCIsXG4gIFwiUkVCTE9HR0VEX1BPU1RcIjpcItei16nXmdeq150g15zXpNeV16HXmCDXqNeZ15HXnNeV15IhXCIsXG4gIFwiTE9HSU5fRkFJTFwiOlwi15TXm9eg15nXodeUINeg15vXqdec15QhINeQ16DXkCDXldeT15DXlSDXqdeg15vXoNeh16rXnSDXotedINeU16HXmdeh157XkCDXlNeo15DXqdeZ16og15DXlSDXqdeU15bXoNeq150g15DXqiDXntek16rXlyDXlNek15XXodeY15nXnSDXkNedINeg15nXodeZ16rXnSDXnNeU15nXm9eg16Eg15HXntem15Eg157Xqten15PXnteqLlwiLFxuICBcIkxPR0lOX0ZBSUxfQVwiOlwi15TXm9eg15nXodeUINeg15vXqdec15QhINeQ16DXkCDXldeT15DXlSDXqdeg15vXoNeh16rXnSDXotedINeU16HXmdeh157XkCDXlNeo15DXqdeZ16og15DXlSDXqdeU15bXoNeq150g15DXqiDXlNee16TXqteXINeU16TXoteZ15wg15DXnSDXoNeZ16HXmdeq150g15zXlNeZ15vXoNehINeR157XpteRINee16rXp9eT157Xqi5cIixcbiAgXCJXQVJOSU5HXCI6XCLXkNeW15TXqNeUXCIsXG4gIFwiVk9URV9GT1JfV0lUTkVTU1wiOlwi15TXpteR16LXlCDXnNei15NcIixcbiAgXCJWT1RFRF9GT1JfV0lUTkVTU1wiOlwi15TXpteR16LXlCDXnNei15Mg15HXldem16LXlFwiLFxuICBcIkFHT1wiOlwi15zXpNeg15lcIixcbiAgXCJGUk9NX05PV1wiOlwi157Xoteb16nXmdeVXCIsXG4gIFwiU0VDU1wiOlwi16nXoNeZ15XXqlwiLFxuICBcIkFfTUlOXCI6XCLXk9en15RcIixcbiAgXCJNSU5TXCI6XCLXk9en15XXqlwiLFxuICBcIkFOX0hPVVJcIjpcItep16LXlFwiLFxuICBcIkhPVVJTXCI6XCLXqdei15XXqlwiLFxuICBcIkFfREFZXCI6XCLXmdeV151cIixcbiAgXCJEQVlTXCI6XCLXmdee15nXnVwiLFxuICBcIkFfTU9OVEhcIjpcIteX15XXk9epXCIsXG4gIFwiTU9OVEhTXCI6XCLXl9eV15PXqdeZ151cIixcbiAgXCJBX1lFQVJcIjpcItep16DXlFwiLFxuICBcIllFQVJTXCI6XCLXqdeg15nXnVwiLFxuICBcIk1JTl9SRUFEXCI6XCLXk9en15XXqiDXp9eo15nXkNeUXCIsXG4gIFwiRE9XTlZPVEVfRkxBR1wiOlwi16LXqdeVINeQ16DXnNeZ15nXp1wiLFxuICBcIkNBUFRVUkVfUElDVFVSRVwiOlwi16bXnNee15Ug16rXnteV16DXlFwiLFxuICBcIlNFTEVDVF9QSUNUVVJFXCI6XCLXkdeX16gg16rXnteV16DXlFwiLFxuICBcIlNFVF9DVVNUT01fVVJMXCI6XCLXp9eR16LXlSDXm9eq15XXkdeqINeQ15nXqdeZ16pcIixcbiAgXCJJTlNFUlRfUElDVFVSRVwiOlwi15TXm9eg16HXlCDXqtee15XXoNeUXCIsXG4gIFwiRVJST1JcIjpcItep15LXmdeQ15RcIixcbiAgXCJVUExPQURfRVJST1JcIjpcItep15LXmdeQ15Qg15HXlNei15zXkNeUXCIsXG4gIFwiQ0FNRVJBX0NBTkNFTExFRFwiOlwi157Xptec157XlCDXkdeV15jXnNeUXCIsXG4gIFwiU0VUX1VSTFwiOlwi16fXkdei15Ug16fXmdep15XXqFwiLFxuICBcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjpcIten15nXqdeV16gg15zXqtee15XXoNeUXCIsXG4gIFwiQ09NTUVOVF9TVUJNSVRURURcIjpcIteU16rXkteV15HXlCDXoNep15zXl9eUIVwiLFxuICBcIkRFTEVURV9DT01NRU5UXCI6XCLXkNeZINeQ16TXqdeoINec16nXl9eW16gg16rXkteV15HXlCDXqdeg157Xl9en15QuLi5cIixcbiAgXCJERUxFVEVEX0NPTU1FTlRcIjpcIteq15LXldeR15Qg16DXnteX16fXlFwiLFxuICBcIlVQTE9BRElOR19QSUNUVVJFXCI6XCLXntei15zXlCDXqtee15XXoNeUXCIsXG4gIFwiVVBMT0FEX0NPTVBMRVRFRFwiOlwi16rXnteV16DXlCDXlNeV16LXnNeq15RcIixcbiAgXCJVUExPQURfRkFJTEVEXCI6XCLXlNei15zXkNeUINeg15vXqdec15RcIixcbiAgXCJQQVNTV09SRF9JTkNPUlJFQ1RcIjpcIteU16HXmdeh157XlCDXkNeVINep150g15TXnteq16nXntepINep15LXldeZ15nXnVwiLFxuICBcIklORk9cIjpcItee15nXk9eiXCIsXG4gIFwiUVJfVEVYVFwiOlwi16nXmdee15Ug16fXldeTIFFSINeR16rXldeaINeQ15bXldeoINeU16fXqNeZ15DXlFwiLFxuICBcIkJBTEFOQ0VfVEVYVFwiOlwi15HXk9en15Ug16nXmdepINec15vXnSDXnteh16TXmdenINeb16HXpNeZ150g15zXlNei15HXqNeUIVwiLFxuICBcIk5PTkVYSVNUX1VTRVJcIjpcIteU157Xqdeq157XqSDXqdeQ15zXmdeVINeg15nXodeZ16rXnSDXnNeU16LXkdeZ16gg15vXodek15nXnSDXnNeQINen15nXmdedIVwiLFxuICBcIlRSQU5TRkVSX1RFWFRcIjpcIteR15jXldeXINep16rXqNem15Ug15zXlNei15HXmdeoINeQ16og15TXm9eh16TXmdedP1wiLFxuICBcIkNPTkZJUk1BVElPTlwiOlwi15DXmdep15XXqFwiLFxuICBcIlRYX0JST0FEQ0FTVEVEXCI6XCLXlNek16LXldec15Qg16DXqdec15fXlFwiLFxuICBcIkZFRURcIjpcItek15nXk1wiLFxuICBcIlRSRU5ESU5HXCI6XCLXntem15zXmdeXXCIsXG4gIFwiSE9UXCI6XCLXl9edXCIsXG4gIFwiTkVXXCI6XCLXl9eT16lcIixcbiAgXCJQUk9NT1RFRFwiOlwi157Xp9eV15PXnteZ151cIixcbiAgXCJWT1RFU1wiOlwi15zXmdeZ16fXmdedXCIsXG4gIFwiUEFZT1VUXCI6XCLXqtep15zXldedXCIsXG4gIFwiQ09NTUVOVFNcIjpcIteq15LXldeR15XXqlwiLFxuICBcIlRSRU5ESU5HXzMwXCI6XCLXl9ee15nXnSDXkS0zMCDXlNeZ157XmdedINeU15DXl9eo15XXoNeZ151cIixcbiAgXCJTT1JUX1BPU1RfQllcIjpcItee15nXmdeg15Ug15zXpNeZOlwiLFxuICBcIlBBWU9VVF9DWUNMRVwiOlwi15bXntefINeq16nXnNeV151cIixcbiAgXCJQT1RFTlRJQUxfUEFZT1VUXCI6XCLXqtep15zXldedINei16rXmdeT15lcIixcbiAgXCJQQVNUX1BBWU9VVFwiOlwi16rXqdec15XXnSDXoteR16hcIixcbiAgXCJBVVRIT1JfUEFZT1VUXCI6XCLXqtep15zXldedINec15vXldeq15FcIixcbiAgXCJDVVJBVElPTl9QQVlPVVRcIjpcIteq16nXnNeV150g15zXntep15LXmdeX15nXnVwiLFxuICBcIlBPU1RfU1VCTUlUVEVEXCI6XCLXlNek15XXodeYINeg16nXnNeXIVwiLFxuICBcIlBPU1RfTEFURVJcIjpcItec16nXnNeV15cg157XkNeV15fXqCDXmdeV16rXqFwiLFxuICBcIlNBVkVEXCI6XCLXoNep157XqFwiLFxuICBcIkNMRUFSRURcIjpcIteg15XXp9eUXCIsXG4gIFwiRkxBR0dJTkdfVEVYVFwiOlwi15DXoNec15nXmdenINec16TXldeh15gg157Xl9eh15nXqCDXnteU16rXqdec15XXnSDXldeU15XXpNeaINeQ15XXqteVINec16TXl9eV16og16DXqNeQ15QuINeQ16DXnNeZ15nXpyDXnteZ15XXoteTINec157Xp9eo15nXnSDXlNeR15DXmdedOiDXlNei16rXp9eULCDXkteW16LXoNeV16osINeT15HXqNeZINep16DXkNeULCDXmNeo15XXnNeZ16DXkiwg16HXpNeQ151cIixcbiAgXCJSRVFVRVNUX0xJTUlUX1RFWFRcIjpcIteU15LXoteq150g15zXkteR15XXnCDXnteh16TXqCDXlNeR16fXqdeV16ouINeR15PXp9eVINeY15DXkteZ150g15DXl9eo15nXnSFcIixcbiAgXCJQT1NUX0lTX1VOQk9PS01BUktcIjpcIteU16TXldeh15gg15TXldeh16gg157XlNeh15nXnteg15nXldeqIVwiLFxuICBcIlBPU1RfSVNfQk9PS01BUktcIjpcIteU16TXldeh15gg16DXqdee16gg15HXodeZ157XoNeZ15XXqiFcIixcbiAgXCJSRVNFVFwiOlwi15DXmdeq15fXldecXCIsXG4gIFwiTU9ESUZZX1BJQ1RVUkVcIjpcItec16nXoNeV16og16rXnteV16DXqiDXpNeo15XXpNeZ15xcIixcbiAgXCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOlwi15zXqdeg15XXqiDXqtee15XXoNeqINeb15XXqteo16pcIixcbiAgXCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjpcIteQ16DXkCDXlNeV16HXmdek15Ug157XpNeq15cg16TXoteZ15wg15DXnSDXqteo16bXlSDXnNeU15nXm9eg16Eg15zXntem15Eg157Xqten15PXnSFcIixcbiAgXCJSRVNFVF9QSUNUVVJFX1RFWFRcIjpcIteq157Xldeg16og15TXpNeo15XXpNeZ15wg16rXkNeV16rXl9ecXCIsXG4gIFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6XCLXqtee15XXoNeqINeU15vXldeq16jXqiDXqteQ15XXqteX15xcIixcbiAgXCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOlwi16LXk9eb15XXnyDXlNep16jXqiDXk9eV16jXqSDXkNeq15fXldecIVwiLFxuICBcIlNFVFRJTkdTX1VQREFURURcIjpcIteU15TXkteT16jXldeqINei15XXk9eb16DXlSFcIixcbiAgXCJMQU5HVUFHRVNcIjpcItep16TXldeqXCIsXG4gIFwiTEFOR1VBR0VTX1RFWFRcIjpcIteb15DXnyDXoNeZ16rXnyDXnNep16DXldeqINeQ16og15TXqdek15QuXCIsXG4gIFwiTE9HSU5fVE9fWFwiOlwi16TXoteV15zXlCDXlteVINeT15XXqNep16og157XlNee16nXqtee16kg15zXlNeZ15XXqiDXqNep15XXnSDXotedINeU16HXmdeh157XkCDXlNeo15DXqdeZ16og15XXlNee16TXqteXINeU16TXoteZ15wg15DXlSDXntek16rXlyDXlNek16HXldeYLiDXkNeg15Ag15vXoNeh15Ug15XXoNeh15Ug16nXoNeZ16ouXCIsXG4gIFwiR0FMTEVSWVwiOlwi15LXnNeo15nXlFwiLFxuICBcIlRSQU5TTEFUSU9OU1wiOlwi157Xqteo15LXnteZ151cIixcbiAgXCJTSEFSRVwiOlwi16nXqtejXCIsXG4gIFwiTUFSS0VUUExBQ0VcIjpcIteU16nXldenXCIsXG4gIFwiRVhDSEFOR0VcIjpcItee16HXl9eoXCIsXG4gIFwiRFJBRlRTXCI6XCLXmNeZ15XXmNeV16pcIixcbiAgXCJQT1NUX0lTX1VORFJBRlRcIjpcIteU16TXldeh15gg15TXldeh16gg157XlNeY15nXldeY15XXqiFcIixcbiAgXCJQT1NUX0lTX0RSQUZUXCI6XCLXlNek15XXodeYINeU16rXldeV16HXoyDXnNeY15nXldeY15XXqiFcIixcbiAgXCJTV0lQRV9MRUZUXCI6XCLXlNeX15zXmden15Ug16nXnteQ15zXlCDXkdep15HXmdecINeQ16TXqdeo15XXmdeV16pcIixcbiAgXCJNQU5BR0VcIjpcIteg15nXlNeV15xcIixcbiAgXCJJTUFHRV9SRU1PVkVEXCI6XCLXlNeq157Xldeg15Qg15TXldeh16jXlFwiLFxuICBcIkNPUFlcIjpcIteU16LXqtenXCIsXG4gIFwiTk9fSU1BR0VcIjpcItei15XXkyDXnNeQINeU16LXnNeZ16og16rXnteV16DXlCFcIixcbiAgXCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOlwi157Xqdeb15Ug15zXnteY15Qg15vXk9eZINec16jXoteg159cIixcbiAgXCJFWFRFUk5BTF9BUFBTXCI6XCLXmdeZ16nXldee15nXnSDXl9eZ16bXldeg15nXmdedXCIsXG4gIFwiUExVR0lOU1wiOlwi16rXldeh16TXldeqXCIsXG4gIFwiU1VHR0VTVFwiOlwi15TXpteiINec16fXqNeZ15DXlFwiLFxuICBcIkNPTUlOR19TT09OXCI6XCLXkden16jXldeRXCIsXG4gIFwiQ0hBSU5cIjpcItep16jXqdeo16pcIixcbiAgXCJDSEFJTl9URVhUXCI6XCLXm9eQ158g16rXldeb15zXlSDXnNep16DXldeqINeR15zXlden16Yn15nXmdefINeQ15Ug15DXqiDXkdeo15nXqNeqINeU157Xl9eT15xcIixcbiAgXCJDVVJSRU5DWVwiOlwi157XmNeR16JcIixcbiAgXCJDVVJSRU5DWV9URVhUXCI6XCLXm9eQ158g16rXldeb15zXlSDXnNep16DXldeqINeQ16og157XmNeR16Ig15HXqNeZ16jXqiDXlNee15fXk9ecINep15zXm9edLiDXlNep15XXldeZINep15wg16TXldeh15hcXFxc16rXkteV15HXlCDXmdeV16TXmdeiINeR157XmNeR16Ig15bXlC5cIixcbiAgXCJBQk9VVF8xMVwiOlwiPGJyPjxiPteo16nXmdee16og16nXmdee15XXqdeZ150g15HXpNec15jXpNeV16jXnteUPC9iPiA8YnI+LdeS15nXqdeUINec157XkNee16jXmdedINeZ15fXldeT15nXmdedINeR15vXnCDXoNeV16nXkCDXqdeq15TXmdeVINee16LXldeg15nXmdeg15nXnSDXnNen16jXldeQLiA8YnI+IC3XlNeq15fXkdeo15Ug15zXm9eV16rXkdeZ150g15PXqNeaINeq15LXldeR15XXqiDXldeT15nXldeg15nXnS4gPGJyPi3XlNem15HXoteUINei15HXldeoINek15XXodeY15nXnSDXnNeU16LXoNen16og15LXnteV15wsINeV15TXqNeV15XXl9eqINeS157XldecINei15HXldeoINeU16bXkdei15XXqi4gPGJyPi3XpNeo16HXnteVINee15DXnteo15nXnSDXldek15XXodeY15nXnSwg15TXqNeV15XXmdeX15Ug16rXktee15XXnNeZ150g15XXntem15DXlSDXkNeg16nXmdedINep15nXoten15HXlSDXkNeX16jXmSDXlNeR15zXldeSINep15zXm9edLiA8YnI+Ldeb16rXmdeR16og157XkNee16jXmdedINeT15nXoNee15nXqiwg16nXnteZ16jXqiDXp9eR15XXqiDXqdecINeU16TXldeh15gg15zXpNeo16HXldedINee15DXldeX16gg15nXldeq16guIDxicj4tINep157XqNeVINee15DXnteo15nXnSDXnNen16jXmdeQ15Qg15HXnteV16LXkyDXnteQ15XXl9eoINeZ15XXqteoLiA8YnI+LSDXpNeT15Ug15DXqiDXlNeo15XXldeX15nXnSDXqdec15vXnS4gPGJyPi3Xqdec15fXlSDXm9eh16TXmdedINec15fXkdeo15nXnSDXkNeVINec157Xqdeq157XqdeZ150g15DXl9eo15nXnSA8YnI+LSDXoten15HXlSDXkNeX16jXmSDXodeV16TXqNeZ150g15XXkdec15XXkteo15nXnSDXntei16DXmdeZ16DXmdedLiA8YnI+IC3Xl9eZ16TXldepINeR16LXlden15HXmdedINep15zXm9edINeV15HXnteZINep16LXlden15Eg15DXl9eo15nXm9edLiA8YnI+Lden15HXnNeVINeU15XXk9ei15XXqiDXotecINee16DXqiDXnNeU15nXqdeQ16gg15HXoteg15nXmdeg15nXnSDXotedINei15XXp9eR15nXnSDXldei150g15XXk9eZ15XXoNeZ150g16nXkNeq150g157Xoteo15XXkdeZ150g15HXlNedLiA8YnI+LdeX15nXpNeV16kg16rXkteZ15XXqi/Xp9eY15LXldeo15nXldeqINee16LXoNeZ15nXoNeV16og16nXnCDXnteQ157XqNeZ150g15XXm9eV16rXkdeZ150uIDxicj4gLdeU16rXkNee15Qg15DXmdep15nXqiDXqdecINeU16TXqNeV16TXmdecINep15zXmi4gPGJyPi3XoteV15Mg15TXqNeR15Qg16TXldeg16fXpteZ15XXqiDXkdeT16jXmi4gPGJyPjxicj48Yj7XkNeR15jXl9eUPC9iPiA8YnI+MS4g15zXkNek15zXmden16bXmdeUINeQ15nXnyDXkteZ16nXlCDXnNeb16HXpNeZINeU157Xqdeq157XqS4gPGJyPjIuINeU15DXpNec15nXp9em15nXlCDXntem15nXoteUINee15XXk9ecINeQ15HXmNeX15Qg15HXpteTINeU15zXp9eV15csINei150g157XpNeq15fXldeqINek16jXmNeZ15nXnSDXlNep157Xldeo15nXnSDXkdeQ15XXpNefINee16fXldee15kg15XXqdeQ15nXoNedINeg16nXnNeX15nXnSDXnNep16jXqteZ150sINeQ16rXnSDXkNeX16jXkNeZ150g15zXkteZ15HXldeZINeU16HXmdeh157XkNeV16og16nXnNeb150uIDxicj4zLiDXlNeQ16TXnNeZ16fXpteZ15Qg157XpteZ16LXlCDXntee16nXpyDXldeX15XXldeZ15Qg15DXmNeo16fXmNeZ15HXmdeqINec157Xqdeq157XqSA8YnI+NC4g15TXkNek15zXmden16bXmdeUINee16bXmdei15Qg16nXm9eR15Qg16DXldeh16TXqiDXqdecINeR15nXmNeX15XXnyDXotedINen15XXkyA8YnI+PGJyPiBlU3RlZW0g16rXldee15og15HXpNec15jXpNeV16jXnteV16ogU3RlZW0g15UtR29sb3MuIDxicj5cIixcbiAgXCJGT1VOREVSXCI6XCLXnteZ15nXodeTINeV157XpNeq15cg16jXkNep15lcIixcbiAgXCJBRERfQUNDT1VOVFwiOlwi15TXldeh16Mg157Xqdeq157XqVwiLFxuICBcIlBMQVRGT1JNXCI6XCLXpNec15jXpNeV16jXnteUXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiSE9NRVwiOlwiS2V6ZMWRbGFwXCIsXG4gIFwiTE9HSU5cIjpcIkJlamVsZW50a2V6w6lzXCIsXG4gIFwiTE9HT1VUXCI6XCJLaWplbGVudGtlesOpc1wiLFxuICBcIlBST0ZJTEVcIjpcIlByb2ZpbFwiLFxuICBcIkZPTExPV1wiOlwiS8O2dmV0w6lzXCIsXG4gIFwiQk9PS01BUktTXCI6XCJLw7ZueXZqZWx6xZFrXCIsXG4gIFwiVFJBTlNGRVJcIjpcIsOBdHV0YWzDoXNcIixcbiAgXCJNQVJLRVRcIjpcIlBpYWNcIixcbiAgXCJTRVRUSU5HU1wiOlwiQmXDoWxsw610w6Fzb2tcIixcbiAgXCJBQk9VVFwiOlwiUsOzbHVua1wiLFxuICBcIkFCT1VUXzFcIjpcImFob2wgYsOhcmtpIGthcGhhdCBqdXRhbG1ha2F0IGEgdGFydGFsbWFpw6lydCFcIixcbiAgXCJBQk9VVF8yXCI6XCJhIHt7cGxhdGZvcm1uYW1lfX0gcGxhdGZvcm0gw7x6ZW1lbHRldGkuIEF6IGFsa2FsbWF6w6FzIGvDqXN6w610xZFqZVwiLFxuICBcIkFCT1VUXzNcIjpcIsOpcyBuecOtbHQgZm9ycsOhc2vDs2TDuiwga8O2esO2c3PDqWcgw6FsdGFsIG3FsWvDtmR0ZXRldHQgcHJvamVrdC4gVMOhbW9nYXRqYSBhIHRhcnRhbG9taG96esOhZsOpcsOpc3Qgb2x2YXPDoXPDqXJ0LCBhIGhvenrDoXN6w7Nsw6FzdCwgc3phdmF6w6FzdCwgcG9zenRvbMOhc3QsIGZpemV0c8OpZyDDoXR1dGFsw6Fzw6F0LCBzdGIuIGZ1bmtjacOza2F0LCBhbWlrZXQgYSB7e3BsYXRmb3JtbmFtZX19IGJsb2trbMOhbmMgw6lzIGEge3tzaXRlbmFtZX19IGvDrW7DoWxuYWsuXCIsXG4gIFwiQUJPVVRfNFwiOlwiMS4gQXogYWxrYWxtYXrDoXMgc29oYSBuZW0gZsOpciBob3p6w6EgdmFneSB0w6Fyb2xqYSBhIGZlbGhhc3puw6Fsw7NrIHDDqW56w6l0LlwiLFxuICBcIkFCT1VUXzVcIjpcIjIuIEF6IGFsa2FsbWF6w6FzIGtsaWVucyBvbGRhbGkgYml6dG9uc8OhZ2kgbW9kZWxsdCBrw61uw6FsLCBhIHByaXbDoXQga3VsY3NvayBoZWx5YmVuaSB0w6Fyb2zDoXPDoXZhbCwgYW1payBzb2hhIG5lbSBrZXLDvGxuZWsgZWxrw7xsZMOpc3JlIHNlbW1pbHllbiBzemVydmVycmUuXCIsXG4gIFwiQUJPVVRfNlwiOlwiMy4gQXogYWxrYWxtYXrDoXMgZWd5c3plcsWxLCB0ZXRzemV0xZFzIGZlbGhhc3puw6Fsw7NpIGZlbMO8bGV0ZXQgw6lzIC3DqWxtw6lueXQgbnnDump0LlwiLFxuICBcIkFCT1VUXzdcIjpcIjQuIEF6IGFsa2FsbWF6w6FzIHNvaGEgbmVtIGvDqXJpIGEgZmVsaGFzem7DoWzDs2thdCBhIHN6ZW3DqWx5ZXMgYWRhdGFpayBtZWdhZMOhc8OhcmEuXCIsXG4gIFwiQUJPVVRfOFwiOlwiU3phdmF6eiBnb29kLWthcm1hIC1yYSBtaW50IHRhbsO6XCIsXG4gIFwiQUJPVVRfOVwiOlwiS2FwY3NvbGF0L1Zpc3N6YWplbHrDqXM6XCIsXG4gIFwiQUJPVVRfMTBcIjpcIlTDtmJiIGluZsOzOlwiLFxuICBcIlJFTU9WRVwiOlwiRWx0w6F2b2zDrXTDoXNcIixcbiAgXCJNQVJLRVRfVklFV1wiOlwiUGlhYyBOw6l6ZXRcIixcbiAgXCJQUklDRVwiOlwiw4FyXCIsXG4gIFwiQU1PVU5UXCI6XCLDlnNzemVnXCIsXG4gIFwiVE9UQUxcIjpcIsOWc3N6ZXNlblwiLFxuICBcIk5PT1JERVJTXCI6XCJOaW5jcyBueWl0b3R0IG1lZ2LDrXrDoXNcIixcbiAgXCJEQVRFXCI6XCJEw6F0dW1cIixcbiAgXCJCVVlcIjpcIlbDqXRlbFwiLFxuICBcIlNFTExcIjpcIkVsYWTDoXNcIixcbiAgXCJPUEVOXCI6XCJOeWl0w6FzXCIsXG4gIFwiSElTVE9SWVwiOlwiVMO2cnTDqW5ldFwiLFxuICBcIkZPTExPV19CQUNLXCI6XCJWaXNzemFrw7Z2ZXTDqXNcIixcbiAgXCJGT0xMT1dFRFwiOlwiS8O2dmV0dmVcIixcbiAgXCJVTkZPTExPV1wiOlwiS8O2dmV0w6lzIG1lZ3N6w7xudGV0w6lzZVwiLFxuICBcIkZPTExPV0lOR1wiOlwiS8O2dmV0ZXR0ZWtcIixcbiAgXCJGT0xMT1dFUlNcIjpcIkvDtnZldMWRa1wiLFxuICBcIlNFQVJDSF9GT0xMT1dFUlNcIjpcIkvDtnZldMWRayBrZXJlc8Opc2VcIixcbiAgXCJTRUFSQ0hfRk9MTE9XSU5HXCI6XCJLw7Z2ZXRldHRlayBrZXJlc8Opc2VcIixcbiAgXCJCWVwiOlwiw6FsdGFsXCIsXG4gIFwiSU5cIjpcIml0dDpcIixcbiAgXCJNRU5VXCI6XCJNZW7DvFwiLFxuICBcIkJPT0tNQVJLXCI6XCJLw7ZueXZqZWx6xZFrXCIsXG4gIFwiUkVCTE9HXCI6XCLDmmpyYWJsb2dvbMOhc1wiLFxuICBcIlVQVk9URVwiOlwiRmVsc3phdmF6w6FzXCIsXG4gIFwiRE9XTlZPVEVcIjpcIkxlc3phdmF6w6FzXCIsXG4gIFwiVU5WT1RFX0RPV05WT1RFRFwiOlwiTGVzemF2YXrDoXMgZWx0w6F2b2zDrXTDoXNhXCIsXG4gIFwiVU5WT1RFX1VQVk9URURcIjpcIkZlbHN6YXZhesOhcyBlbHTDoXZvbMOtdMOhc2FcIixcbiAgXCJSRVBMWVwiOlwiVsOhbGFzelwiLFxuICBcIkVESVRcIjpcIlN6ZXJrZXN6dMOpc1wiLFxuICBcIlBPU1RfMVwiOlwiQ3PDunN6dGFzcyBiYWxyYSBhIGhvenrDoXN6w7Nsw6Fzb2tvbiwgaG9neSBsw6FzZCBheiBvcGNpw7NrYXRcIixcbiAgXCJQT1NUXzJcIjpcIktvcHBpbnRzIGEgaG96esOhc3rDs2zDoXNva29uLCBob2d5IGzDoXNkIGF6IGFsLWhvenrDoXN6w7Nsw6Fzb2thdFwiLFxuICBcIk9QVElPTlNcIjpcIk9wY2nDs2tcIixcbiAgXCJSRVNURUVNRURfQllcIjpcIsOaanJhb3N6dHZhIMOhbHRhbGE6XCIsXG4gIFwiTk9USElOR19IRVJFXCI6XCJTZW1taSBzaW5jcyBpdHQgbcOpZy4uLlwiLFxuICBcIkJBTEFOQ0VTXCI6XCJFZ3llbmxlZ2VrXCIsXG4gIFwiUFJPRklMRV8xXCI6XCJ7e3BsYXRmb3JtbmFtZX19LCBlbGFkaGF0w7MgdG9rZW5laywgYW1lbHlla2V0IMOhdCBsZWhldCB1dGFsbmkgYsOhcm1pa29yLlxcbnt7cGxhdGZvcm1uYW1lfX0ga29udmVydMOhbGhhdMOzIHt7cGxhdGZvcm1wb3dlcn19IC3DqSBlZ3kgZm9seWFtYXRiYW4sIGFtaXQgZmVsdMO2bHTDqXNuZWsgbmV2ZXrDvG5rLlwiLFxuICBcIlBST0ZJTEVfMlwiOlwie3twbGF0Zm9ybXBvd2VyfX0sIGJlZm9secOhc29sw7MgdG9rZW5laywgYW1payB0w7ZiYiBlcsWRdCBrYXBuYWsgYSBob3NzesO6IHTDoXbDuiBiaXJ0b2tsw6FzdWvDqXJ0IMOpcyBhIHBvc3p0b2sgZmVsc3phdmF6w6Fzw6HDqXJ0LiBNaW7DqWwgdMO2YmJldCBiaXJ0b2tvbCBiZWzFkWxlIHZhbGFraSwgYW5uw6FsIGpvYmJhbiB0dWRqYSBiZWZvbHnDoXNvbG5pIG3DoXNvayBqdXRhbG1haXQgw6lzIGthcCB0w7ZiYiBqdXRhbG1hdCBheiBhbGFwb3Mgc3phdmF6w6Fzw6lydC5cIixcbiAgXCJQUk9GSUxFXzNcIjpcIlRva2VuZWssIGFtaWsga8O2csO8bGJlbMO8bCB7e3BsYXRmb3Jtc3VuaXR9fSAtbnlpIHt7cGxhdGZvcm1uYW1lfX0gLWV0IMOpcm5lay5cIixcbiAgXCJFU1RJTUFURURfVkFMVUVcIjpcIkJlY3PDvGx0IMOJcnTDqWtcIixcbiAgXCJQUk9GSUxFXzRcIjpcIkEgYmVjc8O8bHQgw6lydMOpayBhIHt7cGxhdGZvcm1uYW1lfX0gNyBuYXBvcyDDoXRsYWdvcyDDqXJ0w6lrw6luIGFsYXBzemlrLlwiLFxuICBcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjpcIsOBdHV0YWzDoXMgVMO2cnTDqW5ldFwiLFxuICBcIlBPU1RJTkdcIjpcIlBvc3p0b2zDoXNcIixcbiAgXCJQUk9GSUxFXzVcIjpcIkEgcG9zenRvbMOzIGt1bGNzIHBvc3p0b2zDoXNyYSDDqXMgc3phdmF6w6FzcmEgaGFzem7DoWxhdG9zLiBLw7xsw7ZuYsO2esWRbmVrIGtlbGwgbGVubmllIGF6IGFrdMOtdiDDqXMgYSB0dWxhamRvbm9zaSBrdWxjc29rdMOzbC5cIixcbiAgXCJPV05FUlwiOlwiVHVsYWpkb25vc1wiLFxuICBcIlBST0ZJTEVfNlwiOlwiQSB0dWxhamRvbm9zIGt1bGNzIGVneSBtZXN0ZXJrdWxjcyBhIHN6w6FtbMOhaG96IMOpcyBrw7Z0ZWxlesWRIGEgdMO2YmJpIGt1bGNzIG1lZ3bDoWx0b3p0YXTDoXPDoWhvei4gQSB0dWxhamRvbm9zaSBrdWxjcyBwcml2w6F0IGt1bGNzw6F0IHZhZ3kgamVsc3phdsOhdCB0aXRva2JhbiDDqXMgb2ZmbGluZSBrZWxsIHRhcnRhbmksIGFtZW5ueWlyZSBjc2FrIGxlaGV0c8OpZ2VzLlwiLFxuICBcIkFDVElWRVwiOlwiQWt0w612XCIsXG4gIFwiUFJPRklMRV83XCI6XCJBeiBha3TDrXYga3VsY3MgaGFzem7DoWxhdG9zIGF6IMOhdHV0YWzDoXNvayBpbmTDrXTDoXPDoWhveiDDqXMgYSBtZWdiw616w6Fzb2sgYmVqZWd5esOpc8OpaGV6IGEgYmVsc8WRIHBpYWNvbi5cIixcbiAgXCJNRU1PXCI6XCJGZWxqZWd5esOpc1wiLFxuICBcIlBST0ZJTEVfOFwiOlwiQSBmZWxqZWd5esOpcyBrdWxjcyBoYXN6bsOhbGF0b3MgZmVsamVneXrDqXNlayBrw6lzesOtdMOpc8OpcmUgw6lzIG9sdmFzw6Fzw6FyYS5cIixcbiAgXCJCTE9HXCI6XCJcIixcbiAgXCJQT1NUU1wiOlwiUG9zenRva1wiLFxuICBcIlJFUExJRVNcIjpcIlbDoWxhc3pva1wiLFxuICBcIldBTExFVFwiOlwiVMOhcmNhXCIsXG4gIFwiVEFHXCI6XCJDw61ta2VcIixcbiAgXCJVU0VSXCI6XCJGZWxoYXN6bsOhbMOzXCIsXG4gIFwiQ0xPU0VcIjpcIkJlesOhclwiLFxuICBcIlRPXCI6XCJOZWtpXCIsXG4gIFwiQVNTRVRcIjpcIlZhZ3lvbnTDoXJneVwiLFxuICBcIlNFTkRcIjpcIkvDvGxkXCIsXG4gIFwiU0VDVVJJVFlcIjpcIkJpenRvbnPDoWdcIixcbiAgXCJBVkFJTEFCTEVcIjpcIlJlbmRlbGtlesOpc3JlIMOhbGxcIixcbiAgXCJQVUJMSUNfTUVNT1wiOlwiTnlpbHbDoW5vcyBmZWxqZWd5esOpc1wiLFxuICBcIlRPX0RFU0NcIjpcIkZlbGhhc3puw6Fsw7MsIHBsLiBnb29kLWthcm1hXCIsXG4gIFwiUElOX0NPREVcIjpcIlBJTi1rw7NkXCIsXG4gIFwiUElOX1RFWFRcIjpcIkEgUElOLWvDs2Qgc2Vnw610IGhvZ3kgbWVnw7N2ZCBheiBhbGthbG1hesOhc29kIMOpcyBheiBhZGF0YWlkLiA8YnIvPjxici8+PGI+TWVnamVneXrDqXM6PC9iPiBNaXV0w6FuIGFsa2FsbWF6dmEgdmFuLCBtYXguIDQgcHLDs2LDoWxrb3rDoXNpIGxlaGV0xZFzw6lnZWQgdmFuIGhvZ3kgZmVsbnlpc2Q7IGhhIGVsZmVsZWp0ZWQgYSBQSU4tdCB2YWd5IGhpYsOhem9sLCBheiBhbGthbG1hesOhcyBlbCBmb2dqYSB0w6F2b2zDrXRhbmkgbWluZGVuIGJlamVsZW50a2V6ZXR0IGZlbGhhc3puw6Fsw7NpIGFkYXRvdC4gVmlzc3phIHR1ZHN6IGplbGVudGtlem5pIMOpcyBmb2x5dGF0aGF0b2QgYXogYWxrYWxtYXrDoXMgaGFzem7DoWxhdMOhdC5cIixcbiAgXCJOT1RJRklDQVRJT05TXCI6XCLDiXJ0ZXPDrXTDqXNla1wiLFxuICBcIlZPVEVfVEVYVFwiOlwiw4lydGVzw610w6lzZWtldCBrYXBzeiwgYW1pa29yIHZhbGFraSBzemF2YXogYSBiZWplZ3l6w6lzZWRyZSEgYnIvPiA8Yj5NZWdqZWd5esOpczo8L2I+IEF6IMOpcnRlc8OtdMOpc2VrIHRhcnRhbG1henrDoWsgYSBzemF2YXrDoXMgc8O6bHlvesOhc8OhdCBhIGZpZ3llbG1lenRldMWRIMO8emVuZXRiZW4gaXMgKExlZ3llbiBheiBmZWxzemF2YXrDoXMsIGxlc3phdmF6w6FzIHZhZ3kgc3phdmF6YXQgdmlzc3phdm9uw6FzYSkuXCIsXG4gIFwiVk9URVwiOlwiU3phdmF6w6FzXCIsXG4gIFwiQ09NTUVOVF9URVhUXCI6XCLDiXJ0ZXPDrXTDqXN0IGthcHN6IGhhIHZhbGFraSBob3p6w6FzesOzbCBhIHBvc3p0b2Rob3ogdmFneSBhIGhvenrDoXN6w7Nsw6Fzb2Rob3ohIDxici8+IDxiPk1lZ2plZ3l6w6lzOjwvYj4gQXogw6lydGVzw610w6lzZWsgdGFydGFsbWF6esOhayBhenQgaXMsIGFtaWtvciB2YWxha2kgPGI+c3plcmtlc3p0aTwvYj4gYSBob3p6w6FzesOzbMOhc2FpdC5cIixcbiAgXCJDT01NRU5UXCI6XCJIb3p6w6FzesOzbMOhc1wiLFxuICBcIkZPTExPV19URVhUXCI6XCLDiXJ0ZXPDrXTDqXN0IGthcHN6LCBhbWlrb3IgdmFsYWtpIEvDtnZldCB0w6lnZWQgdmFneSBWaXNzemF2b25qYSBhIGvDtnZldMOpc3QhXCIsXG4gIFwiTUVOVElPTlNcIjpcIkVtbMOtdMOpc2VrXCIsXG4gIFwiTUVOVElPTlNfVEVYVFwiOlwiw4lydGVzw610w6lzZWtldCBrYXBzeiwgYW1pa29yIHZhbGFraSBtZWdlbWzDrXQgdMOpZ2VkIGVneSBwb3N6dGJhbi9ob3p6w6FzesOzbMOhc2JhbiFcIixcbiAgXCJSRVNURUVNXCI6XCJcIixcbiAgXCJSRVNURUVNX1RFWFRcIjpcIsOJcnRlc8OtdMOpc3Qga2Fwc3osIGFtaWtvciB2YWxha2kgcmVzdGVlbWVsaSBhIHBvc3p0b2RhdCFcIixcbiAgXCJDT05GSUdVUkFUSU9OU1wiOlwiS29uZmlndXLDoWNpw7NcIixcbiAgXCJWT1RJTkdcIjpcIlN6YXZhesOhc1wiLFxuICBcIlZPVElOR19URVhUXCI6XCJBIHN6YXZhemF0IHPDumx5b3rDoXNhIHZhZ3kgc3rDoXphbMOpa2EgYSBzemF2YXphdGkgZXLFkXJlIHZhbiBraWhhdMOhc3NhbCBheiBhbGthbG1hesOhc2Jhbiwgw61neSBzemFiw6FseW96bmkgdHVkb2QgYSBzemF2YXrDoXNpIGp1dGFsbWFpZC4gPGJyLz48YnIvPjxiPk1lZ2plZ3l6w6lzOjwvYj4gRXogYSBsZXN6YXZhesOhcyBzemF2YXphdGkgZXJlasOpdC9zesOhemFsw6lrw6F0IGlzIG1lZyBmb2dqYSB2w6FsdG96dGF0bmkgw6lzIG1pbmRlbsO8dHQgw6lydsOpbnllcyBheiBhbGthbG1hesOhc29uIGJlbMO8bC5cIixcbiAgXCJTRVJWRVJcIjpcIlN6ZXJ2ZXJcIixcbiAgXCJTRVJWRVJfVEVYVFwiOlwiQWrDoW5sb3R0XCIsXG4gIFwiU0FWRV9DSEFOR0VTXCI6XCJWw6FsdG96dGF0w6Fzb2sgTWVudMOpc2VcIixcbiAgXCJWT1RFUlNfSU5GT1wiOlwiSW5mw7MgYSBzemF2YXrDs2tyw7NsXCIsXG4gIFwiV0VMQ09NRV9CQUNLXCI6XCLDnGR2IMO6anJhIVwiLFxuICBcIkxPR0lOXzFcIjpcIkEgZm9seXRhdMOhc2hveiBqZWxlbnRrZXp6IGJlIGEgZmVsaGFzem7DoWzDs25ldmVkZGVsIMOpcyBqZWxzemF2YWRkYWwuXCIsXG4gIFwiTE9HSU5fMlwiOlwiQSBwb3N6dG9sw7Mga3VsY3MgYSBwb3N6dG9raG96LCBob3p6w6FzesOzbMOhc29raG96LCBzemF2YXrDoXNob3ogw6lzIGvDtnZldMOpc2hleiBoYXN6bsOhbGF0b3MuXCIsXG4gIFwiTE9HSU5fM1wiOlwiQXogYWt0w612IGt1bGNzIGF6IHV0YWzDoXNva2hveiDDqXMgYSBwcm9maWxrw6lwIGZyaXNzw610w6lzw6loZXogaGFzem7DoWxhdG9zLlwiLFxuICBcIkxPR0lOXzRcIjpcIkEgZmVsaGFzem7DoWzDsyBiZWplbGVudGtlesOpc2kgYWRhdGFpIGhlbHlpbGVnIHZhbm5hayB0w6Fyb2x2YSBhIGvDqXN6w7xsw6lrZW4uIEtpamVsZW50a2V6w6lza29yIGEgYmVqZWxlbnRrZXrDqXNpIGFkYXRvayBlbHTDoXZvbMOtdMOzZG5hayFcIixcbiAgXCJET05UX0hBVkVcIjpcIk5pbmNzIG3DqWcgZmnDs2tvZD9cIixcbiAgXCJTSUdOX1VQX05PV1wiOlwiUmVnaXN6dHLDoWxqIG1vc3RcIixcbiAgXCJDQU5DRUxcIjpcIk3DqWdzZVwiLFxuICBcIkFEVkFOQ0VEXCI6XCJIYWxhZMOzXCIsXG4gIFwiQUNUSVZFX1BSSUtFWVwiOlwiQWt0w612IHByaXbDoXQga3VsY3NcIixcbiAgXCJQT1NUSU5HX1BSSUtFWVwiOlwiUG9zenRvbMOzIHByaXbDoXQga3VsY3NcIixcbiAgXCJNQVNURVJfUEFTU1wiOlwiTWVzdGVyL2bFkSBqZWxzesOzXCIsXG4gIFwiVVNFUk5BTUVcIjpcIkZlbGhhc3puw6Fsw7Nuw6l2XCIsXG4gIFwiQ0FSRF9WSUVXXCI6XCJLw6FydHlhIG7DqXpldFwiLFxuICBcIkNPTVBBQ1RfVklFV1wiOlwiS29tcGFrdCBuw6l6ZXRcIixcbiAgXCJTRUFSQ0hcIjpcIktlcmVzw6lzXCIsXG4gIFwiU1VCTUlUX0FfU1RPUllcIjpcIkNpa2sgYmVrw7xsZMOpc2VcIixcbiAgXCJSRVBMWVRPXCI6XCJWw6FsYXN6IG5la2lcIixcbiAgXCJQT1NUXCI6XCJQb3N6dFwiLFxuICBcIlBSRVZJRVdcIjpcIkVsxZFuw6l6ZXRcIixcbiAgXCJERUZBVUxUXCI6XCJBbGFww6lydGVsbWV6ZXR0IDUwJSAvIDUwJVwiLFxuICBcIlBPV0VSVVBcIjpcIkZlbHTDtmx0w6lzIDEwMCVcIixcbiAgXCJERUNMSU5FX1BBWU9VVFwiOlwiS2lmaXpldMOpcyBFbHV0YXPDrXTDoXNhXCIsXG4gIFwiU0FWRV9GT1JfTEFURVJcIjpcIk1FTlTDiVMgS8OJU8WQQkJSRVwiLFxuICBcIkNMRUFSXCI6XCJUw5ZSTMOJU1wiLFxuICBcIlBPU1RfQ09OVEVOVFwiOlwiVGFydGFsb20gcG9zenRvbMOhc2FcIixcbiAgXCJDT01NRU5UX0NPTlRFTlRcIjpcIkhvenrDoXN6w7Nsw6FzIHRhcnRhbG9taG96XCIsXG4gIFwiVElUTEVcIjpcIkPDrW1cIixcbiAgXCJUQUdTXCI6XCJDw61ta8Opa1wiLFxuICBcIk5PVF9NQVRDSFwiOlwiTkVNIElMTElLIMOWU1NaRVwiLFxuICBcIkNPTkZJUk1fUElOXCI6XCJQSU4gbWVnZXLFkXPDrXTDqXNlXCIsXG4gIFwiSU5DT1JSRUNUXCI6XCJORU0gTUVHRkVMRUzFkFwiLFxuICBcIk9QRU5JTkdfUE9TVFwiOlwibnlpdMOzIHBvc3p0XCIsXG4gIFwiU0VUX1BJTlwiOlwiUElOIGJlw6FsbMOtdMOhc2FcIixcbiAgXCJFTlRFUl9QSU5cIjpcIlBJTiBtZWdhZMOhc2FcIixcbiAgXCJBUkVfWU9VX1NVUkVcIjpcIkJpenRvcyB2YWd5IGJlbm5lP1wiLFxuICBcIlJFQkxPR19URVhUXCI6XCJBIHJlc3RlZW0gdmlzc3phdm9uaGF0YXRsYW4sIGJpenRvcyB2YWd5IGJlbm5lP1wiLFxuICBcIkJST0FEQ0FTVF9FUlJPUlwiOlwiVGVyamVzenTDqXNpIGhpYmEsIHByw7Niw6FsZCDDumpyYS5cIixcbiAgXCJTVUNDRVNTXCI6XCJTaWtlclwiLFxuICBcIlJFQkxPR0dFRF9QT1NUXCI6XCLDmmpyYWJsb2dvbHQgcG9zenQhXCIsXG4gIFwiTE9HSU5fRkFJTFwiOlwiQSBiZWzDqXDDqXMgbmVtIHNpa2Vyw7xsdCEgS8OpcmxlayBnecWResWRZGogbWVnIHLDs2xhLCBob2d5IGEgbWVzdGVyamVsc3phdmFkZGFsIGzDqXB0w6lsIGJlIHZhZ3kgbWVnYWR0YWQgYSBQb3N6dG9sw7MgcHJpdsOhdCBrdWxjc290LCBoYSBhIEhhbGFkw7MgbcOzZG90IHbDoWxhc3p0b3R0YWQgQmVqZWxlbnRrZXrDqXNrb3IuXCIsXG4gIFwiTE9HSU5fRkFJTF9BXCI6XCJBIGJlbMOpcMOpcyBuZW0gc2lrZXLDvGx0ISBLw6lybGVrIGd5xZF6xZFkaiBtZWcgcsOzbGEsIGhvZ3kgYSBtZXN0ZXJqZWxzemF2YWRkYWwgbMOpcHTDqWwgYmUgdmFneSBtZWdhZHRhZCBheiBBa3TDrXYgcHJpdsOhdCBrdWxjc290LCBoYSBhIEhhbGFkw7MgbcOzZG90IHbDoWxhc3p0b3R0YWQgQmVqZWxlbnRrZXrDqXNrb3IuXCIsXG4gIFwiV0FSTklOR1wiOlwiRmlneWVsbWV6dGV0w6lzXCIsXG4gIFwiVk9URV9GT1JfV0lUTkVTU1wiOlwiU3phdmF6w6FzIHRhbsO6cmFcIixcbiAgXCJWT1RFRF9GT1JfV0lUTkVTU1wiOlwiU3phdmF6dMOhbCB0YW7DunJhXCIsXG4gIFwiQUdPXCI6XCLDs3RhXCIsXG4gIFwiRlJPTV9OT1dcIjpcIm1vc3RhbnTDs2xcIixcbiAgXCJTRUNTXCI6XCJtw6Fzb2RwZXJjXCIsXG4gIFwiQV9NSU5cIjpcImVneSBwZXJjXCIsXG4gIFwiTUlOU1wiOlwicGVyY2VrXCIsXG4gIFwiQU5fSE9VUlwiOlwiZWd5IMOzcmFcIixcbiAgXCJIT1VSU1wiOlwiw7NyYVwiLFxuICBcIkFfREFZXCI6XCJlZ3kgbmFwXCIsXG4gIFwiREFZU1wiOlwibmFwb2tcIixcbiAgXCJBX01PTlRIXCI6XCJlZ3kgaMOzbmFwXCIsXG4gIFwiTU9OVEhTXCI6XCJow7NuYXBva1wiLFxuICBcIkFfWUVBUlwiOlwiZWd5IMOpdlwiLFxuICBcIllFQVJTXCI6XCLDqXZla1wiLFxuICBcIk1JTl9SRUFEXCI6XCJwZXJjIG9sdmFzw6FzXCIsXG4gIFwiRE9XTlZPVEVfRkxBR1wiOlwiTGVzemF2YXrDoXMgdmFneSBKZWxlbnTDqXNcIixcbiAgXCJDQVBUVVJFX1BJQ1RVUkVcIjpcIkvDqXAgS8Opc3rDrXTDqXNcIixcbiAgXCJTRUxFQ1RfUElDVFVSRVwiOlwiS8OpcCBLaXbDoWxhc3p0w6FzXCIsXG4gIFwiU0VUX0NVU1RPTV9VUkxcIjpcIkVneWVkaSBVUkwgQmXDoWxsw610w6FzXCIsXG4gIFwiSU5TRVJUX1BJQ1RVUkVcIjpcIkvDqXAgQmVpbGxlc3p0w6lzXCIsXG4gIFwiRVJST1JcIjpcIkhpYmFcIixcbiAgXCJVUExPQURfRVJST1JcIjpcIkZlbHTDtmx0w6lzaSBIaWJhXCIsXG4gIFwiQ0FNRVJBX0NBTkNFTExFRFwiOlwiS2FtZXJhIFTDtnLDtmx2ZVwiLFxuICBcIlNFVF9VUkxcIjpcIlVSTCBiZcOhbGzDrXTDoXNcIixcbiAgXCJESVJFQ1RfTElOS19QSUNUVVJFXCI6XCJEaXJla3Qgd2ViIGxpbmsgYSBrw6lwaGV6XCIsXG4gIFwiQ09NTUVOVF9TVUJNSVRURURcIjpcIkEgaG96w6FzesOzbMOhcyBlbGvDvGxkdmUhXCIsXG4gIFwiREVMRVRFX0NPTU1FTlRcIjpcIkEgaG96esOhc3rDs2zDoXNvayB0w7ZybMOpc2Ugdmlzc3phdm9uaGF0YXRsYW4uLi5cIixcbiAgXCJERUxFVEVEX0NPTU1FTlRcIjpcIlTDtnLDtmx0IGhvenrDoXN6w7Nsw6FzXCIsXG4gIFwiVVBMT0FESU5HX1BJQ1RVUkVcIjpcIkvDqXAgZmVsdMO2bHTDqXNlXCIsXG4gIFwiVVBMT0FEX0NPTVBMRVRFRFwiOlwiRmVsdMO2bHTDqXMgS8Opc3pcIixcbiAgXCJVUExPQURfRkFJTEVEXCI6XCJGZWx0w7ZsdMOpcyBNZWdoacO6c3VsdFwiLFxuICBcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOlwiQSBqZWxzesOzIHZhZ3kgZmVsaGFzem7DoWzDs27DqXYgaGliw6FzIHZvbHRcIixcbiAgXCJJTkZPXCI6XCJJbmbDs1wiLFxuICBcIlFSX1RFWFRcIjpcIkhlbHllenogZWd5IFFSLWvDs2RvdCBhIGxlb2x2YXPDoXNpIHRlcsO8bGV0YmVcIixcbiAgXCJCQUxBTkNFX1RFWFRcIjpcIkd5xZF6xZFkaiBtZWcgcsOzbGEsIGhvZ3kgZWxlZ2VuZMWRIGVneWVubGVnZWQgdmFuIGF6IHV0YWzDoXNob3ohXCIsXG4gIFwiTk9ORVhJU1RfVVNFUlwiOlwiQSBmZWxoYXN6bsOhbMOzLCBha2luZWsgdXRhbG5pIHByw7Niw6Fsc3osIG5lbSBsw6l0ZXppayFcIixcbiAgXCJUUkFOU0ZFUl9URVhUXCI6XCJCaXp0b3MgdmFneSBiZW5uZSwgaG9neSB1dGFsbmkgYWthcnN6P1wiLFxuICBcIkNPTkZJUk1BVElPTlwiOlwiTWVnZXLFkXPDrXTDqXNcIixcbiAgXCJUWF9CUk9BRENBU1RFRFwiOlwiQSB0cmFuemFrY2nDsyBrw7Z6dmV0w610dmVcIixcbiAgXCJGRUVEXCI6XCJIw61yZm9seWFtXCIsXG4gIFwiVFJFTkRJTkdcIjpcIk7DqXBzemVyxbFcIixcbiAgXCJIT1RcIjpcIkZvcnLDs1wiLFxuICBcIk5FV1wiOlwiw5pqXCIsXG4gIFwiUFJPTU9URURcIjpcIlTDoW1vZ2F0b3R0XCIsXG4gIFwiVk9URVNcIjpcIlN6YXZhemF0b2tcIixcbiAgXCJQQVlPVVRcIjpcIktpZml6ZXTDqXNcIixcbiAgXCJDT01NRU5UU1wiOlwiSG96esOhc3rDs2zDoXNva1wiLFxuICBcIlRSRU5ESU5HXzMwXCI6XCJOw6lwc3plcsWxIDMwIG5hcHJhXCIsXG4gIFwiU09SVF9QT1NUX0JZXCI6XCJQb3N6dG9rIHJlbmRlesOpc2U6XCIsXG4gIFwiUEFZT1VUX0NZQ0xFXCI6XCJLaWZpemV0w6lzaSBDaWtsdXNcIixcbiAgXCJQT1RFTlRJQUxfUEFZT1VUXCI6XCJMZWhldHPDqWdlcyBLaWZpemV0w6lzXCIsXG4gIFwiUEFTVF9QQVlPVVRcIjpcIlLDqWdpIEtpZml6ZXTDqXNcIixcbiAgXCJBVVRIT1JfUEFZT1VUXCI6XCJTemVyesWRaSBLaWZpemV0w6lzXCIsXG4gIFwiQ1VSQVRJT05fUEFZT1VUXCI6XCJLdXLDoXRvcmkgS2lmaXpldMOpc1wiLFxuICBcIlBPU1RfU1VCTUlUVEVEXCI6XCJBIHBvc3p0IGJla8O8bGR2ZSFcIixcbiAgXCJQT1NUX0xBVEVSXCI6XCJQb3N6dCBrw6lzxZFiYmkgYmVrw7xsZMOpc3JlIVwiLFxuICBcIlNBVkVEXCI6XCJNZW50dmVcIixcbiAgXCJDTEVBUkVEXCI6XCJUw7Zyw7ZsdmVcIixcbiAgXCJGTEFHR0lOR19URVhUXCI6XCJFZ3kgcG9zenQgamVsZW50w6lzZSBlbCB0dWRqYSB0w6F2b2zDrXRhbmkgYSBqdXRhbG1ha2F0IMOpcyBrZXbDqXNiw6kgbMOhdGhhdMOzdsOhIHRlc3ppIGV6dCBheiBhbnlhZ290Ljxicj48YnI+QSBqZWxlbnTDqXN0IGEga8O2dmV0a2V6xZFrcmUga2VsbGVuZSBoYXN6bsOhbG5pOiA8dWw+PGxpPkNzYWzDoXMgdmFneSBQbGFnaXrDoWzDoXM8L2xpPjxsaT5HecWxbMO2bGV0IGJlc3rDqWQgdmFneSBJbnRlcm5ldCBUcm9sbGtvZMOhczwvbGk+PGxpPlR1ZGF0b3NhbiBmw6lscmVrYXRlZ29yaXrDoWx0IHRhcnRhbG9tIHZhZ3kgU3BhbTwvbGk+PC91bD5cIixcbiAgXCJSRVFVRVNUX0xJTUlUX1RFWFRcIjpcIkvDqXLDqXNpIGxpbWl0IGVsw6lydmUuIE7DqXp6IG1lZyBtw6FzIHRyZW5kZXQvY8OtbWvDqXQhXCIsXG4gIFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6XCJBIHBvc3p0IGVsdMOhdm9sw610dmEgYSBrw7ZueXZqZWx6xZFrIGvDtnrDvGwhXCIsXG4gIFwiUE9TVF9JU19CT09LTUFSS1wiOlwiQSBwb3N6dCBob3p6w6FhZHZhIGEga8O2bnl2amVsesWRa2jDtnohXCIsXG4gIFwiUkVTRVRcIjpcIlZpc3N6YcOhbGzDrXTDoXNcIixcbiAgXCJNT0RJRllfUElDVFVSRVwiOlwiUHJvZmlsa8OpcCBNw7Nkb3PDrXTDoXNhXCIsXG4gIFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjpcIkJvcsOtdMOza8OpcCBNw7Nkb3PDrXTDoXNhXCIsXG4gIFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6XCJLw6lybGVrIGFkZCBtZWcgYXogQWt0w612IHByaXbDoXQga3VsY3NvdCwgaGEgYSBIYWxhZMOzIGJlbMOpcMOpc2kgbcOzZG90IHbDoWxhc3p0b3R0YWQhXCIsXG4gIFwiUkVTRVRfUElDVFVSRV9URVhUXCI6XCJFeiB2aXNzemEgZm9namEgw6FsbMOtdGFuaSBhIHByb2ZpbGvDqXBldFwiLFxuICBcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOlwiRXogdmlzc3phIGZvZ2phIMOhbGzDrXRhbmkgYSBib3LDrXTDs2vDqXBldFwiLFxuICBcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6XCJBIHN6ZXJ2ZXIgZnJpc3PDrXTDqXNlIG1lZ2vDtnZldGVsaSBheiDDmmpyYWluZMOtdMOhc3QuXCIsXG4gIFwiU0VUVElOR1NfVVBEQVRFRFwiOlwiQmXDoWxsw610w6Fzb2sgZnJpc3PDrXR2ZSFcIixcbiAgXCJMQU5HVUFHRVNcIjpcIk55ZWx2ZWtcIixcbiAgXCJMQU5HVUFHRVNfVEVYVFwiOlwiSXR0IHR1ZG9kIG1lZ3bDoWx0b3p0YXRuaSBheiBhbGthbG1hesOhcyBueWVsdsOpdC5cIixcbiAgXCJMT0dJTl9UT19YXCI6XCJFeiBhIG3FsXZlbGV0IG1lZ2vDtnZldGVsaSwgaG9neSBhIGZlbGhhc3puw6Fsw7MgYSBmxZEgamVsc3phdsOhdmFsLCBha3TDrXYvcG9zenRvbMOzIGt1bGNzw6F2YWwgbGVneWVuIGJlamVsZW50a2V6dmUuIEvDqXJsZWsgbMOpcGogYmUgw6lzIHByw7Niw6FsZCDDumpyYS5cIixcbiAgXCJHQUxMRVJZXCI6XCJHYWzDqXJpYVwiLFxuICBcIlRSQU5TTEFUSU9OU1wiOlwiQSBmb3Jkw610w6FzIGvDtnpyZW3FsWvDtmTFkWlcIixcbiAgXCJTSEFSRVwiOlwiTWVnb3N6dMOhc1wiLFxuICBcIk1BUktFVFBMQUNFXCI6XCJQaWFjdMOpclwiLFxuICBcIkVYQ0hBTkdFXCI6XCJWw6FsdMOzXCIsXG4gIFwiRFJBRlRTXCI6XCJQaXN6a296YXRcIixcbiAgXCJQT1NUX0lTX1VORFJBRlRcIjpcIkEgYmVqZWd5esOpcyBlbHTDoXZvbMOtdHZhIGEgcGlzemtvemF0b2tiw7NsIVwiLFxuICBcIlBPU1RfSVNfRFJBRlRcIjpcIkEgYmVqZWd5esOpcyBob3p6w6FhZHZhIGEgcGlzemtvemF0b2tob3ohXCIsXG4gIFwiU1dJUEVfTEVGVFwiOlwiQ3PDunN6dGFzcyBiYWxyYSBheiBvcGNpw7Nrw6lydFwiLFxuICBcIk1BTkFHRVwiOlwiS2V6ZWzDqXNcIixcbiAgXCJJTUFHRV9SRU1PVkVEXCI6XCJLw6lwIHTDtnLDtmx2ZVwiLFxuICBcIkNPUFlcIjpcIk3DoXNvbMOhc1wiLFxuICBcIk5PX0lNQUdFXCI6XCJNw6lnIG5lbSB0w7ZsdMO2dHTDqWwgZmVsIHNlbW1pbHllbiBrw6lwZXQhXCIsXG4gIFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjpcIkjDunpkIGxlIGEgZnJpc3PDrXTDqXNoZXpcIixcbiAgXCJFWFRFUk5BTF9BUFBTXCI6XCJLw7xsc8WRIEFsa2FsbWF6w6Fzb2tcIixcbiAgXCJQTFVHSU5TXCI6XCJCZcOpcMO8bMWRa1wiLFxuICBcIlNVR0dFU1RcIjpcIkphdmFzb2xcIixcbiAgXCJDT01JTkdfU09PTlwiOlwiSGFtYXJvc2FuIG1lZ2plbGVuaWtcIixcbiAgXCJDSEFJTlwiOlwiTMOhbmNcIixcbiAgXCJDSEFJTl9URVhUXCI6XCJJdHQgdHVkc3ogYmxva2tsw6FuY290IHZhZ3kgYWxhcMOpcnRlbG1lemV0dCBmZWzDvGxldGV0IGNzZXLDqWxuaS5cIixcbiAgXCJDVVJSRU5DWVwiOlwiXCIsXG4gIFwiQ1VSUkVOQ1lfVEVYVFwiOlwiXCIsXG4gIFwiQUJPVVRfMTFcIjpcIlwiLFxuICBcIkZPVU5ERVJcIjpcIlwiLFxuICBcIkFERF9BQ0NPVU5UXCI6XCJcIixcbiAgXCJQTEFURk9STVwiOlwiXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiSE9NRVwiOlwiQmVyYW5kYVwiLFxuICBcIkxPR0lOXCI6XCJNYXN1a1wiLFxuICBcIkxPR09VVFwiOlwiS2VsdWFyXCIsXG4gIFwiUFJPRklMRVwiOlwiUHJvZmlsXCIsXG4gIFwiRk9MTE9XXCI6XCJJa3V0aVwiLFxuICBcIkJPT0tNQVJLU1wiOlwiXCIsXG4gIFwiVFJBTlNGRVJcIjpcIlwiLFxuICBcIk1BUktFVFwiOlwiXCIsXG4gIFwiU0VUVElOR1NcIjpcIlNldGVsYW5cIixcbiAgXCJBQk9VVFwiOlwiVGVudGFuZ1wiLFxuICBcIkFCT1VUXzFcIjpcIlNpYXBhcHVuIGJpc2EgbWVuZGFwYXRrYW4ga2V1bnR1bmdhbiBkYXJpIGtvbnRlblwiLFxuICBcIkFCT1VUXzJcIjpcIkFwcGxpa2FzaSBkaWJ1YXQgb2xlaFwiLFxuICBcIkFCT1VUXzNcIjpcImRhbiBpbmkgYWRhbGFoIG9wZW4gc291cmNlLCBwcm95ZWsgbW9iaWxlIGJlcmJhc2lzIG1hc3lhcmFrYXQuIEluaSBtZW5hd2Fya2FuIGFrc2VzIGtvbnRlbiB1bnR1ayBtZW1iYWNhLCBiZXJrb21lbnRhciwgdm90aW5nLCBwb3N0aW5nLCBtZW50cmFuc2ZlciBwZW5kYXBhdGFuLCBkbGwgZml0dXIgeWFuZyBkaXRhd2Fya2FuIG9sZWgge3twbGF0Zm9ybW5hbWV9fSBibG9ja2NoYWluIGRhbiB7e3NpdGVuYW1lfX0uXCIsXG4gIFwiQUJPVVRfNFwiOlwiMS4gQXBwIHRpZGFrIHBlcm5haCBtZW5nYWtzZXMgYXRhdSBtZW1lZ2FuZyBkYW5hIHBlbmdndW5hLlwiLFxuICBcIkFCT1VUXzVcIjpcIjIuIEFwcCBtZW5hd2Fya2FuIG1vZGVsIGtlYW1hbmFuIGNsaWVudC1zaWRlLCBkZW5nYW4ga3VuY2kgcHJpYmFkaSBob3N0IHNlY2FyYSBsb2thbCBkYW4gdGlkYWsgcGVybmFoIGRpa2lyaW0ga2Ugc2VydmVyLlwiLFxuICBcIkFCT1VUXzZcIjpcIjMuIEFwcCBtZW5hd2Fya2FuIHNlZGVyaGFuYSwgdXNlciBpbnRlcmZhY2UgeWFuZyBtZW5hcmlrIGRhbiBwZW5nYWxhbWFuLlwiLFxuICBcIkFCT1VUXzdcIjpcIjQuIEFwcCB0aWRhayBwZXJuYWggbWVuZ2hhcnVza2FuIHBlbmdndW5hIHVudHVrIG1lbWFzdWtrYW4gaW5mb3JtYXNpIHByaWJhZGkgYXBhcHVuLlwiLFxuICBcIkFCT1VUXzhcIjpcIlBpbGloIGdvb2Qta2FybWEgc2ViYWdhaSB3aXRuZXNzXCIsXG4gIFwiQUJPVVRfOVwiOlwiS29udGFrL1NhcmFuOlwiLFxuICBcIkFCT1VUXzEwXCI6XCJJbmZvIGxlYmloIGxhbmp1dDpcIixcbiAgXCJSRU1PVkVcIjpcIk1lbmdoYXB1c1wiLFxuICBcIk1BUktFVF9WSUVXXCI6XCJQYXNhclwiLFxuICBcIlBSSUNFXCI6XCJIYXJnYVwiLFxuICBcIkFNT1VOVFwiOlwiSnVtbGFoXCIsXG4gIFwiVE9UQUxcIjpcIlwiLFxuICBcIk5PT1JERVJTXCI6XCJObyBvcGVuIG9yZGVyIHVudHVrXCIsXG4gIFwiREFURVwiOlwiVGFuZ2dhbFwiLFxuICBcIkJVWVwiOlwiQmVsaVwiLFxuICBcIlNFTExcIjpcIkp1YWxcIixcbiAgXCJPUEVOXCI6XCJCdWthXCIsXG4gIFwiSElTVE9SWVwiOlwiUml3YXlhdFwiLFxuICBcIkZPTExPV19CQUNLXCI6XCJcIixcbiAgXCJGT0xMT1dFRFwiOlwiXCIsXG4gIFwiVU5GT0xMT1dcIjpcIlwiLFxuICBcIkZPTExPV0lOR1wiOlwiTWVuZ2lrdXRpXCIsXG4gIFwiRk9MTE9XRVJTXCI6XCJQZW5naWt1dFwiLFxuICBcIlNFQVJDSF9GT0xMT1dFUlNcIjpcIk1lbmNhcmkgUGVuZ2lrdXRcIixcbiAgXCJTRUFSQ0hfRk9MTE9XSU5HXCI6XCJNZW5jYXJpIE1lbmdpa3V0aVwiLFxuICBcIkJZXCI6XCJvbGVoXCIsXG4gIFwiSU5cIjpcImRhbGFtXCIsXG4gIFwiTUVOVVwiOlwiXCIsXG4gIFwiQk9PS01BUktcIjpcIlwiLFxuICBcIlJFQkxPR1wiOlwiXCIsXG4gIFwiVVBWT1RFXCI6XCJcIixcbiAgXCJET1dOVk9URVwiOlwiXCIsXG4gIFwiVU5WT1RFX0RPV05WT1RFRFwiOlwiQmF0YWxrYW4gRG93bnZvdGVcXG5cIixcbiAgXCJVTlZPVEVfVVBWT1RFRFwiOlwiQmF0YWxrYW4gVXB2b3RlZFxcblwiLFxuICBcIlJFUExZXCI6XCJCYWxhc1wiLFxuICBcIkVESVRcIjpcIlwiLFxuICBcIlBPU1RfMVwiOlwiR2VzZXIga2Uga2lyaSBwYWRhIGtvbWVudGFyIHVudHVrIG1lbGloYXQgb3BzaVwiLFxuICBcIlBPU1RfMlwiOlwiS2V0dWsgcGFkYSBrb21lbnRhciB1bnR1ayBtZWxpaGF0IHN1Yi1rb21lbnRhclwiLFxuICBcIk9QVElPTlNcIjpcIk9wc2lcIixcbiAgXCJSRVNURUVNRURfQllcIjpcIlJlc3RlZW1lZCBPbGVoXCIsXG4gIFwiTk9USElOR19IRVJFXCI6XCJUaWRhayBhZGEgZGkgc2luaS4uLlwiLFxuICBcIkJBTEFOQ0VTXCI6XCJTYWxkb1wiLFxuICBcIlBST0ZJTEVfMVwiOlwie3tQbGF0Zm9ybW5hbWV9fSwgdG9rZW4gdHJhZGVhYmxlIHlhbmcgZGFwYXQgZGl0cmFuc2ZlciBrYXBhbiBzYWphLiB7e1BsYXRmb3JtbmFtZX19IGRhcGF0IGRpa29udmVyc2kga2Uge3trZWt1YXRhbiBwbGF0Zm9ybSB5YW5nfX0gZGFsYW0gcHJvc2VzIHlhbmcgZGlzZWJ1dCBwb3dlcmluZyB1cC5cIixcbiAgXCJQUk9GSUxFXzJcIjpcInt7UGxhdGZvcm1wb3dlcn19LCBtZW1wZW5nYXJ1aGkgdG9rZW4geWFuZyBtZW5kYXBhdGthbiBsZWJpaCBiYW55YWsga2VrdWF0YW4gdW50dWsgbWVtZWdhbmcgamFuZ2thIHBhbmphbmcgZGFuIHN1YXJhIHBhZGEgcG9zdGluZy4gU2VtYWtpbiBzYXR1IG1lbWVnYW5nIGxlYmloIHNhdHUgZGFwYXQgbWVtcGVuZ2FydWhpIGltYmFsYW4gbGFpbiBkYW4gbWVuZGFwYXRrYW4gaW1iYWxhbiB1bnR1ayB2b3RpbmcgYWt1cmF0LlwiLFxuICBcIlBST0ZJTEVfM1wiOlwiVG9rZW4gYmVybmlsYWkgc2VraXRhciB7e3BsYXRmb3Jtc3VuaXR9fSBkYXJpIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG4gIFwiRVNUSU1BVEVEX1ZBTFVFXCI6XCJQZXJraXJhYW4gTmlsYWlcIixcbiAgXCJQUk9GSUxFXzRcIjpcIk5pbGFpIGVzdGltYXNpIGluaSBkaWRhc2Fya2FuIHBhZGEgbmlsYWkgcmF0YS1yYXRhIDcgaGFyaSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuICBcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjpcIlNlamFyYWggVHJhbnNha3NpXCIsXG4gIFwiUE9TVElOR1wiOlwiUG9zdGluZ2FuXCIsXG4gIFwiUFJPRklMRV81XCI6XCJLdW5jaSBwb3N0aW5nYW4gZGlndW5ha2FuIHVudHVrIHBvc3RpbmcgZGFuIHZvdGluZy4gSW5pIGhhcnVzIGJlcmJlZGEgZGFyaSB0b21ib2wgYWt0aWYgZGFuIHBlbWlsaWsuXCIsXG4gIFwiT1dORVJcIjpcIlBlbWlsaWtcIixcbiAgXCJQUk9GSUxFXzZcIjpcIkt1bmNpIHBlbWlsaWsgYWRhbGFoIGt1bmNpIG1hc3RlciB1bnR1ayBhY2NvdW50IGRhbiBkaXBlcmx1a2FuIHVudHVrIG1lbmd1YmFoIGt1bmNpIGxhaW5ueWEuIEt1bmNpIHByaWJhZGkgYXRhdSBwYXNzd29yZCB1bnR1ayBrdW5jaSBwZW1pbGlrIGhhcnVzIGRpc2ltcGFuIHNlY2FyYSBvZmZsaW5lIHNlYmFueWFrIG11bmdraW4uXCIsXG4gIFwiQUNUSVZFXCI6XCJBa3RpZlwiLFxuICBcIlBST0ZJTEVfN1wiOlwiS3VuY2kgYWt0aWYgZGlndW5ha2FuIHVudHVrIG1lbGFrdWthbiB0cmFuc2ZlciBkYW4gdGVtcGF0IG9yZGVyIGRpIHBhc2FyIGludGVybmFsLlwiLFxuICBcIk1FTU9cIjpcIlwiLFxuICBcIlBST0ZJTEVfOFwiOlwiS3VuY2kgbWVtbyBkaWd1bmFrYW4gdW50dWsgbWVtYnVhdCBkYW4gbWVtYmFjYSBtZW1vLlwiLFxuICBcIkJMT0dcIjpcIlwiLFxuICBcIlBPU1RTXCI6XCJQb3N0XCIsXG4gIFwiUkVQTElFU1wiOlwiQmFsYXNhblwiLFxuICBcIldBTExFVFwiOlwiRG9tcGV0XCIsXG4gIFwiVEFHXCI6XCJcIixcbiAgXCJVU0VSXCI6XCJcIixcbiAgXCJDTE9TRVwiOlwiVHV0dXBcIixcbiAgXCJUT1wiOlwiS2VwYWRhXCIsXG4gIFwiQVNTRVRcIjpcIkFzZXRcIixcbiAgXCJTRU5EXCI6XCJLaXJpbVwiLFxuICBcIlNFQ1VSSVRZXCI6XCJLZWFtYW5hblwiLFxuICBcIkFWQUlMQUJMRVwiOlwiVGVyc2VkaWFcIixcbiAgXCJQVUJMSUNfTUVNT1wiOlwiTWVtbyBwdWJsaWtcIixcbiAgXCJUT19ERVNDXCI6XCJcIixcbiAgXCJQSU5fQ09ERVwiOlwiS29kZSBQaW5cIixcbiAgXCJQSU5fVEVYVFwiOlwiS29kZSBQSU4gbWVtYmFudHUgQW5kYSB1bnR1ayBtZW5nYW1hbmthbiBhcGxpa2FzaSBkYW4gZGF0YSBBbmRhLiA8YnIvPjxici8+IDxiPkNhdGF0YW46PC9iPiBTZXRlbGFoIGRpYWt0aWZrYW4sIEFuZGEgbWVtaWxpa2kgbWF4IDQgbWVuY29iYSB1bnR1ayBtZW1idWthLCBqaWthIEFuZGEgbHVwYSBwaW4gYXRhdSBnYWdhbCwgYXBsaWthc2kgYWthbiBoYXB1cyBsb2dpbiBkYXRhIHBlbmdndW5hLiBBbmRhIGRhcGF0IGxvZ2luIGtlbWJhbGkgZGFuIHRlcnVzIG1lbmdndW5ha2FuIGFwbGlrYXNpLlwiLFxuICBcIk5PVElGSUNBVElPTlNcIjpcIk5vdGlmaWthc2lcIixcbiAgXCJWT1RFX1RFWFRcIjpcIkFuZGEgYWthbiBtZW5kYXBhdGthbiBub3RpZmlrYXNpIGtldGlrYSBzZXNlb3JhbmcgbWVtYmVyaWthbiBzdWFyYSBrb250ZW4gQW5kYSEgPGJyLz4gPGI+Q2F0YXRhbjo8L2I+IFBlbWJlcml0YWh1YW4gdGVybWFzdWsgc3VhcmEgYmVyYXQgc2VydGEgZGFsYW0gcGVzYW4gcGVyaW5nYXRhbi4gKEJhaWsgaXR1IHVwLXZvdGUsIGRvd24tdm90ZSwgdW4tdm90ZSkuXCIsXG4gIFwiVk9URVwiOlwiVm90aW5nXCIsXG4gIFwiQ09NTUVOVF9URVhUXCI6XCJBbmRhIGFrYW4gbWVuZGFwYXRrYW4gbm90aWZpa2FzaSBrZXRpa2Egc2VzZW9yYW5nIGtvbWVudGFyIHBhZGEgcG9zdGluZyBhdGF1IGtvbWVudGFyITxici8+IDxiPkNhdGF0YW46PC9iPiBQZW1iZXJpdGFodWFuIHRlcm1hc3VrIGtldGlrYSBzZXNlb3JhbmcgPGI+U3VudGluZzwvYj4ga29tZW50YXIgbWVyZWthIGp1Z2EuXCIsXG4gIFwiQ09NTUVOVFwiOlwiS29tZW50YXJcIixcbiAgXCJGT0xMT1dfVEVYVFwiOlwiQW5kYSBha2FuIG1lbmRhcGF0a2FuIG5vdGlmaWthc2kga2V0aWthIHNlc2VvcmFuZyBGb2xsb3cgYXRhdSBVbmZvbGxvdyBBbmRhIVwiLFxuICBcIk1FTlRJT05TXCI6XCJNZW55ZWJ1dGthblwiLFxuICBcIk1FTlRJT05TX1RFWFRcIjpcIkFuZGEgYWthbiBtZW5kYXBhdGthbiBwZW1iZXJpdGFodWFuIGJpbGEgc2VzZW9yYW5nIG1lbnllYnV0a2FuIEFuZGEgZGFsYW0gcG9zdGluZ2FuIG1lcmVrYS9rb21lbnRhciFcIixcbiAgXCJSRVNURUVNXCI6XCJcIixcbiAgXCJSRVNURUVNX1RFWFRcIjpcIkFuZGEgYWthbiBtZW5kYXBhdGthbiBub3RpZmlrYXNpIGtldGlrYSBzZXNlb3JhbmcgcmVzdGVlbXMgcG9zdGluZyBBbmRhIVxcblwiLFxuICBcIkNPTkZJR1VSQVRJT05TXCI6XCJLb25maWd1cmFzaVwiLFxuICBcIlZPVElOR1wiOlwiXCIsXG4gIFwiVk9USU5HX1RFWFRcIjpcIktla3VhdGFuIFZvdGluZyBhdGF1IHBlcnNlbnRhc2UgbWVtcGVuZ2FydWhpIGhhayBzdWFyYSBwYWRhIGFwbGlrYXNpLCBzZWhpbmdnYSBBbmRhIGRhcGF0IG1lbmdhdHVyIHJld2FyZCBWb3RpbmcgQW5kYS4gPGJyLz48YnIvPjxiPkNhdGF0YW46PC9iPiBpbmkgYWthbiBtZW5ndWJhaCBrZWt1YXRhbiB2b3RpbmcvcGVyc2VudGFzZSB1bnR1ayBkb3dudm90aW5nIGp1Z2EgZGFuIGl0dSBhZGFsYWggZGkgbWFuYS1tYW5hIHBhZGEgYXBsaWthc2lcIixcbiAgXCJTRVJWRVJcIjpcIlwiLFxuICBcIlNFUlZFUl9URVhUXCI6XCJEaXJla29tZW5kYXNpa2FuXCIsXG4gIFwiU0FWRV9DSEFOR0VTXCI6XCJTaW1wYW4gcGVydWJhaGFuXCIsXG4gIFwiVk9URVJTX0lORk9cIjpcIlwiLFxuICBcIldFTENPTUVfQkFDS1wiOlwiU2VsYW1hdCBEYXRhbmcga2VtYmFsaSFcIixcbiAgXCJMT0dJTl8xXCI6XCJNYXN1ayBkZW5nYW4gbmFtYSBwZW5nZ3VuYSBkYW4gcGFzc3dvcmQgdW50dWsgbWVsYW5qdXRrYW4uXCIsXG4gIFwiTE9HSU5fMlwiOlwiUG9zdGluZyBrdW5jaSBkaWd1bmFrYW4gdW50dWsgcG9zdGluZywga29tZW50YXIsIHZvdGluZywgZm9sbG93LlwiLFxuICBcIkxPR0lOXzNcIjpcIkFjdGl2ZSBrdW5jaSBkaWd1bmFrYW4gdW50dWsgdHJhbnNmZXIgZGFuIG1lbXBlcmJhcnVpIGdhbWJhciBwcm9maWwuXCIsXG4gIFwiTE9HSU5fNFwiOlwia3JlZGVuc2lhbCBwZW5nZ3VuYSBkaXNpbXBhbiBzZWNhcmEgbG9rYWwgcGFkYSBwZXJhbmdrYXQuIFNldGVsYWggS2VsdWFyIGtyZWRlbnNpYWwgZGloYXB1cyFcIixcbiAgXCJET05UX0hBVkVcIjpcIlRpZGFrIG1lbWlsaWtpIGFrdW4/XCIsXG4gIFwiU0lHTl9VUF9OT1dcIjpcIkRhZnRhciBTZWthcmFuZ1wiLFxuICBcIkNBTkNFTFwiOlwiQmF0YWxcIixcbiAgXCJBRFZBTkNFRFwiOlwiTGFuanV0YW5cIixcbiAgXCJBQ1RJVkVfUFJJS0VZXCI6XCJLdW5jaSBha3RpZiBwcmliYWRpXCIsXG4gIFwiUE9TVElOR19QUklLRVlcIjpcIkt1bmNpIFBvc3RpbmcgUHJpYmFkaVwiLFxuICBcIk1BU1RFUl9QQVNTXCI6XCJNYXN0ZXIvcGFzc3dvcmQgdXRhbWFcIixcbiAgXCJVU0VSTkFNRVwiOlwiTmFtYSBQZW5nZ3VuYVwiLFxuICBcIkNBUkRfVklFV1wiOlwiXCIsXG4gIFwiQ09NUEFDVF9WSUVXXCI6XCJcIixcbiAgXCJTRUFSQ0hcIjpcIkNhcmlcIixcbiAgXCJTVUJNSVRfQV9TVE9SWVwiOlwiXCIsXG4gIFwiUkVQTFlUT1wiOlwiQmFsYXMga2VcIixcbiAgXCJQT1NUXCI6XCJwb3N0aW5nXCIsXG4gIFwiUFJFVklFV1wiOlwiXCIsXG4gIFwiREVGQVVMVFwiOlwiXCIsXG4gIFwiUE9XRVJVUFwiOlwiXCIsXG4gIFwiREVDTElORV9QQVlPVVRcIjpcIlwiLFxuICBcIlNBVkVfRk9SX0xBVEVSXCI6XCJTSU1QQU4gVU5UVUsgTkFOVElcIixcbiAgXCJDTEVBUlwiOlwiQkVSU0lIS0FOXCIsXG4gIFwiUE9TVF9DT05URU5UXCI6XCJQb3N0aW5nIGtvbnRlblwiLFxuICBcIkNPTU1FTlRfQ09OVEVOVFwiOlwiS29udGVuIGtvbWVudGFyXCIsXG4gIFwiVElUTEVcIjpcIkp1ZHVsXCIsXG4gIFwiVEFHU1wiOlwiXCIsXG4gIFwiTk9UX01BVENIXCI6XCJUSURBSyBDT0NPS1wiLFxuICBcIkNPTkZJUk1fUElOXCI6XCJLb25maXJtYXNpIFBpblwiLFxuICBcIklOQ09SUkVDVFwiOlwiU0FMQUhcIixcbiAgXCJPUEVOSU5HX1BPU1RcIjpcIlBvc3QgcGVtYnVrYWFuXCIsXG4gIFwiU0VUX1BJTlwiOlwiXCIsXG4gIFwiRU5URVJfUElOXCI6XCJNYXN1a2FuIFBJTlwiLFxuICBcIkFSRV9ZT1VfU1VSRVwiOlwiQXBha2FoIGFuZGEgeWFraW4/XCIsXG4gIFwiUkVCTE9HX1RFWFRcIjpcIlJlc3RlZW0gaXJldmVyc2liZWwsIGFwYWthaCBBbmRhIGluZ2luIG1lbGFuanV0a2FuP1wiLFxuICBcIkJST0FEQ0FTVF9FUlJPUlwiOlwiU2lhcmFuIGVycm9yLCBjb2JhIGxhZ2khXCIsXG4gIFwiU1VDQ0VTU1wiOlwiU3Vrc2VzXCIsXG4gIFwiUkVCTE9HR0VEX1BPU1RcIjpcIlwiLFxuICBcIkxPR0lOX0ZBSUxcIjpcIkdhZ2FsIG1hc3VrISBQYXN0aWthbiBBbmRhIHRlbGFoIGxvZ2luIGRlbmdhbiBwYXNzd29yZCBtYXN0ZXIgYXRhdSB0ZXJzZWRpYSBQb3N0aW5nIGt1bmNpIHByaWJhZGkgcGFkYSBMb2dpbiBqaWthIEFuZGEgdGVsYWggY2hvb3NlZCBtb2RlIEFkdmFuY2VkLlwiLFxuICBcIkxPR0lOX0ZBSUxfQVwiOlwiR2FnYWwgbWFzdWshIFBhc3Rpa2FuIEFuZGEgdGVsYWggbG9naW4gZGVuZ2FuIHBhc3N3b3JkIG1hc3RlciBhdGF1IGRpc2VkaWFrYW4ga3VuY2kgcHJpYmFkaSBBa3RpZiBkaSBMb2dpbiBqaWthIEFuZGEgdGVsYWggbWVtaWxpaCBtb2RlIEFkdmFuY2VkLlwiLFxuICBcIldBUk5JTkdcIjpcIlBlcmluZ2F0YW5cIixcbiAgXCJWT1RFX0ZPUl9XSVRORVNTXCI6XCJWb3RpbmcgdW50dWsgd2l0bmVzc1wiLFxuICBcIlZPVEVEX0ZPUl9XSVRORVNTXCI6XCJWb3RlZCB1bnR1ayB3aXRuZXNzXCIsXG4gIFwiQUdPXCI6XCJsYWx1XCIsXG4gIFwiRlJPTV9OT1dcIjpcImRhcmkgc2VrYXJhbmdcIixcbiAgXCJTRUNTXCI6XCJkZXRpa1wiLFxuICBcIkFfTUlOXCI6XCJzZW1lbml0XCIsXG4gIFwiTUlOU1wiOlwibWVuaXRcIixcbiAgXCJBTl9IT1VSXCI6XCJzZWphbVwiLFxuICBcIkhPVVJTXCI6XCJqYW1cIixcbiAgXCJBX0RBWVwiOlwic2VoYXJpXCIsXG4gIFwiREFZU1wiOlwiaGFyaVwiLFxuICBcIkFfTU9OVEhcIjpcInNlYnVsYW5cIixcbiAgXCJNT05USFNcIjpcImJ1bGFuXCIsXG4gIFwiQV9ZRUFSXCI6XCJzZXRhaHVuXCIsXG4gIFwiWUVBUlNcIjpcInRhaHVuXCIsXG4gIFwiTUlOX1JFQURcIjpcIm1pbiBiYWNhXCIsXG4gIFwiRE9XTlZPVEVfRkxBR1wiOlwiXCIsXG4gIFwiQ0FQVFVSRV9QSUNUVVJFXCI6XCJBbWJpbCBHYW1iYXJcIixcbiAgXCJTRUxFQ1RfUElDVFVSRVwiOlwiUGlsaWggR2FtYmFyXCIsXG4gIFwiU0VUX0NVU1RPTV9VUkxcIjpcIlwiLFxuICBcIklOU0VSVF9QSUNUVVJFXCI6XCJNYXN1a2FuIEdhbWJhclwiLFxuICBcIkVSUk9SXCI6XCJcIixcbiAgXCJVUExPQURfRVJST1JcIjpcIlwiLFxuICBcIkNBTUVSQV9DQU5DRUxMRURcIjpcIkthbWVyYSBEaWJhdGFsa2FuXCIsXG4gIFwiU0VUX1VSTFwiOlwiXCIsXG4gIFwiRElSRUNUX0xJTktfUElDVFVSRVwiOlwiRGlyZWN0IHdlYiBsaW5rIHV0dWsgR2FtYmFyXCIsXG4gIFwiQ09NTUVOVF9TVUJNSVRURURcIjpcIktvbWVudGFyIGRpc2FtcGFpa2FuIVwiLFxuICBcIkRFTEVURV9DT01NRU5UXCI6XCJNZW5naGFwdXMga29tZW50YXIgYWRhbGFoIGlyZXZlcnNpYmVsLi4uXCIsXG4gIFwiREVMRVRFRF9DT01NRU5UXCI6XCJNZW5naGFwdXMga29tZW50YXJcIixcbiAgXCJVUExPQURJTkdfUElDVFVSRVwiOlwiVXBsb2FkIEdhbWJhclwiLFxuICBcIlVQTE9BRF9DT01QTEVURURcIjpcIlVwbG9hZCBTZWxlc2FpXCIsXG4gIFwiVVBMT0FEX0ZBSUxFRFwiOlwiVXBsb2FkIEdhZ2FsXCIsXG4gIFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6XCJQYXNzd29yZCBhdGF1IG5hbWEgYWt1biB0aWRhayBiZW5hclwiLFxuICBcIklORk9cIjpcIlwiLFxuICBcIlFSX1RFWFRcIjpcIlRlbXBhdGthbiBrb2RlIFFSIGRpIGRhbGFtIGFyZWEgcGluZGFpXCIsXG4gIFwiQkFMQU5DRV9URVhUXCI6XCJQYXN0aWthbiBBbmRhIG1lbWlsaWtpIHNhbGRvIHlhbmcgY3VrdXAgdW50dWsgdHJhbnNha3NpIVwiLFxuICBcIk5PTkVYSVNUX1VTRVJcIjpcIlBlbmdndW5hIHlhbmcgQW5kYSBjY29iYSB1bnR1ayBtZW50cmFuc2ZlciBkYW5hLCB0aWRhayBhZGEhXCIsXG4gIFwiVFJBTlNGRVJfVEVYVFwiOlwiQXBha2FoIEFuZGEgeWFraW4gQW5kYSBpbmdpbiBtZW50cmFuc2Zlcj9cIixcbiAgXCJDT05GSVJNQVRJT05cIjpcIktvbmZpcm1hc2lcIixcbiAgXCJUWF9CUk9BRENBU1RFRFwiOlwiVHJhbnNha3NpIGRpc2lhcmthblwiLFxuICBcIkZFRURcIjpcIlVtcGFuXCIsXG4gIFwiVFJFTkRJTkdcIjpcIlwiLFxuICBcIkhPVFwiOlwiXCIsXG4gIFwiTkVXXCI6XCJCYXJ1XCIsXG4gIFwiUFJPTU9URURcIjpcIlByb21vc2lcIixcbiAgXCJWT1RFU1wiOlwiVm90ZVwiLFxuICBcIlBBWU9VVFwiOlwiRGliYXlhclwiLFxuICBcIkNPTU1FTlRTXCI6XCJLb21lbnRhclwiLFxuICBcIlRSRU5ESU5HXzMwXCI6XCJUcmVuZGluZyAzMCBIYXJpXCIsXG4gIFwiU09SVF9QT1NUX0JZXCI6XCJVcnV0a2FuIFBvc3RpbmdhbjpcIixcbiAgXCJQQVlPVVRfQ1lDTEVcIjpcIlwiLFxuICBcIlBPVEVOVElBTF9QQVlPVVRcIjpcIlBvdGVuc2kgUGVtYmF5YXJhblwiLFxuICBcIlBBU1RfUEFZT1VUXCI6XCJQZW1iYXlhcmFuIHRlcmFraGlyXCIsXG4gIFwiQVVUSE9SX1BBWU9VVFwiOlwiUGVtYmF5YXJhbiBQZW51bGlzXCIsXG4gIFwiQ1VSQVRJT05fUEFZT1VUXCI6XCJQZW1iYXlhcmFuIEt1cmFzaVwiLFxuICBcIlBPU1RfU1VCTUlUVEVEXCI6XCJQb3N0IGRpdGF5YW5na2FuIVwiLFxuICBcIlBPU1RfTEFURVJcIjpcIlBvc3RpbmcgdW50dWsgZGlhanVrYW4gbmFudGkhXCIsXG4gIFwiU0FWRURcIjpcIkRpc2ltcGFuXCIsXG4gIFwiQ0xFQVJFRFwiOlwiRGliZXJzaWhrYW5cIixcbiAgXCJGTEFHR0lOR19URVhUXCI6XCJGbGFnZ2luZyBwb3N0aW5nYW4gZGFwYXQgbWVuZ2hhcHVzIGltYmFsYW4gZGFuIG1lbWJ1YXQgYmFoYW4gaW5pIGt1cmFuZyB0ZXJsaWhhdCA8YnI+IGJlbmRlcmEgaGFydXMgZGlndW5ha2FuIHVudHVrIGJlcmlrdXQ6IDx1bD48bGk+UGVuaXB1YW4gYXRhdSBQbGFnaWFyaXNtZTwvbGk+PGxpPkthdGEga2FzYXIgYXRhdSBJbnRlcm5ldCBUcm9sbGluZyA8L2xpPjxsaT5Lb250ZW4gRGlzZW5nYWphIGRpa2F0ZWdvcmlrYW4gYXRhdSBTcGFtPC9saT4gPC91bD5cIixcbiAgXCJSRVFVRVNUX0xJTUlUX1RFWFRcIjpcIkJhdGFzIHBlcm1pbnRhYW4gdGVyY2FwYWkuIExpaGF0IHRyZW4vdGFnIGxhaW5ueWEhXCIsXG4gIFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6XCJQb3N0aW5nIGRpaGlsYW5na2FuIGRhcmkgYm9va21hcmshXCIsXG4gIFwiUE9TVF9JU19CT09LTUFSS1wiOlwiUG9zdGluZyBkaXRhbWJhaGthbiBrZSBib29rbWFyayFcIixcbiAgXCJSRVNFVFwiOlwiU2V0ZWwgVWxhbmdcIixcbiAgXCJNT0RJRllfUElDVFVSRVwiOlwiTW9kaWZpa2FzaSBnYW1iYXIgUHJvZmlsXCIsXG4gIFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjpcIk1lbW9kaWZpa2FzaSBTYW1wdWwgZ2FtYmFyXCIsXG4gIFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6XCJIYXJhcCBtZW1iZXJpa2FuIGt1bmNpIHByaWJhZGkgQWN0aXZlIGppa2EgQW5kYSB0ZWxhaCBtZW1pbGloIG1vZHVzIG1hc3VrIExhbmp1dGFuIVwiLFxuICBcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOlwiSW5pIGFrYW4gbWVueWV0ZWwgdWxhbmcgZ2FtYmFyIHByb2ZpbFwiLFxuICBcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOlwiSW5pIGFrYW4gbWVyZXNldCBnYW1iYXIgc2FtcHVsXCIsXG4gIFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjpcIlVwZGF0ZSBzZXJ2ZXIgbWVtZXJsdWthbiBSZXN0YXJ0IVwiLFxuICBcIlNFVFRJTkdTX1VQREFURURcIjpcIlBlbmdhdHVyYW4gZGlwZXJiYXJ1aSFcIixcbiAgXCJMQU5HVUFHRVNcIjpcIkJhaGFzYVwiLFxuICBcIkxBTkdVQUdFU19URVhUXCI6XCJEaSBzaW5pIEFuZGEgZGFwYXQgbWVuZ3ViYWggYmFoYXNhIGFwbGlrYXNpLlwiLFxuICBcIkxPR0lOX1RPX1hcIjpcIk9wZXJhc2kgaW5pIG1lbmdoYXJ1c2thbiBwZW5nZ3VuYSB1bnR1ayBsb2dpbiBkZW5nYW4gcGFzc3dvcmQgdXRhbWEsIGFrdGlmL3Bvc3RpbmdhbiBrdW5jaS4gU2lsYWhrYW4gbG9naW4gZGFuIGNvYmEgbGFnaS5cIixcbiAgXCJHQUxMRVJZXCI6XCJHYWxlcmlcIixcbiAgXCJUUkFOU0xBVElPTlNcIjpcIktvbnRyaWJ1dG9yIHRlcmplbWFoYW5cIixcbiAgXCJTSEFSRVwiOlwiQmFnaWthblxcblwiLFxuICBcIk1BUktFVFBMQUNFXCI6XCJcIixcbiAgXCJFWENIQU5HRVwiOlwiXCIsXG4gIFwiRFJBRlRTXCI6XCJkcmFmdFwiLFxuICBcIlBPU1RfSVNfVU5EUkFGVFwiOlwiUG9zdGluZyBha2FuIGRpaGFwdXMgZGFyaSBkcmFmdCFcIixcbiAgXCJQT1NUX0lTX0RSQUZUXCI6XCJQb3N0aW5nIGRpdGFtYmFoa2FuIGtlIGRyYWZ0IVwiLFxuICBcIlNXSVBFX0xFRlRcIjpcIkdlc2VyIGtlIGtpcmkgdW50dWsgbWVsaWhhdCBvcHNpXCIsXG4gIFwiTUFOQUdFXCI6XCJNZW5nZWxvbGFcXG5cIixcbiAgXCJJTUFHRV9SRU1PVkVEXCI6XCJHYW1iYXIgZGloYXB1c1wiLFxuICBcIkNPUFlcIjpcImNvcHlcIixcbiAgXCJOT19JTUFHRVwiOlwiQW5kYSBiZWx1bSBtZW5ndW5nZ2FoIGdhbWJhciBhcGFwdW4sIGJlbHVtIVwiLFxuICBcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6XCJUYXJpayBrZSBiYXdhaCB1bnR1ayBtZW55ZWdhcmthblwiLFxuICBcIkVYVEVSTkFMX0FQUFNcIjpcIlxcbiBFeHRlcm5hbCBBcHBzXCIsXG4gIFwiUExVR0lOU1wiOlwiXCIsXG4gIFwiU1VHR0VTVFwiOlwiU2FyYW5cIixcbiAgXCJDT01JTkdfU09PTlwiOlwiXCIsXG4gIFwiQ0hBSU5cIjpcIkNoYWluXFxuXCIsXG4gIFwiQ0hBSU5fVEVYVFwiOlwiRGkgc2luaSBBbmRhIGRhcGF0IG1lbmd1YmFoIGJsb2NrY2hhaW4gYXRhdSBwbGF0Zm9ybSBkZWZhdWx0LlxcbkNoYWluX1RleHRcIixcbiAgXCJDVVJSRU5DWVwiOlwiXCIsXG4gIFwiQ1VSUkVOQ1lfVEVYVFwiOlwiXCIsXG4gIFwiQUJPVVRfMTFcIjpcIlwiLFxuICBcIkZPVU5ERVJcIjpcIlwiLFxuICBcIkFERF9BQ0NPVU5UXCI6XCJcIixcbiAgXCJQTEFURk9STVwiOlwiXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiSE9NRVwiOlwiXCIsXG4gIFwiTE9HSU5cIjpcIklubG9nZ2VuXCIsXG4gIFwiTE9HT1VUXCI6XCJVaXRsb2dnZW5cIixcbiAgXCJQUk9GSUxFXCI6XCJQcm9maWVsXCIsXG4gIFwiRk9MTE9XXCI6XCJWb2xnZW5cIixcbiAgXCJCT09LTUFSS1NcIjpcIkJsYWR3aWp6ZXJzXCIsXG4gIFwiVFJBTlNGRVJcIjpcIk92ZXJkcmFjaHRcIixcbiAgXCJNQVJLRVRcIjpcIk1hcmt0XCIsXG4gIFwiU0VUVElOR1NcIjpcIkluc3RlbGxpbmdlblwiLFxuICBcIkFCT1VUXCI6XCJPdmVyXCIsXG4gIFwiQUJPVVRfMVwiOlwid2FhciBpZWRlcmVlbiBlZW4gYmVsb25pbmcga2FuIHZlcmRpZW5lbiFcIixcbiAgXCJBQk9VVF8yXCI6XCJtZWRlIG1vZ2VsaWprIGdlbWFha3QgZG9vciB7e3BsYXRmb3JtbmFtZX19IHBsYXRmb3JtLiBBcHAgZ2VtYWFrdCBkb29yXCIsXG4gIFwiQUJPVVRfM1wiOlwiZW4gaGV0IGlzIGVlbiBvcGVuLXNvdXJjZSwgY29tbXVuaXR5IGdlZHJldmVuIHByb2plY3QuIEhldCBiaWVkdCBtb2dlbGlqa2hlZGVuIHRvdCBsZXplbiwgcmVhZ2VyZW4sIHN0ZW1tZW4sIGJlcmljaHRlbiBwbGFhdHNlbiwgaW5rb21zdGVuIG92ZXJzY2hyaWp2ZW4sIGV0Yy4gZnVuY3RpZXMgYWFuZ2Vib2RlbiBkb29yIHt7cGxhdGZvcm1uYW1lfX0gYmxvY2tjaGFpbiBhbmQge3tzaXRlbmFtZX19LlwiLFxuICBcIkFCT1VUXzRcIjpcIjEuIERlIGFwcCBoZWVmdCBnZWVuIHRvZWdhbmcgdG90IGZvbmRzZW4gdmFuIGRlIGdlYnJ1aWtlci5cIixcbiAgXCJBQk9VVF81XCI6XCIyLiBEZSBhcHAgYmllZHQgZWVuIGJldmVpbGlnaW5nc21vZGVsIGFhbiBkZSBrYW50IHZhbiBkZSBnZWJydWlrZXIsIG1ldCBwcml2w6lzbGV1dGVscyBkaWUgbG9rYWFsIHdvcmRlbiBvcGdlc2xhZ2VuIGVuIG5vb2l0IG5hYXIgc2VydmVycyB3b3JkZW4gdmVyem9uZGVuLlwiLFxuICBcIkFCT1VUXzZcIjpcIjMuIERlIGFwcCBiaWVkdCBzaW1wZWxlLCBhYW50cmVra2VsaWprZSBnZWJydWlrZXJzb21nZXZpbmdlbiBlbiBlcnZhcmluZ2VuLlwiLFxuICBcIkFCT1VUXzdcIjpcIjQuIERlIGFwcCB2cmFhZ3QgdSBub29pdCBvbSBwZXJzb29ubGlqa2UgaW5mb3JtYXRpZS5cIixcbiAgXCJBQk9VVF84XCI6XCJTdGVtIG9wIGdvb2Qta2FybWEgYWxzIHdpdG5lc3NcIixcbiAgXCJBQk9VVF85XCI6XCJcIixcbiAgXCJBQk9VVF8xMFwiOlwiTWVlciBpbmZvcm1hdGllOlwiLFxuICBcIlJFTU9WRVwiOlwiVmVyd2lqZGVyZW5cIixcbiAgXCJNQVJLRVRfVklFV1wiOlwiTWFya3QgV2VlcmdhdmVcIixcbiAgXCJQUklDRVwiOlwiUHJpanNcIixcbiAgXCJBTU9VTlRcIjpcIkJlZHJhZ1wiLFxuICBcIlRPVEFMXCI6XCJUb3RhYWxcIixcbiAgXCJOT09SREVSU1wiOlwiR2VlbiBvcGVuIG9wZHJhY2h0ZW4gdm9vclwiLFxuICBcIkRBVEVcIjpcIkRhdHVtXCIsXG4gIFwiQlVZXCI6XCJLb3BlblwiLFxuICBcIlNFTExcIjpcIlZlcmtvcGVuXCIsXG4gIFwiT1BFTlwiOlwiXCIsXG4gIFwiSElTVE9SWVwiOlwiR2VzY2hpZWRlbmlzXCIsXG4gIFwiRk9MTE9XX0JBQ0tcIjpcIlRlcnVndm9sZ2VuXCIsXG4gIFwiRk9MTE9XRURcIjpcIkdldm9sZ2RcIixcbiAgXCJVTkZPTExPV1wiOlwiT250dm9sZ2VuXCIsXG4gIFwiRk9MTE9XSU5HXCI6XCJWb2xnZW5kXCIsXG4gIFwiRk9MTE9XRVJTXCI6XCJWb2xnZXJzXCIsXG4gIFwiU0VBUkNIX0ZPTExPV0VSU1wiOlwiWm9layB2b2xnZXJzXCIsXG4gIFwiU0VBUkNIX0ZPTExPV0lOR1wiOlwiWm9layB2b2xnZW5kZW5cIixcbiAgXCJCWVwiOlwiZG9vclwiLFxuICBcIklOXCI6XCJcIixcbiAgXCJNRU5VXCI6XCJcIixcbiAgXCJCT09LTUFSS1wiOlwiQmxhZHdpanplclwiLFxuICBcIlJFQkxPR1wiOlwiSGVyYmxvZ1wiLFxuICBcIlVQVk9URVwiOlwiXCIsXG4gIFwiRE9XTlZPVEVcIjpcIlwiLFxuICBcIlVOVk9URV9ET1dOVk9URURcIjpcIkRvd252b3RlIHdlZ2hhbGVuXCIsXG4gIFwiVU5WT1RFX1VQVk9URURcIjpcIlVwdm90ZSB3ZWdoYWxlblwiLFxuICBcIlJFUExZXCI6XCJSZWFnZWVyXCIsXG4gIFwiRURJVFwiOlwiQWFucGFzc2VuXCIsXG4gIFwiUE9TVF8xXCI6XCJTd2lwZSBuYWFyIGxpbmtzIG9wIGVlbiByZWFjdGllIG9tIG9wdGllcyB0ZSB6aWVuXCIsXG4gIFwiUE9TVF8yXCI6XCJUaWsgb3AgZWVuIHJlYWN0aWUgb20gc3ViLXJlYWN0aWUgdGUgemllblwiLFxuICBcIk9QVElPTlNcIjpcIk9wdGllc1wiLFxuICBcIlJFU1RFRU1FRF9CWVwiOlwiSGVyc3RlZW1lZCBkb29yXCIsXG4gIFwiTk9USElOR19IRVJFXCI6XCJOb2cgbmlldHMgdGUgemllbiBoaWVyLi4uXCIsXG4gIFwiQkFMQU5DRVNcIjpcIlRlZ29lZGVuXCIsXG4gIFwiUFJPRklMRV8xXCI6XCJ7e3BsYXRmb3JtbmFtZX19LCBydWlsYmFyZSB2YWx1dGEgZGllIGFsdGlqZCBvdmVyZ2VtYWFrdCBrYW4gd29yZGVuLiB7e3BsYXRmb3JtbmFtZX19IGthbiB3b3JkZW4gb21nZXZvcm1kIG5hYXIge3twbGF0Zm9ybXBvd2VyfX0gaW4gZWVuIHByb2NlcyBnZW5hYW1kIHBvd2VyaW5nIHVwLlwiLFxuICBcIlBST0ZJTEVfMlwiOlwie3twbGF0Zm9ybXBvd2VyfX0sIGludmxvZWRzdmFsdXRhIGRpZSBtZWVyIGtyYWNodCB2ZXJkaWVuZW4gZG9vciBoZXQgb3AgbGFuZ2UgdGVybWlqbiB0ZSBiZXdhcmVuIGVuIGRvb3IgaGV0IHN0ZW1tZW4gb3AgdmVyaGFsZW4uIEhvZSBtZWVyIHUgdmFzdGhvdWR0LCBob2UgbWVlciBpbnZsb2VkIHUgaGVlZnQgb3AgYW5kZXJtYW5zIG9wYnJlbmdzdGVuLlwiLFxuICBcIlBST0ZJTEVfM1wiOlwiRWVuaGVkZW4gemlqbiBvbmdldmVlciB7e3BsYXRmb3Jtc3VuaXR9fSB7e3BsYXRmb3JtbmFtZX19IHdhYXJkLlwiLFxuICBcIkVTVElNQVRFRF9WQUxVRVwiOlwiR2VzY2hhdHRlIHdhYXJkZVwiLFxuICBcIlBST0ZJTEVfNFwiOlwiRGUgZ2VzY2hhdHRlIHdhYXJkZSB3b3JkdCBnZWJhc2VlcmQgb3AgZWVuIGdlbWlkZGVsZGUgdmFuIHdhYXJkZSB2YW4ge3twbGF0Zm9ybW5hbWV9fSBvdmVyIDcgZGFnZW4uXCIsXG4gIFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOlwiVHJhbnNhY3RpZWdlc2NoaWVkZW5pc1wiLFxuICBcIlBPU1RJTkdcIjpcIlBsYWF0c2VuXCIsXG4gIFwiUFJPRklMRV81XCI6XCJEZSBwb3N0aW5nIHNsZXV0ZWwgd29yZHQgZ2VicnVpa3Qgdm9vciBoZXQgcGxhYXRzZW4gdmFuIHBvc3RzIGVuIHZvb3IgaGV0IHN0ZW1tZW4gb3AgcG9zdHMuIERlemUgem91IGFuZGVycyBtb2V0ZW4gemlqbiBkYW4gZGUgYWN0aWV2ZS0gZW4gZWlnZW5uYWFyc3NsZXV0ZWxzLlwiLFxuICBcIk9XTkVSXCI6XCJFaWdlbmFhclwiLFxuICBcIlBST0ZJTEVfNlwiOlwiRGUgZWlnZW5hYXJzc2xldXRlbCBpcyBkZSBob29mZHNsZXV0ZWwgdm9vciBoZXQgYWNjb3VudCBlbiBpcyBub2RpZyBvbSBhbmRlcmUgc2xldXRlbHMgYWFuIHRlIHBhc3Nlbi4gRGUgcHJpdsOpc2xldXRlbCBvZiB3YWNodHdvb3JkIHZvb3IgZGUgZWlnZW5hYXJzc2xldXRlbCB6b3Ugem8gdmVlbCBtb2dlbGlqayBvZmZsaW5lIGdlbGF0ZW4gbW9ldGVuIHdvcmRlbi5cIixcbiAgXCJBQ1RJVkVcIjpcIkFjdGllZlwiLFxuICBcIlBST0ZJTEVfN1wiOlwiRGUgYWN0aWV2ZSBzbGV1dGVsIHdvcmR0IGdlYnJ1aWt0IG9tIHRyYW5zYWN0aWVzIGVuIGJlc3RlbGxpbmdlbiB0ZSBkb2VuIGluIGRlIGludGVybmUgbWFya3QuXCIsXG4gIFwiTUVNT1wiOlwiXCIsXG4gIFwiUFJPRklMRV84XCI6XCJEZSBtZW1vIHNsZXV0ZWwgd29yZHQgZ2VicnVpa3Qgdm9vciBoZXQgbWFrZW4gZW4gbGV6ZW4gdmFuIG1lbW8ncy5cIixcbiAgXCJCTE9HXCI6XCJcIixcbiAgXCJQT1NUU1wiOlwiXCIsXG4gIFwiUkVQTElFU1wiOlwiUmVhY3RpZXNcIixcbiAgXCJXQUxMRVRcIjpcIlBvcnRlbW9ubmVlXCIsXG4gIFwiVEFHXCI6XCJcIixcbiAgXCJVU0VSXCI6XCJHZWJydWlrZXJcIixcbiAgXCJDTE9TRVwiOlwiU2x1aXRlblwiLFxuICBcIlRPXCI6XCJOYWFyXCIsXG4gIFwiQVNTRVRcIjpcIkFjdGl2dW1cIixcbiAgXCJTRU5EXCI6XCJWZXJ6ZW5kZW5cIixcbiAgXCJTRUNVUklUWVwiOlwiQmV2ZWlsaWdpbmdcIixcbiAgXCJBVkFJTEFCTEVcIjpcIkJlc2NoaWtiYWFyXCIsXG4gIFwiUFVCTElDX01FTU9cIjpcIlB1YmxpZWtlbGlqa2UgbWVtb1wiLFxuICBcIlRPX0RFU0NcIjpcIkdlYnJ1aWtlciBiaWp2LiBnb29kLWthcm1hXCIsXG4gIFwiUElOX0NPREVcIjpcIlBpbmNvZGVcIixcbiAgXCJQSU5fVEVYVFwiOlwiUElOIGNvZGUgaGVscHQgdSB1dyBhcHAgZW4gZ2VnZXZlbnMgdGUgYmVzY2hlcm1lbi4gPGJyLz48YnIvPjxiPk9wbWVya2luZzo8L2I+IEVlbm1hYWwgaW5nZXN0ZWxkIGhlZWZ0IHUgbWF4aW1hYWwgNCBrYW5zZW4sIHdhbm5lZXIgdSBkZSBQSU4gYmVudCB2ZXJnZXRlbiBvZiB1IGhldCA0IGtlZXIgdmVya2VlcmQgaGVlZnQgaW5nZXZvZXJkIHphbCBkZSBhcHAgdXcgZ2VicnVpa2Vyc2dlZ2V2ZW5zIHZlcndpamRlcmVuLiBVIGt1bnQgZGFuIG9wbmlldXcgaW5sb2dnZW4gb20gZGUgYXBwIHdlZXIgdGUga3VubmVuIGdlYnJ1aWtlbi5cIixcbiAgXCJOT1RJRklDQVRJT05TXCI6XCJOb3RpZmljYXRpZXNcIixcbiAgXCJWT1RFX1RFWFRcIjpcIlUga3Jpamd0IGVlbiBub3RpZmljYXRpZSB3YW5uZWVyIGllbWFuZCBvcCB1dyBjb250ZW50IHN0ZW10Ljxici8+IDxiPk9wbWVya2luZzo8L2I+IE5vdGlmaWNhdGllcyBpbmNsdXNpZWYgendhYXJ0ZSB2YW4gdm90ZSBlbiBlZW4gYWxlcnQuICh6aWogaGV0IGVlbiB1cC12b3RlLCBkb3duLXZvdGUsIHVuLXZvdGUpLlwiLFxuICBcIlZPVEVcIjpcIlwiLFxuICBcIkNPTU1FTlRfVEVYVFwiOlwiVSBrcmlqZ3QgZWVuIG5vdGlmaWNhdGllIHdhbm5lZXIgaWVtYW5kIG9wIHUgcmVhZ2VlcnQuIDxici8+IDxiPk9wbWVya2luZzo8L2I+IE5vdGlmaWNhdGllcyB3YW5uZWVyIGllbWFuZCB6aWpuIGNvbW1lbnQgPGI+YWFucGFzdDwvYj4gd29yZGVuIG9vayB3ZWVyZ2V2ZW4uXCIsXG4gIFwiQ09NTUVOVFwiOlwiQ29tbWVudGFhclwiLFxuICBcIkZPTExPV19URVhUXCI6XCJVIGtyaWpndCBlZW4gbm90aWZpY2F0aWUgd2FubmVlciBpZW1hbmQgdSB2b2xndCBvZiBzdG9wdCBtZXQgdm9sZ2VuIVwiLFxuICBcIk1FTlRJT05TXCI6XCJWZXJub2VtaW5nZW5cIixcbiAgXCJNRU5USU9OU19URVhUXCI6XCJVIGtyaWpndCBlZW4gbm90aWZpY2F0aWUgd2FubmVlciBpZW1hbmQgdSBub2VtdCBpbiB6aWpuIG9mIGhhYXIgcG9zdC9yZWFjdGllIVwiLFxuICBcIlJFU1RFRU1cIjpcIkhlcnN0ZWVtXCIsXG4gIFwiUkVTVEVFTV9URVhUXCI6XCJVIGtyaWpndCBlZW4gbm90aWZpY2F0aWUgd2FubmVlciBpZW1hbmQgdXcgcG9zdCBoZXJzdGVlbWVkIVwiLFxuICBcIkNPTkZJR1VSQVRJT05TXCI6XCJDb25maWd1cmF0aWVzXCIsXG4gIFwiVk9USU5HXCI6XCJTdGVtbWVuXCIsXG4gIFwiVk9USU5HX1RFWFRcIjpcIlN0ZW16d2FhcnRlIG9mIHBlcmNlbnRhZ2VzIGhlYmJlbiBpbnZsb2VkIG9wIFN0ZW1rcmFjaHQgaW4gZGUgYXBwLCB6b2RhdCB1IHV3IHN0ZW1vcGJyZW5nc3RlbiBrdW4gcmVndWxlcmVuLiA8YnIvPjxici8+PGI+T3BtZXJraW5nOjwvYj4gRGl0IHphbCB1dyBzdGVta3JhY2h0L3BlcmNlbnRhZ2Ugdm9vciBoZXQgbmFhciBiZW5lZGVuIHN0ZW1tZW4gb29rIGFhbnRhc3RlbiBlbiBoZXQgaXMgb3ZlcmFsIGluIGRlIGFwcFwiLFxuICBcIlNFUlZFUlwiOlwiXCIsXG4gIFwiU0VSVkVSX1RFWFRcIjpcIkFhbmdlcmFkZW5cIixcbiAgXCJTQVZFX0NIQU5HRVNcIjpcIldpanppZ2luZ2VuIG9wc2xhYW5cIixcbiAgXCJWT1RFUlNfSU5GT1wiOlwiU3RlbW1lcnMgaW5mb3JtYXRpZVwiLFxuICBcIldFTENPTUVfQkFDS1wiOlwiV2Vsa29tIHRlcnVnIVwiLFxuICBcIkxPR0lOXzFcIjpcIkxvZyBpbiBtZXQgdXcgZ2VicnVpa2Vyc25hYW0gZW4gd2FjaHR3b29yZCBvbSB2ZXJkZXIgdGUgZ2Fhbi5cIixcbiAgXCJMT0dJTl8yXCI6XCJQb3N0aW5nIHNsZXV0ZWwgd29yZHQgZ2VicnVpa3Qgdm9vciBoZXQgcGxhYXRzZW4gdmFuIGJlcmljaHRlbiwgY29tbWVudGFhciwgc3RlbW1lbiBlbiBoZXQgdm9sZ2VuIHZhbiBnZWJydWlrZXJzLlwiLFxuICBcIkxPR0lOXzNcIjpcIkFjdGlldmUgc2xldXRlbCB3b3JkdCBnZWJydWlrdCB2b29yIG92ZXJtYWtlbiBlbiBwcm9maWVsZm90byBhYW5wYXNzaW5nZW4uXCIsXG4gIFwiTE9HSU5fNFwiOlwiR2VicnVpa2Vyc2dlZ2V2ZW5zIHdvcmRlbiBsb2thYWwgb3AgdXcgYXBwYXJhYXQgb3BnZXNsYWdlbi4gQmlqIGhldCB1aXRsb2dnZW4gd29yZGVuIGRlIGdlZ2V2ZW5zIHZlcndpamRlcmQhXCIsXG4gIFwiRE9OVF9IQVZFXCI6XCJIZWVmdCB1IGdlZW4gYWNjb3VudD9cIixcbiAgXCJTSUdOX1VQX05PV1wiOlwiTWVsZCBqZSBudSBhYW5cIixcbiAgXCJDQU5DRUxcIjpcIkFubnVsZXJlblwiLFxuICBcIkFEVkFOQ0VEXCI6XCJHZWF2YW5jZWVyZFwiLFxuICBcIkFDVElWRV9QUklLRVlcIjpcIkFjdGlldmUgcHJpbWFpcmUgc2xldXRlbFwiLFxuICBcIlBPU1RJTkdfUFJJS0VZXCI6XCJQb3N0aW5nIHByaXbDqSBzbGV1dGVsXCIsXG4gIFwiTUFTVEVSX1BBU1NcIjpcIkJlbGFuZ3JpamtzdGUgd2FjaHR3b29yZFwiLFxuICBcIlVTRVJOQU1FXCI6XCJHZWJydWlrZXJzbmFhbVwiLFxuICBcIkNBUkRfVklFV1wiOlwiS2FhcnQgd2VlcmdhdmVcIixcbiAgXCJDT01QQUNUX1ZJRVdcIjpcIkNvbXBhY3RlIHdlZXJnYXZlXCIsXG4gIFwiU0VBUkNIXCI6XCJab2VrZW5cIixcbiAgXCJTVUJNSVRfQV9TVE9SWVwiOlwiUGxhYXRzIGVlbiB2ZXJoYWFsXCIsXG4gIFwiUkVQTFlUT1wiOlwiUmVhZ2VlciBvcFwiLFxuICBcIlBPU1RcIjpcIlwiLFxuICBcIlBSRVZJRVdcIjpcIlZvb3JiZWVsZFwiLFxuICBcIkRFRkFVTFRcIjpcIlN0YW5kYWFyZCA1MCUgLyA1MCVcIixcbiAgXCJQT1dFUlVQXCI6XCJcIixcbiAgXCJERUNMSU5FX1BBWU9VVFwiOlwiVWl0YmV0YWxpbmcgYWZ3aWp6ZW5cIixcbiAgXCJTQVZFX0ZPUl9MQVRFUlwiOlwiT1BTTEFBTiBWT09SIExBVEVSXCIsXG4gIFwiQ0xFQVJcIjpcIkxFRUdNQUtFTlwiLFxuICBcIlBPU1RfQ09OVEVOVFwiOlwiUGxhYXRzIGJlcmljaHRcIixcbiAgXCJDT01NRU5UX0NPTlRFTlRcIjpcIlJlYWdlZXIgb3AgYmVyaWNodFwiLFxuICBcIlRJVExFXCI6XCJUaXRlbFwiLFxuICBcIlRBR1NcIjpcIkxhYmVsc1wiLFxuICBcIk5PVF9NQVRDSFwiOlwiTUFUQ0hFTiBOSUVUXCIsXG4gIFwiQ09ORklSTV9QSU5cIjpcIkJldmVzdGlnIFBJTlwiLFxuICBcIklOQ09SUkVDVFwiOlwiXCIsXG4gIFwiT1BFTklOR19QT1NUXCI6XCJCZXJpY2h0IG9wZW5lblwiLFxuICBcIlNFVF9QSU5cIjpcIkluc3RlbGxlbiBQSU5cIixcbiAgXCJFTlRFUl9QSU5cIjpcIkludm9lcmVuIFBJTlwiLFxuICBcIkFSRV9ZT1VfU1VSRVwiOlwiV2VldCB1IGhldCB6ZWtlcj9cIixcbiAgXCJSRUJMT0dfVEVYVFwiOlwiSGVyc3RlZW1lbiBpcyBkZWZpbml0aWVmLCB3aWx0IHUgZG9vcmdhYW4/XCIsXG4gIFwiQlJPQURDQVNUX0VSUk9SXCI6XCJWZXJ6ZW5kZm91dCwgcHJvYmVlciBvcG5pZXV3IVwiLFxuICBcIlNVQ0NFU1NcIjpcIlN1Y2Nlc3ZvbFwiLFxuICBcIlJFQkxPR0dFRF9QT1NUXCI6XCJCZXJpY2h0IGdlcmVibG9nZCFcIixcbiAgXCJMT0dJTl9GQUlMXCI6XCJJbmxvZ2dlbiBtaXNsdWt0ISBDb250cm9sZWVyIG9mIHUgaGVlZnQgZ2Vwcm9iZWVyZCBpbiB0ZSBsb2dnZW4gbWV0IHV3IGhvb2Zkd2FjaHR3b29yZCBvZiBQb3N0aW5nIHByaXbDqXNsZXV0ZWwgYWxzIHUgdm9vciBnZWF2YW5jZWVyZGUgbW9kdXMgaGVlZnQgZ2Vrb3plbi5cIixcbiAgXCJMT0dJTl9GQUlMX0FcIjpcIklubG9nZ2VuIG1pc2x1a3QhIENvbnRyb2xlZXIgb2YgdSBoZWVmdCBnZXByb2JlZXJkIGluIHRlIGxvZ2dlbiBtZXQgdXcgaG9vZmR3YWNodHdvb3JkIG9mIHByaXbDqXNsZXV0ZWwgYWxzIHUgdm9vciBnZWF2YW5jZWVyZGUgbW9kdXMgaGVlZnQgZ2Vrb3plbi5cIixcbiAgXCJXQVJOSU5HXCI6XCJXYWFyc2NodXdpbmdcIixcbiAgXCJWT1RFX0ZPUl9XSVRORVNTXCI6XCJTdGVtbWVuIGFscyBnZXR1aWdlXCIsXG4gIFwiVk9URURfRk9SX1dJVE5FU1NcIjpcIkdlc3RlbWQgdm9vciBnZXR1aWdlXCIsXG4gIFwiQUdPXCI6XCJnZWxlZGVuXCIsXG4gIFwiRlJPTV9OT1dcIjpcInZhbmFmIG51XCIsXG4gIFwiU0VDU1wiOlwic2Vjb25kZW5cIixcbiAgXCJBX01JTlwiOlwiZWVuIG1pbnV1dFwiLFxuICBcIk1JTlNcIjpcIm1pbnV0ZW5cIixcbiAgXCJBTl9IT1VSXCI6XCJlZW4gdXVyXCIsXG4gIFwiSE9VUlNcIjpcInVyZW5cIixcbiAgXCJBX0RBWVwiOlwiZWVuIGRhZ1wiLFxuICBcIkRBWVNcIjpcImRhZ2VuXCIsXG4gIFwiQV9NT05USFwiOlwiZWVuIG1hYW5kXCIsXG4gIFwiTU9OVEhTXCI6XCJtYWFuZGVuXCIsXG4gIFwiQV9ZRUFSXCI6XCJlZW4gamFhclwiLFxuICBcIllFQVJTXCI6XCJqYXJlblwiLFxuICBcIk1JTl9SRUFEXCI6XCJtaW4uIGxlZXN0aWpkXCIsXG4gIFwiRE9XTlZPVEVfRkxBR1wiOlwiT21sYWFnIHN0ZW1tZW4gb2YgYWFuZ2V2ZW5cIixcbiAgXCJDQVBUVVJFX1BJQ1RVUkVcIjpcIk5lZW0gZm90b1wiLFxuICBcIlNFTEVDVF9QSUNUVVJFXCI6XCJTZWxlY3RlZXIgZm90b1wiLFxuICBcIlNFVF9DVVNUT01fVVJMXCI6XCJTdGVsIGFhbmdlcGFzdCBVUkwgaW5cIixcbiAgXCJJTlNFUlRfUElDVFVSRVwiOlwiRm90byBpbnZvZWdlblwiLFxuICBcIkVSUk9SXCI6XCJGb3V0XCIsXG4gIFwiVVBMT0FEX0VSUk9SXCI6XCJVcGxvYWQgZm91dFwiLFxuICBcIkNBTUVSQV9DQU5DRUxMRURcIjpcIkNhbWVyYSBnZWFubnVsZWVyZFwiLFxuICBcIlNFVF9VUkxcIjpcIlN0ZWwgVVJMIGluXCIsXG4gIFwiRElSRUNUX0xJTktfUElDVFVSRVwiOlwiRGlyZWN0ZSB3ZWIgbGluayB2b29yIGRlIGZvdG9cIixcbiAgXCJDT01NRU5UX1NVQk1JVFRFRFwiOlwiQ29tbWVudGFhciBpcyBpbmdlZGllbmQhXCIsXG4gIFwiREVMRVRFX0NPTU1FTlRcIjpcIkhldCB2ZXJ3aWpkZXJlbiB2YW4gY29tbWVudHMgaXMgZGVmaW5pdGllZi4uLlwiLFxuICBcIkRFTEVURURfQ09NTUVOVFwiOlwiVmVyd2lqZGVyZCBjb21tZW50YWFyXCIsXG4gIFwiVVBMT0FESU5HX1BJQ1RVUkVcIjpcIkZvdG8gaXMgYWFuIGhldCB1cGxvYWRlblwiLFxuICBcIlVQTE9BRF9DT01QTEVURURcIjpcIlVwbG9hZCBnZXNsYWFnZFwiLFxuICBcIlVQTE9BRF9GQUlMRURcIjpcIlVwbG9hZCBtaXNsdWt0XCIsXG4gIFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6XCJIZXQgd2FjaHR3b29yZCBvZiBnZWJydWlrZXJzbmFhbSBpcyBmb3V0XCIsXG4gIFwiSU5GT1wiOlwiXCIsXG4gIFwiUVJfVEVYVFwiOlwiUGxhYXRzIGVlbiBRUiBjb2RlIGluIGhldCBzY2FuZ2ViaWVkXCIsXG4gIFwiQkFMQU5DRV9URVhUXCI6XCJDb250cm9sZWVyIG9mIHUgZ2Vub2VnIGZvbmRzZW4gaGVlZnQgdm9vciBkZSB0cmFuc2FjdGllIVwiLFxuICBcIk5PTkVYSVNUX1VTRVJcIjpcIkRlIGdlYnJ1aWtlciBuYWFyIHdpZSB1IHByb2JlZXJ0IG92ZXIgdGUgbWFrZW4sIGJlc3RhYXQgbmlldCFcIixcbiAgXCJUUkFOU0ZFUl9URVhUXCI6XCJXZWV0IHUgemVrZXIgdGUgd2lsIG92ZXJtYWtlbj9cIixcbiAgXCJDT05GSVJNQVRJT05cIjpcIkJldmVzdGlnaW5nXCIsXG4gIFwiVFhfQlJPQURDQVNURURcIjpcIlRyYW5zYWN0aWUgaXMgdmVyc3R1dXJkXCIsXG4gIFwiRkVFRFwiOlwiXCIsXG4gIFwiVFJFTkRJTkdcIjpcIlwiLFxuICBcIkhPVFwiOlwiSGVldFwiLFxuICBcIk5FV1wiOlwiTmlldXdcIixcbiAgXCJQUk9NT1RFRFwiOlwiR2Vwcm9tb290XCIsXG4gIFwiVk9URVNcIjpcIlN0ZW1tZW5cIixcbiAgXCJQQVlPVVRcIjpcIlVpdGJldGFsaW5nXCIsXG4gIFwiQ09NTUVOVFNcIjpcIkNvbW1lbnRhYXJcIixcbiAgXCJUUkVORElOR18zMFwiOlwiVHJlbmRpbmcgdm9vciAzMCBkYWdlblwiLFxuICBcIlNPUlRfUE9TVF9CWVwiOlwiU29ydGVlciBwb3N0cyBvcDpcIixcbiAgXCJQQVlPVVRfQ1lDTEVcIjpcIlVpdGJldGFsaW5nc2N5Y2x1c1wiLFxuICBcIlBPVEVOVElBTF9QQVlPVVRcIjpcIlBvdGVudGnDq2xlIHVpdGJldGFsaW5nXCIsXG4gIFwiUEFTVF9QQVlPVVRcIjpcIlZlcmxlZGVuIHVpdGJldGFsaW5nXCIsXG4gIFwiQVVUSE9SX1BBWU9VVFwiOlwiVWl0YmV0YWxpbmcgYXV0ZXVyXCIsXG4gIFwiQ1VSQVRJT05fUEFZT1VUXCI6XCJVaXRiZXRhbGluZyB2b29yIHN0ZW1tZW5cIixcbiAgXCJQT1NUX1NVQk1JVFRFRFwiOlwiUG9zdCBpcyBkb29yZ2V2b2VyZCFcIixcbiAgXCJQT1NUX0xBVEVSXCI6XCJQbGFhdHNlbiB2b29yIGxhdGVyIVwiLFxuICBcIlNBVkVEXCI6XCJPcGdlc2xhZ2VuXCIsXG4gIFwiQ0xFQVJFRFwiOlwiTGVlZ2dlbWFha3RcIixcbiAgXCJGTEFHR0lOR19URVhUXCI6XCJFZW4gcG9zdCBmbGFnZ2VuIG9mIG5hYXIgYmVuZWRlbiBzdGVtbWVuIGthbiBkZSBvcGJyZW5nc3RlbiB2YW4gZGUgcG9zdCB3ZWdoYWxlbiBlbiBoZXQgYmVyaWNodCBtaW5kZXIgemljaHRiYWFyIG1ha2VuLjxicj48YnI+RGUgZmxhZyBtYWcgYWxsZWVuIGluIGRlIHZvbGdlbmRlIGdldmFsbGVuIGdlYnJ1aWt0IHdvcmRlbjogPHVsPjxsaT5GcmF1ZGUgb3IgUGxhZ2lhYXQ8L2xpPjxsaT5IYWF0c3ByYWFrIG9mIFRyb2xsaW5nPC9saT48bGk+TWV0IGludGVudGllIGluIHZlcmtlZXJkZSBjYXRlZ29yaWUgZ2VwbGFhdHN0IG9mIFNwYW08L2xpPjwvdWw+XCIsXG4gIFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6XCJMaW1pZXQgdmVyem9layBiZXJlaWt0LiBCZWtpamsgb29rIGFuZGVyZSB0cmVuZHMvdGFncyFcIixcbiAgXCJQT1NUX0lTX1VOQk9PS01BUktcIjpcIlBvc3QgaXMgdmFuIGJsYWR3aWp6ZXJzIHZlcndpamRlcmQhXCIsXG4gIFwiUE9TVF9JU19CT09LTUFSS1wiOlwiUG9zdCBpcyBhYW4gYmxhZHdpanplcnMgdG9lZ2V2b2VnZCFcIixcbiAgXCJSRVNFVFwiOlwiXCIsXG4gIFwiTU9ESUZZX1BJQ1RVUkVcIjpcIlBhcyBwcm9maWVsZm90byBhYW5cIixcbiAgXCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOlwiUGFzIG9tc2xhZ2ZvdG8gYWFuXCIsXG4gIFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6XCJHZWxpZXZlIGVlbiBhY3RpZXZlIHNsZXV0ZWwgYWFuIHRlIGxldmVyZW4gd2FubmVlciB1IGtpZXN0IHZvb3IgZ2VhdmFuY2VlcmRlIGlubG9nbW9kdXMhXCIsXG4gIFwiUkVTRVRfUElDVFVSRV9URVhUXCI6XCJEaXQgemFsIGRlIHByb2ZpZWxmb3RvIHZhbiBkZSBnZWJydWlrZXIgcmVzZXR0ZW5cIixcbiAgXCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjpcIkRpdCB6YWwgZGUgb21zbGFnZm90byB2YW4gZGUgZ2VicnVpa2VyIHJlc2V0dGVuXCIsXG4gIFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjpcIlNlcnZlciB1cGRhdGUgdmVyZWlzdCByZXN0YXJ0IVwiLFxuICBcIlNFVFRJTkdTX1VQREFURURcIjpcIkluc3RlbGxpbmdlbiB6aWpuIHZlcndlcmt0IVwiLFxuICBcIkxBTkdVQUdFU1wiOlwiVGFsZW5cIixcbiAgXCJMQU5HVUFHRVNfVEVYVFwiOlwiSGllciBrdW50IHUgZGUgdGFhbCB2YW4gZGUgYXBwIHZlcmFuZGVyZW4uXCIsXG4gIFwiTE9HSU5fVE9fWFwiOlwiT20gZGl0IHRlIGRvZW4gZGllbnQgdSBpbiB0ZSBsb2dnZW4gbWV0IHV3IGhvb2Zkd2FjaHR3b29yZCwgYWN0aWV2ZS9wb3N0aW5nIGtleS4gTG9nIGFsc3R1YmxpZWZ0IGluIGVuIHByb2JlZXIgb3BuaWV1dy5cIixcbiAgXCJHQUxMRVJZXCI6XCJHYWxsZXJpalwiLFxuICBcIlRSQU5TTEFUSU9OU1wiOlwiVmVydGFsaW5nc2JpamRyYWdlcnNcIixcbiAgXCJTSEFSRVwiOlwiRGVsZW5cIixcbiAgXCJNQVJLRVRQTEFDRVwiOlwiTWFya3RwbGFhdHNcIixcbiAgXCJFWENIQU5HRVwiOlwiQmV1cnNcIixcbiAgXCJEUkFGVFNcIjpcIkNvbmNlcHRlblwiLFxuICBcIlBPU1RfSVNfVU5EUkFGVFwiOlwiUG9zdCBpcyB1aXQgY29uY2VwdGVuIHZlcndpamRlcmQhXCIsXG4gIFwiUE9TVF9JU19EUkFGVFwiOlwiUG9zdCB0b2VnZXZvZWdkIGFhbiBjb25jZXB0ZW4hXCIsXG4gIFwiU1dJUEVfTEVGVFwiOlwiU3dpcGUgbmFhciBsaW5rcyB2b29yIG9wdGllc1wiLFxuICBcIk1BTkFHRVwiOlwiQmVoZWVyXCIsXG4gIFwiSU1BR0VfUkVNT1ZFRFwiOlwiQWZiZWVsZGluZyBpcyB2ZXJ3aWpkZXJkXCIsXG4gIFwiQ09QWVwiOlwiS29wacOrcmVuXCIsXG4gIFwiTk9fSU1BR0VcIjpcIkplIGhlYnQgbm9nIGdlZW4gYWZiZWVsZGluZyBnZXVwbG9hZC5cIixcbiAgXCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOlwiVHJlayBuYWFyIGJlbmVkZW4gb3AgdGUgdmVydmVyc2VuXCIsXG4gIFwiRVhURVJOQUxfQVBQU1wiOlwiRXh0ZXJuZSBhcHBsaWNhdGllc1wiLFxuICBcIlBMVUdJTlNcIjpcIlwiLFxuICBcIlNVR0dFU1RcIjpcIlN1Z2dlcmVlclwiLFxuICBcIkNPTUlOR19TT09OXCI6XCJCaW5uZW5rb3J0IGJlc2NoaWtiYWFyXCIsXG4gIFwiQ0hBSU5cIjpcIktldHRpbmdcIixcbiAgXCJDSEFJTl9URVhUXCI6XCJIaWVyIGt1bnQgdSB2ZXJhbmRlcmVuIG5hYXIgYmxvY2tjaGFpbiBvZiBzdGFuZGFhcmQgcGxhdGZvcm1cIixcbiAgXCJDVVJSRU5DWVwiOlwiXCIsXG4gIFwiQ1VSUkVOQ1lfVEVYVFwiOlwiXCIsXG4gIFwiQUJPVVRfMTFcIjpcIlwiLFxuICBcIkZPVU5ERVJcIjpcIlwiLFxuICBcIkFERF9BQ0NPVU5UXCI6XCJcIixcbiAgXCJQTEFURk9STVwiOlwiXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiSE9NRVwiOlwiU3Ryb25hIGfFgsOzd25hXCIsXG4gIFwiTE9HSU5cIjpcIlphbG9ndWpcIixcbiAgXCJMT0dPVVRcIjpcIld5bG9ndWpcIixcbiAgXCJQUk9GSUxFXCI6XCJQcm9maWxcIixcbiAgXCJGT0xMT1dcIjpcIk9ic2Vyd3VqXCIsXG4gIFwiQk9PS01BUktTXCI6XCJaYWvFgmFka2lcIixcbiAgXCJUUkFOU0ZFUlwiOlwiUHJ6ZWxld1wiLFxuICBcIk1BUktFVFwiOlwiR2llxYJkYVwiLFxuICBcIlNFVFRJTkdTXCI6XCJVc3Rhd2llbmlhXCIsXG4gIFwiQUJPVVRcIjpcIk8gTmFzXCIsXG4gIFwiQUJPVVRfMVwiOlwiZ2R6aWUga2HFvGR5IG1vxbxlIHpkb2J5d2HEhyB3eW5hZ3JvZHplbmllIHphIHN3b2plIHdwaXN5IVwiLFxuICBcIkFCT1VUXzJcIjpcImZ1bmtjam9udWplIHcgb3BhcmNpdSBvIHBhdGZvcm3EmSB7e3BsYXRmb3JtbmFtZX19LiBBcGxpa2FjamEgamVzdCBzdHdvcnpvbmEgcHJ6ZXpcIixcbiAgXCJBQk9VVF8zXCI6XCJpIGplc3Qgb25hIG90d2FydHltIGkgcHJvd2Fkem9ueW0gcHJ6ZXogc3BvxYJlY3pub8WbxIcgcHJvamVrdGVtLiBPZmVydWplIGRvc3TEmXAgZG8gY3p5dGFuaWEsIGtvbWVudG93YW5pYSwgb2RkYXdhbmlhIGfFgm9zdSBuYSB0cmXFm2NpIG9yYXogdWRvc3TEmXBuaWFuaWEgd3Bpc8OzdywgYSB0YWvFvGUgbmEgemFyesSFZHphbmllIHphcm9ia2FtaSBvcmF6IGlubnltaSBkb3N0xJlwbnltaSBvcGNqYW1pIG9mZXJvd2FueW1pIHByemV6IMWCYcWEY3VjaCBibG9rw7N3IHt7cGxhdGZvcm1uYW1lfX0gaSB7e3NpdGVuYW1lfX0uXCIsXG4gIFwiQUJPVVRfNFwiOlwiQXBsaWthY2phIG5pZ2R5IG5pZSBtYSBkb3N0xJlwdSBpIG5pZSBwcnpldHJ6eW11amUgxZtyb2Rrw7N3IGZpbmFuc293eWNoIHXFvHl0a293bmlrYS5cIixcbiAgXCJBQk9VVF81XCI6XCJBcGxpa2FjamEgb2ZlcnVqZSBtb2RlbCBiZXpwaWVjemXFhHN0d2EgcG8gc3Ryb25pZSBrbGllbnRhLCBnZHppZSBrbHVjemUgcHJ5d2F0bmUgc8SFIHByemVjaG93eXdhbmUgbG9rYWxuaWUgaSBuaWdkeSBuaWUgc8SFIHByemVzecWCYW5lIG5hIGpha2lla29sd2llayBzZXJ3ZXJ5LlwiLFxuICBcIkFCT1VUXzZcIjpcIkFwbGlrYWNqYSBvZmVydWplIMWCYXR3eSBpIHByenlqZW1ueSB3IG9ic8WCdWR6ZSBpbnRlcmZlanMuXCIsXG4gIFwiQUJPVVRfN1wiOlwiQXBsaWthY2phIG5pZ2R5IG5pZSB3eW1hZ2EgcG9kYW5pYSBkYW55Y2ggb3NvYm93eWNoIG9kIHN3b2ljaCB1xbx5dGtvd25pa8Ozdy5cIixcbiAgXCJBQk9VVF84XCI6XCJaYWfFgm9zdWogbmEgZ29vZC1rYXJtYSBuYSDFm3dpYWRrYVwiLFxuICBcIkFCT1VUXzlcIjpcIktvbnRha3QvT3BpbmllXCIsXG4gIFwiQUJPVVRfMTBcIjpcIldpxJljZWogaW5mb3JtYWNqaTpcIixcbiAgXCJSRU1PVkVcIjpcIlVzdcWEXCIsXG4gIFwiTUFSS0VUX1ZJRVdcIjpcIldpZG9rIG5hIGdpZcWCZMSZXCIsXG4gIFwiUFJJQ0VcIjpcIkNlbmFcIixcbiAgXCJBTU9VTlRcIjpcIklsb8WbxIdcIixcbiAgXCJUT1RBTFwiOlwiU3VtYVwiLFxuICBcIk5PT1JERVJTXCI6XCJCcmFrIHByemVrYXrDs3cgdyB0b2t1IGRsYVwiLFxuICBcIkRBVEVcIjpcIkRhdGFcIixcbiAgXCJCVVlcIjpcIkt1cFwiLFxuICBcIlNFTExcIjpcIlNwcnplZGFqXCIsXG4gIFwiT1BFTlwiOlwiVyB0b2t1XCIsXG4gIFwiSElTVE9SWVwiOlwiSGlzdG9yaWFcIixcbiAgXCJGT0xMT1dfQkFDS1wiOlwiT2JzZXJ3dWogcsOzd25pZcW8XCIsXG4gIFwiRk9MTE9XRURcIjpcIk9ic2Vyd293YW55XCIsXG4gIFwiVU5GT0xMT1dcIjpcIlByemVzdGHFhCBvYnNlcndvd2HEh1wiLFxuICBcIkZPTExPV0lOR1wiOlwiT2JzZXJ3dWplc3pcIixcbiAgXCJGT0xMT1dFUlNcIjpcIk9ic2Vyd3VqxIUgY2nEmVwiLFxuICBcIlNFQVJDSF9GT0xMT1dFUlNcIjpcIlN6dWthaiB3xZtyw7NkIG9ic2Vyd3VqxIVjeWNoXCIsXG4gIFwiU0VBUkNIX0ZPTExPV0lOR1wiOlwiU3p1a2FqIHfFm3LDs2Qgb2JzZXJ3b3dhbnljaFwiLFxuICBcIkJZXCI6XCJwcnplelwiLFxuICBcIklOXCI6XCJ3XCIsXG4gIFwiTUVOVVwiOlwiXCIsXG4gIFwiQk9PS01BUktcIjpcIlpha8WCYWRraVwiLFxuICBcIlJFQkxPR1wiOlwiUmVibG9ndWpcIixcbiAgXCJVUFZPVEVcIjpcIkfFgm9zIHphXCIsXG4gIFwiRE9XTlZPVEVcIjpcIkfFgm9zIHByemVjaXdcIixcbiAgXCJVTlZPVEVfRE9XTlZPVEVEXCI6XCJBbnVsdWogZ8WCb3MgcHJ6ZWNpd1wiLFxuICBcIlVOVk9URV9VUFZPVEVEXCI6XCJBbnVsdWogZ8WCb3MgemFcIixcbiAgXCJSRVBMWVwiOlwiT2Rwb3dpZWTFulwiLFxuICBcIkVESVRcIjpcIkVkeXR1alwiLFxuICBcIlBPU1RfMVwiOlwiUHJ6ZWNpxIVnbmlqIGtvbWVudGFyeiB3IGxld28sIGFieSB6b2JhY3p5xIcgZG9zdMSZcG5lIG9wY2plXCIsXG4gIFwiUE9TVF8yXCI6XCJOYWNpxZtuaWogbmEga29tZW50YXJ6ZSwgYWJ5IHJvendpbsSFxIdcIixcbiAgXCJPUFRJT05TXCI6XCJPcGNqZVwiLFxuICBcIlJFU1RFRU1FRF9CWVwiOlwiUmVzdGVlbW93YW55IHByemV6XCIsXG4gIFwiTk9USElOR19IRVJFXCI6XCJOYSByYXppZSBuaWMgdHUgbmllIG1hLi4uXCIsXG4gIFwiQkFMQU5DRVNcIjpcIlNhbGRhXCIsXG4gIFwiUFJPRklMRV8xXCI6XCJ7e3BsYXRmb3JtbmFtZX19IHd5bWllbmlhbG5lIHRva2VueSwga3TDs3JlIG1vZ8SFIGJ5xIcgcHJ6ZXRyYW5zZmVyb3dhbmUgdyBkb3dvbG55bSBtb21lbmNpZS4ge3twbGF0Zm9ybW5hbWV9fSBtb2fEhSBiecSHIHd5bWllbmlvbmUgbmEge3twbGF0Zm9ybXBvd2VyfX0gdyBwcm9jZXNpZSB6d2FueW0gUG93ZXItdXAuXFxuXCIsXG4gIFwiUFJPRklMRV8yXCI6XCJ7e3BsYXRmb3JtcG93ZXJ9fSB0b2tlbnkgd3DFgnl3dSwga3TDs3JlIHVtb8W8bGl3aWFqxIUgbmEgemRvYnl3YW5pZSB3acSZa3N6ZWogaWxvxZtjaSBtb2N5IHphIHRyenltYW5pZSBpY2ggZMWCdW90ZXJtaW5vd28gb3JheiB6YSBnxYJvc293YW5pZSBuYSB3cGlzeS4gSW0gd2nEmWNlaiBzacSZIGljaCBwb3NpYWRhLCB0eW0gYmFyZHppZWogd3DFgnl3YSBzacSZIG5hIHd5bmFncm9kemVuaWUgaW5ueWNoIHdwaXPDs3cgaSBuYSB6ZG9ieXdhbmllIG5hZ3LDs2QgendpxIV6YW5lIHogb2RkYW5pZW0gZ8WCb3N1LlwiLFxuICBcIlBST0ZJTEVfM1wiOlwiVG9rZW55IHdhcnRlIG9rb8WCbyB7e3BsYXRmb3Jtc3VuaXR9fSBwbGF0Zm9ybXkge3twbGF0Zm9ybW5hbWV9fS5cIixcbiAgXCJFU1RJTUFURURfVkFMVUVcIjpcIlN6YWNvd2FuYSB3YXJ0b8WbxIdcIixcbiAgXCJQUk9GSUxFXzRcIjpcIldhcnRvxZvEhyBqZXN0IHN6YWNvd2FuYSBuYSBwb2RzdGF3aWUgxZtyZWRuaWVqIHdhcnRvxZtjaSB6IDctbWl1IGRuaS5cIixcbiAgXCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6XCJIaXN0b3JpYSB0cmFuc2FrY2ppXCIsXG4gIFwiUE9TVElOR1wiOlwiVWRvc3TEmXBuaWFuaWVcIixcbiAgXCJQUk9GSUxFXzVcIjpcIktsdWN6IHVkb3N0xJlwbmllbmlhIGplc3QgdcW8eXdhbnkgcHJ6eSB1ZG9zdMSZcG5pYW5pdSB3cGlzw7N3IGkgb2RkYXdhbml1IGfFgm9zw7N3LiBQb3dpbmllbiBiecSHIGlubnkgbmnFvCBrbHVjeiBha3R5d255IGkga2x1Y3ogd8WCYXNub8WbY2kuXCIsXG4gIFwiT1dORVJcIjpcIlfFgmHFm2NpY2llbFwiLFxuICBcIlBST0ZJTEVfNlwiOlwiS2x1Y3ogd8WCYXNub8WbY2kgamVzdCBrbHVjemVtIGfFgsOzd255bSBrb250YSBpIGplc3Qgd3ltYWdhbnkgZG8gem1pYW55IHBvem9zdGHFgnljaCBrbHVjenkuIEtsdWN6IHByeXdhdG55IGx1YiBoYXPFgm8gZG8ga2x1Y3phIHfFgmFzbm/Fm2NpIHBvd2lubm8gYnnEhyB0cnp5bWFuZSBvZmZsaW5lLCBnZHkgamVzdCB0byB0eWxrbyBtb8W8bGl3ZS5cIixcbiAgXCJBQ1RJVkVcIjpcIkFrdHl3bnlcIixcbiAgXCJQUk9GSUxFXzdcIjpcIktsdWN6IGFrdHl3bnkgamVzdCB1xbx5d2FueSBkbyB3eWtvbnl3YW5pYSBwcnplbGV3w7N3IGkgc2vFgmFkYW5pYSB6YW3Ds3dpZcWEIG5hIHdld27EmXRyem5laiBnaWXFgmR6aWUuXCIsXG4gIFwiTUVNT1wiOlwiTm90YXRrYVwiLFxuICBcIlBST0ZJTEVfOFwiOlwiS2x1Y3ogbm90YXRraSBqZXN0IHXFvHl0eSwgYWJ5IHNwb3J6xIVkemHEhyBpIGN6eXRhxIcgbm90YXRraS5cIixcbiAgXCJCTE9HXCI6XCJcIixcbiAgXCJQT1NUU1wiOlwiV3Bpc3lcIixcbiAgXCJSRVBMSUVTXCI6XCJPZHBvd2llZHppXCIsXG4gIFwiV0FMTEVUXCI6XCJQb3J0ZmVsXCIsXG4gIFwiVEFHXCI6XCJFdHlraWV0YVwiLFxuICBcIlVTRVJcIjpcIlXFvHl0a293bmlrXCIsXG4gIFwiQ0xPU0VcIjpcIlphbWtuaWpcIixcbiAgXCJUT1wiOlwiRG9cIixcbiAgXCJBU1NFVFwiOlwiS2FwaXRhxYJcIixcbiAgXCJTRU5EXCI6XCJXecWbbGlqXCIsXG4gIFwiU0VDVVJJVFlcIjpcIkJlenBpZWN6ZcWEc3R3b1wiLFxuICBcIkFWQUlMQUJMRVwiOlwiRG9zdMSZcG55XCIsXG4gIFwiUFVCTElDX01FTU9cIjpcIk5vdGF0a2EgcHVibGljem5hXCIsXG4gIFwiVE9fREVTQ1wiOlwiVcW8eXRrb3duaWsgbnAuIGdvb2Qta2FybWFcIixcbiAgXCJQSU5fQ09ERVwiOlwiS29kIFBJTlwiLFxuICBcIlBJTl9URVhUXCI6XCJLb2QgUElOIHBvendhbGEgQ2kgemFiZXpwaWVjennEhyBhcGxpa2FjasSZIG9yYXogdHdvamUgZGFuZS4gPGJyLz48YnIvPiA8Yj5Vd2FnYTo8Lz4gTWFzeiBtYWtzeW1hbG5pZSA0IHByw7NieSBhYnkgd3Bpc2HEhyBwb3ByYXduZSBoYXPFgm8gaSBvZGJsb2tvd2HEhyBrb250bywgamXFvGVsaSB6YXBvbW5pYcWCZcWbIGtvZHUgUElOIGx1YiB3cGlzYcWCZcWbIHrFgmUgaGFzxYJvIHdpxJljZWogcmF6eSwgYXBsaWthY2phIHVzdW5pZSB3c3p5c3RraWUgZGFuZSB1xbx5dGtvd25pa2EuIE1vxbxlc3ogc2nEmSB3dGVkeSB6YWxvZ293YcSHIHBvbm93bmllIGkga29udHludW93YcSHIHXFvHl0a293YW5pZSBhcGxpa2FjamkuXCIsXG4gIFwiTk9USUZJQ0FUSU9OU1wiOlwiUG93aWFkb21pZW5pYVwiLFxuICBcIlZPVEVfVEVYVFwiOlwiT3RyenltYXN6IHBvd2lhZG9taWVuaWUsIGdkeSBrdG/FmyBvZGRhIGfFgm9zIG5hIHR3w7NqIHdwaXMhIDxici8+PGI+VXdhZ2E6PC9iPlBvd2lhZG9taWVuaWEgemF3aWVyYWrEhSB0YWvFvGUgdHlwIGfFgm9zdSAodHpuLiBnxYJvcyB6YSwgZ8WCb3MgcHJ6ZWNpdywgYW51bHVqIGfFgm9zKS5cIixcbiAgXCJWT1RFXCI6XCJaYWfFgm9zdWpcIixcbiAgXCJDT01NRU5UX1RFWFRcIjpcIk90cnp5bWFzeiBwb3dhZG9taWVuaWUsIGdkeSBrdG/FmyBza29tZW50dWplIHR3w7NqIHdwaXMgbHViIGtvbWVudGFyeiE8YnIvPiA8Yj5Vd2FnYTo8L2I+Wm9zdGFuaWVzeiByw7N3bmllxbwgcG93aWFkb21pb255LCBnZHkga3RvxZsgPGI+ZWR5dHVqZTwvYj4gc3fDs2oga29tZW50YXJ6LlwiLFxuICBcIkNPTU1FTlRcIjpcIktvbWVudGFyelwiLFxuICBcIkZPTExPV19URVhUXCI6XCJPdHJ6eW1hc3ogcG93aWFkb21pZW5pZSwgZ2R5IGt0b8WbIHphY3puaWUgbHViIHByemVzdGFuaWUgY2nEmSBvYnNlcndvd2HEhyFcIixcbiAgXCJNRU5USU9OU1wiOlwiV3ptaWFua2lcIixcbiAgXCJNRU5USU9OU19URVhUXCI6XCJab3N0YW5pZXN6IHBvd2lhZG9taW9ueSwgZ2R5IGt0b8WbIHdzcG9tbmkgY2nEmSB3IHN3b2ltIHdwaXNpZS9rb21lbnRhcnp1IVwiLFxuICBcIlJFU1RFRU1cIjpcIlJlc3RlZW11alwiLFxuICBcIlJFU1RFRU1fVEVYVFwiOlwiT3RyenltYXN6IHBvd2lhZG9taWVuaWUsIGdkeSBrdG/FmyByZXN0ZWVtdWplIHR3w7NqIHdwaXMhXCIsXG4gIFwiQ09ORklHVVJBVElPTlNcIjpcIktvbmZpZ3VyYWNqZVwiLFxuICBcIlZPVElOR1wiOlwiT2RkYW5pZSBnxYJvc3VcIixcbiAgXCJWT1RJTkdfVEVYVFwiOlwiTW9jIGx1YiBwcm9jZW50IGfFgm9zdSB3cMWCeXdhIG5hIG1vYyBvZGRhbmVnbyBnxYJvc3UgaSB1bW/FvGxpd2lhIGNpIG5hIHJlZ3Vsb3dhbmllIHN3b2plZ28gd3luYWdyb2R6ZW5pYSB6YSBvZGRhbmUgZ8WCb3N5LiA8YnIvPjxici8+PGI+VXdhZ2E6PC9iPiBabWlhbmEgd3DFgnluaWUgbmEgbW9jL3Byb2NlbnQgZ8WCb3N1IGNhxYJlaiBhcGxpa2FjamksIGRvdHljenkgdG8gcsOzd25pZcW8IGfFgm9zw7N3IG9kZGFueWNoIHByemVjaXdcIixcbiAgXCJTRVJWRVJcIjpcIlNlcndlclwiLFxuICBcIlNFUlZFUl9URVhUXCI6XCJSZWtvbWVuZG93YW5lXCIsXG4gIFwiU0FWRV9DSEFOR0VTXCI6XCJaYWNob3dhaiB6bWlhbnlcIixcbiAgXCJWT1RFUlNfSU5GT1wiOlwiR8WCb3Nvd2FsaVwiLFxuICBcIldFTENPTUVfQkFDS1wiOlwiV2l0YWogcG9ub3duaWUhXCIsXG4gIFwiTE9HSU5fMVwiOlwiQWJ5IGtvbnR5bnVvd2HEhywgemFsb2d1aiBzacSZIHByenkgdcW8eWNpdSBsb2dpbnUgaSBoYXPFgmEuXCIsXG4gIFwiTE9HSU5fMlwiOlwiS2x1Y3ogdWRvc3TEmXBuaWFqxIVjeSBqZXN0IHXFvHl3YW55IGRvIHVkb3N0xJlwbmlhbmlhIHdwaXPDs3csIGtvbWVudG93YW5pYSwgZ8WCb3Nvd2FuaWEgaSDFm2xlZHplbmlhLlwiLFxuICBcIkxPR0lOXzNcIjpcIktsdWN6IGFrdHl3bnkgdcW8eXdhbnkgamVzdCBkbyB3eWtvbnl3YW5pYSBwcnplbGV3w7N3IGkgem1pYW4gemRqxJljaWEgcHJvZmlsb3dlZ28uXCIsXG4gIFwiTE9HSU5fNFwiOlwiRGFuZSB1xbx5dGtvd25pa2Egc8SFIHRyenltYW5lIGxva2FsbmllIHByenkgdcW8eWNpYSB0d29qZWdvIHVyesSFZHplbmlhLiBQbyB3eWxvZ293YW5pdSBkYW5lIHpvc3RhasSFIHVzdW5pxJl0ZSFcIixcbiAgXCJET05UX0hBVkVcIjpcIk5pZSBtYXN6IGplc3pjemUga29udGE/XCIsXG4gIFwiU0lHTl9VUF9OT1dcIjpcIlphxYLDs8W8IGtvbnRvXCIsXG4gIFwiQ0FOQ0VMXCI6XCJBbnVsdWpcIixcbiAgXCJBRFZBTkNFRFwiOlwiWmFhd2Fuc293YW5lXCIsXG4gIFwiQUNUSVZFX1BSSUtFWVwiOlwiS2x1Y3ogYWt0eXdueSBwcnl3YXRueVwiLFxuICBcIlBPU1RJTkdfUFJJS0VZXCI6XCJLbHVjeiB1ZG9zdMSZcG5pYWrEhWN5IHByeXdhdG55XCIsXG4gIFwiTUFTVEVSX1BBU1NcIjpcIkhhc8WCbyBnxYLDs3duZVwiLFxuICBcIlVTRVJOQU1FXCI6XCJMb2dpblwiLFxuICBcIkNBUkRfVklFV1wiOlwiV2lkb2sga2FydHlcIixcbiAgXCJDT01QQUNUX1ZJRVdcIjpcIldpZG9rIGtvbXBha3Rvd3lcIixcbiAgXCJTRUFSQ0hcIjpcIlN6dWthalwiLFxuICBcIlNVQk1JVF9BX1NUT1JZXCI6XCJPcHVibGlrdWogdHJlxZvEh1wiLFxuICBcIlJFUExZVE9cIjpcIk9kcG93aWVkelwiLFxuICBcIlBPU1RcIjpcIk9wdWJsaWt1alwiLFxuICBcIlBSRVZJRVdcIjpcIlBvZGdsxIVkXCIsXG4gIFwiREVGQVVMVFwiOlwiU3RhbmRhcmRvd2UgNTAlIC8gNTAlXCIsXG4gIFwiUE9XRVJVUFwiOlwiXCIsXG4gIFwiREVDTElORV9QQVlPVVRcIjpcIk9kbcOzdyB3eW5hZ3JvZHplbmlhXCIsXG4gIFwiU0FWRV9GT1JfTEFURVJcIjpcIlpBQ0hPV0FKIE5BIFDDk8W5TklFSlwiLFxuICBcIkNMRUFSXCI6XCJXWUNaWcWaxIZcIixcbiAgXCJQT1NUX0NPTlRFTlRcIjpcIk9wdWJsaWt1aiB3cGlzXCIsXG4gIFwiQ09NTUVOVF9DT05URU5UXCI6XCJTa29tZW50dWpcIixcbiAgXCJUSVRMRVwiOlwiVHl0dcWCXCIsXG4gIFwiVEFHU1wiOlwiRXR5a2lldHlcIixcbiAgXCJOT1RfTUFUQ0hcIjpcIkJSQUsgWkdPRE5PxZpDSVwiLFxuICBcIkNPTkZJUk1fUElOXCI6XCJQb3d0w7NyeiBQSU5cIixcbiAgXCJJTkNPUlJFQ1RcIjpcIk5JRVBPUFJBV05ZXCIsXG4gIFwiT1BFTklOR19QT1NUXCI6XCJvdHdpZXJhbmllIHdwaXN1XCIsXG4gIFwiU0VUX1BJTlwiOlwiVXN0YXcgUElOXCIsXG4gIFwiRU5URVJfUElOXCI6XCJQb2RhaiBQSU5cIixcbiAgXCJBUkVfWU9VX1NVUkVcIjpcIkN6eSBqZXN0ZcWbIHBld2llbj9cIixcbiAgXCJSRUJMT0dfVEVYVFwiOlwiUmVzdGVlbW93YW5pZSBqZXN0IG5pZW9kd3JhY2FsbmUsIGN6eSBjaGNlc3oga29udHludW93YcSHP1wiLFxuICBcIkJST0FEQ0FTVF9FUlJPUlwiOlwiQsWCxIVkIHBvxYLEhWN6ZW5pYSwgc3Byw7NidWogcG9ub3duaWUhXCIsXG4gIFwiU1VDQ0VTU1wiOlwiWmFrb8WEY3pvbm8gcG93b2R6ZW5pZW1cIixcbiAgXCJSRUJMT0dHRURfUE9TVFwiOlwiUmVibG9ndWogd3BpcyFcIixcbiAgXCJMT0dJTl9GQUlMXCI6XCJCxYLEhWQgbG9nb3dhbmlhISBVcGV3bmlqIHNpxJkgY3p5IHphbG9nb3dhxYJlxZsgc2nEmSBwcnp5IHXFvHljaXUga2x1Y3phIGfFgsOzd25lZ28gbHViIGN6eSB1xbx5xYJlxZsgYWt0eXduZWdvIGtsdWN6YSBwcnl3YXRuZWdvIHByenkgbG9nb3dhbml1IHcgdHJ5YmllIHphYXdhbnNvd2FueW0uXCIsXG4gIFwiTE9HSU5fRkFJTF9BXCI6XCJCxYLEhWQgbG9nb3dhbmlhISBVcGV3bmlqIHNpxJkgY3p5IHphbG9nb3dhxYJlxZsgc2nEmSBwcnp5IHXFvHljaXUga2x1Y3phIGfFgsOzd25lZ28gbHViIGN6eSB1xbx5xYJlxZsgcHJ5d2F0bmVnbyBrbHVjemEgdWRvc3TEmXBuaWFqxIVjZWdvIHByenkgbG9nb3dhbml1IHcgdHJ5YmllIHphYXdhbnNvd2FueW0uXCIsXG4gIFwiV0FSTklOR1wiOlwiVXdhZ2FcIixcbiAgXCJWT1RFX0ZPUl9XSVRORVNTXCI6XCJHxYJvc3VqZXN6IG5hIMWbd2lhZGthXCIsXG4gIFwiVk9URURfRk9SX1dJVE5FU1NcIjpcIlphZ8WCb3Nvd2HFgmXFmyBuYSDFm3dpYWRrYVwiLFxuICBcIkFHT1wiOlwidGVtdVwiLFxuICBcIkZST01fTk9XXCI6XCJvZCB0ZXJhelwiLFxuICBcIlNFQ1NcIjpcInNla3VuZCh5KVwiLFxuICBcIkFfTUlOXCI6XCJtaW51dMSZXCIsXG4gIFwiTUlOU1wiOlwibWludXQoeSlcIixcbiAgXCJBTl9IT1VSXCI6XCJnb2R6aW7EmVwiLFxuICBcIkhPVVJTXCI6XCJnb2R6aW4oeSlcIixcbiAgXCJBX0RBWVwiOlwiZHppZcWEXCIsXG4gIFwiREFZU1wiOlwiZG5pXCIsXG4gIFwiQV9NT05USFwiOlwibWllc2nEhWNcIixcbiAgXCJNT05USFNcIjpcIm1pZXNpxJljeVwiLFxuICBcIkFfWUVBUlwiOlwicm9rXCIsXG4gIFwiWUVBUlNcIjpcImxhdChhKVwiLFxuICBcIk1JTl9SRUFEXCI6XCJtaW51dCB0ZW11IHpvc3RhxYJvIHByemVjenl0YW5lXCIsXG4gIFwiRE9XTlZPVEVfRkxBR1wiOlwiR8WCb3N1aiBwcnplY2l3IGx1YiBvZmxhZ3VqXCIsXG4gIFwiQ0FQVFVSRV9QSUNUVVJFXCI6XCJacsOzYiB6ZGrEmWNpZVwiLFxuICBcIlNFTEVDVF9QSUNUVVJFXCI6XCJXeWJpZXJ6IG9icmF6XCIsXG4gIFwiU0VUX0NVU1RPTV9VUkxcIjpcIlVzdGF3IHd5YnJhbnkgVVJMXCIsXG4gIFwiSU5TRVJUX1BJQ1RVUkVcIjpcIldzdGF3IG9icmF6XCIsXG4gIFwiRVJST1JcIjpcIkLFgsSFZFwiLFxuICBcIlVQTE9BRF9FUlJPUlwiOlwiQsWCxIVkIHByenkgd3J6dWNhbml1IHBsaWt1XCIsXG4gIFwiQ0FNRVJBX0NBTkNFTExFRFwiOlwiQXBhcmF0IG5pZWFrdHl3bmFcIixcbiAgXCJTRVRfVVJMXCI6XCJVc3RhdyBVUkxcIixcbiAgXCJESVJFQ1RfTElOS19QSUNUVVJFXCI6XCJCZXpwb8WbcmVkbmkgbGluayBuYSBzdHJvbsSZIHplIHpkasSZY2llbVwiLFxuICBcIkNPTU1FTlRfU1VCTUlUVEVEXCI6XCJLb21lbnRhcnogem9zdGHFgiBvcHVibGlrb3dhbnkhXCIsXG4gIFwiREVMRVRFX0NPTU1FTlRcIjpcIlVzdW5pxJljaWUga29tZW50YXJ6eSBqZXN0IG5pZW9kd3JhY2FsbmUuLi5cIixcbiAgXCJERUxFVEVEX0NPTU1FTlRcIjpcIlVzdcWEIGtvbWVudGFyelwiLFxuICBcIlVQTE9BRElOR19QSUNUVVJFXCI6XCJXc3RhdyB6ZGrEmWNpZVwiLFxuICBcIlVQTE9BRF9DT01QTEVURURcIjpcIldzdGF3aWVuaWUgemFrb8WEY3pvbmVcIixcbiAgXCJVUExPQURfRkFJTEVEXCI6XCJXcnp1Y2VuaWUgbmllIHBvd2lvZMWCbyBzacSZXCIsXG4gIFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6XCJOaWVwcmF3aWTFgm93eSBsb2dpbiBsdWIgaGFzxYJvXCIsXG4gIFwiSU5GT1wiOlwiSW5mb3JtYWNqYVwiLFxuICBcIlFSX1RFWFRcIjpcIlVtaWXFm8SHIGtvZCBRUiB3IG9icsSZYmllIHBvbGEgc2thbm93YW5pYVwiLFxuICBcIkJBTEFOQ0VfVEVYVFwiOlwiVXBld25paiBzacSZLCBjenkgbWFzeiB3eXN0YXJjemFqxIVjxIUgaWxvxZvEhyDFm3JvZGvDs3cgYWJ5IHd5a29uYcSHIHRyYW5zYWtjasSZIVwiLFxuICBcIk5PTkVYSVNUX1VTRVJcIjpcIlXFvHl0a293bmlrIGRvIGt0w7NyZWdvIHByw7NidWplc3ogcHJ6ZXPFgmHEhyDFm3JvZGtpLCBuaWUgaXN0bmllamUhXCIsXG4gIFwiVFJBTlNGRVJfVEVYVFwiOlwiQ3p5IG5hIHBld25vIGNoY2VzeiB3eXPFgmHEhyDFm3JvZGtpP1wiLFxuICBcIkNPTkZJUk1BVElPTlwiOlwiUG90d2llcmR6ZW5pZVwiLFxuICBcIlRYX0JST0FEQ0FTVEVEXCI6XCJUcmFuc2FrY2phIHcgdG9rdVwiLFxuICBcIkZFRURcIjpcIkFrdHVhbG5vxZtjaVwiLFxuICBcIlRSRU5ESU5HXCI6XCJUcmVuZHlcIixcbiAgXCJIT1RcIjpcIk5hIHRvcGllXCIsXG4gIFwiTkVXXCI6XCJOb3dlXCIsXG4gIFwiUFJPTU9URURcIjpcIlByb21vd2FuZVwiLFxuICBcIlZPVEVTXCI6XCJJbG/Fm8SHIGfFgm9zw7N3XCIsXG4gIFwiUEFZT1VUXCI6XCJQcnp5Y2jDs2RcIixcbiAgXCJDT01NRU5UU1wiOlwiSWxvxZvEhyBLb21lbnRhcnp5XCIsXG4gIFwiVFJFTkRJTkdfMzBcIjpcIlRyZW5keSB6IDMwIGRuaVwiLFxuICBcIlNPUlRfUE9TVF9CWVwiOlwiVXBvcnrEhWRrdWogd2VkxYJ1ZzpcIixcbiAgXCJQQVlPVVRfQ1lDTEVcIjpcIkN5a2wgcHJ6eWNob2R1XCIsXG4gIFwiUE9URU5USUFMX1BBWU9VVFwiOlwiUG90ZW5jamFsbnkgcHJ6eWNow7NkXCIsXG4gIFwiUEFTVF9QQVlPVVRcIjpcIldjemXFm25pZWogd3lwxYJhY29ub1wiLFxuICBcIkFVVEhPUl9QQVlPVVRcIjpcIlByenljaMOzZCBhdXRvcmFcIixcbiAgXCJDVVJBVElPTl9QQVlPVVRcIjpcIlByenljaMOzZCB6YSBtZWNlbmF0XCIsXG4gIFwiUE9TVF9TVUJNSVRURURcIjpcIldwaXMgem9zdGHFgiBvcHVibGlrb3dhbnkhXCIsXG4gIFwiUE9TVF9MQVRFUlwiOlwiT3B1Ymxpa3VqIHdwaXMgcMOzxbpuaWVqIVwiLFxuICBcIlNBVkVEXCI6XCJaYXBhbWnEmXRhalwiLFxuICBcIkNMRUFSRURcIjpcIld5Y3p5xZvEh1wiLFxuICBcIkZMQUdHSU5HX1RFWFRcIjpcIk9mbGFnb3dhbmllIHdwaXN1IG1vxbxlIHNwb3dvZG93YcSHIHVzdW5pxJljaWUgd3luYWdyb2R6ZW5pYSBpIHptbmllanN6ZW5pZSBqZWdvIHdpZG9jem5vxZtjaS48YnI+PGJyPkZsYWdhIHBvd2lubmEgYnnEhyB1xbx5dGEgdyBzeXR1YWNqYWNoIHRha2ljaCBqYWs6IDx1bD48bGk+T3N6dXN0d28gbHViIFBsYWdpYXQ8L2xpPjxsaT5Nb3fEmSBuaWVuYXdpxZtjaSBsdWIgSW50ZXJuZXRvd3kgdHJvbGxpbmc8L2xpPjxsaT5XcGlzIGNlbG93byDFumxlIHNrYXRhZ29yeXpvd2FueSBsdWIgU3BhbTwvbGk+PC91bD5cIixcbiAgXCJSRVFVRVNUX0xJTUlUX1RFWFRcIjpcIkxpbWl0IHpvc3RhxYIgb3NpxIVnbmnEmXR5LiBTcHJhd2TFuiBpbm5lIGV0eWtpZXR5L3RyZW5keSFcIixcbiAgXCJQT1NUX0lTX1VOQk9PS01BUktcIjpcIldwaXMgem9zdGHFgiB1c3VuacSZdHkgeiB6YWvFgmFkZWshXCIsXG4gIFwiUE9TVF9JU19CT09LTUFSS1wiOlwiV3BpcyB6b3N0YcWCIGRvZGFueSBkbyB6YWvFgmFkZWshXCIsXG4gIFwiUkVTRVRcIjpcIlpyZXNldHVqXCIsXG4gIFwiTU9ESUZZX1BJQ1RVUkVcIjpcIlptb2R5ZmlrdWogemRqxJljaWUgcHJvZmlsb3dlXCIsXG4gIFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjpcIlptaWXFhCB6ZGrEmWNpZSB3IHRsZVwiLFxuICBcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOlwiUG9kYWogYWt0eXdueSBrbHVjeiBwcnl3YXRueSBqZcWbbGkgd3licmHFgmXFmyB0cnliIHphYXdhbnNvd2FuZWdvIGxvZ293YW5pYSFcIixcbiAgXCJSRVNFVF9QSUNUVVJFX1RFWFRcIjpcIlNwb3dvZHVqZSB6cmVzZXRvd2FuaWUgemRqxJljaWEgcHJvZmlsb3dlZ29cIixcbiAgXCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjpcIlNwb3dvZHVqZSB6cmVzZXRvd2FuaWUgemRqxJljaWEgdyB0bGVcIixcbiAgXCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOlwiQWt0dWFsaXphY2phIHNlcndlcmEgd3ltYWdhIHpyZXNldG93YW5pYSFcIixcbiAgXCJTRVRUSU5HU19VUERBVEVEXCI6XCJVc3Rhd2llbmlhIHpvc3RhxYJ5IHpha3R1YWxpem93YW5lXCIsXG4gIFwiTEFOR1VBR0VTXCI6XCJKxJl6eWtcIixcbiAgXCJMQU5HVUFHRVNfVEVYVFwiOlwiVHUgbW/FvGVzeiB6bWllbmnEhyBqxJl6eWsgYXBsaWthY2ppLlwiLFxuICBcIkxPR0lOX1RPX1hcIjpcIlRhIG9wZXJhY2phIHd5bWFnYSB6YWxvZ293YW5pYSBoYXPFgmVtIGfFgsOzd255bSwga2x1Y3plbSBha3l0d255bS91ZG9zdMSZcG5pYWrEhWN5bS4gWmFsb2d1aiBzacSZIGkgc3Byw7NidWogcG9ub3duaWUuXCIsXG4gIFwiR0FMTEVSWVwiOlwiR2FsZXJpYVwiLFxuICBcIlRSQU5TTEFUSU9OU1wiOlwiUHJ6ZXTFgnVtYWN6eWxpXCIsXG4gIFwiU0hBUkVcIjpcIlBvbGXEh1wiLFxuICBcIk1BUktFVFBMQUNFXCI6XCJTa2xlcFwiLFxuICBcIkVYQ0hBTkdFXCI6XCJXeW1pYW5hXCIsXG4gIFwiRFJBRlRTXCI6XCJXZXJzamUgcm9ib2N6ZVwiLFxuICBcIlBPU1RfSVNfVU5EUkFGVFwiOlwiV3BpcyB6b3N0YcWCIHVzdW5pxJl0eSB6IHJvYm9jenljaCFcIixcbiAgXCJQT1NUX0lTX0RSQUZUXCI6XCJXcGlzIHpvc3RhxYIgemFwaXNhbnkgamFrbyB3ZXJzamEgcm9ib2N6YSFcIixcbiAgXCJTV0lQRV9MRUZUXCI6XCJQcnplY2nEhWduaWogdyBsZXdvLCBhYnkgem9iYWN6ecSHIG9wY2plXCIsXG4gIFwiTUFOQUdFXCI6XCJaYXJ6xIVkemFqXCIsXG4gIFwiSU1BR0VfUkVNT1ZFRFwiOlwiT2JyYXogem9zdGHFgiB1c3VuacSZdHlcIixcbiAgXCJDT1BZXCI6XCJLb3BpdWpcIixcbiAgXCJOT19JTUFHRVwiOlwiTmllIG9wdWJsaWtvd2HFgmXFmyBqZXN6Y3plIMW8YWRuZWdvIG9icmF6dSFcIixcbiAgXCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOlwiUHJ6ZWNpxIVnbmlqIHcgZMOzxYIsIGFieSBvZMWbd2llxbx5xIcuXCIsXG4gIFwiRVhURVJOQUxfQVBQU1wiOlwiQXBsaWthY2plIHpld27EmXRyem5lXCIsXG4gIFwiUExVR0lOU1wiOlwiUGx1Z2lueVwiLFxuICBcIlNVR0dFU1RcIjpcIlphc3VnZXJ1alwiLFxuICBcIkNPTUlOR19TT09OXCI6XCJKdcW8IHdrcsOzdGNlXCIsXG4gIFwiQ0hBSU5cIjpcIsWBYcWEY3VjaFwiLFxuICBcIkNIQUlOX1RFWFRcIjpcIlR1dGFqIG1vxbxlc3ogem1pZW5pxIcgxYJhxYRjdWNoIGJsb2vDs3cgbHViIGRvbXnFm2xuxIUgcGxhdGZvcm3EmS5cIixcbiAgXCJDVVJSRU5DWVwiOlwiXCIsXG4gIFwiQ1VSUkVOQ1lfVEVYVFwiOlwiXCIsXG4gIFwiQUJPVVRfMTFcIjpcIlwiLFxuICBcIkZPVU5ERVJcIjpcIlwiLFxuICBcIkFERF9BQ0NPVU5UXCI6XCJcIixcbiAgXCJQTEFURk9STVwiOlwiXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiSE9NRVwiOlwiUMOhZ2luYSBJbmljaWFsXCIsXG4gIFwiTE9HSU5cIjpcIkVudHJhclwiLFxuICBcIkxPR09VVFwiOlwiU2FpclwiLFxuICBcIlBST0ZJTEVcIjpcIlBlcmZpbFwiLFxuICBcIkZPTExPV1wiOlwiU2VndWlyXCIsXG4gIFwiQk9PS01BUktTXCI6XCJGYXZvcml0b3NcIixcbiAgXCJUUkFOU0ZFUlwiOlwiVHJhbnNmZXJpclwiLFxuICBcIk1BUktFVFwiOlwiTWVyY2Fkb1wiLFxuICBcIlNFVFRJTkdTXCI6XCJDb25maWd1cmHDp8O1ZXNcIixcbiAgXCJBQk9VVFwiOlwiU29icmVcIixcbiAgXCJBQk9VVF8xXCI6XCJvbmRlIHF1YWxxdWVyIHVtIHBvZGUgZ2FuaGFyIHJlY29tcGVuc2FzIHBlbG8gc2V1IGNvbnRlw7pkb1wiLFxuICBcIkFCT1VUXzJcIjpcIsOpIHBhdHJvY2luYWRvIHBlbGEgcGxhdGFmb3JtYSB7e3BsYXRmb3JtbmFtZX19LiBBcGxpY2F0aXZvIGNyaWFkbyBwb3JcIixcbiAgXCJBQk9VVF8zXCI6XCJlIMOpIGPDs2RpZ28tYWJlcnRvLCBwcm9qZWN0byBvcmllbnRhZG8gcGFyYSBhIGNvbXVuaWRhZGUgbcOzdmVsLiBPZmVyZWNlIGFjZXNzbyBhbyBjb250ZcO6ZG8gcGFyYSBsZWl0dXJhLCBjb21lbnTDoXJpb3MsIHZvdG9zLCBwdWJsaWNhciwgdHJhbmZlcmlyIGdhbmhvcyBldGMuIENhcmF0ZXLDrXN0aWNhcyBvZmVyZWNpZGFzIHBlbCB7e3BsYXRmb3JtbmFtZX19IGJsb2NrY2hhaW4gZSB7e3NpdGVuYW1lfX0uXCIsXG4gIFwiQUJPVVRfNFwiOlwiMS4gTyBhcGxpY2F0aXZvIG51bmNhIGFjZXNzYSBvdSBndWFyZGEgbyBkaW5oZWlybyBkb3MgdXN1w6FyaW9zLlwiLFxuICBcIkFCT1VUXzVcIjpcIjIuIEEgQXBwIG9mZXJlw6dlIHVtIG1vZGVsbyBzZWd1cm8gZG8gbGFkby1jbGllbnRlLCBjb20gY2hhdmVzIHByaXZhZGFzLCBndWFyZGFkYXMgbG9jYWxtZW50ZSBlIG51bmNhIGVudmlkYSBhIG91dHJvcyBzZXJ2aWRvcmVzLlwiLFxuICBcIkFCT1VUXzZcIjpcIjMuIE8gQXBsaWNhdGl2byBvZmVyZWNlIHNpbXBsaWNpZGFkZSwgaW50ZXJmYWNlcyBkZSB1c3XDoXJpbyBlIGV4cGVyacOqbmNpYXMgYXRyYXRpdmFzLlwiLFxuICBcIkFCT1VUXzdcIjpcIjQuIE8gQXBsaWNhdGl2byByZXF1ZXIgcXVlIG9zIHVzdcOhcmlvcyBpbnNpcmFtIGluZm9ybWHDp8O1ZXMgcGVzc29haXMuXCIsXG4gIFwiQUJPVVRfOFwiOlwiVm90ZSBib20ta2FybWEgY29tbyB0ZXN0ZW11bmhhXCIsXG4gIFwiQUJPVVRfOVwiOlwiQ29udGF0by9Db21lbnTDoXJpb3NcIixcbiAgXCJBQk9VVF8xMFwiOlwiTWFpcyBpbmZvcm1hw6fDtWVzOlwiLFxuICBcIlJFTU9WRVwiOlwiUmVtb3ZlclwiLFxuICBcIk1BUktFVF9WSUVXXCI6XCJWaXPDo28gZG8gTWVyY2Fkb1wiLFxuICBcIlBSSUNFXCI6XCJQcmXDp29cIixcbiAgXCJBTU9VTlRcIjpcIlF1YW50aWRhZGVcIixcbiAgXCJUT1RBTFwiOlwiXCIsXG4gIFwiTk9PUkRFUlNcIjpcIlNlbSBvcmRlbnMgYWJlcnRhcyBwYXJhXCIsXG4gIFwiREFURVwiOlwiRGF0YVwiLFxuICBcIkJVWVwiOlwiQ29tcHJhclwiLFxuICBcIlNFTExcIjpcIlZlbmRlclwiLFxuICBcIk9QRU5cIjpcIkFicmlyXCIsXG4gIFwiSElTVE9SWVwiOlwiSGl0w7NyaWNvXCIsXG4gIFwiRk9MTE9XX0JBQ0tcIjpcIlNlZ3VpciBkZSB2b2x0YVwiLFxuICBcIkZPTExPV0VEXCI6XCJTZWd1aWRvXCIsXG4gIFwiVU5GT0xMT1dcIjpcIkRlaXhhciBkZSBzZWd1aXJcIixcbiAgXCJGT0xMT1dJTkdcIjpcIlNlZ3VpbmRvXCIsXG4gIFwiRk9MTE9XRVJTXCI6XCJTZWd1aWRvcmVzXCIsXG4gIFwiU0VBUkNIX0ZPTExPV0VSU1wiOlwiUHJvY3VyYXIgc2VndWlkb3Jlc1wiLFxuICBcIlNFQVJDSF9GT0xMT1dJTkdcIjpcIlByb2N1cmFyIHF1ZW0gZXN0b3Ugc2VndWluZG9cIixcbiAgXCJCWVwiOlwicG9yXCIsXG4gIFwiSU5cIjpcIm5vXCIsXG4gIFwiTUVOVVwiOlwiXCIsXG4gIFwiQk9PS01BUktcIjpcIkZhdm9yaXRvc1wiLFxuICBcIlJFQkxPR1wiOlwiUmVwb3N0YXJcIixcbiAgXCJVUFZPVEVcIjpcIlVwdm90ZSBcIixcbiAgXCJET1dOVk9URVwiOlwiXCIsXG4gIFwiVU5WT1RFX0RPV05WT1RFRFwiOlwiQ2FuY2VsYXIgRG93bnZvdGVcIixcbiAgXCJVTlZPVEVfVVBWT1RFRFwiOlwiQ2FuY2VsYXIgVXB2b3RlXCIsXG4gIFwiUkVQTFlcIjpcIlJlc3BvbmRlclwiLFxuICBcIkVESVRcIjpcIkVkaXRhclwiLFxuICBcIlBPU1RfMVwiOlwiRGVzbGl6ZSBwYXJhIGVzcXVlcmRhIG5vcyBjb21lbnTDoXJpb3MgcGFyYSB2ZXIgYXMgb3DDp8O1ZXNcIixcbiAgXCJQT1NUXzJcIjpcIlRvcXVlIG5vcyBjb21lbnTDoXJpb3MgcGFyYSB2ZXIgb3Mgc3ViLWNvbWVudMOhcmlvc1wiLFxuICBcIk9QVElPTlNcIjpcIk9ww6fDtWVzXCIsXG4gIFwiUkVTVEVFTUVEX0JZXCI6XCJSZXBvc3RhZG8gcG9yXCIsXG4gIFwiTk9USElOR19IRVJFXCI6XCJOYWRhIHBvciBhcXVpLCBhaW5kYS4uLlwiLFxuICBcIkJBTEFOQ0VTXCI6XCJCYWxhbsOnb1wiLFxuICBcIlBST0ZJTEVfMVwiOlwie3twbGF0Zm9ybW5hbWV9fSwgcHJvdmFzIHRyYW5zYWNpb27DoXZlaXMgcXVlIHBvZGVtIHNlciB0cmFuc2ZlcmlkYXMgZW0gcXVhbHF1ZXIgYWx0dXJhLiB7e3BsYXRmb3JtbmFtZX19IHBvZGVtIHNlciBjb252ZXJ0aWRhcyB7e3BsYXRmb3JtcG93ZXJ9fSBudW0gcHJvY2Vzc28gY2hhbWFkbyBwb2RlciBhYmFpeG8uXCIsXG4gIFwiUFJPRklMRV8yXCI6XCJ7e3BsYXRmb3JtcG93ZXJ9fSwgcHJvdmFzIGRlIGluZmx1ZW5jaWEgcGFyIGdhbmhhciBtYWlzIHBvZGVyIHBvciBndWFyZGFyIGEgbG9uZ28gcHJhem8gZSB2b3RhciBuYXMgcHVibGljYcOnw7Vlcy4gUXVhbnRvIG1haXMgc2UgcG9zc3VpIG1haXMgc2UgcG9kZSBpbmZsdWVuY2lhciBhcyByZWNvbXBlbnNhcyBhIG91dHJvcyBlIGdhbmhhciBtYWlzIHJlY29tcGVuc2FzIHBvciB2b3Rhci5cIixcbiAgXCJQUk9GSUxFXzNcIjpcIlByb3ZhcyB2YWxlbmRvIGNlcmNhIGRlIHt7cGxhdGZvcm1zdW5pdH19IGRlIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG4gIFwiRVNUSU1BVEVEX1ZBTFVFXCI6XCJWYWxvciBlc3RpbWFkb1wiLFxuICBcIlBST0ZJTEVfNFwiOlwiTyB2YWxvciBlc3RpbWFkbyDDqSBiYXNlYWRvIG51bWEgbcOpZGlhIGRvIHZhbG9yIGRlIDcgZGlhcyBkZSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuICBcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjpcIkhpc3TDs3JpY28gZGUgVHJhbnNhw6fDtWVzXCIsXG4gIFwiUE9TVElOR1wiOlwiUG9zdGFuZG9cIixcbiAgXCJQUk9GSUxFXzVcIjpcIkEgY2hhdmUgZGUgcG9zdGFnZW0gw6kgdXNhZGEgcGFyYSBwb3N0YXIgZSB2b3Rhci4gRWxhIGRldmVyw6Egc2VyIGRpZmVyZW50ZSBkYSBjaGF2ZSBkZSBhdGl2YcOnw6NvIGUgZGEgY2hhdmUgZGUgcHJvcHJpZXTDoXJpby5cIixcbiAgXCJPV05FUlwiOlwiUHJvcHJpZXTDoXJpb1wiLFxuICBcIlBST0ZJTEVfNlwiOlwiQSBjaGF2ZSBkZSBwcm9wcmlldMOhcmlvIMOpIGEgY2hhdmUgbWVzdHJhIHBhcmEgY29udGEgZSDDqSBleGlnaWRhIHBhcmEgbXVkYXIgYXMgb3V0cmFzIGNoYXZlcy4gVW1hIGNoYXZlIHByaXZhZGEgb3Ugc2VuaGEgcGFyYSBhIGNoYXZlIGRlIHByb3ByaWV0w6FyaW8gZGV2ZXLDoSBzZXIgbWFudGlkYSBvZmZsaW5lIGFzc2ltIHF1ZSBwb3Nzw612ZWwuXCIsXG4gIFwiQUNUSVZFXCI6XCJBdGl2b1wiLFxuICBcIlBST0ZJTEVfN1wiOlwiQSBjaGF2ZSBkZSBhdGl2YcOnw6NvIMOpIHVzYWRhIHBhcmEgZmF6ZXIgdHJhbnNmZXLDqm5jaWFzIGUgY29sb2NhciBvcmRlbnMgbm8gbWVyY2FkbyBpbnRlcm5vLlwiLFxuICBcIk1FTU9cIjpcIkFub3Rhw6fDtWVzXCIsXG4gIFwiUFJPRklMRV84XCI6XCJBIGNoYXZlIGRlIGFub3Rhw6fDtWVzIMOpIHVzYWRhIHBhcmEgY3JpYXIgZSBsZXIgYW5vdGHDp8O1ZXMuXCIsXG4gIFwiQkxPR1wiOlwiXCIsXG4gIFwiUE9TVFNcIjpcIlBvc3RhZ2Vuc1wiLFxuICBcIlJFUExJRVNcIjpcIlJlc3Bvc3Rhc1wiLFxuICBcIldBTExFVFwiOlwiQ2FydGVpcmFcIixcbiAgXCJUQUdcIjpcIlwiLFxuICBcIlVTRVJcIjpcIlVzdcOhcmlvXCIsXG4gIFwiQ0xPU0VcIjpcIkZlY2hhZG9cIixcbiAgXCJUT1wiOlwiUGFyYVwiLFxuICBcIkFTU0VUXCI6XCJBdGl2b1wiLFxuICBcIlNFTkRcIjpcIkVudmlhclwiLFxuICBcIlNFQ1VSSVRZXCI6XCJTZWd1cmFuw6dhXCIsXG4gIFwiQVZBSUxBQkxFXCI6XCJEaXNwb27DrXZlbFwiLFxuICBcIlBVQkxJQ19NRU1PXCI6XCJNZW1vcmFuZG8gUMO6YmxpY29cIixcbiAgXCJUT19ERVNDXCI6XCJVdGlsaXphZG9yIGV4OiBnb29kLWthcm1hXCIsXG4gIFwiUElOX0NPREVcIjpcIkPDs2RpZ28gUGluXCIsXG4gIFwiUElOX1RFWFRcIjpcIkPDs2RpZ28gUGluIGFqdWRhIHZvY8OqIGEgYXNzZWd1cmFyIG8gYXBsaWNhdGl2byBlIHN1YXMgaW5mb3JtYcOnw7Vlcy4gPGJyLz48YnIvPiBVbWEgdmV6IGF0aXZhZG8sIHZvY8OqIHRlcsOhIG5vIG3DoXhpbW8gNCB0ZW50YXRpdmFzIHBhcmEgZGVzdHJhdmFyLCBzZSB2b2NlIGVzcXVlY2VybyBwaW4gb3UgZXJyYXIsIG8gYXBsaWNhdGl2byBpcsOhIHJlbW92ZXIgc3VhcyBpbmZvcm1hw6fDtWVzIGRlIHVzdcOhcmlvLiBWb2PDqiBwb2RlIGVudHJhciBkZSBub3ZvIGUgY29udGludWFyIGEgdXNhciBvIGFwbGljYXRpdm8uXCIsXG4gIFwiTk9USUZJQ0FUSU9OU1wiOlwiTm90aWZpY2HDp8O1ZXNcIixcbiAgXCJWT1RFX1RFWFRcIjpcIlZvY8OqIHJlY2ViZXLDoSB1bWEgbm90aWZpY2HDp8OjbyBxdWFuZG8gYWxndcOpbSB2b3RlciBubyBzZXUgY29udGXDumRvISBOb3RpZmljYcOnw7VlcyB0YW1iw6ltIGluY2x1ZW0gcGVzbyBkZSB2b3RvIG5vIGFsZXJ0YSBkYSBtZW5zYWdlbS4pIHNlamEgdm90byBwb3NpdGl2bywgdm90byBuZWdhdGl2bywgdm90byBudWxvKS5cIixcbiAgXCJWT1RFXCI6XCJWb3RhclwiLFxuICBcIkNPTU1FTlRfVEVYVFwiOlwiVm9jw6ogcmVjZWJlcsOhIG5vdGlmaWNhw6fDo28gcXVhbmRvIGFsZ3XDqW0gY29tZW50YXIgbmFzIHN1YXMgcG9zdGFnZW5zIG91IGNvbWVudMOhcmlvcy48YnIvPiBOb3RpZmljYcOnw7VlcyBpbmNsdWVtIHF1YW5kbyBhbGd1w6ltIGVkaXRhIG9zIGNvbWVudMOhcmlvcyB0YW1iw6ltLlwiLFxuICBcIkNPTU1FTlRcIjpcIkNvbWVudGFyXCIsXG4gIFwiRk9MTE9XX1RFWFRcIjpcIlZvY8OqIHJlY2ViZXLDoSB1bWEgbm90aWZpY2HDp8OjbyBxdWFuZG8gYWxndcOpbSBTZWd1aXIgb3UgRGVpeGFyIGRlIHNlZ3VpciB2b2PDqiFcIixcbiAgXCJNRU5USU9OU1wiOlwiTWVuw6fDtWVzXCIsXG4gIFwiTUVOVElPTlNfVEVYVFwiOlwiVm9jw6ogcmVjZWJlcsOhIHVtYSBub3RpZmljYcOnw6NvIHF1YW5kbyBhbGd1w6ltIG1lbmNpb25hciB2b2PDqiBlbSBhbGd1bWEgcG9zdGFnZW0gb3UgY29tZW50w6FyaW8hXCIsXG4gIFwiUkVTVEVFTVwiOlwiXCIsXG4gIFwiUkVTVEVFTV9URVhUXCI6XCJJcsOhIHJlY2ViZXIgbm90aWZpY2HDp8OjbyBxdWFuZG8gYWxndWVtIHJlcHVibGljYXIgYSBzdWEgcHVibGljYcOnw6MhXCIsXG4gIFwiQ09ORklHVVJBVElPTlNcIjpcIkNvbmZpZ3VyYcOnw7Vlc1wiLFxuICBcIlZPVElOR1wiOlwiVm90YW5kb1wiLFxuICBcIlZPVElOR19URVhUXCI6XCJPIHBlc28gZGUgdm90byBvdSBwZXJjZW50YWdlbSBhZmV0YSBvIHBvZGVyIGRlIHZvdG8gbmEgYXBwLCBwb3IgaXNzbyBwb2RlIHJlZ3VsYXIgbyBzZXUgcmVjb21wZW5zYSBkZSB2b3RvIDxici8+PGJyLz48Yj5Ob3RhOjwvYj4gSXN0byBpcsOhIG1vZGlmaWNhciBvIHBzZXNvL3BlcmNlbnRhZ2VtIHBhcmEgdm90YXIgcGFyYSBiYWl4byB0YW1iw6ltIGUgZW0gdG9kbyBvIGxhZG8gbmEgQXBwXCIsXG4gIFwiU0VSVkVSXCI6XCJTZXJ2aWRvclwiLFxuICBcIlNFUlZFUl9URVhUXCI6XCJSZWNvbWVuZGFkb1wiLFxuICBcIlNBVkVfQ0hBTkdFU1wiOlwiU2FsdmFyIG11ZGFuw6dhc1wiLFxuICBcIlZPVEVSU19JTkZPXCI6XCJJbmZvcm1hw6fDtWVzIGRvcyBlbGVpdG9yZXNcIixcbiAgXCJXRUxDT01FX0JBQ0tcIjpcIkJlbSB2aW5kbyBkZSBWb2x0YSFcIixcbiAgXCJMT0dJTl8xXCI6XCJDb25lY3RlLXNlIGNvbSBzZXUgbm9tZSBkZSB1c3XDoXJpbyBlIHNlbmhhIHBhcmEgY29udGludWFyLlwiLFxuICBcIkxPR0lOXzJcIjpcIkNoYXZlIGRlIHBvc3RhZ2VtIMOpIHVzYWRhIHBhcmEgcG9zdGFyLCBjb21lbnRhciwgdm90YXIsIHNlZ3Vpci5cIixcbiAgXCJMT0dJTl8zXCI6XCJDaGF2ZSBkZSBhdGl2YcOnw6NvIMOpIHVzYWRhIHBhcmEgdHJhbmZlcsOqbmNpYXMgZSBhdHVhbGl6YcOnw6NvIGRlIGZvdG9zIGRlIHBlcmZpbC5cIixcbiAgXCJMT0dJTl80XCI6XCJBcyBjcmVkZW5jaWFpcyBkbyB1dGlsaXphZG9yIHPDo28gZ3VhcmRhZGFzIGxvY2FsbWVudGUgbm8gc2V1IGFwYXJlbGhvLiBEZXBpcyBkZSBkZXNsaWdhciBhcyBzdWFzIGNlcmRlbmNpYWlzIHPDo28gcmVtb3ZpZGFzIVwiLFxuICBcIkRPTlRfSEFWRVwiOlwiTsOjbyBwb3NzdWkgdW1hIGNvbnRhP1xcblwiLFxuICBcIlNJR05fVVBfTk9XXCI6XCJDYWRhc3RyZS1zZSBhZ29yYVwiLFxuICBcIkNBTkNFTFwiOlwiQ2FuY2VsYXJcIixcbiAgXCJBRFZBTkNFRFwiOlwiQXZhbsOnYWRvXCIsXG4gIFwiQUNUSVZFX1BSSUtFWVwiOlwiQ2hhdmUgZGUgYXRpdmHDp8OjbyBwcml2YWRhXCIsXG4gIFwiUE9TVElOR19QUklLRVlcIjpcIkNoYXZlIGRlIHBvc3RhZ2VtIHByaXZhZGFcIixcbiAgXCJNQVNURVJfUEFTU1wiOlwiU2VuaGEgTWVzdHJhL1ByaW5jaXBhbFwiLFxuICBcIlVTRVJOQU1FXCI6XCJVc3XDoXJpb1wiLFxuICBcIkNBUkRfVklFV1wiOlwiVmlzw6NvIGRlIENhcnTDo29cIixcbiAgXCJDT01QQUNUX1ZJRVdcIjpcIlZpc3RhIGNvbXBhY3RhXCIsXG4gIFwiU0VBUkNIXCI6XCJQcm9jdXJhclwiLFxuICBcIlNVQk1JVF9BX1NUT1JZXCI6XCJQb3N0YXIgdW1hIGhpc3TDs3JpYVwiLFxuICBcIlJFUExZVE9cIjpcIlJlc3BvbmRlciBwYXJhXCIsXG4gIFwiUE9TVFwiOlwiUG9zdGFnZW1cIixcbiAgXCJQUkVWSUVXXCI6XCJWaXp1YWxpemHDp8Ojb1wiLFxuICBcIkRFRkFVTFRcIjpcIlBhZHLDo28gNTAlIC8gNTAlXCIsXG4gIFwiUE9XRVJVUFwiOlwiRm9yw6dhIFRvdGFsIDEwMCVcIixcbiAgXCJERUNMSU5FX1BBWU9VVFwiOlwiUmVjdXNhciBQYWdhbWVudG9cIixcbiAgXCJTQVZFX0ZPUl9MQVRFUlwiOlwiR3VhcmRhciBwcmEgbWFpcyB0YXJkZVwiLFxuICBcIkNMRUFSXCI6XCJUZXJtaW5hZG9cIixcbiAgXCJQT1NUX0NPTlRFTlRcIjpcIkNvbnRlw7pkbyBkYSBwb3N0YWdlbVwiLFxuICBcIkNPTU1FTlRfQ09OVEVOVFwiOlwiQ29udGXDumRvIGRvIGNvbWVudMOhcmlvXCIsXG4gIFwiVElUTEVcIjpcIlTDrXR1bG9cIixcbiAgXCJUQUdTXCI6XCJcIixcbiAgXCJOT1RfTUFUQ0hcIjpcIk7Do28gY29uZGl6XCIsXG4gIFwiQ09ORklSTV9QSU5cIjpcIkNvbmZpcm1hciBQaW5cIixcbiAgXCJJTkNPUlJFQ1RcIjpcIkluY29ycmV0b1wiLFxuICBcIk9QRU5JTkdfUE9TVFwiOlwiQWJyaW5kbyBwb3N0YWdlbVwiLFxuICBcIlNFVF9QSU5cIjpcIkNvbmZpZ3VyZSBQSU5cIixcbiAgXCJFTlRFUl9QSU5cIjpcIkVudHJhciBjb20gUGluXCIsXG4gIFwiQVJFX1lPVV9TVVJFXCI6XCJWb2PDqiB0ZW0gY2VydGV6YT9cIixcbiAgXCJSRUJMT0dfVEVYVFwiOlwiUmVwdWJsaWNhciDDqSBpcnJldmVyc8OtdmVsLCBxdWVyIG1lc21vIGNvbnRpbnVhcj9cIixcbiAgXCJCUk9BRENBU1RfRVJST1JcIjpcIkVycm8gZGUgZGlmdXPDo28sIHRlbnRlIG5vdmFtZW50ZSFcIixcbiAgXCJTVUNDRVNTXCI6XCJTdWNlc3NvXCIsXG4gIFwiUkVCTE9HR0VEX1BPU1RcIjpcIlB1Ymx1Y2HDp8OjbyByZXB1YmxpY2FkYVwiLFxuICBcIkxPR0lOX0ZBSUxcIjpcIkxvZ2luIGZhbGhvdSEgcG9yIGZhdm9yIGNlcnRpZmlxdWUtc2UgcXVlIGVzdMOhIGNvbmV0YWRvIGNvbSBhIHNlbmhhIG1hc3RlciBvdSBhIGNoYXZlIHB1YmxpY2HDp8OjbyBwcml2YWRhIG5vIExvZ2luIHNlIGVzY29saGV1IG8gbW9kbyBhdmFuw6dhZG8uXCIsXG4gIFwiTE9HSU5fRkFJTF9BXCI6XCJMb2dpbiBmYWxob3UhIHBvciBmYXZvciBjZXJ0aWZpcXVlLXNlIHF1ZSBlc3TDoSBjb25ldGFkbyBjb20gYSBzZW5oYSBtYXN0ZXIgb3UgYSBjaGF2ZSBhdGl2YSBwcml2YWRhIG5vIExvZ2luIHNlIGVzY29saGV1IG8gbW9kbyBhdmFuw6dhZG8uXCIsXG4gIFwiV0FSTklOR1wiOlwiQ3VpZGFkb1wiLFxuICBcIlZPVEVfRk9SX1dJVE5FU1NcIjpcIlZvdGFuZG8gcG9yIHVtYSBUZXN0ZW11bmhhXCIsXG4gIFwiVk9URURfRk9SX1dJVE5FU1NcIjpcIlZvdG91IHBvciB1bWEgVGVzdGVtdW5oYVwiLFxuICBcIkFHT1wiOlwiYXRyw6FzXCIsXG4gIFwiRlJPTV9OT1dcIjpcImRlIGFnb3JhXCIsXG4gIFwiU0VDU1wiOlwic2Vnc1wiLFxuICBcIkFfTUlOXCI6XCJ1bSBtaW51dG9cIixcbiAgXCJNSU5TXCI6XCJcIixcbiAgXCJBTl9IT1VSXCI6XCJ1bWEgaG9yYVwiLFxuICBcIkhPVVJTXCI6XCJob3Jhc1wiLFxuICBcIkFfREFZXCI6XCJ1bSBkaWFcIixcbiAgXCJEQVlTXCI6XCJkaWFzXCIsXG4gIFwiQV9NT05USFwiOlwidW0gbcOqc1wiLFxuICBcIk1PTlRIU1wiOlwibWVzZXNcIixcbiAgXCJBX1lFQVJcIjpcInVtIGFub1wiLFxuICBcIllFQVJTXCI6XCJhbm9zXCIsXG4gIFwiTUlOX1JFQURcIjpcImxlciBtaW5cIixcbiAgXCJET1dOVk9URV9GTEFHXCI6XCJWb3RlIGFiYWl4byBvdSBiYW5kZWlyZVwiLFxuICBcIkNBUFRVUkVfUElDVFVSRVwiOlwiQ2FwdHVyYXIgaW1hZ2VtXCIsXG4gIFwiU0VMRUNUX1BJQ1RVUkVcIjpcIkVzY29saGVyIHVtYSBpbWFnZW1cIixcbiAgXCJTRVRfQ1VTVE9NX1VSTFwiOlwiQ29uZmlndXJlIFVSTCBjb3N0dW1pemFkYVwiLFxuICBcIklOU0VSVF9QSUNUVVJFXCI6XCJJbnNlcmlyIHVtYSBpbWFnZW1cIixcbiAgXCJFUlJPUlwiOlwiRXJyb1wiLFxuICBcIlVQTE9BRF9FUlJPUlwiOlwiRXJybyBubyBjYXJyZWdhbWVudG9cIixcbiAgXCJDQU1FUkFfQ0FOQ0VMTEVEXCI6XCJDYW1lcmEgY2FuY2VsYWRhXCIsXG4gIFwiU0VUX1VSTFwiOlwiQ29uZmlndXJhbCBVUkxcIixcbiAgXCJESVJFQ1RfTElOS19QSUNUVVJFXCI6XCJMaW5rIHdlYiBkaXJldG8gcGFyYSBhIGltYWdlbVwiLFxuICBcIkNPTU1FTlRfU1VCTUlUVEVEXCI6XCJDb21lbnTDoXJpbyBwb3N0YWRvIVwiLFxuICBcIkRFTEVURV9DT01NRU5UXCI6XCJEZWxldGFyIGNvbWVudMOhcmlvcyDDqSBpcnJldmVyc8OtdmVsXCIsXG4gIFwiREVMRVRFRF9DT01NRU5UXCI6XCJDb21lbnTDoXJpbyBkZWxldGFkb1wiLFxuICBcIlVQTE9BRElOR19QSUNUVVJFXCI6XCJDYXJyZWdhYmRvIGltYWdlbVwiLFxuICBcIlVQTE9BRF9DT01QTEVURURcIjpcIkNhcnJlZ2FtZW50byBjb21wZWxldG9cIixcbiAgXCJVUExPQURfRkFJTEVEXCI6XCJDYXJyZWdhbWVudG8gZmFsaG91XCIsXG4gIFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6XCJBIHNlbmhhIG91IG5vbWUgZGEgY29udGEgZXN0w6NvIGluY29ycmV0b3NcIixcbiAgXCJJTkZPXCI6XCJJbmZvcm1hw6fDtWVzXCIsXG4gIFwiUVJfVEVYVFwiOlwiUG9uaGEgbyBjw7NkaWdvIFFSIGRlbnRybyBkYSDDoXJlYSBkZSBzY2FuXCIsXG4gIFwiQkFMQU5DRV9URVhUXCI6XCJDZXJ0aWZpcXVlLXNlIHF1ZSBwb3NzdWkgc2FsZG8gc3VmaWNpZW50ZSBwYXJhIGEgdHJhbnNhw6fDo28hXCIsXG4gIFwiTk9ORVhJU1RfVVNFUlwiOlwiTyB1dGlsaXphZG9yIHBhcmEgcXVlbSBlc3TDoSBhIHRlbnRhciB0cmFuc2ZlcmlyIGZ1bmRvcywgbsOjbyBleGlzdGVcIixcbiAgXCJUUkFOU0ZFUl9URVhUXCI6XCJUZW0gY2VydGV6YSBxdWUgcXVlciB0cmFuc2ZlcmlyP1wiLFxuICBcIkNPTkZJUk1BVElPTlwiOlwiQ29uZmlybWHDp8Ojb1wiLFxuICBcIlRYX0JST0FEQ0FTVEVEXCI6XCJUcmFuc2HDp8OjbyBmb2kgZGlmdW5kaWRhXCIsXG4gIFwiRkVFRFwiOlwiXCIsXG4gIFwiVFJFTkRJTkdcIjpcIlRlbmRlbmNpYVwiLFxuICBcIkhPVFwiOlwiUXVlbnRlXCIsXG4gIFwiTkVXXCI6XCJOb3ZpZGFkZXNcIixcbiAgXCJQUk9NT1RFRFwiOlwiUHJvbW92aWRvc1wiLFxuICBcIlZPVEVTXCI6XCJWb3Rvc1wiLFxuICBcIlBBWU9VVFwiOlwiUGFnYW1lbnRvXCIsXG4gIFwiQ09NTUVOVFNcIjpcIkNvbWVudMOhcmlvc1wiLFxuICBcIlRSRU5ESU5HXzMwXCI6XCJUZW5kZW5jaWEgYSAzMCBkaWFzXCIsXG4gIFwiU09SVF9QT1NUX0JZXCI6XCJPcmRlbmFyIHB1YmxpY2HDp8O1ZXMgcG9yOlwiLFxuICBcIlBBWU9VVF9DWUNMRVwiOlwiQ2ljbG8gZGUgUGFnYW1lbnRvXCIsXG4gIFwiUE9URU5USUFMX1BBWU9VVFwiOlwiUGFnYW1lbnRvIGVtIHBvdGVuY2lhbFwiLFxuICBcIlBBU1RfUEFZT1VUXCI6XCLDmmx0aW1vIFBhZ2FtZW50b1wiLFxuICBcIkFVVEhPUl9QQVlPVVRcIjpcIlBhZ2FtZW50byBkbyBBdXRvclwiLFxuICBcIkNVUkFUSU9OX1BBWU9VVFwiOlwiUGFnYW1lbnRvIGRlIGN1cmFkb3JpYVwiLFxuICBcIlBPU1RfU1VCTUlUVEVEXCI6XCJQb3N0YWdlbSBlbnZpYWRhIVwiLFxuICBcIlBPU1RfTEFURVJcIjpcIlB1YmxpcXVlIHBhcmEgZnV0dXJhIHN1Ym1pc3PDo29cIixcbiAgXCJTQVZFRFwiOlwiU2Fsdm9cIixcbiAgXCJDTEVBUkVEXCI6XCJMaW1wb1wiLFxuICBcIkZMQUdHSU5HX1RFWFRcIjpcIlBvciBCYW5kZWlyYSBudW1hIHB1YmxpY2HDp8OjbyBwb2RlIHJlbW92ZXIgcmVjb21wZW5zYXMgZSB0b3JuYXIgbyBtYXRlcmlhbCBtZW5vcyB2aXNpdmVsLjxicj48YnI+QSBiYW5kZWlyYSBkZXYgc2VyIHVzYWRhIHBhcmEgOiA8dWw+PGxpPkZyYXVkZSBvdSBQbGFnaWFyaXNtbzwvbGk+PGxpPkRpc2N1cnNvIGRlIMOzZGlvIG91IEludGVybmV0IFRyb2xsaW5nPC9saT48bGk+Q2F0ZWdvcml6YcOnw6NvIG1hbCBmZWl0YSBpbnRlbmNpb25hbG1lbnRlIG91IFNwYW08L2xpPjwvdWw+XCIsXG4gIFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6XCJMaW1pdGUgZGUgcGVkaWRvcyBhdGluZ2lkby4gdmVyaWZpcXVlIG91dHJvIGFzc3VudG8vZXRpcXVldGEhXCIsXG4gIFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6XCJQb3N0YWdlbSByZW1vdmlkYSBkb3MgZmF2b3JpdG9zIVwiLFxuICBcIlBPU1RfSVNfQk9PS01BUktcIjpcIlBvc3RhZ2VtIGFkaWNpb25hZGEgYW9zIGZhdm9yaXRvcyFcIixcbiAgXCJSRVNFVFwiOlwiUmVpbmljaWFyXCIsXG4gIFwiTU9ESUZZX1BJQ1RVUkVcIjpcIk1vZGlmaWNhciBmb3RvIGRlIHBlcmZpbFwiLFxuICBcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6XCJNb2RpZmljYXIgZm90byBkZSBjYXBhXCIsXG4gIFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6XCJQb3IgZmF2b3IgZm9ybmHDp2EgYSBjaGF2ZSBkZSBhY3RpdmHDp8OjbyBwcml2YWRhIHF1ZSBlc2NvbGhldSwgTW9kbyBkZSBMb2dpbiBBdmFuw6dhZG9cIixcbiAgXCJSRVNFVF9QSUNUVVJFX1RFWFRcIjpcIklzdG8gcmVjb25maWd1cmEgYSBpbWFnZW0gZG8gcGVyZmlsIHVsdGl6YWRvclwiLFxuICBcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOlwiSXN0byByZWNvbmZpZ3VyYSBhIGltYWdlbSBkbyB1bHRpemFkb3JcIixcbiAgXCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOlwiQXR1YWxpemHDp8OjbyBkbyBzZXJ2ZXIgb2JyaWdhIGEgUmVpbmljaWFyIVwiLFxuICBcIlNFVFRJTkdTX1VQREFURURcIjpcIkNvbmZpZ3VyYcOnw7VlcyBmb3JhbSBhdHVhbGl6YWRhc1wiLFxuICBcIkxBTkdVQUdFU1wiOlwiTMOtbmd1YXNcIixcbiAgXCJMQU5HVUFHRVNfVEVYVFwiOlwiQXF1aSBwb2RlIG11ZGFyIGEgbMOtbmd1YSBkYSBBcHBcIixcbiAgXCJMT0dJTl9UT19YXCI6XCJFc3Qgb3BlcmHDp8OjbyBvYnJpZ2EgcXVlIG8gdXRpbGl6YWRvciBlc3RhamEgbGlnYWRvIGNvbSBhIHNlbmhhIHByaW5pcGFsLCBjaGF2ZSBhY3RpdmHDp8Ojby9wdWJsaWNhw6fDo29cIixcbiAgXCJHQUxMRVJZXCI6XCJHYWxlcmlhXCIsXG4gIFwiVFJBTlNMQVRJT05TXCI6XCJUcmFkdXRvcmVzIHF1ZSBjb250cmlidWlyYW1cIixcbiAgXCJTSEFSRVwiOlwiUGFydGlsaGFyXCIsXG4gIFwiTUFSS0VUUExBQ0VcIjpcIk1lcmNhZG9cIixcbiAgXCJFWENIQU5HRVwiOlwiQ2FtYmlvXCIsXG4gIFwiRFJBRlRTXCI6XCJSYXNjdW5ob3NcIixcbiAgXCJQT1NUX0lTX1VORFJBRlRcIjpcIlBvc3RhZ2VtIHJlbW92aWRhIGRvcyBSYXNjdW5ob3MhXCIsXG4gIFwiUE9TVF9JU19EUkFGVFwiOlwiUG9zdGFnZW0gYWRpY2lvbmFkYSBhIFJhc2N1bmhvcyFcIixcbiAgXCJTV0lQRV9MRUZUXCI6XCJSb2xlIHBhcmEgYSBlc3F1ZXJkYSBwYXJhIG9ww6fDtWVzXCIsXG4gIFwiTUFOQUdFXCI6XCJHZXJpclwiLFxuICBcIklNQUdFX1JFTU9WRURcIjpcIkltYWdlLiByZW1vdmlkYVwiLFxuICBcIkNPUFlcIjpcIkNvcGlhclwiLFxuICBcIk5PX0lNQUdFXCI6XCJOw6NvIGNhcnJlZ291IG5lbmh1bWEgaW1hZ2VtLCBhaW5kYVwiLFxuICBcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6XCJDYXJyZWd1ZSBwYXJhIHJlZnJlc2NhclwiLFxuICBcIkVYVEVSTkFMX0FQUFNcIjpcIkFwcHMgRXh0ZXJuYXNcIixcbiAgXCJQTFVHSU5TXCI6XCJcIixcbiAgXCJTVUdHRVNUXCI6XCJTdWdpcmFcIixcbiAgXCJDT01JTkdfU09PTlwiOlwiQnJldmVtZW50ZVwiLFxuICBcIkNIQUlOXCI6XCJcIixcbiAgXCJDSEFJTl9URVhUXCI6XCJBcXVpIHBvZGUgZXNjb2xoZXIgYmxvY2tjaGFpbiBvdSBhIHBsYXRhZm9ybWEgcG9yIGRlZmVpdG9cIixcbiAgXCJDVVJSRU5DWVwiOlwiXCIsXG4gIFwiQ1VSUkVOQ1lfVEVYVFwiOlwiXCIsXG4gIFwiQUJPVVRfMTFcIjpcIlwiLFxuICBcIkZPVU5ERVJcIjpcIlwiLFxuICBcIkFERF9BQ0NPVU5UXCI6XCJcIixcbiAgXCJQTEFURk9STVwiOlwiXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiSE9NRVwiOlwiUMOhZ2luYSBJbmljaWFsXCIsXG4gIFwiTE9HSU5cIjpcIkVudHJhclwiLFxuICBcIkxPR09VVFwiOlwiU2FpclwiLFxuICBcIlBST0ZJTEVcIjpcIlBlcmZpbFwiLFxuICBcIkZPTExPV1wiOlwiU2VndWlyXCIsXG4gIFwiQk9PS01BUktTXCI6XCJGYXZvcml0b3NcIixcbiAgXCJUUkFOU0ZFUlwiOlwiVHJhbnNmZXJpclwiLFxuICBcIk1BUktFVFwiOlwiTWVyY2Fkb1wiLFxuICBcIlNFVFRJTkdTXCI6XCJDb25maWd1cmHDp8O1ZXNcIixcbiAgXCJBQk9VVFwiOlwiU29icmVcIixcbiAgXCJBQk9VVF8xXCI6XCJPbmRlIHF1YWxxdWVyIHVtIHBvZGUgZ2FuaGFyIHJlY29tcGVuc2FzIHBlbG8gc2V1IGNvbnRlw7pkb1wiLFxuICBcIkFCT1VUXzJcIjpcIsOJIHBhdHJvY2luYWRvIHBlbGEgcGxhdGFmb3JtYSB7e3BsYXRmb3JtbmFtZX19LiBBcGxpY2F0aXZvIGNyaWFkbyBwb3JcIixcbiAgXCJBQk9VVF8zXCI6XCJlIMOpIGPDs2RpZ28tYWJlcnRvLCBwcm9qZWN0byBvcmllbnRhZG8gcGFyYSBhIGNvbXVuaWRhZGUgbcOzdmVsLiBPZmVyZWNlIGFjZXNzbyBhbyBjb250ZcO6ZG8gcGFyYSBsZWl0dXJhLCBjb21lbnTDoXJpb3MsIHZvdG9zLCBwdWJsaWNhciwgdHJhbmZlcmlyIGdhbmhvcyBldGMuIENhcmF0ZXJpc3RpY2FzIG9mZXJlY2lkYXMgcG9yIHt7cGxhdGZvcm1uYW1lfX0gYmxvY2tjaGFpbiBhbmQge3tzaXRlbmFtZX19LlwiLFxuICBcIkFCT1VUXzRcIjpcIjEuIE8gYXBsaWNhdGl2byBudW5jYSBhY2Vzc2Egb3UgZ3VhcmRhIG8gZGluaGVpcm8gZG9zIHV0aWxpemFkb3Jlcy5cIixcbiAgXCJBQk9VVF81XCI6XCIyLiBBIEFwcCBvZmVyZWNlIHVtIG1vZGVsbyBzZWd1cm8gZG8gbGFkby1jbGllbnRlLCBjb20gY2hhdmVzIHByaXZhZGFzLCBndWFyZGFkYXMgbG9jYWxtZW50ZSBlIG51bmNhIGVudmlhZGEgcGFyYSBvdXRyb3Mgc2Vydmlkb3Jlcy5cIixcbiAgXCJBQk9VVF82XCI6XCIzLiBPIEFwbGljYXRpdm8gb2ZlcmVjZSBzaW1wbGljaWRhZGUsIGludGVyZmFjZXMgZGUgdXRpbGl6YWRvciBlIGV4cGVyacOqbmNpYXMgYXRyYXRpdmFzLlwiLFxuICBcIkFCT1VUXzdcIjpcIjQuIE8gQXBsaWNhdGl2byByZXF1ZXIgcXVlIG9zIHV0aWxpemFkb3JlcyBpbnNpcmFtIGluZm9ybWHDp8O1ZXMgcGVzc29haXMuXCIsXG4gIFwiQUJPVVRfOFwiOlwiVm90ZSBib20ta2FybWEgY29tbyB0ZXN0ZW11bmhhXCIsXG4gIFwiQUJPVVRfOVwiOlwiQ29udGF0by9Db21lbnTDoXJpb3NcIixcbiAgXCJBQk9VVF8xMFwiOlwiTWFpcyBpbmZvcm1hw6fDtWVzOlwiLFxuICBcIlJFTU9WRVwiOlwiUmVtb3ZlclwiLFxuICBcIk1BUktFVF9WSUVXXCI6XCJWaXPDo28gZG8gTWVyY2Fkb1wiLFxuICBcIlBSSUNFXCI6XCJQcmXDp29cIixcbiAgXCJBTU9VTlRcIjpcIlF1YW50aWRhZGVcIixcbiAgXCJUT1RBTFwiOlwiXCIsXG4gIFwiTk9PUkRFUlNcIjpcIlNlbSBvcmRlbnMgYWJlcnRhcyBwYXJhXCIsXG4gIFwiREFURVwiOlwiRGF0YVwiLFxuICBcIkJVWVwiOlwiQ29tcHJhclwiLFxuICBcIlNFTExcIjpcIlZlbmRlclwiLFxuICBcIk9QRU5cIjpcIkFicmlyXCIsXG4gIFwiSElTVE9SWVwiOlwiSGl0w7NyaWNvXCIsXG4gIFwiRk9MTE9XX0JBQ0tcIjpcIlNlZ3VpciBkZSB2b2x0YVwiLFxuICBcIkZPTExPV0VEXCI6XCJTZWd1aWRvXCIsXG4gIFwiVU5GT0xMT1dcIjpcIkRlaXhhciBkZSBzZWd1aXJcIixcbiAgXCJGT0xMT1dJTkdcIjpcIlNlZ3VpbmRvXCIsXG4gIFwiRk9MTE9XRVJTXCI6XCJTZWd1aWRvcmVzXCIsXG4gIFwiU0VBUkNIX0ZPTExPV0VSU1wiOlwiUHJvY3VyYXIgc2VndWlkb3Jlc1wiLFxuICBcIlNFQVJDSF9GT0xMT1dJTkdcIjpcIlByb2N1cmFyIHF1ZW0gZXN0b3UgYSBzZWd1aXJcIixcbiAgXCJCWVwiOlwicG9yXCIsXG4gIFwiSU5cIjpcIm5vXCIsXG4gIFwiTUVOVVwiOlwiXCIsXG4gIFwiQk9PS01BUktcIjpcIkZhdm9yaXRvc1wiLFxuICBcIlJFQkxPR1wiOlwiUmVwb3N0YXJcIixcbiAgXCJVUFZPVEVcIjpcIlVwdm90ZSBcIixcbiAgXCJET1dOVk9URVwiOlwiXCIsXG4gIFwiVU5WT1RFX0RPV05WT1RFRFwiOlwiQ2FuY2VsYXIgRG93bnZvdGVcIixcbiAgXCJVTlZPVEVfVVBWT1RFRFwiOlwiQ2FuY2VsYXIgVXB2b3RlXCIsXG4gIFwiUkVQTFlcIjpcIlJlc3BvbmRlclwiLFxuICBcIkVESVRcIjpcIkVkaXRhclwiLFxuICBcIlBPU1RfMVwiOlwiRGVzbGl6ZSBwYXJhIGVzcXVlcmRhIG5vcyBjb21lbnTDoXJpb3MgcGFyYSB2ZXJhcyBvcMOnw7Vlc1wiLFxuICBcIlBPU1RfMlwiOlwiVG9xdWUgbm9zIGNvbWVudMOhcmlvcyBwYXJhIHZlciBvcyBzdWItY29tZW50w6FyaW9zXCIsXG4gIFwiT1BUSU9OU1wiOlwiT3DDp8O1ZXNcIixcbiAgXCJSRVNURUVNRURfQllcIjpcIlJlcG9zdGFkbyBwb3JcIixcbiAgXCJOT1RISU5HX0hFUkVcIjpcIk5hZGEgcG9yIGFxdWksIGFpbmRhLi4uXCIsXG4gIFwiQkFMQU5DRVNcIjpcIkJhbGFuw6dvXCIsXG4gIFwiUFJPRklMRV8xXCI6XCJ7e3BsYXRmb3JtbmFtZX19LCBwcm92YXMgdHJhbnNhY2lvbsOhdmVpcyBxdWUgcG9kZW0gc2VyIHRyYW5zZmVyaWRhcyBlbSBxdWFscXVlciBhbHR1cmEuIHt7cGxhdGZvcm1uYW1lfX0gcG9kZW0gc2VyIGNvbnZlcnRpZGFzIHt7cGxhdGZvcm1wb3dlcn19IG51bSBwcm9jZXNzbyBjaGFtYWRvIHBvZGVyIGFiYWl4by5cIixcbiAgXCJQUk9GSUxFXzJcIjpcInt7cGxhdGZvcm1wb3dlcn19LCB0b2tlbnMgZGUgaW5mbHVlbmNpYSBwYXJhIGdhbmhhciBtYWlzIHBvZGVyIHBhcmEgZ3VhcmRhciBhIGxvbmdvIHByYXpvIGUgdm90YXIgbmFzIHB1YmxpY2HDp8O1ZXMuIFF1YW50byBtYWlzIHNlIHBvc3N1aSBtYWlzIHNlIHBvZGUgaW5mbHVlbmNpYXIgYXMgcmVjb21wZW5zYXMgcGFyYSBvdXRyb3MgZSBnYW5oYXIgbWFpcyByZWNvbXBlbnNhcyBwb3Igdm90YXIuXCIsXG4gIFwiUFJPRklMRV8zXCI6XCJQcm92YXMgcXVlIHZhbGVtIGNlcmNhIGRlIHt7cGxhdGZvcm1zdW5pdH19IGRlIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG4gIFwiRVNUSU1BVEVEX1ZBTFVFXCI6XCJWYWxvciBlc3RpbWFkb1wiLFxuICBcIlBST0ZJTEVfNFwiOlwiTyB2YWxvciBlc3RpbWFkbyDDqSBiYXNlYWRvIG51bWEgbcOpZGlhIGRvIHZhbG9yIGRlIDcgZGlhcyBkZSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuICBcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjpcIkhpc3TDs3JpY28gZGUgVHJhbnNhw6fDo29cIixcbiAgXCJQT1NUSU5HXCI6XCJQdWJsaWNhbmRvXCIsXG4gIFwiUFJPRklMRV81XCI6XCJBIGNoYXZlIGRlIHB1YmxpY2HDp8OjbyDDqSB1c2FkYSBwYXJhIHB1YmxpY2FyIGUgdm90YXIuIEVsYSBkZXZlIHNlciBkaWZlcmVudGUgZGEgY2hhdmUgZGUgYXRpdmHDp8OjbyBlIGRhIGNoYXZlIGRlIHByb3ByaWV0w6FyaW8uXCIsXG4gIFwiT1dORVJcIjpcIlByb3ByaWV0w6FyaW9cIixcbiAgXCJQUk9GSUxFXzZcIjpcIkEgY2hhdmUgZGUgcHJvcHJpZXTDoXJpbyDDqSBhIGNoYXZlIG1lc3RyYSBwYXJhIGNvbnRhIGUgw6kgZXhpZ2lkYSBwYXJhIG11ZGFyIGFzIG91dHJhcyBjaGF2ZXMuIFVtYSBjaGF2ZSBwcml2YWRhIG91IHNlbmhhIHBhcmEgYSBjaGF2ZSBkZSBwcm9wcmlldMOhcmlvIGRldmVyw6Egc2VyIG1hbnRpZGEgb2ZmbGluZSBhc3NpbSBxdWUgcG9zc8OtdmVsLlwiLFxuICBcIkFDVElWRVwiOlwiQXRpdm9cIixcbiAgXCJQUk9GSUxFXzdcIjpcIkEgY2hhdmUgZGUgYXRpdmHDp8OjbyDDqSB1c2FkYSBwYXJhIGZhemVyIHRyYW5zZmVyw6puY2lhcyBlIGNvbG9jYXIgb3JkZW5zIG5vIG1lcmNhZG8gaW50ZXJuby5cIixcbiAgXCJNRU1PXCI6XCJBbm90YcOnw7Vlc1wiLFxuICBcIlBST0ZJTEVfOFwiOlwiQSBjaGF2ZSBkZSBhbm90YcOnw7VlcyDDqSB1c2FkYSBwYXJhIGNyaWFyIGUgbGVyIGFub3Rhw6fDtWVzLlwiLFxuICBcIkJMT0dcIjpcIlwiLFxuICBcIlBPU1RTXCI6XCJQdWJsaWNhw6fDtWVzXCIsXG4gIFwiUkVQTElFU1wiOlwiUmVzcG9zdGFzXCIsXG4gIFwiV0FMTEVUXCI6XCJDYXJ0ZWlyYVwiLFxuICBcIlRBR1wiOlwiXCIsXG4gIFwiVVNFUlwiOlwiVXRpbGl6YWRvclwiLFxuICBcIkNMT1NFXCI6XCJGZWNoYWRvXCIsXG4gIFwiVE9cIjpcIlBhcmFcIixcbiAgXCJBU1NFVFwiOlwiQXRpdm9cIixcbiAgXCJTRU5EXCI6XCJFbnZpYXJcIixcbiAgXCJTRUNVUklUWVwiOlwiU2VndXJhbsOnYVwiLFxuICBcIkFWQUlMQUJMRVwiOlwiRGlzcG9uw612ZWxcIixcbiAgXCJQVUJMSUNfTUVNT1wiOlwiTWVtb3JhbmRvIFDDumJsaWNvXCIsXG4gIFwiVE9fREVTQ1wiOlwiVXRpbGl6YWRvciBleDogZ29vZC1rYXJtYVwiLFxuICBcIlBJTl9DT0RFXCI6XCJDw7NkaWdvIFBpblwiLFxuICBcIlBJTl9URVhUXCI6XCJDw7NkaWdvIFBpbiBhanVkYSBhIGFzc2VndXJhciBvIGFwbGljYXRpdm8gZSBzdWFzIGluZm9ybWHDp8O1ZXMuIDxici8+PGJyLz4gVW1hIHZleiBhdGl2YWRvLCB0ZXLDoSBubyBtw6F4aW1vIDQgdGVudGF0aXZhcyBwYXJhIGRlc3RyYXZhciwgc2UgZXNxdWVjZXIgbyBwaW4gb3UgZXJyYXIsIG8gYXBsaWNhdGl2byBpcsOhIHJlbW92ZXIgc3VhcyBpbmZvcm1hw6fDtWVzIGRlIHV0aWxpemFkb3IuIFBvZGUgZW50cmFyIGRlIG5vdm8gZSBjb250aW51YXIgYSB1c2FyIG8gYXBsaWNhdGl2by5cIixcbiAgXCJOT1RJRklDQVRJT05TXCI6XCJOb3RpZmljYcOnw7Vlc1wiLFxuICBcIlZPVEVfVEVYVFwiOlwiVm9jw6ogcmVjZWJlcsOhIHVtYSBub3RpZmljYcOnw6NvIHF1YW5kbyBhbGd1w6ltIHZvdGFyIG5vIHNldSBjb250ZcO6ZG8hIE5vdGlmaWNhw6fDtWVzIHRhbWLDqW0gaW5jbHVlbSBwZXNvIGRlIHZvdG8gbm8gYWxlcnRhIGRhIG1lbnNhZ2VtLikgc2VqYSB2b3RvIHBvc2l0aXZvLCB2b3RvIG5lZ2F0aXZvLCB2b3RvIG51bG8pLlwiLFxuICBcIlZPVEVcIjpcIlZvdGFyXCIsXG4gIFwiQ09NTUVOVF9URVhUXCI6XCJSZWNlYmUgdW1hIG5vdGlmaWNhw6fDo28gcXVhbmRvIGFsZ3XDqW0gY29tZW50YXIgbmFzIHN1YXMgcHVibGljYcOnw7VlcyBvdSBjb21lbnTDoXJpb3MuPGJyLz4gTm90aWZpY2HDp8O1ZXMgaW5jbHVlbSBxdWFuZG8gYWxndcOpbSBlZGl0YSBvcyBjb21lbnTDoXJpb3MgdGFtYsOpbS5cIixcbiAgXCJDT01NRU5UXCI6XCJDb21lbnRhclwiLFxuICBcIkZPTExPV19URVhUXCI6XCJSZWNlYmUgc2VtcHJlIHVtYSBub3RpZmljYcOnw6NvIHF1YW5kbyBhbGd1w6ltIFNlZ3VpciBvdSBEZWl4YXIgZGUgc2VndWktbG8hXCIsXG4gIFwiTUVOVElPTlNcIjpcIk1lbsOnw7Vlc1wiLFxuICBcIk1FTlRJT05TX1RFWFRcIjpcIlJlY2ViZSBzZW1wcmUgdW1hIG5vdGlmaWNhw6fDo28gcXVhbmRvIGFsZ3XDqW0gbyBtZW5jaW9uYXIgbmFsZ3VtYSBwdWJsaWNhw6fDo28gb3UgY29tZW50w6FyaW8hXCIsXG4gIFwiUkVTVEVFTVwiOlwiXCIsXG4gIFwiUkVTVEVFTV9URVhUXCI6XCJJcsOhIHJlY2ViZXIgbm90aWZpY2HDp8OjbyBxdWFuZG8gYWxndWVtIHJlcHVibGljYXIgYSBzdWEgcHVibGljYcOnw6MhXCIsXG4gIFwiQ09ORklHVVJBVElPTlNcIjpcIkNvbmZpZ3VyYcOnw7Vlc1wiLFxuICBcIlZPVElOR1wiOlwiVm90YW5kb1wiLFxuICBcIlZPVElOR19URVhUXCI6XCJPIHBlc28gZGUgdm90byBvdSBwZXJjZW50YWdlbSBhZmV0YSBvIHBvZGVyIGRlIHZvdG8gbmEgYXBwLCBwb3IgaXNzbyBwb2RlIHJlZ3VsYXIgbyBzZXUgcmVjb21wZW5zYSBkZSB2b3RvIDxici8+PGJyLz48Yj5Ob3RhOjwvYj4gSXN0byBpcsOhIG1vZGlmaWNhciBvIHBlc28vcGVyY2VudGFnZW0gcGFyYSB2b3RhciBwYXJhIGJhaXhvIHRhbWLDqW0gZSBlbSB0b2RvIG8gbGFkbyBuYSBBcHBcIixcbiAgXCJTRVJWRVJcIjpcIlNlcnZpZG9yXCIsXG4gIFwiU0VSVkVSX1RFWFRcIjpcIlJlY29tZW5kYWRvXCIsXG4gIFwiU0FWRV9DSEFOR0VTXCI6XCJTYWx2YXIgbXVkYW7Dp2FzXCIsXG4gIFwiVk9URVJTX0lORk9cIjpcIkluZm9ybWHDp8O1ZXMgZG9zIGVsZWl0b3Jlc1wiLFxuICBcIldFTENPTUVfQkFDS1wiOlwiQmVtIHZpbmRvIGRlIFZvbHRhIVwiLFxuICBcIkxPR0lOXzFcIjpcIkNvbmVjdGUtc2UgY29tIHNldSBub21lIGRlIHV0aWxpemFkb3IgZSBzZW5oYSBwYXJhIGNvbnRpbnVhci5cIixcbiAgXCJMT0dJTl8yXCI6XCJDaGF2ZSBkZSBwdWJsaWNhw6fDo28gw6kgdXNhZGEgcGFyYSBwdWJsaWNhciwgY29tZW50YXIsIHZvdGFyLCBzZWd1aXIuXCIsXG4gIFwiTE9HSU5fM1wiOlwiQ2hhdmUgZGUgYXRpdmHDp8OjbyDDqSB1c2FkYSBwYXJhIHRyYW5mZXLDqm5jaWFzIGUgYXR1YWxpemHDp8OjbyBkZSBmb3RvcyBkZSBwZXJmaWwuXCIsXG4gIFwiTE9HSU5fNFwiOlwiQXMgY3JlZGVuY2lhaXMgZG8gdXRpbGl6YWRvciBzw6NvIGd1YXJkYWRhcyBsb2NhbG1lbnRlIG5vIHNldSBhcGFyZWxoby4gRGVwaXMgZGUgZGVzbGlnYXIgYXMgc3VhcyBjcmVkZW5jaWFpcyBzw6NvIHJlbW92aWRhc1wiLFxuICBcIkRPTlRfSEFWRVwiOlwiTsOjbyBwb3NzdWkgY29udGE/XFxuXCIsXG4gIFwiU0lHTl9VUF9OT1dcIjpcIlJlZ2lzdGUtc2UgYWdvcmFcIixcbiAgXCJDQU5DRUxcIjpcIkNhbmNlbGFyXCIsXG4gIFwiQURWQU5DRURcIjpcIkF2YW7Dp2Fkb1wiLFxuICBcIkFDVElWRV9QUklLRVlcIjpcIkNoYXZlIGRlIGF0aXZhw6fDo28gcHJpdmFkYVwiLFxuICBcIlBPU1RJTkdfUFJJS0VZXCI6XCJDaGF2ZSBkZSBwdWJsaWNhw6fDo28gcHJpdmFkYVwiLFxuICBcIk1BU1RFUl9QQVNTXCI6XCJTZW5oYSBNZXN0cmEvUHJpbmNpcGFsXCIsXG4gIFwiVVNFUk5BTUVcIjpcIlV0aWxpemFkb3JcIixcbiAgXCJDQVJEX1ZJRVdcIjpcIlZpc8OjbyBkZSBDYXJ0w6NvXCIsXG4gIFwiQ09NUEFDVF9WSUVXXCI6XCJWaXN0YSBjb21wYWN0YVwiLFxuICBcIlNFQVJDSFwiOlwiUHJvY3VyYXJcIixcbiAgXCJTVUJNSVRfQV9TVE9SWVwiOlwiUHVibGljYXIgdW1hIGhpc3TDs3JpYVwiLFxuICBcIlJFUExZVE9cIjpcIlJlc3BvbmRlciBwYXJhXCIsXG4gIFwiUE9TVFwiOlwiUHVibGljYcOnw6NvXCIsXG4gIFwiUFJFVklFV1wiOlwiVml6dWFsaXphclwiLFxuICBcIkRFRkFVTFRcIjpcIlBhZHLDo28gNTAlIC8gNTAlXCIsXG4gIFwiUE9XRVJVUFwiOlwiRm9yw6dhIFRvdGFsIDEwMCVcIixcbiAgXCJERUNMSU5FX1BBWU9VVFwiOlwiUmVjdXNhciBQYWdhbWVudG9cIixcbiAgXCJTQVZFX0ZPUl9MQVRFUlwiOlwiR3VhcmRhciBwcmEgbWFpcyB0YXJkZVwiLFxuICBcIkNMRUFSXCI6XCJUZXJtaW5hZG9cIixcbiAgXCJQT1NUX0NPTlRFTlRcIjpcIkNvbnRlw7pkbyBkYSBwdWJsaWNhw6fDo29cIixcbiAgXCJDT01NRU5UX0NPTlRFTlRcIjpcIkNvbnRlw7pkbyBkbyBjb21lbnTDoXJpb1wiLFxuICBcIlRJVExFXCI6XCJUw610dWxvXCIsXG4gIFwiVEFHU1wiOlwiXCIsXG4gIFwiTk9UX01BVENIXCI6XCJOw6NvIGNvbmRpelwiLFxuICBcIkNPTkZJUk1fUElOXCI6XCJDb25maXJtYXIgUGluXCIsXG4gIFwiSU5DT1JSRUNUXCI6XCJJbmNvcnJldG9cIixcbiAgXCJPUEVOSU5HX1BPU1RcIjpcIkFicmluZG8gcG9zdGFnZW1cIixcbiAgXCJTRVRfUElOXCI6XCJDb25maWd1cmUgUElOXCIsXG4gIFwiRU5URVJfUElOXCI6XCJFbnRyYXIgY29tIFBpblwiLFxuICBcIkFSRV9ZT1VfU1VSRVwiOlwiVGVtIGEgY2VydGV6YT9cIixcbiAgXCJSRUJMT0dfVEVYVFwiOlwiUmVwdWJsaWNhciDDqSBpcnJldmVyc8OtdmVsLCBxdWVyIG1lc21vIGNvbnRpbnVhclwiLFxuICBcIkJST0FEQ0FTVF9FUlJPUlwiOlwiRXJybyBkZSBkaWZ1c8OjbywgdGVudGUgbm92YW1lbnRlIVwiLFxuICBcIlNVQ0NFU1NcIjpcIlN1Y2Vzc29cIixcbiAgXCJSRUJMT0dHRURfUE9TVFwiOlwiUHVibGljYcOnw6NvIHJlcHVibGljYWRhXCIsXG4gIFwiTE9HSU5fRkFJTFwiOlwiTG9naW4gZmFsaG91ISBwb3IgZmF2b3IgY2VydGlmaXF1ZS1zZSBxdWUgZXN0w6EgbGlnYWRvIGNvbSBhIHNlbmhhIG1hc3RlciBvdSBhIGNoYXZlIHB1YmxpY2HDp8OjbyBwcml2YWRhIG5vIExvZ2luIHNlIGVzY29saGV1IG8gbW9kbyBhdmFuw6dhZG8uXCIsXG4gIFwiTE9HSU5fRkFJTF9BXCI6XCJMb2dpbiBmYWxob3UhIHBvciBmYXZvciBjZXJ0aWZpcXVlLXNlIHF1ZSBlc3TDoSBjb25ldGFkbyBjb20gYSBzZW5oYSBtYXN0ZXIgb3UgYSBjaGF2ZSBhdGl2YSBwcml2YWRhIG5vIExvZ2luIHNlIGVzY29saGV1IG8gbW9kbyBhdmFuw6dhZG8uXCIsXG4gIFwiV0FSTklOR1wiOlwiQ3VpZGFkb1wiLFxuICBcIlZPVEVfRk9SX1dJVE5FU1NcIjpcIlZvdGFuZG8gcG9yIHVtYSBUZXN0ZW11bmhhXCIsXG4gIFwiVk9URURfRk9SX1dJVE5FU1NcIjpcIlZvdG91IHBvciB1bWEgVGVzdGVtdW5oYVwiLFxuICBcIkFHT1wiOlwiYXRyw6FzXCIsXG4gIFwiRlJPTV9OT1dcIjpcImRlIGFnb3JhXCIsXG4gIFwiU0VDU1wiOlwic2Vnc1wiLFxuICBcIkFfTUlOXCI6XCJ1bSBtaW51dG9cIixcbiAgXCJNSU5TXCI6XCJcIixcbiAgXCJBTl9IT1VSXCI6XCJ1bWEgaG9yYVwiLFxuICBcIkhPVVJTXCI6XCJob3Jhc1wiLFxuICBcIkFfREFZXCI6XCJ1bSBkaWFcIixcbiAgXCJEQVlTXCI6XCJkaWFzXCIsXG4gIFwiQV9NT05USFwiOlwidW0gbcOqc1wiLFxuICBcIk1PTlRIU1wiOlwibWVzZXNcIixcbiAgXCJBX1lFQVJcIjpcInVtIGFub1wiLFxuICBcIllFQVJTXCI6XCJhbm9zXCIsXG4gIFwiTUlOX1JFQURcIjpcImxlciBtaW5cIixcbiAgXCJET1dOVk9URV9GTEFHXCI6XCJWb3RlIHBhcmEgYmFpeG8gb3UgYmFuZGVpcmFcIixcbiAgXCJDQVBUVVJFX1BJQ1RVUkVcIjpcIkNhcHR1cmFyIGltYWdlbVwiLFxuICBcIlNFTEVDVF9QSUNUVVJFXCI6XCJFc2NvbGhlciB1bWEgaW1hZ2VtXCIsXG4gIFwiU0VUX0NVU1RPTV9VUkxcIjpcIkNvbmZpZ3VyZSBVUkwgY29zdHVtaXphZGFcIixcbiAgXCJJTlNFUlRfUElDVFVSRVwiOlwiSW5zZXJpciB1bWEgaW1hZ2VtXCIsXG4gIFwiRVJST1JcIjpcIkVycm9cIixcbiAgXCJVUExPQURfRVJST1JcIjpcIkVycm8gbm8gY2FycmVnYW1lbnRvXCIsXG4gIFwiQ0FNRVJBX0NBTkNFTExFRFwiOlwiQ2FtZXJhIGNhbmNlbGFkYVwiLFxuICBcIlNFVF9VUkxcIjpcIkNvbmZpZ3VyYXJsIFVSTFwiLFxuICBcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjpcIkxpbmsgd2ViIGRpcmV0byBwYXJhIGEgaW1hZ2VtXCIsXG4gIFwiQ09NTUVOVF9TVUJNSVRURURcIjpcIkNvbWVudMOhcmlvIHB1YmxpY2FkbyFcIixcbiAgXCJERUxFVEVfQ09NTUVOVFwiOlwiQXBhZ2FyIGNvbWVudMOhcmlvcyDDqSBpcnJldmVyc8OtdmVsXCIsXG4gIFwiREVMRVRFRF9DT01NRU5UXCI6XCJDb21lbnTDoXJpbyBhcGFnYWRvXCIsXG4gIFwiVVBMT0FESU5HX1BJQ1RVUkVcIjpcIkNhcnJlZ2FuZG8gaW1hZ2VtXCIsXG4gIFwiVVBMT0FEX0NPTVBMRVRFRFwiOlwiQ2FycmVnYW1lbnRvIGNvbXBsZXRvXCIsXG4gIFwiVVBMT0FEX0ZBSUxFRFwiOlwiQ2FycmVnYW1lbnRvIGZhbGhvdVwiLFxuICBcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOlwiQSBzZW5oYSBvdSBub21lIGRhIGNvbnRhIHPDo28gaW5jb3JyZXRvc1wiLFxuICBcIklORk9cIjpcIkluZm9ybWHDp8O1ZXNcIixcbiAgXCJRUl9URVhUXCI6XCJQb25oYSBvIGPDs2RpZ28gUVIgZGVudHJvIGRhIMOhcmVhIGRlIHNjYW5cIixcbiAgXCJCQUxBTkNFX1RFWFRcIjpcIkNlcnRpZmlxdWUtc2UgcXVlIHBvc3N1aSBzYWxkbyBzdWZpY2llbnRlIHBhcmEgYSB0cmFuc2HDp8OjbyFcIixcbiAgXCJOT05FWElTVF9VU0VSXCI6XCJPIHV0aWxpemFkb3IgcGFyYSBxdWVtIGVzdMOhIGEgdGVudGFyIHRyYW5zZmVyaXIgZnVuZG9zLCBuw6NvIGV4aXN0ZVwiLFxuICBcIlRSQU5TRkVSX1RFWFRcIjpcIlRlbSBjZXJ0ZXphIHF1ZSBxdWVyIHRyYW5zZmVyaXI/XCIsXG4gIFwiQ09ORklSTUFUSU9OXCI6XCJDb25maXJtYcOnw6NvXCIsXG4gIFwiVFhfQlJPQURDQVNURURcIjpcIlRyYW5zYcOnw6NvIGZvaSBkaWZ1bmRpZGFcIixcbiAgXCJGRUVEXCI6XCJcIixcbiAgXCJUUkVORElOR1wiOlwiVGVuZGVuY2lhXCIsXG4gIFwiSE9UXCI6XCJRdWVudGVcIixcbiAgXCJORVdcIjpcIk5vdmlkYWRlc1wiLFxuICBcIlBST01PVEVEXCI6XCJQcm9tb3ZpZG9zXCIsXG4gIFwiVk9URVNcIjpcIlZvdG9zXCIsXG4gIFwiUEFZT1VUXCI6XCJQYWdhbWVudG9cIixcbiAgXCJDT01NRU5UU1wiOlwiQ29tZW50w6FyaW9zXCIsXG4gIFwiVFJFTkRJTkdfMzBcIjpcIlRlbmRlbmNpYSBhIDMwIGRpYXNcIixcbiAgXCJTT1JUX1BPU1RfQllcIjpcIk9yZGVuYXIgcHVibGljYcOnw7VlcyBwb3I6XCIsXG4gIFwiUEFZT1VUX0NZQ0xFXCI6XCJDaWNsbyBkZSBQYWdhbWVudG9cIixcbiAgXCJQT1RFTlRJQUxfUEFZT1VUXCI6XCJQYWdhbWVudG8gZW0gcG90ZW5jaWFsXCIsXG4gIFwiUEFTVF9QQVlPVVRcIjpcIsOabHRpbW8gUGFnYW1lbnRvXCIsXG4gIFwiQVVUSE9SX1BBWU9VVFwiOlwiUGFnYW1lbnRvIGRvIEF1dG9yXCIsXG4gIFwiQ1VSQVRJT05fUEFZT1VUXCI6XCJQYWdhbWVudG8gZGUgY3VyYWRvcmlhXCIsXG4gIFwiUE9TVF9TVUJNSVRURURcIjpcIlB1YmxpY2HDp8OjbyBlbnZpYWRhIVwiLFxuICBcIlBPU1RfTEFURVJcIjpcIlB1YmxpcXVlIHBhcmEgZnV0dXJhIHN1Ym1pc3PDo29cIixcbiAgXCJTQVZFRFwiOlwiU2Fsdm9cIixcbiAgXCJDTEVBUkVEXCI6XCJMaW1wb1wiLFxuICBcIkZMQUdHSU5HX1RFWFRcIjpcIlBvciB1bWEgYmFuZGVpcmEgbnVtYSBwdWJsaWNhw6fDo28gcG9kZSByZW1vdmVyIHJlY29tcGVuc2FzIGUgdG9ybmFyIG8gbWF0ZXJpYWwgbWVub3MgdmlzaXZlbC48YnI+PGJyPkEgYmFuZGVpcmEgZGV2ZSBzZXIgdXNhZGEgcGFyYSA6IDx1bD48bGk+RnJhdWRlIG91IFBsYWdpYXJpc21vPC9saT48bGk+RGlzY3Vyc28gZGUgw7NkaW8gb3UgSW50ZXJuZXQgVHJvbGxpbmc8L2xpPjxsaT5DYXRlZ29yaXphw6fDo28gbWFsIGZlaXRhIGludGVuY2lvbmFsbWVudGUgb3UgU3BhbTwvbGk+PC91bD5cIixcbiAgXCJSRVFVRVNUX0xJTUlUX1RFWFRcIjpcIkxpbWl0ZSBkZSBwZWRpZG9zIGF0aW5naWRvLiB2ZXJpZmlxdWUgb3V0cm8gYXNzdW50by9ldGlxdWV0YSFcIixcbiAgXCJQT1NUX0lTX1VOQk9PS01BUktcIjpcIlB1YmxpY2HDp8OjbyByZW1vdmlkYSBkb3MgZmF2b3JpdG9zIVwiLFxuICBcIlBPU1RfSVNfQk9PS01BUktcIjpcIlB1YmxpY2HDp8OjbyBhZGljaW9uYWRhIGFvcyBmYXZvcml0b3MhXCIsXG4gIFwiUkVTRVRcIjpcIlJlaW5pY2lhclwiLFxuICBcIk1PRElGWV9QSUNUVVJFXCI6XCJNb2RpZmljYXIgYSBmb3RvZ3JhZmlhIGRlIHBlcmZpbFwiLFxuICBcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6XCJNb2RpZmljYXIgZm90b2dyYWZpYSBkYSBjYXBhXCIsXG4gIFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6XCJQb3IgZmF2b3IgaW5zaXJhIGEgY2hhdmUgZGUgYWN0aXZhw6fDo28gcHJpdmFkYSBxdWUgZXNjb2xoZXUsIE1vZG8gZGUgTG9naW4gQXZhbsOnYWRvXCIsXG4gIFwiUkVTRVRfUElDVFVSRV9URVhUXCI6XCJJc3RvIHJlY29uZmlndXJhIGEgaW1hZ2VtIGRvIHBlcmZpbCB1bHRpemFkb3JcIixcbiAgXCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjpcIklzdG8gcmVjb25maWd1cmEgYSBpbWFnZW0gZG8gdWx0aXphZG9yXCIsXG4gIFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjpcIkF0dWFsaXphw6fDo28gZG8gc2VydmVyIG9icmlnYSBhIFJlaW5pY2lhciFcIixcbiAgXCJTRVRUSU5HU19VUERBVEVEXCI6XCJDb25maWd1cmHDp8O1ZXMgZm9yYW0gYXR1YWxpemFkYXNcIixcbiAgXCJMQU5HVUFHRVNcIjpcIkzDrW5ndWFcIixcbiAgXCJMQU5HVUFHRVNfVEVYVFwiOlwiQXF1aSBwb2RlIG11ZGFyIGEgbMOtbmd1YSBkYSBBcHBcIixcbiAgXCJMT0dJTl9UT19YXCI6XCJFc3RhIG9wZXJhw6fDo28gb2JyaWdhIHF1ZSBvIHV0aWxpemFkb3IgZXN0YWphIGxpZ2FkbyBjb20gYSBzZW5oYSBwcmluY2lwYWwsIGNoYXZlIGFjdGl2YcOnw6NvL3B1YmxpY2HDp8Ojb1wiLFxuICBcIkdBTExFUllcIjpcIkdhbGVyaWFcIixcbiAgXCJUUkFOU0xBVElPTlNcIjpcIlRyYWR1dG9yZXMgcXVlIGNvbnRyaWJ1aXJhbVwiLFxuICBcIlNIQVJFXCI6XCJQYXJ0aWxoYXJcIixcbiAgXCJNQVJLRVRQTEFDRVwiOlwiTWVyY2Fkb1wiLFxuICBcIkVYQ0hBTkdFXCI6XCJDw6JtYmlvXCIsXG4gIFwiRFJBRlRTXCI6XCJSYXNjdW5ob3NcIixcbiAgXCJQT1NUX0lTX1VORFJBRlRcIjpcIlB1YmxpY2HDp8OjbyByZW1vdmlkYSBkb3MgUmFzY3VuaG9zIVwiLFxuICBcIlBPU1RfSVNfRFJBRlRcIjpcIlB1cGxpY2HDp8OjbyBhZGljaW9uYWRhIGEgUmFzY3VuaG9zIVwiLFxuICBcIlNXSVBFX0xFRlRcIjpcIlJvbGUgcGFyYSBhIGVzcXVlcmRhIHBhcmEgb3DDp8O1ZXNcIixcbiAgXCJNQU5BR0VcIjpcIkdlcmlyXCIsXG4gIFwiSU1BR0VfUkVNT1ZFRFwiOlwiSW1hZ2VtIHJlbW92aWRhXCIsXG4gIFwiQ09QWVwiOlwiQ29waWFyXCIsXG4gIFwiTk9fSU1BR0VcIjpcIk7Do28gY2FycmVnb3UgbmVuaHVtYSBpbWFnZW0sIGFpbmRhXCIsXG4gIFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjpcIkNhcnJlZ3VlIHBhcmEgcmVmcmVzY2FyXCIsXG4gIFwiRVhURVJOQUxfQVBQU1wiOlwiQXBwcyBFeHRlcm5hc1wiLFxuICBcIlBMVUdJTlNcIjpcIlwiLFxuICBcIlNVR0dFU1RcIjpcIlN1Z2lyYVwiLFxuICBcIkNPTUlOR19TT09OXCI6XCJCcmV2ZW1lbnRlXCIsXG4gIFwiQ0hBSU5cIjpcIlwiLFxuICBcIkNIQUlOX1RFWFRcIjpcIkFxdWkgcG9kZSBlc2NvbGhlciBibG9ja2NoYWluIG91IGEgcGxhdGFmb3JtYSBwb3IgZGVmZWl0b1wiLFxuICBcIkNVUlJFTkNZXCI6XCJcIixcbiAgXCJDVVJSRU5DWV9URVhUXCI6XCJcIixcbiAgXCJBQk9VVF8xMVwiOlwiXCIsXG4gIFwiRk9VTkRFUlwiOlwiXCIsXG4gIFwiQUREX0FDQ09VTlRcIjpcIlwiLFxuICBcIlBMQVRGT1JNXCI6XCJcIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJIT01FXCI6XCLQlNC+0LzQvtC5XCIsXG4gIFwiTE9HSU5cIjpcItCS0L7QudGC0LhcIixcbiAgXCJMT0dPVVRcIjpcItCS0YvQudGC0LhcIixcbiAgXCJQUk9GSUxFXCI6XCLQn9GA0L7RhNC40LvRjFwiLFxuICBcIkZPTExPV1wiOlwi0J/QvtC00L/QuNGB0LDRgtGM0YHRj1wiLFxuICBcIkJPT0tNQVJLU1wiOlwi0JfQsNC60LvQsNC00LrQuFwiLFxuICBcIlRSQU5TRkVSXCI6XCLQn9C10YDQtdCy0LXRgdGC0Lgg0YHRgNC10LTRgdGC0LLQsFwiLFxuICBcIk1BUktFVFwiOlwi0KDRi9C90L7QulwiLFxuICBcIlNFVFRJTkdTXCI6XCLQndCw0YHRgtGA0L7QudC60LhcIixcbiAgXCJBQk9VVFwiOlwi0J4g0L/RgNC+0LPRgNCw0LzQvNC1XCIsXG4gIFwiQUJPVVRfMVwiOlwi0LPQtNC1INC60LDQttC00YvQuSDQvNC+0LbQtdGCINC/0L7Qu9GD0YfQsNGC0Ywg0LLQvtC30L3QsNCz0YDQsNC20LTQtdC90LjQtSDQt9CwINGB0LLQvtC4INC60L7QvdGC0LXQvdGCIVwiLFxuICBcIkFCT1VUXzJcIjpcItC+0YHQvdC+0LLQsNC90L4g0L3QsCDQv9C70LDRgtGE0L7RgNC80LUge3twbGF0Zm9ybW5hbWV9fS4g0J/RgNC40LvQvtC20LXQvdC40LUg0YHQvtC30LTQsNC90L5cIixcbiAgXCJBQk9VVF8zXCI6XCLQuCDRj9Cy0LvRj9C10YLRgdGPINC80L7QsdC40LvRjNC90YvQvCDQv9GA0L7QtdC60YLQvtC8INGBINC+0YLQutGA0YvRgtGL0Lwg0LjRgdGF0L7QtNC90YvQvCDQutC+0LTQvtC8INGD0L/RgNCw0LLQu9GP0LXQvNGL0Lwg0YHQvtC+0LHRidC10YHRgtCy0L7QvC4g0J/RgNC40LvQvtC20LXQvdC40LUg0L/RgNC10LTQvtGB0YLQsNCy0LvRj9C10YIg0LTQvtGB0YLRg9C/INC6INC60L7QvdGC0LXQvdGC0YMg0LTQu9GPINGH0YLQtdC90LjRjywg0LrQvtC80LzQtdC90YLQuNGA0L7QstCw0L3QuNGPLCDQs9C+0LvQvtGB0L7QstCw0L3QuNGPINC4INGA0LDQt9C80LXRidC10L3QuNGPLCDQv9GA0LXQtNC+0YHRgtCw0LLQu9GP0LXRgiDQstC+0LfQvNC+0LbQvdC+0YHRgtGMINC/0LXRgNC10LLQvtC00LAg0YHRgNC10LTRgdGC0LIg0Lgg0LTRgNGD0LPQuNC1INGE0YPQvdC60YbQuNC4LCDQv9GA0LXQtNC70LDQs9Cw0LXQvNGL0LUg0LHQu9C+0LrRh9C10LnQvdC+0Lwge3twbGF0Zm9ybW5hbWV9fSDQuCDRgdC10YDQstC40YHQvtC8IHt7c2l0ZW5hbWV9fS5cIixcbiAgXCJBQk9VVF80XCI6XCIxLiDQn9GA0LjQu9C+0LbQtdC90LjQtSDQvdC1INC40LzQtdC10YIg0LTQvtGB0YLRg9C/0LAg0Log0LTQtdC90LXQttC90YvQvCDRgdGA0LXQtNGB0YLQstCw0Lwg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GPINC4INC90LUg0YPQtNC10YDQttC40LLQsNC10YIg0LjRhTtcIixcbiAgXCJBQk9VVF81XCI6XCIyLiDQn9GA0LjQu9C+0LbQtdC90LjQtSDQuNGB0L/QvtC70YzQt9GD0LXRgiDQvNC+0LTQtdC70Ywg0LHQtdC30L7Qv9Cw0YHQvdC+0YHRgtC4INC90LAg0YHRgtC+0YDQvtC90LUg0LrQu9C40LXQvdGC0LAsINC30LDQutGA0YvRgtGL0LUg0LrQu9GO0YfQuCDRhdGA0LDQvdGP0YLRgdGPINC70L7QutCw0LvRjNC90L4g0Lgg0L3QuNC60L7Qs9C00LAg0L3QtSDQv9C10YDQtdC00LDRjtGC0YHRjyDQvdCwINGB0LXRgNCy0LXRgNCwO1wiLFxuICBcIkFCT1VUXzZcIjpcIjMuINCf0YDQuNC70L7QttC10L3QuNC1INC/0YDQtdC00L7RgdGC0LDQstC70Y/QtdGCINC/0YDQvtGB0YLQvtC5INC4INC/0YDQuNCy0LvQtdC60LDRgtC10LvRjNC90YvQuSDQv9C+0LvRjNC30L7QstCw0YLQtdC70YzRgdC60LjQuSDQuNC90YLQtdGA0YTQtdC50YE7XCIsXG4gIFwiQUJPVVRfN1wiOlwiNC4g0J/RgNC40LvQvtC20LXQvdC40LUg0L3QuNC60L7Qs9C00LAg0L3QtSDRgtGA0LXQsdGD0LXRgiDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y8g0LLQstC10YHRgtC4INC60LDQutC40LUt0LvQuNCx0L4g0L/QtdGA0YHQvtC90LDQu9GM0L3Ri9C1INC00LDQvdC90YvQtS5cIixcbiAgXCJBQk9VVF84XCI6XCLQn9GA0L7Qs9C+0LvQvtGB0L7QstCw0YLRjCDQt9CwINC00LXQu9C10LPQsNGC0LAgZ29vZC1rYXJtYVwiLFxuICBcIkFCT1VUXzlcIjpcItCa0L7QvdGC0LDQutGC0Ysv0J7QsdGA0LDRgtC90LDRjyDRgdCy0Y/Qt9GMOlwiLFxuICBcIkFCT1VUXzEwXCI6XCLQlNC+0L/QvtC70L3QuNGC0LXQu9GM0L3QsNGPINC40L3RhNC+0YDQvNCw0YbQuNGPOlwiLFxuICBcIlJFTU9WRVwiOlwi0KPQtNCw0LvQuNGC0YxcIixcbiAgXCJNQVJLRVRfVklFV1wiOlwi0J7QsdC30L7RgCDRgNGL0L3QutCwXCIsXG4gIFwiUFJJQ0VcIjpcItCm0LXQvdCwXCIsXG4gIFwiQU1PVU5UXCI6XCLQodGD0LzQvNCwXCIsXG4gIFwiVE9UQUxcIjpcItCS0YHQtdCz0L5cIixcbiAgXCJOT09SREVSU1wiOlwi0J3QtdGCINC+0YLQutGA0YvRgtGL0YUg0L7RgNC00LXRgNC+0LIg0YNcIixcbiAgXCJEQVRFXCI6XCLQlNCw0YLQsFwiLFxuICBcIkJVWVwiOlwi0JrRg9C/0LjRgtGMXCIsXG4gIFwiU0VMTFwiOlwi0J/RgNC+0LTQsNGC0YxcIixcbiAgXCJPUEVOXCI6XCLQntGC0LrRgNGL0YLRjFwiLFxuICBcIkhJU1RPUllcIjpcItCY0YHRgtC+0YDQuNGPXCIsXG4gIFwiRk9MTE9XX0JBQ0tcIjpcItCf0L7QtNC/0LjRgdCw0YLRjNGB0Y8g0LLQt9Cw0LjQvNC90L5cIixcbiAgXCJGT0xMT1dFRFwiOlwi0J/QvtC00L/QuNGB0LrQuFwiLFxuICBcIlVORk9MTE9XXCI6XCLQntGC0L/QuNGB0LDRgtGM0YHRj1wiLFxuICBcIkZPTExPV0lOR1wiOlwi0J/QvtC00L/QuNGB0LrQsFwiLFxuICBcIkZPTExPV0VSU1wiOlwi0J/QvtC00L/QuNGB0LDQvdGLXCIsXG4gIFwiU0VBUkNIX0ZPTExPV0VSU1wiOlwi0J/QvtC40YHQuiDQv9C+0LTQv9C40YHRh9C40LrQvtCyXCIsXG4gIFwiU0VBUkNIX0ZPTExPV0lOR1wiOlwi0J/QvtC40YHQuiDQv9C+0LTQv9C40YHQsNC90L3Ri9GFXCIsXG4gIFwiQllcIjpcItC+0YJcIixcbiAgXCJJTlwiOlwi0LJcIixcbiAgXCJNRU5VXCI6XCLQnNC10L3RjlwiLFxuICBcIkJPT0tNQVJLXCI6XCLQl9Cw0LrQu9Cw0LTQutCwXCIsXG4gIFwiUkVCTE9HXCI6XCLQoNC10L/QvtGB0YJcIixcbiAgXCJVUFZPVEVcIjpcItCT0L7Qu9C+0YEg0JfQsFwiLFxuICBcIkRPV05WT1RFXCI6XCLQk9C+0LvQvtGBINCf0YDQvtGC0LjQslwiLFxuICBcIlVOVk9URV9ET1dOVk9URURcIjpcItCh0L3Rj9GC0Ywg0JPQvtC70L7RgSDQn9GA0L7RgtC40LJcIixcbiAgXCJVTlZPVEVfVVBWT1RFRFwiOlwi0KHQvdGP0YLRjCDQk9C+0LvQvtGBINCX0LBcIixcbiAgXCJSRVBMWVwiOlwi0J7RgtCy0LXRgtC40YLRjFwiLFxuICBcIkVESVRcIjpcItCg0LXQtNCw0LrRgtC40YDQvtCy0LDRgtGMXCIsXG4gIFwiUE9TVF8xXCI6XCLQn9GA0L7QstC10LTQuNGC0LUg0L/QsNC70YzRhtC10Lwg0LLQu9C10LLQviDQvdCwINC60L7QvNC80LXQvdGC0LDRgNC40LgsINGH0YLQvtCx0Ysg0YPQstC40LTQtdGC0Ywg0LLQsNGA0LjQsNC90YLRi1wiLFxuICBcIlBPU1RfMlwiOlwi0J3QsNC20LzQuNGC0LUg0L3QsCDQutC+0LzQvNC10L3RgtCw0YDQuNC4LCDRh9GC0L7QsdGLINGD0LLQuNC00LXRgtGMINCy0LvQvtC20LXQvdC90YvQtSDQutC+0LzQvNC10L3RgtCw0YDQuNC4XCIsXG4gIFwiT1BUSU9OU1wiOlwi0J/QsNGA0LDQvNC10YLRgNGLXCIsXG4gIFwiUkVTVEVFTUVEX0JZXCI6XCLQoNC10L/QvtGB0YLQvdGD0YLQvlwiLFxuICBcIk5PVEhJTkdfSEVSRVwiOlwi0JfQtNC10YHRjCDQv9C+0LrQsCDQvdC40YfQtdCz0L4g0L3QtdGCLi4uXCIsXG4gIFwiQkFMQU5DRVNcIjpcItCR0LDQu9Cw0L3RgdGLXCIsXG4gIFwiUFJPRklMRV8xXCI6XCJ7e3BsYXRmb3JtbmFtZX19LCDQv9C10YDQtdC80LXRidCw0LXQvNGL0LUg0YbQuNGE0YDQvtCy0YvQtSDRgtC+0LrQtdC90YssINC60L7RgtC+0YDRi9C1INC80L7Qs9GD0YIg0LHRi9GC0Ywg0L/QtdGA0LXQtNCw0L3RiyDQsiDQu9GO0LHQvtC1INCy0YDQtdC80Y8uIHt7cGxhdGZvcm1uYW1lfX0g0LzQvtC20LXRgiDQsdGL0YLRjCDQutC+0L3QstC10YDRgtC40YDQvtCy0LDQvSDQsiB7e3BsYXRmb3JtcG93ZXJ9fSwg0Y3RgtC+0YIg0L/RgNC+0YbQtdGB0YEg0L3QsNC30YvQstCw0LXRgtGB0Y8gwqvRg9GB0LjQu9C10L3QuNC1IHt7cGxhdGZvcm1uYW1lfX0t0LDCuy5cIixcbiAgXCJQUk9GSUxFXzJcIjpcInt7cGxhdGZvcm1wb3dlcn19LCDQvdC10L/QtdGA0LXQvNC10YnQsNC10LzRi9C1INGG0LjRhNGA0L7QstGL0LUg0YLQvtC60LXQvdGLLCDQuNGFINC60L7Qu9C40YfQtdGB0YLQstC+INGD0LLQtdC70LjRh9C40LLQsNC10YLRgdGPINC/0YDQuCDQtNC+0LvQs9C+0YHRgNC+0YfQvdC+0Lwg0YXRgNCw0L3QtdC90LjQuCDQuCDQs9C+0LvQvtGB0L7QstCw0L3QuNC4INC30LAg0L/QvtGB0YLRiy4g0KfQtdC8INC40YUg0YMg0JLQsNGBINCx0L7Qu9GM0YjQtSwg0YLQtdC8INGB0LjQu9GM0L3QtdC5INCS0Ysg0LLQu9C40Y/QtdGC0LUg0L3QsCDQstC+0LfQvdCw0LPRgNCw0LbQtNC10L3QuNC1INC30LAg0L/QvtGB0YLRiyDQtNGA0YPQs9C40YUg0Lgg0YLQtdC8INCx0L7Qu9GM0YjQtSDQktGLINC/0L7Qu9GD0YfQsNC10YLQtSDQstC+0LfQvdCw0LPRgNCw0LbQtNC10L3QuNC1INC30LAg0YHQstC+0LUg0LPQvtC70L7RgdC+0LLQsNC90LjQtS5cIixcbiAgXCJQUk9GSUxFXzNcIjpcItCi0L7QutC10L3RiyDRgdGC0L7Rj9GCINC/0YDQuNC80LXRgNC90L4ge3twbGF0Zm9ybXN1bml0fX0g0LIge3twbGF0Zm9ybW5hbWV9fSDRjdC60LLQuNCy0LDQu9C10L3RgtC1LlwiLFxuICBcIkVTVElNQVRFRF9WQUxVRVwiOlwi0J7RgNC40LXQvdGC0LjRgNC+0LLQvtGH0L3QsNGPINGB0YLQvtC40LzQvtGB0YLRjFwiLFxuICBcIlBST0ZJTEVfNFwiOlwi0J7RgNC40LXQvdGC0LjRgNC+0LLQvtGH0L3QsNGPINGB0YLQvtC40LzQvtGB0YLRjCDQvtGB0L3QvtCy0LDQvdCwINC90LAgNy3QtNC90LXQstC90L7QuSDRgdGA0LXQtNC90LXQuSDRgdGC0L7QuNC80L7RgdGC0Lgge3twbGF0Zm9ybW5hbWV9fS5cIixcbiAgXCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6XCLQmNGB0YLQvtGA0LjRjyDRgtGA0LDQvdC30LDQutGG0LjQuVwiLFxuICBcIlBPU1RJTkdcIjpcItCf0L7RgdGC0LjQvdCzXCIsXG4gIFwiUFJPRklMRV81XCI6XCLQn9C+0YHRgtC40L3QsyDQutC70Y7RhyDQuNGB0L/QvtC70YzQt9GD0LXRgtGB0Y8g0LTQu9GPINC/0L7RgdGC0LjQvdCz0LAg0Lgg0LPQvtC70L7RgdC+0LLQsNC90LjRjy4g0J7QvSDQtNC+0LvQttC10L0g0L7RgtC70LjRh9Cw0YLRjNGB0Y8g0L7RgiDQsNC60YLQuNCy0L3QvtCz0L4g0LrQu9GO0YfQsCDQuCDQutC70Y7Rh9CwINCy0LvQsNC00LXQu9GM0YbQsC5cIixcbiAgXCJPV05FUlwiOlwi0JLQu9Cw0LTQtdC70LXRhlwiLFxuICBcIlBST0ZJTEVfNlwiOlwi0JrQu9GO0Ycg0LLQu9Cw0LTQtdC70YzRhtCwINGP0LLQu9GP0LXRgtGB0Y8g0LzQsNGB0YLQtdGAINC60LvRjtGH0L7QvCDQtNC70Y8g0LDQutC60LDRg9C90YLQsCDQuCDRgtGA0LXQsdGD0LXRgtGB0Y8g0LTQu9GPINC40LfQvNC10L3QtdC90LjRjyDQtNGA0YPQs9C40YUg0LrQu9GO0YfQtdC5LiDQl9Cw0LrRgNGL0YLRi9C5INC60LvRjtGHINC40LvQuCDQv9Cw0YDQvtC70Ywg0L7RgiDQutC70Y7Rh9CwINCy0LvQsNC00LXQu9GM0YbQsCDQtNC+0LvQttC10L0g0YXRgNCw0L3QuNGC0YzRgdGPINC+0YTQu9Cw0LnQvSwg0L3QsNGB0LrQvtC70YzQutC+INGN0YLQviDQstC+0LfQvNC+0LbQvdC+LlwiLFxuICBcIkFDVElWRVwiOlwi0JDQutGC0LjQstC90YvQuVwiLFxuICBcIlBST0ZJTEVfN1wiOlwi0JDQutGC0LjQstC90YvQuSDQutC70Y7RhyDQuNGB0L/QvtC70YzQt9GD0LXRgtGB0Y8g0LTQu9GPINC/0LXRgNC10LLQvtC00LAg0YHRgNC10LTRgdGC0LIg0Lgg0YDQsNC30LzQtdGJ0LXQvdC40Y8g0L7RgNC00LXRgNC+0LIg0L3QsCDQstC90YPRgtGA0LXQvdC90LXQvCDRgNGL0L3QutC1LlwiLFxuICBcIk1FTU9cIjpcItCf0YDQuNC80LXRh9Cw0L3QuNC1XCIsXG4gIFwiUFJPRklMRV84XCI6XCLQmtC70Y7RhyDQtNC70Y8g0L/RgNC40LzQtdGH0LDQvdC40Lkg0LjRgdC/0L7Qu9GM0LfRg9C10YLRgdGPINC00LvRjyDRgdC+0LfQtNCw0L3QuNGPINC4INGH0YLQtdC90LjRjyDQv9GA0LjQvNC10YfQsNC90LjQuS5cIixcbiAgXCJCTE9HXCI6XCLQkdC70L7Qs1wiLFxuICBcIlBPU1RTXCI6XCLQn9C+0YHRgtGLXCIsXG4gIFwiUkVQTElFU1wiOlwi0J7RgtCy0LXRgtGLXCIsXG4gIFwiV0FMTEVUXCI6XCLQmtC+0YjQtdC70LXQulwiLFxuICBcIlRBR1wiOlwi0KLQtdCzXCIsXG4gIFwiVVNFUlwiOlwi0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GMXCIsXG4gIFwiQ0xPU0VcIjpcItCX0LDQutGA0YvRgtGMXCIsXG4gIFwiVE9cIjpcItCa0L7QvNGDXCIsXG4gIFwiQVNTRVRcIjpcItCQ0LrRgtC40LJcIixcbiAgXCJTRU5EXCI6XCLQntGC0L/RgNCw0LLQuNGC0YxcIixcbiAgXCJTRUNVUklUWVwiOlwi0JHQtdC30L7Qv9Cw0YHQvdC+0YHRgtGMXCIsXG4gIFwiQVZBSUxBQkxFXCI6XCLQlNC+0YHRgtGD0L/QvdC+XCIsXG4gIFwiUFVCTElDX01FTU9cIjpcItCe0LHRidC10LTQvtGB0YLRg9C/0L3QvtC1INC/0YDQuNC80LXRh9Cw0L3QuNC1XCIsXG4gIFwiVE9fREVTQ1wiOlwi0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GMLCDQvdCw0L/RgNC40LzQtdGAIGdvb2Qta2FybWFcIixcbiAgXCJQSU5fQ09ERVwiOlwiUElOLdC60L7QtFwiLFxuICBcIlBJTl9URVhUXCI6XCJQSU4t0LrQvtC0INC/0L7QvNC+0LbQtdGCINCS0LDQvCDQt9Cw0YnQuNGC0LjRgtGMINC/0YDQuNC70L7QttC10L3QuNC1INC4INCS0LDRiNC4INC00LDQvdC90YvQtS4gPGJyLz48YnIvPjxiPtCf0YDQuNC80LXRh9Cw0L3QuNC1OjwvYj4g0J/QvtGB0LvQtSDQstC60LvRjtGH0LXQvdC40Y8sINGDINCS0LDRgSDQtdGB0YLRjCDQvNCw0LrRgdC40LzRg9C8IDQg0L/QvtC/0YvRgtC60Lgg0YDQsNC30LHQu9C+0LrQuNGA0L7QstCw0YLRjCDQv9GA0LjQu9C+0LbQtdC90LjQtSwg0LXRgdC70Lgg0JLRiyDQt9Cw0LHRi9C70LggUElOLdC60L7QtCDQuNC70Lgg0L7RiNC40LHQu9C40YHRjCDQsiDQtdCz0L4g0L3QsNCx0L7RgNC1LCDQv9GA0LjQu9C+0LbQtdC90LjQtSDRg9C00LDQu9C40YIg0LTQsNC90L3Ri9C1INCy0L7RiNC10LTRiNC10LPQviDQsiDRgdC40YHRgtC10LzRgyDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y8uINCS0Ysg0LzQvtC20LXRgtC1INC/0L7QstGC0L7RgNC90L4g0LLRi9C/0L7Qu9C90LjRgtGMINCy0YXQvtC0INC4INC/0YDQvtC00L7Qu9C20LjRgtGMINC40YHQv9C+0LvRjNC30L7QstCw0YLRjCDQv9GA0LjQu9C+0LbQtdC90LjQtS5cIixcbiAgXCJOT1RJRklDQVRJT05TXCI6XCLQo9Cy0LXQtNC+0LzQu9C10L3QuNGPXCIsXG4gIFwiVk9URV9URVhUXCI6XCLQktGLINC/0L7Qu9GD0YfQuNGC0LUg0YPQstC10LTQvtC80LvQtdC90LjQtSwg0LrQvtCz0LTQsCDQutGC0L4g0YLQviDQs9C+0LvQvtGB0YPQtdGCINC30LAg0JLQsNGIINC60L7QvdGC0LXQvdGCISA8YnIvPjxiPtCf0YDQuNC80LXRh9Cw0L3QuNC1OjwvYj4g0KPQstC10LTQvtC80LvQtdC90LjRjyDQvtGC0L7QsdGA0LDQttCw0Y7RgiDQstC10YEg0LPQvtC70L7RgdCwINCyINGB0L7QvtCx0YnQtdC90LjQuCAo0LHRg9C00Ywg0YLQviDQk9C+0LvQvtGBINCX0LAsINCT0L7Qu9C+0YEg0J/RgNC+0YLQuNCyLCDRgdC90Y/RgtC40LUg0JPQvtC70L7RgdCwKS5cIixcbiAgXCJWT1RFXCI6XCLQk9C+0LvQvtGB0L7QstCw0L3QuNC1XCIsXG4gIFwiQ09NTUVOVF9URVhUXCI6XCLQktGLINC/0L7Qu9GD0YfQuNGC0LUg0YPQstC10LTQvtC80LvQtdC90LjQtSwg0LrQvtCz0LTQsCDQutGC0L4t0YLQviDQv9GA0L7QutC+0LzQvNC10L3RgtC40YDRg9C10YIg0JLQsNGI0Lgg0L/QvtGB0YLRiyDQuNC70Lgg0LrQvtC80LzQtdC90YLQsNGA0LjQuCE8YnIvPiA8Yj7Qn9GA0LjQvNC10YfQsNC90LjQtTo8L2I+INCS0Ysg0YLQsNC60LbQtSDQv9C+0LvRg9GH0LjRgtC1INGD0LLQtdC00L7QvNC70LXQvdC40LUsINC10YHQu9C4INC60YLQvi3RgtC+IDxiPtC+0YLRgNC10LTQsNC60YLQuNGA0YPQtdGCPC9iPiDRgdCy0L7QuSDQutC+0LzQvNC10L3RgtCw0YDQuNC5LlwiLFxuICBcIkNPTU1FTlRcIjpcItCa0L7QvNC80LXQvdGC0LDRgNC40LlcIixcbiAgXCJGT0xMT1dfVEVYVFwiOlwi0JLRiyDQv9C+0LvRg9GH0LjRgtC1INGD0LLQtdC00L7QvNC70LXQvdC40LUsINC60L7Qs9C00LAg0LrRgtC+LdGC0L4g0L/QvtC00L/QuNGI0LXRgtGB0Y8g0LjQu9C4INC+0YLQv9C40YjQtdGC0YHRjyDQvtGCINCS0LDRgSFcIixcbiAgXCJNRU5USU9OU1wiOlwi0KPQv9C+0LzQuNC90LDQvdC40Y9cIixcbiAgXCJNRU5USU9OU19URVhUXCI6XCLQktGLINC/0L7Qu9GD0YfQuNGC0LUg0YPQstC10LTQvtC80LvQtdC90LjQtSwg0LrQvtCz0LTQsCDQutGC0L4t0YLQviDRg9C/0L7QvNGP0L3QtdGCINCS0LDRgSDQsiDRgdCy0L7QtdC8INC/0L7RgdGC0LUv0LrQvtC80LzQtdC90YLQsNGA0LjQuSFcIixcbiAgXCJSRVNURUVNXCI6XCLQoNC10L/QvtGB0YLRi1wiLFxuICBcIlJFU1RFRU1fVEVYVFwiOlwi0JLRiyDQv9C+0LvRg9GH0LjRgtC1INGD0LLQtdC00L7QvNC70LXQvdC40LUsINC60L7Qs9C00LAg0LrRgtC+LdGC0L4g0YHQtNC10LvQsNC10YIg0YDQtdC/0L7RgdGCINCS0LDRiNC10LPQviDQv9C+0YHRgtCwIVwiLFxuICBcIkNPTkZJR1VSQVRJT05TXCI6XCLQmtC+0L3RhNC40LPRg9GA0LDRhtC40Y9cIixcbiAgXCJWT1RJTkdcIjpcItCT0L7Qu9C+0YHQvtCy0LDRgtGMXCIsXG4gIFwiVk9USU5HX1RFWFRcIjpcItCS0LXRgSDQs9C+0LvQvtGB0LAg0LIg0L/RgNC+0YbQtdC90YLQsNGFINCy0LvQuNGP0LXRgiDQvdCwINGB0LjQu9GDINCz0L7Qu9C+0YHQsCDQsiDQv9GA0LjQu9C+0LbQtdC90LjQuCwg0YLQsNC6INGH0YLQviDQktGLINC80L7QttC10YLQtSDRgNC10LPRg9C70LjRgNC+0LLQsNGC0Ywg0L3QsNCz0YDQsNC00YMg0L/RgNC4INCz0L7Qu9C+0YHQvtCy0LDQvdC40LguIDxici8+PGJyLz48Yj7Qn9GA0LjQvNC10YfQsNC90LjQtTo8L2I+INCt0YLQviDRgtCw0LrQttC1INC40LfQvNC10L3QuNGCINCy0LXRgSDQk9C+0LvQvtGB0LAg0J/RgNC+0YLQuNCyXCIsXG4gIFwiU0VSVkVSXCI6XCLQodC10YDQstC10YBcIixcbiAgXCJTRVJWRVJfVEVYVFwiOlwi0KDQtdC60L7QvNC10L3QtNC+0LLQsNC90L3Ri9C5XCIsXG4gIFwiU0FWRV9DSEFOR0VTXCI6XCLQodC+0YXRgNCw0L3QuNGC0Ywg0LjQt9C80LXQvdC10L3QuNGPXCIsXG4gIFwiVk9URVJTX0lORk9cIjpcItCY0L3RhNC+0YDQvNCw0YbQuNGPINC+INC/0YDQvtCz0L7Qu9C+0YHQvtCy0LDQstGI0LjRhVwiLFxuICBcIldFTENPTUVfQkFDS1wiOlwi0JTQvtCx0YDQviDQv9C+0LbQsNC70L7QstCw0YLRjCFcIixcbiAgXCJMT0dJTl8xXCI6XCLQp9GC0L7QsdGLINC/0YDQvtC00L7Qu9C20LjRgtGMLCDQstC+0LnQtNC40YLQtSDRgSDQktCw0YjQuNC8INC40LzQtdC90LXQvCDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y8g0Lgg0L/QsNGA0L7Qu9C10LwuXCIsXG4gIFwiTE9HSU5fMlwiOlwi0J/QvtGB0YLQuNC90LMg0LrQu9GO0Ycg0LjRgdC/0L7Qu9GM0LfRg9C10YLRgdGPINC00LvRjyDQvdCw0L/QuNGB0LDQvdC40Y8g0L/QvtGB0YLQvtCyLCDQutC+0LzQvNC10L3RgtCw0YDQuNC10LIsINCz0L7Qu9C+0YHQvtCy0LDQvdC40Y8g0Lgg0L/QvtC00L/QuNGB0L7Qui5cIixcbiAgXCJMT0dJTl8zXCI6XCLQkNC60YLQuNCy0L3Ri9C5INC60LvRjtGHINC40YHQv9C+0LvRjNC30YPQtdGC0YHRjyDQtNC70Y8g0L/QtdGA0LXQstC+0LTQsCDRgdGA0LXQtNGB0YLQsiDQuCDQvtCx0L3QvtCy0LvQtdC90LjRjyDQuNC30L7QsdGA0LDQttC10L3QuNGPINCyINC/0YDQvtGE0LjQu9C1LlwiLFxuICBcIkxPR0lOXzRcIjpcItCj0YfQtdGC0L3Ri9C1INC00LDQvdC90YvQtSDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y8g0YXRgNCw0L3Rj9GC0YHRjyDQu9C+0LrQsNC70YzQvdC+INC90LAg0YPRgdGC0YDQvtC50YHRgtCy0LUuINCf0YDQuCDQktGL0YXQvtC00LUg0YPRh9C10YLQvdGL0LUg0LTQsNC90L3Ri9C1INCx0YPQtNGD0YIg0YPQtNCw0LvQtdC90YshXCIsXG4gIFwiRE9OVF9IQVZFXCI6XCLQndC1INC30LDRgNC10LPQuNGB0YLRgNC40YDQvtCy0LDQvdGLP1wiLFxuICBcIlNJR05fVVBfTk9XXCI6XCLQl9Cw0YDQtdCz0LjRgdGC0YDQuNGA0L7QstCw0YLRjNGB0Y8g0YHQtdC50YfQsNGBXCIsXG4gIFwiQ0FOQ0VMXCI6XCLQntGC0LzQtdC90LBcIixcbiAgXCJBRFZBTkNFRFwiOlwi0KDQsNGB0YjQuNGA0LXQvdC90YvQuSDRgNC10LbQuNC8XCIsXG4gIFwiQUNUSVZFX1BSSUtFWVwiOlwi0JDQutGC0LjQstC90YvQuSDQt9Cw0LrRgNGL0YLRi9C5INC60LvRjtGHXCIsXG4gIFwiUE9TVElOR19QUklLRVlcIjpcItCf0L7RgdGC0LjQvdCzINC30LDQutGA0YvRgtGL0Lkg0LrQu9GO0YdcIixcbiAgXCJNQVNURVJfUEFTU1wiOlwi0JzQsNGB0YLQtdGAL9C+0YHQvdC+0LLQvdC+0Lkg0L/QsNGA0L7Qu9GMXCIsXG4gIFwiVVNFUk5BTUVcIjpcItCY0LzRjyDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y9cIixcbiAgXCJDQVJEX1ZJRVdcIjpcItCa0LDRgNGC0L7Rh9C60LhcIixcbiAgXCJDT01QQUNUX1ZJRVdcIjpcItCa0L7QvNC/0LDQutGC0L3Ri9C5XCIsXG4gIFwiU0VBUkNIXCI6XCLQn9C+0LjRgdC6XCIsXG4gIFwiU1VCTUlUX0FfU1RPUllcIjpcItCU0L7QsdCw0LLQuNGC0Ywg0YHRgtCw0YLRjNGOXCIsXG4gIFwiUkVQTFlUT1wiOlwi0J7RgtCy0LXRgtC40YLRjCDQvdCwXCIsXG4gIFwiUE9TVFwiOlwi0J/QvtGB0YJcIixcbiAgXCJQUkVWSUVXXCI6XCLQn9GA0LXQtNCy0LDRgNC40YLQtdC70YzQvdGL0Lkg0L/RgNC+0YHQvNC+0YLRgFwiLFxuICBcIkRFRkFVTFRcIjpcItCf0L4g0YPQvNC+0LvRh9Cw0L3QuNGOIDUwJSAvIDUwJVwiLFxuICBcIlBPV0VSVVBcIjpcItCX0LDQv9C70LDRgtC40YLRjCAxMDAlINCyIHt7cGxhdGZvcm1wb3dlcn19XCIsXG4gIFwiREVDTElORV9QQVlPVVRcIjpcItCe0YLQutCw0LfQsNGC0YzRgdGPINC+0YIg0LLRi9C/0LvQsNGC0YtcIixcbiAgXCJTQVZFX0ZPUl9MQVRFUlwiOlwi0KHQntCl0KDQkNCd0JjQotCsINCU0JvQryDQn9Ce0KHQm9CV0JTQo9Cu0KnQldCT0J4g0JjQodCf0J7Qm9Cs0JfQntCS0JDQndCY0K9cIixcbiAgXCJDTEVBUlwiOlwi0J7Qp9CY0KHQotCY0KLQrFwiLFxuICBcIlBPU1RfQ09OVEVOVFwiOlwi0KHQvtC00LXRgNC20LDQvdC40LUg0L/QvtGB0YLQsFwiLFxuICBcIkNPTU1FTlRfQ09OVEVOVFwiOlwi0KHQvtC00LXRgNC20LDQvdC40LUg0LrQvtC80LzQtdC90YLQsNGA0LjRj1wiLFxuICBcIlRJVExFXCI6XCLQl9Cw0LPQvtC70L7QstC+0LpcIixcbiAgXCJUQUdTXCI6XCLQotC10LPQuFwiLFxuICBcIk5PVF9NQVRDSFwiOlwi0J3QlSDQodCe0JLQn9CQ0JTQldCd0JjQmVwiLFxuICBcIkNPTkZJUk1fUElOXCI6XCLQn9C+0LTRgtCy0LXRgNC00LjRgtC1IFBJTi3QutC+0LRcIixcbiAgXCJJTkNPUlJFQ1RcIjpcItCd0JXQn9Cg0JDQktCY0JvQrNCd0J5cIixcbiAgXCJPUEVOSU5HX1BPU1RcIjpcItC+0YLQutGA0YvRgtC40LUg0L/QvtGB0YLQsFwiLFxuICBcIlNFVF9QSU5cIjpcItCj0YHRgtCw0L3QvtCy0LjRgtC1IFBJTi3QutC+0LRcIixcbiAgXCJFTlRFUl9QSU5cIjpcItCS0LLQtdC00LjRgtC1IFBJTi3QutC+0LRcIixcbiAgXCJBUkVfWU9VX1NVUkVcIjpcItCS0Ysg0YPQstC10YDQtdC90Ys/XCIsXG4gIFwiUkVCTE9HX1RFWFRcIjpcItCg0LXQv9C+0YHRgiDRj9Cy0LvRj9C10YLRgdGPINC90LXQvtCx0YDQsNGC0LjQvNGL0LwsINCS0Ysg0YXQvtGC0LjRgtC1INC/0YDQvtC00L7Qu9C20LjRgtGMP1wiLFxuICBcIkJST0FEQ0FTVF9FUlJPUlwiOlwi0J3QtSDRg9C00LDQu9C+0YHRjCDRgtGA0LDQvdGB0LvQuNGA0L7QstCw0YLRjCwg0L/QvtC/0YDQvtCx0YPQudGC0LUg0LXRidC1INGA0LDQtyFcIixcbiAgXCJTVUNDRVNTXCI6XCLQo9GB0L/QtdGI0L3QvlwiLFxuICBcIlJFQkxPR0dFRF9QT1NUXCI6XCLQoNC10L/QvtGB0YLQvdGD0YLRi9C5INC/0L7RgdGCIVwiLFxuICBcIkxPR0lOX0ZBSUxcIjpcItCe0YjQuNCx0LrQsCDQstGF0L7QtNCwISDQn9C+0LbQsNC70YPQudGB0YLQsCwg0YPQsdC10LTQuNGC0LXRgdGMLCDRh9GC0L4g0LLRiyDQstC+0YjQu9C4INCyINGB0LjRgdGC0LXQvNGDINGBINC80LDRgdGC0LXRgCDQv9Cw0YDQvtC70LXQvCDQuNC70Lgg0YPQutCw0LfQsNC70Lgg0LfQsNC60YDRi9GC0YvQuSDQn9C+0YHRgtC40L3QsyDQutC70Y7RhyDQv9GA0Lgg0LLRhdC+0LTQtSDQsiDRgdC40YHRgtC10LzRgyDQsiDRgNCw0YHRiNC40YDQtdC90L3QvtC8INGA0LXQttC40LzQtS5cIixcbiAgXCJMT0dJTl9GQUlMX0FcIjpcItCe0YjQuNCx0LrQsCDQstGF0L7QtNCwISDQn9C+0LbQsNC70YPQudGB0YLQsCwg0YPQsdC10LTQuNGC0LXRgdGMLCDRh9GC0L4g0LLRiyDQstC+0YjQu9C4INCyINGB0LjRgdGC0LXQvNGDINGBINC80LDRgdGC0LXRgCDQv9Cw0YDQvtC70LXQvCDQuNC70Lgg0YPQutCw0LfQsNC70Lgg0LfQsNC60YDRi9GC0YvQuSDQkNC60YLQuNCy0L3Ri9C5INC60LvRjtGHINC/0YDQuCDQstGF0L7QtNC1INCyINGB0LjRgdGC0LXQvNGDINCyINGA0LDRgdGI0LjRgNC10L3QvdC+0Lwg0YDQtdC20LjQvNC1LlwiLFxuICBcIldBUk5JTkdcIjpcItCf0YDQtdC00YPQv9GA0LXQttC00LXQvdC40LVcIixcbiAgXCJWT1RFX0ZPUl9XSVRORVNTXCI6XCLQk9C+0LvQvtGB0L7QstCw0YLRjCDQt9CwINC00LXQu9C10LPQsNGC0LBcIixcbiAgXCJWT1RFRF9GT1JfV0lUTkVTU1wiOlwi0J/RgNC+0LPQvtC70L7RgdC+0LLQsNC70Lgg0LfQsCDQtNC10LvQtdCz0LDRgtCwXCIsXG4gIFwiQUdPXCI6XCLQvdCw0LfQsNC0XCIsXG4gIFwiRlJPTV9OT1dcIjpcItGBINGN0YLQvtCz0L4g0LzQvtC80LXQvdGC0LBcIixcbiAgXCJTRUNTXCI6XCLRgdC10LrRg9C90LRcIixcbiAgXCJBX01JTlwiOlwi0LzQuNC90YPRgtCwXCIsXG4gIFwiTUlOU1wiOlwi0LzQuNC90YPRgijRiylcIixcbiAgXCJBTl9IT1VSXCI6XCLRh9Cw0YFcIixcbiAgXCJIT1VSU1wiOlwi0YfQsNGB0LAo0L7QsilcIixcbiAgXCJBX0RBWVwiOlwi0LTQtdC90YxcIixcbiAgXCJEQVlTXCI6XCLQtNC90Y8o0LXQuSlcIixcbiAgXCJBX01PTlRIXCI6XCLQvNC10YHRj9GGXCIsXG4gIFwiTU9OVEhTXCI6XCLQvNC10YHRj9GG0LAo0LXQsilcIixcbiAgXCJBX1lFQVJcIjpcItCz0L7QtFwiLFxuICBcIllFQVJTXCI6XCLQs9C+0LTQsFwiLFxuICBcIk1JTl9SRUFEXCI6XCLQvNC40L0g0YfRgtC10L3QuNGPXCIsXG4gIFwiRE9XTlZPVEVfRkxBR1wiOlwi0JPQvtC70L7RgSDQn9GA0L7RgtC40LIg0LjQu9C4INGE0LvQsNCzXCIsXG4gIFwiQ0FQVFVSRV9QSUNUVVJFXCI6XCLQl9Cw0YXQstCw0YIg0LjQt9C+0LHRgNCw0LbQtdC90LjRj1wiLFxuICBcIlNFTEVDVF9QSUNUVVJFXCI6XCLQktGL0LHQvtGAINC40LfQvtCx0YDQsNC20LXQvdC40Y9cIixcbiAgXCJTRVRfQ1VTVE9NX1VSTFwiOlwi0JfQsNC00LDRgtGMINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjNGB0LrQuNC5IFVSTFwiLFxuICBcIklOU0VSVF9QSUNUVVJFXCI6XCLQktGB0YLQsNCy0LjRgtGMINC40LfQvtCx0YDQsNC20LXQvdC40LVcIixcbiAgXCJFUlJPUlwiOlwi0J7RiNC40LHQutCwXCIsXG4gIFwiVVBMT0FEX0VSUk9SXCI6XCLQntGI0LjQsdC60LAg0L/RgNC4INC30LDQs9GA0YPQt9C60LVcIixcbiAgXCJDQU1FUkFfQ0FOQ0VMTEVEXCI6XCLQl9Cw0YXQstCw0YIg0LjQt9C+0LHRgNCw0LbQtdC90LjRjyDQvtGC0LzQtdC90LXQvVwiLFxuICBcIlNFVF9VUkxcIjpcItCS0YHRgtCw0LLQuNGC0Ywg0YHRgdGL0LvQutGDXCIsXG4gIFwiRElSRUNUX0xJTktfUElDVFVSRVwiOlwi0J/RgNGP0LzQsNGPINGB0YHRi9C70LrQsCDQvdCwINC40LfQvtCx0YDQsNC20LXQvdC40LVcIixcbiAgXCJDT01NRU5UX1NVQk1JVFRFRFwiOlwi0JrQvtC80LzQtdC90YLQsNGA0LjQuSDQvtGC0L/RgNCw0LLQu9C10L0hXCIsXG4gIFwiREVMRVRFX0NPTU1FTlRcIjpcItCj0LTQsNC70LXQvdC40LUg0LrQvtC80LzQtdC90YLQsNGA0LjQtdCyINGP0LLQu9GP0LXRgtGB0Y8g0L3QtdC+0LHRgNCw0YLQuNC80YvQvFwiLFxuICBcIkRFTEVURURfQ09NTUVOVFwiOlwi0KPQtNCw0LvQtdC90L3Ri9C5INC60L7QvNC80LXQvdGC0LDRgNC40LlcIixcbiAgXCJVUExPQURJTkdfUElDVFVSRVwiOlwi0JfQsNCz0YDRg9C30LrQsCDQuNC30L7QsdGA0LDQttC10L3QuNGPXCIsXG4gIFwiVVBMT0FEX0NPTVBMRVRFRFwiOlwi0JfQsNCz0YDRg9C30LrQsCDQt9Cw0LLQtdGA0YjQtdC90LBcIixcbiAgXCJVUExPQURfRkFJTEVEXCI6XCLQndC1INGD0LTQsNC70L7RgdGMINC30LDQs9GA0YPQt9C40YLRjFwiLFxuICBcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOlwi0J3QtdC/0YDQsNCy0LjQu9GM0L3Ri9C5INC/0LDRgNC+0LvRjCDQuNC70Lgg0LjQvNGPINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRj1wiLFxuICBcIklORk9cIjpcItCY0L3RhNC+0YDQvNCw0YbQuNGPXCIsXG4gIFwiUVJfVEVYVFwiOlwi0KDQsNC30LzQtdGB0YLQuNGC0LUgUVIg0LrQvtC0INCy0L3Rg9GC0YDQuCDRgdC60LDQvdC40YDRg9GO0YnQtdC5INC+0LHQu9Cw0YHRgtC4XCIsXG4gIFwiQkFMQU5DRV9URVhUXCI6XCLQo9Cx0LXQtNC40YLQtdGB0Ywg0YfRgtC+INGDINCS0LDRgSDQtNC+0YHRgtCw0YLQvtGH0L3QviDRgdGA0LXQtNGB0YLQsiDQtNC70Y8g0YLRgNCw0L3Qt9Cw0LrRhtC40LghXCIsXG4gIFwiTk9ORVhJU1RfVVNFUlwiOlwi0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GMLCDQutC+0YLQvtGA0L7QvNGDINCS0Ysg0L/Ri9GC0LDQtdGC0LXRgdGMINC/0LXRgNC10LLQtdGB0YLQuCDRgdGA0LXQtNGB0YLQstCwLCDQvdC1INGB0YPRidC10YHRgtCy0YPQtdGCIVwiLFxuICBcIlRSQU5TRkVSX1RFWFRcIjpcItCS0Ysg0YPQstC10YDQtdC90Ysg0YfRgtC+INGF0L7RgtC40YLQtSDQvtGB0YPRidC10YHRgtCy0LjRgtGMINC/0LXRgNC10LLQvtC0INGB0YDQtdC00YHRgtCyP1wiLFxuICBcIkNPTkZJUk1BVElPTlwiOlwi0J/QvtC00YLQstC10YDQttC00LXQvdC40LVcIixcbiAgXCJUWF9CUk9BRENBU1RFRFwiOlwi0KLRgNCw0L3Qt9Cw0LrRhtC40Y8g0LHRi9C70LAg0YLRgNCw0L3RgdC70LjRgNC+0LLQsNC90LBcIixcbiAgXCJGRUVEXCI6XCLQm9C10L3RgtCwXCIsXG4gIFwiVFJFTkRJTkdcIjpcItCb0YPRh9GI0LXQtVwiLFxuICBcIkhPVFwiOlwi0JDQutGC0YPQsNC70YzQvdC+0LVcIixcbiAgXCJORVdcIjpcItCd0L7QstC+0LVcIixcbiAgXCJQUk9NT1RFRFwiOlwi0J/RgNC+0LTQstC40LPQsNC10LzQvtC1XCIsXG4gIFwiVk9URVNcIjpcItCT0L7Qu9C+0YHQvtCyXCIsXG4gIFwiUEFZT1VUXCI6XCLQktGL0L/Qu9Cw0YLQsFwiLFxuICBcIkNPTU1FTlRTXCI6XCLQmtC+0LzQvNC10L3RgtCw0YDQuNC10LJcIixcbiAgXCJUUkVORElOR18zMFwiOlwi0JvRg9GH0YjQtdC1INC30LAgMzAg0LTQvdC10LlcIixcbiAgXCJTT1JUX1BPU1RfQllcIjpcItCh0L7RgNGC0LjRgNC+0LLQsNGC0Ywg0L/QvtGB0YLRiyDQv9C+OlwiLFxuICBcIlBBWU9VVF9DWUNMRVwiOlwi0J/QtdGA0LjQvtC0INCy0YvQv9C70LDRglwiLFxuICBcIlBPVEVOVElBTF9QQVlPVVRcIjpcItCf0L7RgtC10L3RhtC40LDQu9GM0L3QsNGPINCy0YvQv9C70LDRgtCwXCIsXG4gIFwiUEFTVF9QQVlPVVRcIjpcItCf0L7RgdC70LXQtNC90Y/RjyDQstGL0L/Qu9Cw0YLQsFwiLFxuICBcIkFVVEhPUl9QQVlPVVRcIjpcItCQ0LLRgtC+0YDRgdC60LDRjyDQstGL0L/Qu9Cw0YLQsFwiLFxuICBcIkNVUkFUSU9OX1BBWU9VVFwiOlwi0JrRg9GA0LDRgtC+0YDRgdC60LDRjyDQstGL0L/Qu9Cw0YLQsFwiLFxuICBcIlBPU1RfU1VCTUlUVEVEXCI6XCLQn9C+0YHRgiDQvtC/0YPQsdC70LjQutC+0LLQsNC9IVwiLFxuICBcIlBPU1RfTEFURVJcIjpcItCf0L7RgdGCINC00LvRjyDQvtGC0YHRgNC+0YfQtdC90L3QvtC5INC/0YPQsdC70LjQutCw0YbQuNC4IVwiLFxuICBcIlNBVkVEXCI6XCLQodC+0YXRgNCw0L3QtdC9XCIsXG4gIFwiQ0xFQVJFRFwiOlwi0J7Rh9C40YnQtdC9XCIsXG4gIFwiRkxBR0dJTkdfVEVYVFwiOlwi0KHRgtCw0LLRjyDRhNC70LDQsyDQv9C+0YHRgtGDLCDQktGLINC80L7QttC10YLQtSDRg9C80LXQvdGM0YjQuNGC0Ywg0L3QsNCz0YDQsNC00YMg0Lgg0YHQtNC10LvQsNGC0Ywg0Y3RgtC+0YIg0LzQsNGC0LXRgNC40LDQuyDQvNC10L3QtdC1INC30LDQvNC10YLQvdGL0LwuPGJyPjxicj7QpNC70LDQsyDQtNC+0LvQttC10L0g0LHRi9GC0Ywg0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvSDQsiDRgdC70LXQtNGD0Y7RidC40YUg0YHQu9GD0YfQsNGP0YU6IDx1bD48bGk+0JzQvtGI0LXQvdC90LjRh9C10YHRgtCy0L4g0LjQu9C4INCf0LvQsNCz0LjQsNGCPC9saT48bGk+0JHRgNCw0L3RjCDQuNC70Lgg0JjQvdGC0LXRgNC90LXRgiDQotGA0L7Qu9C70LjQvdCzPC9saT48bGk+0J/RgNC10LTQvdCw0LzQtdGA0LXQvdC90L7QtSDQuNGB0L/QvtC70YzQt9C+0LLQsNC90LjQtSDQvdC10YHQvtC+0YLQstC10YDRgdGC0LLRg9GO0YnQtdC5INC60LDRgtC10LPQvtGA0LjQuCDQuNC70Lgg0KHQv9Cw0Lw8L2xpPjwvdWw+XCIsXG4gIFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6XCLQn9GA0LXQstGL0YjQtdC90L4g0LrQvtC70LjRh9C10YHRgtCy0L4g0LfQsNC/0YDQvtGB0L7Qsi4g0J/RgNC+0LLQtdGA0YzRgtC1INC00YDRg9Cz0LjQtSDRgtGA0LXQvdC00Ysv0YLQtdCz0LghXCIsXG4gIFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6XCLQn9C+0YHRgiDRg9C00LDQu9C10L0g0LjQtyDQt9Cw0LrQu9Cw0LTQvtC6IVwiLFxuICBcIlBPU1RfSVNfQk9PS01BUktcIjpcItCf0L7RgdGCINC00L7QsdCw0LLQu9C10L0g0LIg0LfQsNC60LvQsNC00LrQuCFcIixcbiAgXCJSRVNFVFwiOlwi0KHQsdGA0L7RgdC40YLRjFwiLFxuICBcIk1PRElGWV9QSUNUVVJFXCI6XCLQmNC30LzQtdC90LjRgtGMINC40LfQvtCx0YDQsNC20LXQvdC40LUg0L/RgNC+0YTQuNC70Y9cIixcbiAgXCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOlwi0JjQt9C80LXQvdC40YLRjCDQuNC30L7QsdGA0LDQttC10L3QuNC1INC+0LHQu9C+0LbQutC4XCIsXG4gIFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6XCLQn9C+0LbQsNC70YPQudGB0YLQsCwg0L/RgNC10LTQvtGB0YLQsNCy0YzRgtC1INCQ0LrRgtC40LLQvdGL0Lkg0LfQsNC60YDRi9GC0YvQuSDQutC70Y7Rhywg0LXRgdC70Lgg0JLRiyDQstGL0LHRgNCw0LvQuCDRgNCw0YHRiNC40YDQtdC90L3Ri9C5INGA0LXQttC40Lwg0LDQstGC0L7RgNC40LfQsNGG0LjQuCFcIixcbiAgXCJSRVNFVF9QSUNUVVJFX1RFWFRcIjpcItCt0YLQviDQv9GA0LjQstC10LTQtdGCINC6INGB0LHRgNC+0YHRgyDQuNC30L7QsdGA0LDQttC10L3QuNGPINCS0LDRiNC10LPQviDQv9GA0L7RhNC40LvRj1wiLFxuICBcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOlwi0K3RgtC+INC/0YDQuNCy0LXQtNC10YIg0Log0YHQsdGA0L7RgdGDINC40LfQvtCx0YDQsNC20LXQvdC40Y8g0JLQsNGI0LXQuSDQvtCx0LvQvtC20LrQuFwiLFxuICBcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6XCLQntCx0L3QvtCy0LvQtdC90LjQtSDRgdC10YDQstC10YDQsCDRgtGA0LXQsdGD0LXRgiDQv9C10YDQtdC30LDQs9GA0YPQt9C60LghXCIsXG4gIFwiU0VUVElOR1NfVVBEQVRFRFwiOlwi0J3QsNGB0YLRgNC+0LnQutC4INC+0LHQvdC+0LLQu9C10L3RiyFcIixcbiAgXCJMQU5HVUFHRVNcIjpcItCv0LfRi9C60LhcIixcbiAgXCJMQU5HVUFHRVNfVEVYVFwiOlwi0JfQtNC10YHRjCDQstGLINC80L7QttC10YLQtSDQuNC30LzQtdC90LjRgtGMINGP0LfRi9C6INC/0YDQuNC70L7QttC10L3QuNGPLlwiLFxuICBcIkxPR0lOX1RPX1hcIjpcItCt0YLQsCDQvtC/0LXRgNCw0YbQuNGPINGC0YDQtdCx0YPQtdGCINCw0LLRgtC+0YDQuNC30LDRhtC40Lgg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GPINCyINGB0LjRgdGC0LXQvNC1INGBINC/0LDRgNC+0LvQtdC8LCDQsNC60YLQuNCy0L3Ri9C8L9C/0L7RgdGC0LjQvdCzINC60LvRjtGH0L7QvC4g0J/QvtC20LDQu9GD0LnRgdGC0LAsINCw0LLRgtC+0YDQuNC30YPQudGC0LXRgdGMINC4INC/0L7QstGC0L7RgNC40YLQtSDQv9C+0L/Ri9GC0LrRgy5cIixcbiAgXCJHQUxMRVJZXCI6XCLQk9Cw0LvQtdGA0LXRj1wiLFxuICBcIlRSQU5TTEFUSU9OU1wiOlwi0JDQstGC0L7RgNGLINC/0LXRgNC10LLQvtC00LBcIixcbiAgXCJTSEFSRVwiOlwi0J/QvtC00LXQu9C40YLRjNGB0Y9cIixcbiAgXCJNQVJLRVRQTEFDRVwiOlwi0KDRi9C90L7QulwiLFxuICBcIkVYQ0hBTkdFXCI6XCLQkdC40YDQttCwXCIsXG4gIFwiRFJBRlRTXCI6XCLQp9C10YDQvdC+0LLQuNC60LhcIixcbiAgXCJQT1NUX0lTX1VORFJBRlRcIjpcItCf0L7RgdGCINGD0LTQsNC70LXQvSDQuNC3INGH0LXRgNC90L7QstC40LrQvtCyIVwiLFxuICBcIlBPU1RfSVNfRFJBRlRcIjpcItCf0L7RgdGCINC00L7QsdCw0LLQu9C10L0g0LIg0YfQtdGA0L3QvtCy0LjQutC4IVwiLFxuICBcIlNXSVBFX0xFRlRcIjpcItCf0YDQvtCy0LXQtNC40YLQtSDQv9Cw0LvRjNGG0LXQvCDQstC70LXQstC+INGH0YLQvtCx0Ysg0YPQstC40LTQtdGC0Ywg0LLQsNGA0LjQsNC90YLRi1wiLFxuICBcIk1BTkFHRVwiOlwi0KPQv9GA0LDQstC70LXQvdC40LVcIixcbiAgXCJJTUFHRV9SRU1PVkVEXCI6XCLQmNC30L7QsdGA0LDQttC10L3QuNC1INGD0LTQsNC70LXQvdC+XCIsXG4gIFwiQ09QWVwiOlwi0JrQvtC/0LjRgNC+0LLQsNGC0YxcIixcbiAgXCJOT19JTUFHRVwiOlwi0JLRiyDQtdGJ0LUg0L3QtSDQt9Cw0LPRgNGD0LfQuNC70Lgg0L3QuCDQvtC00L3QvtCz0L4g0LjQt9C+0LHRgNCw0LbQtdC90LjRjyFcIixcbiAgXCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOlwi0J/QvtGC0Y/QvdC40YLQtSDQstC90LjQtywg0YfRgtC+0LHRiyDQvtCx0L3QvtCy0LjRgtGMXCIsXG4gIFwiRVhURVJOQUxfQVBQU1wiOlwi0JLQvdC10YjQvdC40LUg0L/RgNC40LvQvtC20LXQvdC40Y9cIixcbiAgXCJQTFVHSU5TXCI6XCLQn9C70LDQs9C40L3Ri1wiLFxuICBcIlNVR0dFU1RcIjpcItCf0YDQtdC00LvQvtC20LjRgtGMXCIsXG4gIFwiQ09NSU5HX1NPT05cIjpcItCh0LrQvtGA0L5cIixcbiAgXCJDSEFJTlwiOlwi0JHQu9C+0LrRh9C10LnQvVwiLFxuICBcIkNIQUlOX1RFWFRcIjpcItCX0LTQtdGB0Ywg0LLRiyDQvNC+0LbQtdGC0LUg0LjQt9C80LXQvdC40YLRjCDQv9C70LDRgtGE0L7RgNC80YMg0L/QviDRg9C80L7Qu9GH0LDQvdC40Y4gKNCx0LvQvtC60YfQtdC50L0pLlwiLFxuICBcIkNVUlJFTkNZXCI6XCLQktCw0LvRjtGC0LBcIixcbiAgXCJDVVJSRU5DWV9URVhUXCI6XCLQl9C00LXRgdGMINCS0Ysg0LzQvtC20LXRgtC1INC40LfQvNC10L3QuNGC0Ywg0LLQsNC70Y7RgtGDINC/0L4g0YPQvNC+0LvRh9Cw0L3QuNGOLiDQndCw0LPRgNCw0LTQsCDQt9CwINC/0L7RgdGCL9C60L7QvNC80LXQvdGC0LDRgNC40Lkg0LHRg9C00LXRgiDQvtGC0L7QsdGA0LDQttCw0YLRjNGB0Y8g0LIg0Y3RgtC+0Lkg0LLQsNC70Y7RgtC1LlwiLFxuICBcIkFCT1VUXzExXCI6XCI8YnI+PGI+0J/QtdGA0LXRh9C10L3RjCDQstC+0LfQvNC+0LbQvdC+0YHRgtC10Lk8L2I+PGJyPi0g0J/QvtC70YPRh9C40YLQtSDQtNC+0YHRgtGD0L8g0Log0YPQvdC40LrQsNC70YzQvdGL0Lwg0YHRgtCw0YLRjNGP0Lwg0L3QsCDQu9GO0LHRg9GOINC40L3RgtC10YDQtdGB0L3Rg9GOINCS0LDQvCDRgtC10LzRgzs8YnI+LSDQktC30LDQuNC80L7QtNC10LnRgdGC0LLRg9C50YLQtSDRgSDQsNCy0YLQvtGA0LDQvNC4LCDQutC+0LzQvNC10L3RgtC40YDRg9GPINC4INGD0YfQsNGB0YLQstGD0Y8g0LIg0LTQuNGB0LrRg9GB0YHQuNGP0YU7PGJyPi0g0JPQvtC70L7RgdGD0LnRgtC1INC30LAg0L/QvtGB0YLRiywg0YfRgtC+0LHRiyDQstC+0LfQvdCw0LPRgNCw0LTQuNGC0Ywg0LDQstGC0L7RgNCwLCDQsCDRgtCw0LrQttC1INC/0L7Qu9GD0YfQuNGC0Ywg0LrRg9GA0LDRgtC+0YDRgdC60L7QtSDQstC+0LfQvdCw0LPRgNCw0LbQtNC10L3QuNC1Ozxicj4tINCf0YPQsdC70LjQutGD0LnRgtC1INGB0LLQvtC4INC/0L7RgdGC0Ysg0Lgg0LHQtdGB0L/Qu9Cw0YLQvdC+INGA0LDQt9C80LXRidCw0LnRgtC1INC40YUsINGH0YLQvtCx0Ysg0L/RgNC40LLQu9C10YfRjCDRhNC+0LvQu9C+0LLQtdGA0L7QsiDQuCDQv9C+0LvRg9GH0LjRgtGMINCy0L7Qt9C90LDQs9GA0LDQttC00LXQvdC40Y87PGJyPi0g0J/QuNGI0LjRgtC1INGB0YLQsNGC0YzQuCDQsiDQv9GD0YLQuCwg0YHQvtGF0YDQsNC90Y/QudGC0LUg0L3QtdGB0LrQvtC70YzQutC+INGH0LXRgNC90L7QstC40LrQvtCyINC/0L7RgdGC0LAg0Lgg0L/Rg9Cx0LvQuNC60YPQudGC0LUg0LjRhSwg0LrQvtCz0LTQsCDQktCw0Lwg0YPQtNC+0LHQvdC+Ozxicj4tINCU0L7QsdCw0LLQu9GP0LnRgtC1INC/0L7QvdGA0LDQstC40LLRiNC40LXRgdGPINGB0YLQsNGC0YzQuCDQsiDQt9Cw0LrQu9Cw0LTQutC4LCDRh9GC0L7QsdGLINCy0LXRgNC90YPRgtGM0YHRjyDQuiDQvdC40Lwg0L/QvtC30LbQtTs8YnI+LSDQntCx0LzQtdC90LjQstCw0LnRgtC1INC40LvQuCDQvtCx0L3QsNC70LjRh9C40LLQsNC50YLQtSDQktCw0YjQuCDQstC+0LfQvdCw0LPRgNCw0LbQtNC10L3QuNGPOzxicj4tINCf0L7RgdGL0LvQsNC50YLQtSDRgdGA0LXQtNGB0YLQstCwINC70Y7QsdGL0Lwg0LDQstGC0L7RgNCw0LwsINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRj9C8LCDQtNGA0YPQt9GM0Y/QvCwg0YTQvtC70LvQvtCy0LXRgNCw0Lwg0Lgg0YIu0LQuOzxicj4tINCf0L7QtNC/0LjRgdGL0LLQsNC50YLQtdGB0Ywg0L3QsCDQuNC90YLQtdGA0LXRgdC90YvRhSDQsNCy0YLQvtGA0L7QsiDQuCDQsdC70L7Qs9Cz0LXRgNC+0LI7PGJyPi0g0J/QvtC70YzQt9GD0LnRgtC10YHRjCDRg9C00L7QsdC90YvQvCDQv9C+0LjRgdC60L7QvCDQv9C+INGE0L7Qu9C70L7QstC10YDQsNC8INC40LvQuCDQsNCy0YLQvtGA0LDQvCwg0L3QsCDQutC+0YLQvtGA0YvRhSDQktGLINC/0L7QtNC/0LjRgdCw0L3Rizs8YnI+LSDQn9C+0LvRg9GH0LDQudGC0LUg0YPQstC10LTQvtC80LvQtdC90LjRjyAtINC+0YHRgtCw0LLQsNC50YLQtdGB0Ywg0L3QsCDRgdCy0Y/Qt9C4INGBINCS0LDRiNC40LzQuCDRhNC+0LvQu9C+0LLQtdGA0LDQvNC4INC4INC90LDQsdC70Y7QtNCw0LnRgtC1INC30LAg0YDQsNC30LLQuNGC0LjQtdC8INC00LjRgdC60YPRgdGB0LjQuSwg0LIg0LrQvtGC0L7RgNGL0YUg0YPRh9Cw0YHRgtCy0YPQtdGC0LU7PGJyPi0g0J3QsNGF0L7QtNC40YLQtSDQvdC+0LLRi9GFINC40L3RgtC10YDQtdGB0L3Ri9GFINCw0LLRgtC+0YDQvtCyINC4INGB0YLQsNGC0YzQuCwg0LjRgdC/0L7Qu9GM0LfRg9GPINC/0L7QuNGB0Log0L/QviDRgtC10LPQsNC8L9C60LDRgtC10LPQvtGA0LjRj9C8Ozxicj4tINCf0LXRgNGB0L7QvdCw0LvQuNC30LjRgNGD0LnRgtC1INGB0YLRgNCw0L3QuNGG0YMg0YHQstC+0LXQs9C+INC/0YDQvtGE0LjQu9GPOzxicj4tINCd0LUg0L/RgNC+0L/Rg9GB0LrQsNC50YLQtSDQvtCx0L3QvtCy0LvQtdC90LjRjyAtINCyINC90LjRhSDQktGLINC90LDQudC00LXRgtC1INC10YnQtSDQsdC+0LvRjNGI0LUg0L3QvtCy0YvRhSDRhNGD0L3QutGG0LjQuSE8YnI+PGJyPjxiPtCR0LXQt9C+0L/QsNGB0L3QvtGB0YLRjDwvYj48YnI+MS4g0J/RgNC40LvQvtC20LXQvdC40LUg0L3QtSDQuNC80LXQtdGCINC00L7RgdGC0YPQv9CwINC40LvQuCDQv9GA0LDQstCwINGA0LDRgdC/0L7RgNGP0LbQsNGC0YzRgdGPINGB0YDQtdC00YHRgtCy0LDQvNC4INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjzs8YnI+Mi4g0J/RgNC40LvQvtC20LXQvdC40LUg0L/RgNC10LTQu9Cw0LPQsNC10YIg0LzQvtC00LXQu9GMINCx0LXQt9C+0L/QsNGB0L3QvtGB0YLQuCDQvdCwINGB0YLQvtGA0L7QvdC1INC60LvQuNC10L3RgtCwLCDQs9C00LUg0L/RgNC40LLQsNGC0L3Ri9C1INC60LvRjtGH0Lgg0YXRgNCw0L3Rj9GC0YHRjyDQu9C+0LrQsNC70YzQvdC+INC4INC90LjQutC+0LPQtNCwINC90LUg0L7RgtC/0YDQsNCy0LvRj9GO0YLRgdGPINC90Lgg0L3QsCDQutCw0LrQuNC1INGB0LXRgNCy0LXRgNCwIC0g0YLQvtC70YzQutC+INCS0Ysg0L7RgtCy0LXRgtGB0YLQstC10L3QvdGLINC30LAg0YXRgNCw0L3QtdC90LjQtSDRgdCy0L7QuNGFINC/0LDRgNC+0LvQtdC5Ozxicj4zLiDQn9GA0LjQu9C+0LbQtdC90LjQtSDQvtCx0LvQsNC00LDQtdGCINC/0YDQvtGB0YLRi9C8INC/0YDQuNCy0LvQtdC60LDRgtC10LvRjNC90YvQvCDQv9C+0LvRjNC30L7QstCw0YLQtdC70YzRgdC60LjQvCDQuNC90YLQtdGA0YTQtdC50YHQvtC8LCDRh9GC0L4g0L/QvtC00LDRgNC40YIg0JLQsNC8INC/0L7Qu9C+0LbQuNGC0LXQu9GM0L3Ri9C5INC+0L/Ri9GCINC40YHQv9C+0LvRjNC30L7QstCw0L3QuNGPOzxicj40LiDQkiDQv9GA0LjQu9C+0LbQtdC90LjQuCDQv9GA0LXQtNGD0YHQvNC+0YLRgNC10L0g0LTQvtC/0L7Qu9C90LjRgtC10LvRjNC90YvQuSDRg9GA0L7QstC10L3RjCDQsdC10LfQvtC/0LDRgdC90L7RgdGC0Lgg0LIg0LLQuNC00LUg0L/QuNC9LdC60L7QtNCwLjxicj48YnI+ZVN0ZWVtINC/0L7QtNC00LXRgNC20LjQstCw0LXRgiDQv9C70LDRgtGE0L7RgNC80YsgU3RlZW0g0LggR29sb3MuPGJyPlwiLFxuICBcIkZPVU5ERVJcIjpcItCe0YHQvdC+0LLQsNGC0LXQu9GMINC4INCy0LXQtNGD0YnQuNC5INGA0LDQt9GA0LDQsdC+0YLRh9C40LpcIixcbiAgXCJBRERfQUNDT1VOVFwiOlwi0JTQvtCx0LDQstC40YLRjCDQsNC60LrQsNGD0L3RglwiLFxuICBcIlBMQVRGT1JNXCI6XCLQn9C70LDRgtGE0L7RgNC80LBcIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJIT01FXCI6XCJIZW1cIixcbiAgXCJMT0dJTlwiOlwiTG9nZ2EgaW5cIixcbiAgXCJMT0dPVVRcIjpcIkxvZ2dhIHV0XCIsXG4gIFwiUFJPRklMRVwiOlwiUHJvZmlsXCIsXG4gIFwiRk9MTE9XXCI6XCJGw7ZsalwiLFxuICBcIkJPT0tNQVJLU1wiOlwiQm9rbcOkcmtlblwiLFxuICBcIlRSQU5TRkVSXCI6XCLDlnZlcmbDtnJpbmdcIixcbiAgXCJNQVJLRVRcIjpcIk1hcmtuYWRcIixcbiAgXCJTRVRUSU5HU1wiOlwiSW5zdMOkbGxuaW5nYXJcIixcbiAgXCJBQk9VVFwiOlwiT21cIixcbiAgXCJBQk9VVF8xXCI6XCJkw6RyIHZlbSBzb20gaGVsc3Qga2FuIGJlbMO2bmFzIGbDtnIgc2l0dCBtYXRlcmlhbCFcIixcbiAgXCJBQk9VVF8yXCI6XCLDpHIgZW4gc29jaWFsIG1lZGlhcGxhdGZvcm0gZMOkciBkdSBiZXRhbGFzIGbDtnIgYXR0IGJsb2dnYSwga29tbWVudGVyYSBvY2gga3VycmVyYSBpbmzDpGdnLlwiLFxuICBcIkFCT1VUXzNcIjpcIm9jaCDDpHIgZXR0IGNvbW11bml0eS1kcml2ZXQgcHJvamVrdCBmw7ZyIG1vYmlsZW4gc29tIGJhc2VyYXMgcMOlIMO2cHBlbiBrw6RsbGtvZC4gRGVuIGdlciBnZXIgZGlnIHRpbGxnw6VuZyBzw6UgYXR0IGR1IGthbiBsw6RzYSBpbm5laMOlbGwsIGtvbW1lbnRlcmEsIHLDtnN0YSwgc2thcGEgaW5sw6RnZyBvY2ggZsO2cmEgw7Z2ZXIgYmVsw7ZuaW5nYXIsIG9jaCBkaXZlcnNlIGFuZHJhIGZ1bmt0aW9uZXIgc29tIGfDtnJzIG3DtmpsaWdhIGF2IHt7cGxhdGZvcm1uYW1lfX0gYmxvY2sta2VkamEgb2NoIHt7c2l0ZW5hbWV9fS5cIixcbiAgXCJBQk9VVF80XCI6XCJBcHBlbiBoYXIgYWxkcmlnIHRpbGxnw6VuZyB0aWxsIGFudsOkbmRhcmVucyBwZW5nYXIuXCIsXG4gIFwiQUJPVVRfNVwiOlwiQXBwZW4gZXJianVkZXIgZW4ga2xpZW50Y2VudHJlcmFkIHPDpGtlcmhldHNtb2RlbGwsIGR2cy4gZGluYSBwcml2YXRhIG55Y2tsYXIgc3Rhbm5hciBsb2thbHQgb2NoIHNraWNrYXMgaW50ZSB0aWxsIGFuZHJhIHNlcnZyYXIuXCIsXG4gIFwiQUJPVVRfNlwiOlwiQXBwZW4gZXJianVkZXIgZXR0IGVua2VsdCBvY2ggYXR0cmFrdGl2dCBhbnbDpG5kZXJncsOkbnNzbml0dCwgdmlsa2V0IGdlciBlbiBnb2QgYW52w6RuZGFydXBwbGV2ZWxzZS5cIixcbiAgXCJBQk9VVF83XCI6XCJBcHBlbiBrcsOkdmVyIGFsZHJpZyBhdHQgYW52w6RuZGFyZW4gbWF0YXIgaW4gcGVyc29ubGlnIGluZm9ybWF0aW9uLlwiLFxuICBcIkFCT1VUXzhcIjpcIlLDtnN0YSBww6UgZ29vZC1rYXJtYSBzb20gdml0dG5lXCIsXG4gIFwiQUJPVVRfOVwiOlwiS29udGFrdC/DhXRlcmtvcHBsaW5nXCIsXG4gIFwiQUJPVVRfMTBcIjpcIk1lcmEgaW5mb3JtYXRpb246XCIsXG4gIFwiUkVNT1ZFXCI6XCJUYSBib3J0XCIsXG4gIFwiTUFSS0VUX1ZJRVdcIjpcIk1hcmtuYWRzdnlcIixcbiAgXCJQUklDRVwiOlwiUHJpc1wiLFxuICBcIkFNT1VOVFwiOlwiTcOkbmdkXCIsXG4gIFwiVE9UQUxcIjpcIlN1bW1hXCIsXG4gIFwiTk9PUkRFUlNcIjpcIkluZ2EgYWt0aXZhIG9yZHJhciBmw7ZyXCIsXG4gIFwiREFURVwiOlwiRGF0dW1cIixcbiAgXCJCVVlcIjpcIkvDtnBcIixcbiAgXCJTRUxMXCI6XCJTw6RsalwiLFxuICBcIk9QRU5cIjpcIsOWcHBlblwiLFxuICBcIkhJU1RPUllcIjpcIkhpc3RvcmlrXCIsXG4gIFwiRk9MTE9XX0JBQ0tcIjpcIkbDtmxqIHRpbGxiYWthXCIsXG4gIFwiRk9MTE9XRURcIjpcIkbDtmxqZXJcIixcbiAgXCJVTkZPTExPV1wiOlwiU2x1dGEgZsO2bGphXCIsXG4gIFwiRk9MTE9XSU5HXCI6XCJGw7ZsamVyXCIsXG4gIFwiRk9MTE9XRVJTXCI6XCJGw7ZsamFyZVwiLFxuICBcIlNFQVJDSF9GT0xMT1dFUlNcIjpcIlPDtmsgYmxhbmQgZsO2bGphcmVcIixcbiAgXCJTRUFSQ0hfRk9MTE9XSU5HXCI6XCJTw7ZrIGJsYW5kIGRlIGR1IGbDtmxqZXJcIixcbiAgXCJCWVwiOlwiYXZcIixcbiAgXCJJTlwiOlwiaVwiLFxuICBcIk1FTlVcIjpcIk1lbnlcIixcbiAgXCJCT09LTUFSS1wiOlwiQm9rbcOkcmtcIixcbiAgXCJSRUJMT0dcIjpcIsOFdGVyYmxvZ2dhXCIsXG4gIFwiVVBWT1RFXCI6XCJSw7ZzdGEgdXBwXCIsXG4gIFwiRE9XTlZPVEVcIjpcIlLDtnN0YSBuZXJcIixcbiAgXCJVTlZPVEVfRE9XTlZPVEVEXCI6XCLDhW5ncmEgcsO2c3RhIG5lclwiLFxuICBcIlVOVk9URV9VUFZPVEVEXCI6XCLDhW5ncmEgcsO2c3RhIHVwcFwiLFxuICBcIlJFUExZXCI6XCJTdmFyYVwiLFxuICBcIkVESVRcIjpcIlJlZGlnZXJhXCIsXG4gIFwiUE9TVF8xXCI6XCJTdmVwIMOldCB2w6Ruc3RlciDDtnZlciBrb21tZW50YXJlciBmw7ZyIGF0dCBzZSBhbHRlcm5hdGl2XCIsXG4gIFwiUE9TVF8yXCI6XCJEdXR0YSBww6Uga29tbWVudGFyZXIgZsO2ciBhdHQgc2UgdW5kZXJrb21tZW50YXJlclwiLFxuICBcIk9QVElPTlNcIjpcIkFsdGVybmF0aXZcIixcbiAgXCJSRVNURUVNRURfQllcIjpcIsOFdGVyc3RlZW1hZGVzIGF2XCIsXG4gIFwiTk9USElOR19IRVJFXCI6XCJUb210IMOkbiBzw6UgbMOkbmdlLi4uXCIsXG4gIFwiQkFMQU5DRVNcIjpcIlNhbGRvblwiLFxuICBcIlBST0ZJTEVfMVwiOlwiU3RlZW0sIHV0Ynl0c2JhcmEgcG9sbGV0dGVyIHNvbSBnw6VyIGF0dCDDtnZlcmbDtnJhIG7DpHIgc29tIGhlbHN0LiBTdGVlbSBrYW4gb212YW5kbGFzIHRpbGwgU3RlZW1Qb3dlciBpIGVuIHByb2Nlc3Mgc29tIGthbGxhcyBhdHQgw7ZrYSByw7ZzdGVmZmVrdCBlbGxlciBcXFwiw6VuZ2EgdXBwXFxcIi5cIixcbiAgXCJQUk9GSUxFXzJcIjpcIlN0ZWVtUG93ZXIsIGluZmx5dGFuZGVwb2xsZXR0ZXIgc29tIGdlciBow7ZncmUgcsO2c3RlZmZla3QgZsO2ciBhdHQgZHUgc3BhcmFyIGRlbSBsw6VuZ3Npa3RpZ3Qgb2NoIHLDtnN0YXIgcMOlIGlubMOkZ2cuIEp1IG1lciBkdSBoYXIsIGRlc3RvIG1lciBrYW4gZHUgcMOldmVya2EgYW5kcmFzIGJlbMO2bmluZ2FyIG9jaCBiZWzDtm5hcyBmw7ZyIHNtYXJ0IHLDtnN0bmluZy5cIixcbiAgXCJQUk9GSUxFXzNcIjpcIlBvbGxldHRlciB2w6RyZGEgdW5nZWbDpHIge3twbGF0Zm9ybXN1bml0fX0gYXYge3twbGF0Zm9ybW5hbWV9LlwiLFxuICBcIkVTVElNQVRFRF9WQUxVRVwiOlwiVXBwc2thdHRhdCB2w6RyZGVcIixcbiAgXCJQUk9GSUxFXzRcIjpcIkRldCB1cHBza2F0dGFkZSB2w6RyZGV0IMOkciBiYXNlcmF0IHDDpSBldHQgNyBkYWdhcnMgZ2Vub21zbml0dGxpZyB2w6RyZGUgYXYge3twbGF0Zm9ybW5hbWV9LlwiLFxuICBcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjpcIlRyYW5zYWt0aW9uc2hpc3RvcmlrXCIsXG4gIFwiUE9TVElOR1wiOlwiSW5sw6RnZ1wiLFxuICBcIlBST0ZJTEVfNVwiOlwiSW5sw6RnZ3NueWNrZWxuIGFudsOkbmRzIGbDtnIgYXR0IHNrcml2YSBpbmzDpGdnIG9jaCByw7ZzdGEuIERlbiBiw7ZyIHZhcmEgb2xpayBhbGxtw6Rubnlja2VsbiBvY2ggaHV2dWRueWNrZWxuLlwiLFxuICBcIk9XTkVSXCI6XCLDhGdhcmVcIixcbiAgXCJQUk9GSUxFXzZcIjpcIsOEZ2Fybnlja2VsbiDDpHIgaHV2dWRueWNrZWxuIGbDtnIga29udG90IG9jaCBiZWjDtnZzIGbDtnIgYXR0IGt1bm5hIGJ5dGEgZGUgYW5kcmEgbnlja2xhcm5hLiBGw7ZyIGF0dCDDtmthIHPDpGtlcmhldGVuIGLDtnIgZGVuIFxcXCJwcml2YXRhIG55Y2tlbG5cXFwiIGVsbGVyIGzDtnNlbm9yZGV0IHRpbGwgaHV2dWRueWNrZWxuIGFudsOkbmRhcyBzw6UgbGl0ZSBzb20gbcO2amxpZ3QuXCIsXG4gIFwiQUNUSVZFXCI6XCJSw7ZyZWxzZVwiLFxuICBcIlBST0ZJTEVfN1wiOlwiQWxsbcOkbm55Y2tlbG4gYW52w6RuZHMgZsO2ciBhdHQgZ8O2cmEgw7Z2ZXJmw7ZyaW5nYXIgb2NoIGF0dCBsw6RnZ2Egb3JkcmFyIGkgZGVuIGludGVybmEgbWFya25hZGVuLlwiLFxuICBcIk1FTU9cIjpcIkFudGVja25pbmdcIixcbiAgXCJQUk9GSUxFXzhcIjpcIkFudGVja25pbmdzbnlja2VsbiBhbnbDpG5kcyBmw7ZyIGF0dCBza2FwYSBvY2ggbMOkc2EgYW50ZWNrbmluZ2FyLlwiLFxuICBcIkJMT0dcIjpcIkJsb2dnXCIsXG4gIFwiUE9TVFNcIjpcIklubMOkZ2dcIixcbiAgXCJSRVBMSUVTXCI6XCJTdmFyXCIsXG4gIFwiV0FMTEVUXCI6XCJQbMOlbmJva1wiLFxuICBcIlRBR1wiOlwiw4RtbmVcIixcbiAgXCJVU0VSXCI6XCJBbnbDpG5kYXJlXCIsXG4gIFwiQ0xPU0VcIjpcIlN0w6RuZ1wiLFxuICBcIlRPXCI6XCJUaWxsXCIsXG4gIFwiQVNTRVRcIjpcIlRpbGxnw6VuZ1wiLFxuICBcIlNFTkRcIjpcIlNraWNrYVwiLFxuICBcIlNFQ1VSSVRZXCI6XCJTw6RrZXJoZXRcIixcbiAgXCJBVkFJTEFCTEVcIjpcIlRpbGxnw6RuZ2xpZ1wiLFxuICBcIlBVQkxJQ19NRU1PXCI6XCJPZmZlbnRsaWcgYW50ZWNrbmluZ1wiLFxuICBcIlRPX0RFU0NcIjpcIkFudsOkbmRhcmUgdC5leC4gZ29vZC1rYXJtYVwiLFxuICBcIlBJTl9DT0RFXCI6XCJQaW5rb2RcIixcbiAgXCJQSU5fVEVYVFwiOlwiUGlua29kZW4gaGrDpGxwZXIgZGlnIGF0dCBzw6RrcmEgYXBwZW4gb2NoIGRpbiBkYXRhLiBOw6RyIGRlbiBha3RpdmVyYXMgaGFyIGR1IG1heCA0IGbDtnJzw7ZrIGF0dCBsw6VzYSB1cHAgYXBwZW4uIE9tIGR1IGhhciBnbMO2bXQgZGVuIGVsbGVyIG1pc3NseWNrYXMga29tbWVyIGFwcGVuIGF0dCB0YSBib3J0IGlubG9nZ2FkIGFudsOkbmRhcmRhdGEuIER1IG3DpXN0ZSBkw6UgbG9nZ2EgaW4gcMOlIG55dHQgZsO2ciBhdHQgZm9ydHPDpHR0YSBhbnbDpG5kYSBhcHBlbi5cIixcbiAgXCJOT1RJRklDQVRJT05TXCI6XCJNZWRkZWxhbmRlblwiLFxuICBcIlZPVEVfVEVYVFwiOlwiRHUga29tbWVyIGbDpSBldHQgbWVkZGVsYW5kZSBuw6RyIG7DpWdvbiByw7ZzdGFyIHVwcCBkaXR0IGlubMOkZ2cuIE1lZGRlbGFuZGVuIHRhbGFyIMOkdmVuIG9tIGRlbiB2YWxkYSByw7ZzdHZpa3Rlbi4gKG9hdnNldHQgdXBwcsO2c3RuaW5nLCBuZWRyw7ZzdG5pbmcsIGF2L29tcsO2c3RuaW5nKS5cIixcbiAgXCJWT1RFXCI6XCJSw7ZzdGFcIixcbiAgXCJDT01NRU5UX1RFWFRcIjpcIkR1IGtvbW1lciBmw6UgZXR0IG1lZGRlbGFuZGUgbsOkciBuw6Vnb24ga29tbWVudGVyYXIgcMOlIGRpdHQgaW5sw6RnZyBlbGxlciBrb21tZW50YXIuIE1lZGRlbGFuZGVuIGlua2x1ZGVyYXIgw6R2ZW4gbsOkciBuw6Vnb24gcmVkaWdlcmFyIHNpbiBrb21tZW50YXIuXCIsXG4gIFwiQ09NTUVOVFwiOlwiS29tbWVudGFyXCIsXG4gIFwiRk9MTE9XX1RFWFRcIjpcIkR1IGtvbW1lciBmw6UgZXR0IG1lZGRlbGFuZGUgbsOkciBuw6Vnb24gZsO2bGplciBlbGxlciBzbHV0YXIgZsO2bGphIGRpZy5cIixcbiAgXCJNRU5USU9OU1wiOlwiT21uw6RtbmFuZGVcIixcbiAgXCJNRU5USU9OU19URVhUXCI6XCJEdSBrb21tZXIgZsOlIGV0dCBtZWRkZWxhbmRlIG7DpHIgbsOlZ29uIG7DpG1uYXIgZGl0dCBuYW1uIGkgZGVyYXMgaW5sw6RnZy9rb21tZW50YXIhXCIsXG4gIFwiUkVTVEVFTVwiOlwiw4V0ZXJzdGVlbWFcIixcbiAgXCJSRVNURUVNX1RFWFRcIjpcIkR1IGtvbW1lciBmw6UgZXR0IG1lZGRlbGFuZGUgbsOkciBuw6Vnb24gw6V0ZXJzdGVlbWFyIGRpdHQgaW5sw6RnZyFcIixcbiAgXCJDT05GSUdVUkFUSU9OU1wiOlwiSW5zdMOkbGxuaW5nYXJcIixcbiAgXCJWT1RJTkdcIjpcIlLDtnN0bmluZ1wiLFxuICBcIlZPVElOR19URVhUXCI6XCJSw7ZzdG5pbmdzdmlrdCBlbGxlciBwcm9jZW50IHDDpXZlcmthciByw7ZzdG5pbmdza3JhZnRlbiBww6UgYXBwZW4gc8OlIGF0dCBkdSBrYW4gcmVnbGVyYSBodXIgbXlja2V0IGR1IHZpbGwgYmVsw7ZuYSBpbmzDpGdnLiBEZXR0YSDDpG5kcmFyIG9ja3PDpSBww6UgcsO2c3RuaW5nc3Zpa3Rlbi9wcm9jZW50ZW4gZsO2ciBuZWRyw7ZzdG5pbmdhciBvY2ggZ8OkbGxlciDDtnZlcmFsbHQgcMOlIGFwcGVuLlwiLFxuICBcIlNFUlZFUlwiOlwiU2VydmVyXCIsXG4gIFwiU0VSVkVSX1RFWFRcIjpcIlJla29tbWVuZGVyYXNcIixcbiAgXCJTQVZFX0NIQU5HRVNcIjpcIlNwYXJhIMOkbmRyaW5nYXJcIixcbiAgXCJWT1RFUlNfSU5GT1wiOlwiUsO2c3RhcmVucyBpbmZvcm1hdGlvblwiLFxuICBcIldFTENPTUVfQkFDS1wiOlwiVsOkbGtvbW1lbiB0aWxsYmFrYSFcIixcbiAgXCJMT0dJTl8xXCI6XCJMb2dnYSBpbiBtZWQgZGl0dCBhbnbDpG5kYXJuYW1uIG9jaCBsw7ZzZW5vcmQgZsO2ciBhdHQgZm9ydHPDpHR0YS5cIixcbiAgXCJMT0dJTl8yXCI6XCJJbmzDpGdnc255Y2tlbG4gYW52w6RuZHMgZsO2ciBhdHQgZ8O2cmEgaW5sw6RnZywga29tbWVudGVyYSwgcsO2c3QsIGbDtmxqYS5cIixcbiAgXCJMT0dJTl8zXCI6XCJBbGxtw6Rubnlja2VsbiBhbnbDpG5kcyBmw7ZyIGF0dCBnw7ZyYSDDtnZlcmbDtnJpbmdhciBvY2ggYXR0IHVwcGRhdGVyYSBwcm9maWxiaWxkLlwiLFxuICBcIkxPR0lOXzRcIjpcIkFudsOkbmRhcnVwcGdpZnRlciBsYWdyYXMgbG9rYWx0IHDDpSBlbmhldGVuLiBWaWQgdXRsb2dnbmluZyBhdmzDpGdzbmFzIHVwcGdpZnRlcm5hIVwiLFxuICBcIkRPTlRfSEFWRVwiOlwiSGFyIGR1IGluZ2V0IGtvbnRvP1wiLFxuICBcIlNJR05fVVBfTk9XXCI6XCJSZWdpc3RyZXJhIGRpZyBudVwiLFxuICBcIkNBTkNFTFwiOlwiQXZicnl0XCIsXG4gIFwiQURWQU5DRURcIjpcIkF2YW5jZXJhdCBsw6RnZVwiLFxuICBcIkFDVElWRV9QUklLRVlcIjpcIlByaXZhdCBhbGxtw6Rubnlja2VsXCIsXG4gIFwiUE9TVElOR19QUklLRVlcIjpcIlByaXZhdCBpbmzDpGdnc255Y2tlbFwiLFxuICBcIk1BU1RFUl9QQVNTXCI6XCLDhGdhcmUvaHV2dWRsw7ZzZW5vcmRcIixcbiAgXCJVU0VSTkFNRVwiOlwiQW52w6RuZGFybmFtblwiLFxuICBcIkNBUkRfVklFV1wiOlwiS29ydHZ5XCIsXG4gIFwiQ09NUEFDVF9WSUVXXCI6XCJLb21wYWt0IHZ5XCIsXG4gIFwiU0VBUkNIXCI6XCJTw7ZrXCIsXG4gIFwiU1VCTUlUX0FfU1RPUllcIjpcIkfDtnIgZXR0IGlubMOkZ2dcIixcbiAgXCJSRVBMWVRPXCI6XCJTdmFyYVwiLFxuICBcIlBPU1RcIjpcIlNraWNrYVwiLFxuICBcIlBSRVZJRVdcIjpcIkbDtnJoYW5kc2dyYW5za2FcIixcbiAgXCJERUZBVUxUXCI6XCJOb3JtYWwgNTAlIC8gNTAlXCIsXG4gIFwiUE9XRVJVUFwiOlwiw4VuZ2EgdXBwIDEwMCVcIixcbiAgXCJERUNMSU5FX1BBWU9VVFwiOlwiQXZzw6RnIGRpZyBiZWzDtm5pbmdcIixcbiAgXCJTQVZFX0ZPUl9MQVRFUlwiOlwiU1BBUkEgVElMTCBTRU5BUkVcIixcbiAgXCJDTEVBUlwiOlwiVMOWTVwiLFxuICBcIlBPU1RfQ09OVEVOVFwiOlwiU2tyaXYgaW5sw6RnZ1wiLFxuICBcIkNPTU1FTlRfQ09OVEVOVFwiOlwiS29tbWVudGVyYSBtYXRlcmlhbFwiLFxuICBcIlRJVExFXCI6XCJUaXRlbFwiLFxuICBcIlRBR1NcIjpcIsOEbW5lblwiLFxuICBcIk5PVF9NQVRDSFwiOlwiTUFUQ0hBUiBJTlRFXCIsXG4gIFwiQ09ORklSTV9QSU5cIjpcIkJla3LDpGZ0YSBwaW5rb2RcIixcbiAgXCJJTkNPUlJFQ1RcIjpcIkZFTEFLVElHXCIsXG4gIFwiT1BFTklOR19QT1NUXCI6XCLDtnBwbmFyIGlubMOkZ2dcIixcbiAgXCJTRVRfUElOXCI6XCJTdMOkbGwgaW4gcGlua29kXCIsXG4gIFwiRU5URVJfUElOXCI6XCJBbmdlIHBpbmtvZFwiLFxuICBcIkFSRV9ZT1VfU1VSRVwiOlwiw4RyIGR1IHPDpGtlcj9cIixcbiAgXCJSRUJMT0dfVEVYVFwiOlwiw4V0ZXJzdGVlbWFkZSBpbmzDpGdnIGthbiBpbnRlIMOlbmdyYXMsIHZpbGwgZHUgZm9ydHPDpHR0YT9cIixcbiAgXCJCUk9BRENBU1RfRVJST1JcIjpcIlPDpG5kbmluZ3NmZWwsIGbDtnJzw7ZrIGlnZW4hXCIsXG4gIFwiU1VDQ0VTU1wiOlwiVXRmw7ZydFwiLFxuICBcIlJFQkxPR0dFRF9QT1NUXCI6XCLDhXRlcmJsb2dnYWRlIGlubMOkZ2chXCIsXG4gIFwiTE9HSU5fRkFJTFwiOlwiSW5sb2dnbmluZyBtaXNzbHlja2FkZXMhIFZhciBnb2Qgc8Oka2Vyc3TDpGxsIGF0dCBkdSBsb2dnYXIgaW4gbWVkIGh1dnVkbMO2c2Vub3JkIGVsbGVyIGRpbiBwcml2YXRhIGlubMOkZ2dzbnlja2VsIG9tIGR1IHZhbHQgXFxcIkF2YW5jZXJhdCBsw6RnZVxcXCIuXCIsXG4gIFwiTE9HSU5fRkFJTF9BXCI6XCJJbmxvZ2duaW5nIG1pc3NseWNrYWRlcyEgVmFyIGdvZCBzw6RrZXJzdMOkbGwgYXR0IGR1IGxvZ2dhciBpbiBtZWQgaHV2dWRsw7ZzZW5vcmQgZWxsZXIgZGluIHByaXZhdGEgcsO2cmVsc2VueWNrZWwgb20gZHUgdmFsdCBcXFwiQXZhbmNlcmF0IGzDpGdlXFxcIi5cIixcbiAgXCJXQVJOSU5HXCI6XCJWYXJuaW5nXCIsXG4gIFwiVk9URV9GT1JfV0lUTkVTU1wiOlwiUsO2c3RhIHDDpSB2aXR0bmVcIixcbiAgXCJWT1RFRF9GT1JfV0lUTkVTU1wiOlwiUsO2c3RhZGUgcMOlIHZpdHRuZXRcIixcbiAgXCJBR09cIjpcInNlZGFuXCIsXG4gIFwiRlJPTV9OT1dcIjpcImZyw6VuIG9jaCBtZWQgbnVcIixcbiAgXCJTRUNTXCI6XCJzZWtcIixcbiAgXCJBX01JTlwiOlwiZW4gbWludXRcIixcbiAgXCJNSU5TXCI6XCJtaW5cIixcbiAgXCJBTl9IT1VSXCI6XCJlbiB0aW1tZVwiLFxuICBcIkhPVVJTXCI6XCJ0aW1tYXJcIixcbiAgXCJBX0RBWVwiOlwiZW4gZGFnXCIsXG4gIFwiREFZU1wiOlwiZGFnYXJcIixcbiAgXCJBX01PTlRIXCI6XCJlbiBtw6VuYWRcIixcbiAgXCJNT05USFNcIjpcIm3DpW5hZGVyXCIsXG4gIFwiQV9ZRUFSXCI6XCJldHQgw6VyXCIsXG4gIFwiWUVBUlNcIjpcIsOlclwiLFxuICBcIk1JTl9SRUFEXCI6XCJtaW4gbMOkc25pbmdcIixcbiAgXCJET1dOVk9URV9GTEFHXCI6XCJSw7ZzdGEgTmVyXCIsXG4gIFwiQ0FQVFVSRV9QSUNUVVJFXCI6XCJUYSBGb3RvXCIsXG4gIFwiU0VMRUNUX1BJQ1RVUkVcIjpcIlbDpGxqIEJpbGRcIixcbiAgXCJTRVRfQ1VTVE9NX1VSTFwiOlwiU3TDpGxsIGluIGVnZW4gVVJMXCIsXG4gIFwiSU5TRVJUX1BJQ1RVUkVcIjpcIkluZm9nYSBCaWxkXCIsXG4gIFwiRVJST1JcIjpcIkZlbFwiLFxuICBcIlVQTE9BRF9FUlJPUlwiOlwiVXBwbGFkZG5pbmdzZmVsXCIsXG4gIFwiQ0FNRVJBX0NBTkNFTExFRFwiOlwiS2FtZXJhIEF2YnJ1dGVuXCIsXG4gIFwiU0VUX1VSTFwiOlwiU3TDpGxsIGluIFVSTFwiLFxuICBcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjpcIkRpcmVrdCB3ZWJibMOkbmsgZsO2ciBiaWxkXCIsXG4gIFwiQ09NTUVOVF9TVUJNSVRURURcIjpcIktvbW1lbnRhcmVuIMOkciBza2lja2FkIVwiLFxuICBcIkRFTEVURV9DT01NRU5UXCI6XCJCb3J0dGFnbmluZyBhdiBrb21tZW50YXJlciBnw6VyIGludGUgYXR0IMOlbmdyYS4uLlwiLFxuICBcIkRFTEVURURfQ09NTUVOVFwiOlwiVG9nIGJvcnQga29tbWVudGFyZW5cIixcbiAgXCJVUExPQURJTkdfUElDVFVSRVwiOlwiTGFkZGFyIHVwcCBiaWxkXCIsXG4gIFwiVVBMT0FEX0NPTVBMRVRFRFwiOlwiVXBwbGFkZG5pbmcgU2x1dGbDtnJkXCIsXG4gIFwiVVBMT0FEX0ZBSUxFRFwiOlwiVXBwbGFkZG5pbmcgTWlzc2x5Y2thZGVzXCIsXG4gIFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6XCJMw7ZzZW5vcmRldCBlbGxlciBrb250b25hbW5ldCB2YXIgZmVsYWt0aWd0XCIsXG4gIFwiSU5GT1wiOlwiSW5mb1wiLFxuICBcIlFSX1RFWFRcIjpcIlBsYWNlcmEgUVIta29kIGlubmFuZsO2ciBza2FubmluZ3NvbXLDpWRldFwiLFxuICBcIkJBTEFOQ0VfVEVYVFwiOlwiU2UgdGlsbCBhdHQgZHUgaGFyIHRpbGxyw6Rja2xpZ3Qgc2FsZG8gZsO2ciB0cmFuc2FrdGlvbmVuIVwiLFxuICBcIk5PTkVYSVNUX1VTRVJcIjpcIkFudsOkbmRhcmVuIGR1IGbDtnJzw7ZrZXIgw7Z2ZXJmw7ZyYSB0aWxsIGV4aXN0ZXJhciBpbnRlIVwiLFxuICBcIlRSQU5TRkVSX1RFWFRcIjpcIsOEciBkdSBzw6RrZXIgYXR0IGR1IHZpbGwgZsO2cmEgw7Z2ZXI/XCIsXG4gIFwiQ09ORklSTUFUSU9OXCI6XCJCZWtyw6RmdGVsc2VcIixcbiAgXCJUWF9CUk9BRENBU1RFRFwiOlwiw5Z2ZXJmw7ZyaW5nIHPDpG5kZXNcIixcbiAgXCJGRUVEXCI6XCJGbMO2ZGVcIixcbiAgXCJUUkVORElOR1wiOlwiVHJlbmRhbmRlXCIsXG4gIFwiSE9UXCI6XCJIZXR0XCIsXG4gIFwiTkVXXCI6XCJOeXR0XCIsXG4gIFwiUFJPTU9URURcIjpcIk1hcmtuYWRzZsO2cnRcIixcbiAgXCJWT1RFU1wiOlwiUsO2c3RlclwiLFxuICBcIlBBWU9VVFwiOlwiVXRiZXRhbG5pbmdcIixcbiAgXCJDT01NRU5UU1wiOlwiS29tbWVudGFyZXJcIixcbiAgXCJUUkVORElOR18zMFwiOlwiVHJlbmRhbmRlIGbDtnIgMzAgZGFnYXJcIixcbiAgXCJTT1JUX1BPU1RfQllcIjpcIlNvcnRlcmEgaW5sw6RnZyBlZnRlclwiLFxuICBcIlBBWU9VVF9DWUNMRVwiOlwiVXRiZXRhbG5pbmdzcGVyaW9kXCIsXG4gIFwiUE9URU5USUFMX1BBWU9VVFwiOlwiUG90ZW50aWVsbCBVdGJldGFsbmluZ1wiLFxuICBcIlBBU1RfUEFZT1VUXCI6XCJUaWRpZ2FyZSBVdGJldGFsbmluZ1wiLFxuICBcIkFVVEhPUl9QQVlPVVRcIjpcIlNrcmliZW50cyBVdGJldGFsbmluZ1wiLFxuICBcIkNVUkFUSU9OX1BBWU9VVFwiOlwiS3VyYXRvcmVycyBVdGJldGFsbmluZ1wiLFxuICBcIlBPU1RfU1VCTUlUVEVEXCI6XCJJbmzDpGdnZXQgw6RyIHB1YmxpY2VyYXQhXCIsXG4gIFwiUE9TVF9MQVRFUlwiOlwiSW5sw6RnZyBmw7ZyIHNlbmFyZSBwdWJsaWNlcmluZyFcIixcbiAgXCJTQVZFRFwiOlwiU3BhcmF0XCIsXG4gIFwiQ0xFQVJFRFwiOlwiVMO2bXRcIixcbiAgXCJGTEFHR0lOR19URVhUXCI6XCJBdHQgcsO2c3RhIG5lciBldHQgaW5sw6RnZyBrYW4gdGEgYm9ydCBiZWzDtm5pbmcgb2NoIGfDtnJhIGlubMOkZ2dldCBtaW5kcmUgc3lubGlndC48YnI+PGJyPiBOZWRyw7ZzdGVuIGLDtnIgYW52w6RuZGFzIGbDtnIgZsO2bGphbmRlOiA8dWw+PGxpPkJlZHLDpGdlciBlbGxlciBQbGFnaWF0PC9saT48bGk+SGV0cyBlbGxlciBUcm9sbGluZzwvbGk+PGxpPk1lZHZldGV0IGZlbGthdGVnb3Jpc2VyYXQgaW5uZWjDpWxsIGVsbGVyIFNwYW08L2xpPjwvdWw+XCIsXG4gIFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6XCJTbHV0IHDDpSBmbMO2ZGV0IG7DpXR0LiBLb2xsYSBpbiBhbmRyYSB0cmVuZGVyL8OkbW5lc3RhZ2dhciFcIixcbiAgXCJQT1NUX0lTX1VOQk9PS01BUktcIjpcIklubMOkZ2dldCBoYXIgdGFnaXRzIGJvcnQgZnLDpW4gYm9rbcOkcmtlbiFcIixcbiAgXCJQT1NUX0lTX0JPT0tNQVJLXCI6XCJJbmzDpGdnZXQgaGFyIGxhZ3RzIHRpbGwgaSBib2ttw6Rya2VuIVwiLFxuICBcIlJFU0VUXCI6XCLDhXRlcnN0w6RsbFwiLFxuICBcIk1PRElGWV9QSUNUVVJFXCI6XCJNb2RpZmllcmEgcHJvZmlsYmlsZFwiLFxuICBcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6XCJNb2RpZmllcmEgdXBwc2xhZ3NiaWxkXCIsXG4gIFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6XCJWYXIgZ29kIGFuZ2UgZGVuIHByaXZhdGEgcsO2cmVsc2VueWNrZWxuIG9tIGR1IGhhciB2YWx0IEF2YW5jZXJhdCBsw6RnZSFcIixcbiAgXCJSRVNFVF9QSUNUVVJFX1RFWFRcIjpcIkRldCBow6RyIMOldGVyc3TDpGxsZXIgcHJvZmlsYmlsZFwiLFxuICBcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOlwiRGV0IGjDpHIgw6V0ZXJzdMOkbGxlciB1cHBzbGFnc2JpbGRcIixcbiAgXCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOlwiU2VydmVydXBwZGF0ZXJpbmcga3LDpHZlciBvbXN0YXJ0IVwiLFxuICBcIlNFVFRJTkdTX1VQREFURURcIjpcIkluc3TDpGxsbmluZ2FyIGhhciB1cHBkYXRlcmF0cyFcIixcbiAgXCJMQU5HVUFHRVNcIjpcIlNwcsOla1wiLFxuICBcIkxBTkdVQUdFU19URVhUXCI6XCJIw6RyIGthbiBkdSB2w6RsamEgZGV0IHNwcsOlayBzb20gYXBwZW4gYW52w6RuZGVyLlwiLFxuICBcIkxPR0lOX1RPX1hcIjpcIkRlbiBow6RyIG9wZXJhdGlvbmVuIGtyw6R2ZXIgYXR0IGFudsOkbmRhcmVuIMOkciBpbmxvZ2dhZCBtZWQgbMO2c2Vub3JkLCBhbGxtw6Rubnlja2VsL2lubMOkZ2dzbnlja2VsLiBWYXIgZ29kIGxvZ2dhIGluIG9jaCBmw7Zyc8O2ayBpZ2VuLlwiLFxuICBcIkdBTExFUllcIjpcIkdhbGxlcmlcIixcbiAgXCJUUkFOU0xBVElPTlNcIjpcIkJpZHJhZ2FuZGUgw7Z2ZXJzw6R0dGFyZVwiLFxuICBcIlNIQVJFXCI6XCJEZWxhXCIsXG4gIFwiTUFSS0VUUExBQ0VcIjpcIk1hcmtuYWRzcGxhdHNcIixcbiAgXCJFWENIQU5HRVwiOlwiQsO2cnNcIixcbiAgXCJEUkFGVFNcIjpcIlV0c2tpY2tcIixcbiAgXCJQT1NUX0lTX1VORFJBRlRcIjpcIklubMOkZ2cgaGFyIHRhZ2l0cyBib3J0IGZyw6VuIHV0c2tpY2shXCIsXG4gIFwiUE9TVF9JU19EUkFGVFwiOlwiSW5sw6RnZyBoYXIgbGFndHMgdGlsbCBpIHV0c2tpY2shXCIsXG4gIFwiU1dJUEVfTEVGVFwiOlwiRHJhIMOldCB2w6Ruc3RlciBmw7ZyIGF0dCBzZSBhbHRlcm5hdGl2XCIsXG4gIFwiTUFOQUdFXCI6XCJIYW50ZXJhXCIsXG4gIFwiSU1BR0VfUkVNT1ZFRFwiOlwiQmlsZGVuIMOkciBib3J0dGFnZW5cIixcbiAgXCJDT1BZXCI6XCJLb3BpZXJhXCIsXG4gIFwiTk9fSU1BR0VcIjpcIkR1IGhhciBpbnRlIGxhZGRhdCB1cHAgbsOlZ29uIGJpbGQgw6RubnUhXCIsXG4gIFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjpcIkRyYSBuZXIgZsO2ciBhdHQgdXBwZGF0ZXJhXCIsXG4gIFwiRVhURVJOQUxfQVBQU1wiOlwiRXh0ZXJuYSBhcHBhclwiLFxuICBcIlBMVUdJTlNcIjpcIlBsdWdpblwiLFxuICBcIlNVR0dFU1RcIjpcIkbDtnJzbGFnXCIsXG4gIFwiQ09NSU5HX1NPT05cIjpcIktvbW1lciBzbmFydFwiLFxuICBcIkNIQUlOXCI6XCJLZWRqYVwiLFxuICBcIkNIQUlOX1RFWFRcIjpcIkjDpHIga2FuIGR1IMOkbmRyYSBibG9ja2tlZGphIGVsbGVyIGbDtnJ2YWxkIHBsYXR0Zm9ybS5cIixcbiAgXCJDVVJSRU5DWVwiOlwiVmFsdXRhXCIsXG4gIFwiQ1VSUkVOQ1lfVEVYVFwiOlwiSMOkciBrYW4gZHUgw6RuZHJhIGRpbiBzdGFuZGFyZHZhbHV0YS4gRGV0IMOkciBkZW4gdmFsdXRhIHNvbSBiZWzDtm5pbmdhciBmw7ZyIGlubMOkZ2cva29tbWVudGFyZXIga29tbWVyIGF0dCB2aXNhcyBpLlwiLFxuICBcIkFCT1VUXzExXCI6XCI8YnI+PGI+TGlzdGEgw7Z2ZXIgZnVua3Rpb25lcjwvYj48YnI+LSBUaWxsZ8OlbmcgdGlsbCBhcnRpa2xhciBpIMOkbW5lbiBzb20gaW50cmVzc2VyYXIgZGlnLjxicj4tIEludGVyYWdlcmEgbWVkIHNrcmliZW50ZXIgZ2Vub20gYXR0IGtvbW1lbnRlcmEsIGRpc2t1dGVyYSDDpG1uZW4uPGJyPi0gUsO2c3RhIHDDpSBpbmzDpGdnIGbDtnIgYXQgYmVsw7ZuYSBza3JpYmVudGVyIG9jaCB0asOkbmEga3VyZXJpbmdzYmVsw7ZuaW5nYXIuPGJyPi0gUHVibGljZXJhIGRpbmEgYXJ0aWtsYXIsIGJsb2dnaW5sw6RnZyBvY2ggZ8O2ciBkZW0gdGlsbGfDpG5saWdhIGbDtnIgYW5kcmEgaGVsdCBncmF0aXMsIHNhbXQgdGrDpG5hIGJlbMO2bmluZ2FyIGdlbm9tIGF0dCBlbmdhZ2VyYSBvY2ggZsOlIGbDtmxqYXJlLjxicj4tIFNrcml2IGFydGlrbGFyIHDDpSBzdMOlZW5kZSBmw6V0LCBzcGFyYSBmbGVyYSB1dGthc3QgYXYgZGluYSBpbmzDpGdnIGbDtnIgc2VuYXJlIHB1YmxpY2VyaW5nLjxicj4tIEJva23DpHJrIGZhdm9ydGlubMOkZ2cgZsO2ciBhdHQgbMOkc2Egc2VuYXJlLjxicj4tIEhhbmRsYSBtZWQgZWxsZXIgdGEgdXQgZGluYSBiZWzDtm5pbmdhci48YnI+LSBHw7ZyIHRyYW5zYWt0aW9uZXIgdGlsbCB2YWxmcmkgYW52w6RuZGFyZSwgdsOkbiwgZsO2bGphcmUsIGV0Yy48YnI+LSBGw7ZsaiBpbnRyZXNzYW50YSBza3JpYmVudGVyLCBibG9nZ2FyZS48YnI+LSBTw7ZrIGJsYW5kIGRpbmEgZsO2bGphcmUgb2NoIHNrcmliZW50ZXIgZHUgZsO2bGplci48YnI+LSBGw6UgbWVkZGVsYW5kZSBzw6UgYXR0IGR1IGthbiBow6VsbGEga29udGFrdGVuIG1lZCBkaW5hIGbDtmxqYXJlIG9jaCBoYSBrb2xsIHDDpSBkZSBkaXNrdXNzaW9uZXIgZHUgZGVsdGFyIGkuPGJyPi0gU8O2ayBlZnRlciBpbnRyZXNzYW50YSDDpG1uZW4vYXJ0aWtlbGthdGVnb3JpZXIsIHNrcmliZW50ZXIuPGJyPi0gR8O2ciBkaW4gcHJvZmlsIG1lciBwZXJzb25saWcuPGJyPi0gTcOlbmdhIGZsZXIgZnVua3Rpb25lciBww6UgdsOkZzxicj48YnI+PGI+U8Oka2VyaGV0PC9iPjxicj4xLiBBcHBlbiBoYXIgZsOlciBhbGRyaWcgdGlsbGfDpW5nIHRpbGwgZWxsZXIga29udHJvbGwgw7Z2ZXIgZGluYSBwZW5nYXIuPGJyPjIuIEFwcGVucyBzw6RrZXJoZXRzbW9kZWxsIMOkciBrbGllbnRjZW50cmVyYWQsIG1lZCBwcml2YXRhIG55Y2tsYXIgc3BhcmFkZSBsb2thbHQgb2NoIGFsZHJpZyBza2lja2FkZSB0aWxsIG7DpWdyYSBhbmRyYSBzZXJ2cmFyLCBkdSDDpHIgc2rDpGx2IGFuc3ZhcmlnIGbDtnIgYXR0IHPDpGtlcmhldHNrb3BpZXJhIGRpbmEgbMO2c2Vub3JkLjxicj4zLiBBcHBlbiBlcmJqdWRlciBldHQgZW5rZWx0LCBhdHRyYWt0aXZ0IGFudsOkbmRhcmdyw6Ruc3NuaXR0IG9jaCBhbnbDpG5kYXJ1cHBsZXZlbHNlLjxicj40LiBBcHBlbiBlcmJqdWRlciBleHRyYSBzw6RrZXJoZXQgbWVkIHBpbi1rb2Q8YnI+PGJyPmVTdGVlbSBzdMO2ZGplciBTdGVlbS0gb2NoIEdvbG9zLSBwbGF0dGZvcm1hcm5hLjxicj5cIixcbiAgXCJGT1VOREVSXCI6XCJHcnVuZGFyZSBvY2ggTGVhZCBEZXZlbG9wZXJcIixcbiAgXCJBRERfQUNDT1VOVFwiOlwiTMOkZ2cgdGlsbCBrb250b1wiLFxuICBcIlBMQVRGT1JNXCI6XCJQbGF0dGZvcm1cIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJIT01FXCI6XCLpppbpobVcIixcbiAgXCJMT0dJTlwiOlwi55m75b2VXCIsXG4gIFwiTE9HT1VUXCI6XCLpgIDlh7pcIixcbiAgXCJQUk9GSUxFXCI6XCLnroDku4tcIixcbiAgXCJGT0xMT1dcIjpcIuWFs+azqFwiLFxuICBcIkJPT0tNQVJLU1wiOlwi5Lmm562+XCIsXG4gIFwiVFJBTlNGRVJcIjpcIui9rOi0plwiLFxuICBcIk1BUktFVFwiOlwi5biC5Zy6XCIsXG4gIFwiU0VUVElOR1NcIjpcIuiuvue9rlwiLFxuICBcIkFCT1VUXCI6XCLlhbPkuo5cIixcbiAgXCJBQk9VVF8xXCI6XCLlnKjov5nph4zku7vkvZXkurrpg73lj6/ku6XpnaDotKHnjK7lhoXlrrnotZrpkrHvvIFcIixcbiAgXCJBQk9VVF8yXCI6XCLnlLF7e3BsYXRmb3JtbmFtZX195bmz5Y+w5o+Q5L6b44CC5bqU55So56iL5bqP5Yib5bu655SxXCIsXG4gIFwiQUJPVVRfM1wiOlwi5a6D5L2c5Li65byA5rqQ44CB56S+5Yy66amx5Yqo56e75Yqo56uv6aG555uu77yM5o+Q5L6b5YaF5a656K6/6Zeu55So5LqO6ZiF6K+744CB6K+E6K6644CB5oqV56Wo44CB5Y+R6KGo44CB6L2s6LSm5pS255uK562J5Yqf6IO944CC55Sxe3twbGF0Zm9ybW5hbWV9feWMuuWdl+mTvuWSjHt7c2l0ZW5hbWV9feaPkOS+m+WKn+iDveOAglwiLFxuICBcIkFCT1VUXzRcIjpcIjEu5bqU55So56iL5bqP5rC45LiN6K6/6Zeu5oiW5oyB5pyJ55So5oi36YeR6ZKx44CCXCIsXG4gIFwiQUJPVVRfNVwiOlwiMi4g5bqU55So56iL5bqP5o+Q5L6b5a6i5oi356uv5a6J5YWo5qih5Z6L77yM56eB6ZKl5L+d5a2Y5Zyo5pys5Zyw77yM5rC45LiN5Y+R6YCB57uZ5Lu75L2V5pyN5Yqh5ZmoXCIsXG4gIFwiQUJPVVRfNlwiOlwiMy7lupTnlKjnqIvluo/mj5DkvpvnroDljZXlhbfmnInlkLjlvJXlipvnmoTnlKjmiLfmjqXlj6Pku6Xlj4rkvZPpqozjgIJcIixcbiAgXCJBQk9VVF83XCI6XCI0LuW6lOeUqOeoi+W6j+awuOS4jeimgeaxgueUqOaIt+i+k+WFpeS7u+S9leS4quS6uuS/oeaBr1wiLFxuICBcIkFCT1VUXzhcIjpcIuaKleelqCBnb29kLWthcm1hIOS9nOS4uuingeivgeS6ulwiLFxuICBcIkFCT1VUXzlcIjpcIuiBlOezuy/lj43ppohcIixcbiAgXCJBQk9VVF8xMFwiOlwi5pu05aSa5L+h5oGvXCIsXG4gIFwiUkVNT1ZFXCI6XCLnp7vpmaRcIixcbiAgXCJNQVJLRVRfVklFV1wiOlwi5biC5Zy66KeC5a+fXCIsXG4gIFwiUFJJQ0VcIjpcIuS7t+agvFwiLFxuICBcIkFNT1VOVFwiOlwi5pWw6YePXCIsXG4gIFwiVE9UQUxcIjpcIuaAu+WFsVwiLFxuICBcIk5PT1JERVJTXCI6XCLmsqHmnInorqLljZVcIixcbiAgXCJEQVRFXCI6XCLml6XmnJ9cIixcbiAgXCJCVVlcIjpcIuS5sFwiLFxuICBcIlNFTExcIjpcIuWNllwiLFxuICBcIk9QRU5cIjpcIuW8gOaUvlwiLFxuICBcIkhJU1RPUllcIjpcIuWOhuWPslwiLFxuICBcIkZPTExPV19CQUNLXCI6XCLlhbPms6jlm55cIixcbiAgXCJGT0xMT1dFRFwiOlwi5bey5YWz5rOoXCIsXG4gIFwiVU5GT0xMT1dcIjpcIuWPlua2iOWFs+azqFwiLFxuICBcIkZPTExPV0lOR1wiOlwi5YWz5rOoXCIsXG4gIFwiRk9MTE9XRVJTXCI6XCLnsonkuJ1cIixcbiAgXCJTRUFSQ0hfRk9MTE9XRVJTXCI6XCLmkJzntKLnsonkuJ1cIixcbiAgXCJTRUFSQ0hfRk9MTE9XSU5HXCI6XCLmkJzntKLlhbPms6hcIixcbiAgXCJCWVwiOlwi55SxXCIsXG4gIFwiSU5cIjpcIuWcqFwiLFxuICBcIk1FTlVcIjpcIuiPnOWNlVwiLFxuICBcIkJPT0tNQVJLXCI6XCLkuabnrb5cIixcbiAgXCJSRUJMT0dcIjpcIui9rOWPkVwiLFxuICBcIlVQVk9URVwiOlwi6LWe5oiQ56WoXCIsXG4gIFwiRE9XTlZPVEVcIjpcIuWPjeWvueelqFwiLFxuICBcIlVOVk9URV9ET1dOVk9URURcIjpcIuWPlua2iOWPjeWvueelqFwiLFxuICBcIlVOVk9URV9VUFZPVEVEXCI6XCLlj5bmtojotZ7miJDnpahcIixcbiAgXCJSRVBMWVwiOlwi5Zue5aSNXCIsXG4gIFwiRURJVFwiOlwi57yW6L6RXCIsXG4gIFwiUE9TVF8xXCI6XCLlnKjor4TorrrkuIrlkJHlt6bmu5HliqjmnaXmn6XnnIvpgInpoblcIixcbiAgXCJQT1NUXzJcIjpcIuWcqOivhOiuuuS4iueCueWHu+adpeafpeeci+WtkOivhOiuulwiLFxuICBcIk9QVElPTlNcIjpcIumAiemhuVwiLFxuICBcIlJFU1RFRU1FRF9CWVwiOlwi6L2s5Y+R55SxXCIsXG4gIFwiTk9USElOR19IRVJFXCI6XCLov5nov5jku4DkuYjpg73msqHmnIkuLi5cIixcbiAgXCJCQUxBTkNFU1wiOlwi5L2Z6aKdXCIsXG4gIFwiUFJPRklMRV8xXCI6XCJ7e3BsYXRmb3JtbmFtZX19LCDlj6/kuqTmmJPku6PluIHlj6/ku6Xpmo/ml7bovaznp7suIHt7cGxhdGZvcm1uYW1lfX0g5Y+v5Lul6YCa6L+H5Y+r5YGa5YWF6IO955qE6L+H56iL6KKr6L2s5o2i5Li6e3twbGF0Zm9ybXBvd2VyfX3jgIJcIixcbiAgXCJQUk9GSUxFXzJcIjpcInt7cGxhdGZvcm1wb3dlcn19LCDlvbHlk43lipvku6PluIHnlKjkuo7plb/mnJ/mjIHmnInku6Xlj4rnu5nmlofnq6DmipXnpajjgILmjIHmnInnmoTotorlpJrotorog73lvbHlk43ku5bkurrnmoTotY/ph5Hku6Xlj4rpgJrov4fmraPnoa7lnLDmipXnpajojrflvpflpZblirHjgIJcIixcbiAgXCJQUk9GSUxFXzNcIjpcIuS7o+W4geWkp+amguWAvHt7cGxhdGZvcm1zdW5pdH19IHt7cGxhdGZvcm1uYW1lfX1cIixcbiAgXCJFU1RJTUFURURfVkFMVUVcIjpcIuS8sOiuoeS7t+WAvFwiLFxuICBcIlBST0ZJTEVfNFwiOlwi5Lyw6K6h5Lu35YC85Z+65LqOe3twbGF0Zm9ybW5hbWV9feeahDfml6XlubPlnYflgLxcIixcbiAgXCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6XCLkuqTmmJPljoblj7JcIixcbiAgXCJQT1NUSU5HXCI6XCLlj5HluINcIixcbiAgXCJQUk9GSUxFXzVcIjpcIuWPkeW4g+WvhumSpeeUqOS6juWPkeihqOaWh+eroOS7peWPiuaKleelqO+8jOWug+W6lOivpeS4jeWQjOS6jua0u+WKqOWvhumSpeS7peWPiuaJgOacieiAheWvhumSpeOAglwiLFxuICBcIk9XTkVSXCI6XCLmiYDmnInogIVcIixcbiAgXCJQUk9GSUxFXzZcIjpcIuaJgOacieiAheWvhumSpeaYr+W4kOaIt+S4u+WvhumSpe+8jOW9k+S/ruaUueWFtuWug+WvhumSpeaXtumcgOimgeaPkOS+m+OAguaJgOacieiAheWvhumSpeeahOengemSpeaIluWvhueggeW6lOWwveWPr+iDveWcsOemu+e6v+S/neeuoeOAglwiLFxuICBcIkFDVElWRVwiOlwi5rS75YqoXCIsXG4gIFwiUFJPRklMRV83XCI6XCLmtLvliqjlr4bpkqXnlKjkuo7lj5HotbfovazotKbku6Xlj4rlnKjlhoXpg6jluILlnLrkuIvljZVcIixcbiAgXCJNRU1PXCI6XCLlpIfms6hcIixcbiAgXCJQUk9GSUxFXzhcIjpcIuWkh+azqOWvhumSpeeUqOS6juWIm+W7uuWSjOmYheivu+Wkh+azqFwiLFxuICBcIkJMT0dcIjpcIuWNmuWuolwiLFxuICBcIlBPU1RTXCI6XCLmlofnq6BcIixcbiAgXCJSRVBMSUVTXCI6XCLlm57lpI1cIixcbiAgXCJXQUxMRVRcIjpcIumSseWMhVwiLFxuICBcIlRBR1wiOlwi5qCH562+XCIsXG4gIFwiVVNFUlwiOlwi55So5oi3XCIsXG4gIFwiQ0xPU0VcIjpcIuWFs+mXrVwiLFxuICBcIlRPXCI6XCJcIixcbiAgXCJBU1NFVFwiOlwi6LWE5LqnXCIsXG4gIFwiU0VORFwiOlwi5Y+R6YCBXCIsXG4gIFwiU0VDVVJJVFlcIjpcIuWuieWFqFwiLFxuICBcIkFWQUlMQUJMRVwiOlwi5Y+v55SoXCIsXG4gIFwiUFVCTElDX01FTU9cIjpcIuWFrOWFseWkh+azqFwiLFxuICBcIlRPX0RFU0NcIjpcIueUqOaItyAo5L6L5aaCOmdvb2Qta2FybWEpXCIsXG4gIFwiUElOX0NPREVcIjpcIlBpbiDnoIFcIixcbiAgXCJQSU5fVEVYVFwiOlwiUElO56CB5biu5Yqp5L2g5L+d5oqk5bqU55So5ZKM5pWw5o2u5a6J5YWo44CCPGJyLz48YnIvPjxiPuazqOaEjzo8L2I+5LiA5pem5ZCv55So77yM5L2g5pyA5aSa5bCd6K+V6Kej6ZSBNOasoe+8jOWmguaenOW/mOiusOaIluWksei0pe+8jOW6lOeUqOeoi+W6j+Wwhuenu+mZpOW3sueZu+mZhueUqOaIt+aVsOaNruOAguS9oOWPr+S7pemHjeaWsOeZu+mZhuW5tue7p+e7reS9v+eUqOW6lOeUqOeoi+W6j+OAglwiLFxuICBcIk5PVElGSUNBVElPTlNcIjpcIumAmuefpVwiLFxuICBcIlZPVEVfVEVYVFwiOlwi5b2T5pyJ5Lq657uZ5L2g55qE5YaF5a655oqV56Wo5pe277yM5L2g5bCG5b6X5Yiw6YCa55+l77yBPGJyLz4gPGI+5rOo5oSPOjwvYj4g6YCa55+l5YyF5ous5oqV56Wo5p2D6YeN5Lul5Y+K5o+Q6YaS5L+h5oGv44CCICjotZ7miJDnpagsIOWPjeWvueelqCwg5Y+W5raI5oqV56WoKS4gXCIsXG4gIFwiVk9URVwiOlwi5oqV56WoXCIsXG4gIFwiQ09NTUVOVF9URVhUXCI6XCLlvZPmnInkurror4TorrrkvaDnmoTmlofnq6DmiJbor4Torrrml7bvvIzkvaDlsIblvpfliLDpgJrnn6XvvIE8Yj7ms6jmhI86PC9iPiDpgJrnn6XkuZ/ljIXmi6zliKvkuro8Yj7nvJbovpE8L2I+5LuW5Lus55qE6K+E6K66LiBcIixcbiAgXCJDT01NRU5UXCI6XCLor4TorrpcIixcbiAgXCJGT0xMT1dfVEVYVFwiOlwi5b2T5LuW5Lq65YWz5rOo5L2g5oiW5Y+W5raI5YWz5rOo5pe25L2g5bCG6I635b6X6YCa55+l77yBXCIsXG4gIFwiTUVOVElPTlNcIjpcIuaPkOWPilwiLFxuICBcIk1FTlRJT05TX1RFWFRcIjpcIuW9k+S7luS6uuWcqOaWh+eroOaIluivhOiuuuS4reaPkOWPiuS9oO+8jOS9oOWwhuW+l+WIsOmAmuefpe+8gVwiLFxuICBcIlJFU1RFRU1cIjpcIui9rOWPkVwiLFxuICBcIlJFU1RFRU1fVEVYVFwiOlwi5b2T5LuW5Lq66L2s5Y+R5L2g55qE5paH56ug5pe277yM5L2g5bCG5b6X5Yiw6YCa55+l77yBXCIsXG4gIFwiQ09ORklHVVJBVElPTlNcIjpcIumFjee9rlwiLFxuICBcIlZPVElOR1wiOlwi5oqV56Wo5LitXCIsXG4gIFwiVk9USU5HX1RFWFRcIjpcIuaKleelqOadg+mHjeaIlueZvuWIhuavlOW9seWTjUFQUOS4reaKleelqOWogeWKm++8jOS9oOWPr+S7peeUqOS6juiwg+iKguS9oOeahOaKleelqOaUtuebiuOAgjxici8+PGJyLz48Yj7ms6jmhI86PC9iPiDov5nkuZ/lsIbmm7TmlLnmipXlj43lr7nnpajnmoTmnYPph40v55m+5YiG5q+U5bm25LiU5pW05LiqQVBQ6IyD5Zu05YaF5pyJ5pWILlwiLFxuICBcIlNFUlZFUlwiOlwi5pyN5Yqh5ZmoXCIsXG4gIFwiU0VSVkVSX1RFWFRcIjpcIuaOqOiNkFwiLFxuICBcIlNBVkVfQ0hBTkdFU1wiOlwi5L+d5a2Y5L+u5pS5XCIsXG4gIFwiVk9URVJTX0lORk9cIjpcIuaKleelqOiAheS/oeaBr1wiLFxuICBcIldFTENPTUVfQkFDS1wiOlwi5qyi6L+O5b2S5p2l77yBXCIsXG4gIFwiTE9HSU5fMVwiOlwi5L2/55So55So5oi35ZCN5a+G56CB55m76ZmG5ZCO57un57utXCIsXG4gIFwiTE9HSU5fMlwiOlwi5Y+R5biD5a+G6ZKl55So5LqO5Y+R6KGo5paH56ug44CB6K+E6K6644CB5oqV56Wo44CB5Lul5Y+K5YWz5rOo5LuW5Lq6XCIsXG4gIFwiTE9HSU5fM1wiOlwi5rS75Yqo5a+G6ZKl55So5LqO6L2s6LSm5Lul5Y+K5pu05paw6LWE5paZ5Zu+54mH44CCXCIsXG4gIFwiTE9HSU5fNFwiOlwi55So5oi35Yet6K+B5L+d5a2Y5Zyo6K6+5aSH5pys5Zyw77yM6YCA5Ye65ZCO5Yet6K+B5Lya6KKr56e76Zmk77yBXCIsXG4gIFwiRE9OVF9IQVZFXCI6XCLov5jmsqHmnInotKbmiLfvvJ9cIixcbiAgXCJTSUdOX1VQX05PV1wiOlwi56uL5Y2z5rOo5YaMXCIsXG4gIFwiQ0FOQ0VMXCI6XCLlj5bmtohcIixcbiAgXCJBRFZBTkNFRFwiOlwi6auY57qn55qEXCIsXG4gIFwiQUNUSVZFX1BSSUtFWVwiOlwi5rS75Yqo56eB6ZKlXCIsXG4gIFwiUE9TVElOR19QUklLRVlcIjpcIuWPkeW4g+engemSpVwiLFxuICBcIk1BU1RFUl9QQVNTXCI6XCLkuLvlr4bnoIFcIixcbiAgXCJVU0VSTkFNRVwiOlwi55So5oi35ZCNXCIsXG4gIFwiQ0FSRF9WSUVXXCI6XCLljaHniYfop4blm75cIixcbiAgXCJDT01QQUNUX1ZJRVdcIjpcIue0p+WHkeinhuWbvlwiLFxuICBcIlNFQVJDSFwiOlwi5pCc57SiXCIsXG4gIFwiU1VCTUlUX0FfU1RPUllcIjpcIuaPkOS6pOaVheS6i1wiLFxuICBcIlJFUExZVE9cIjpcIuWbnuWkjee7mVwiLFxuICBcIlBPU1RcIjpcIuWPkeW4g1wiLFxuICBcIlBSRVZJRVdcIjpcIumihOiniFwiLFxuICBcIkRFRkFVTFRcIjpcIum7mOiupCA1MCUgLyA1MCVcIixcbiAgXCJQT1dFUlVQXCI6XCIxMDAlIOWFheiDvVwiLFxuICBcIkRFQ0xJTkVfUEFZT1VUXCI6XCLmi5Lnu53lpZbph5FcIixcbiAgXCJTQVZFX0ZPUl9MQVRFUlwiOlwi55WZ5b6F5Lul5ZCOXCIsXG4gIFwiQ0xFQVJcIjpcIua4hemZpFwiLFxuICBcIlBPU1RfQ09OVEVOVFwiOlwi5paH56ug5YaF5a65XCIsXG4gIFwiQ09NTUVOVF9DT05URU5UXCI6XCLor4TorrrlhoXlrrlcIixcbiAgXCJUSVRMRVwiOlwi5qCH6aKYXCIsXG4gIFwiVEFHU1wiOlwi5qCH562+XCIsXG4gIFwiTk9UX01BVENIXCI6XCLkuI3ljLnphY1cIixcbiAgXCJDT05GSVJNX1BJTlwiOlwi56Gu6K6kIFBJTlwiLFxuICBcIklOQ09SUkVDVFwiOlwi6ZSZ6K+v55qEXCIsXG4gIFwiT1BFTklOR19QT1NUXCI6XCLmraPlnKjmiZPlvIDmlofnq6BcIixcbiAgXCJTRVRfUElOXCI6XCLorr7nva4gUElOXCIsXG4gIFwiRU5URVJfUElOXCI6XCLovpPlhaUgUElOXCIsXG4gIFwiQVJFX1lPVV9TVVJFXCI6XCLkvaDnoa7lrprlkJfvvJ9cIixcbiAgXCJSRUJMT0dfVEVYVFwiOlwi6L2s5Y+R5LiN5Y+v6YCG77yM5piv5ZCm57un57ut77yfXCIsXG4gIFwiQlJPQURDQVNUX0VSUk9SXCI6XCLlub/mkq3plJnor6/vvIzor7fph43or5XvvIFcIixcbiAgXCJTVUNDRVNTXCI6XCLmiJDlip9cIixcbiAgXCJSRUJMT0dHRURfUE9TVFwiOlwi6L2s5Y+R55qE5paH56ugXCIsXG4gIFwiTE9HSU5fRkFJTFwiOlwi55m76ZmG5aSx6LSl77yB5aaC5p6c6YCJ5oup6auY57qn5qih5byP77yM6K+356Gu6K6k5L2/55So5Li75a+G56CB55m76ZmG5oiW5Zyo55m76ZmG5pe25o+Q5L6b5Y+R5biD56eB6ZKl44CCXCIsXG4gIFwiTE9HSU5fRkFJTF9BXCI6XCLnmbvpmYblpLHotKXvvIHlpoLmnpzpgInmi6npq5jnuqfmqKHlvI/vvIzor7fnoa7orqTkvb/nlKjkuLvlr4bnoIHnmbvpmYbmiJblnKjnmbvpmYbml7bmj5Dkvpvlj5HluIPnp4HpkqXjgIJcIixcbiAgXCJXQVJOSU5HXCI6XCLorablkYpcIixcbiAgXCJWT1RFX0ZPUl9XSVRORVNTXCI6XCLmipXnpajnu5nop4Hor4HkurpcIixcbiAgXCJWT1RFRF9GT1JfV0lUTkVTU1wiOlwi5bey5oqV56Wo57uZ6KeB6K+B5Lq6XCIsXG4gIFwiQUdPXCI6XCLku6XliY1cIixcbiAgXCJGUk9NX05PV1wiOlwi5LuO546w5Zyo5byA5aeLXCIsXG4gIFwiU0VDU1wiOlwi56eSXCIsXG4gIFwiQV9NSU5cIjpcIuS4gOWIhumSn1wiLFxuICBcIk1JTlNcIjpcIuWIhumSn1wiLFxuICBcIkFOX0hPVVJcIjpcIuS4gOWwj+aXtlwiLFxuICBcIkhPVVJTXCI6XCLlsI/ml7ZcIixcbiAgXCJBX0RBWVwiOlwi5LiA5aSpXCIsXG4gIFwiREFZU1wiOlwi5aSpXCIsXG4gIFwiQV9NT05USFwiOlwi5LiA5pyIXCIsXG4gIFwiTU9OVEhTXCI6XCLmnIhcIixcbiAgXCJBX1lFQVJcIjpcIuS4gOW5tFwiLFxuICBcIllFQVJTXCI6XCLlubRcIixcbiAgXCJNSU5fUkVBRFwiOlwi5YiG6ZKf6ZiF6K+7XCIsXG4gIFwiRE9XTlZPVEVfRkxBR1wiOlwi5Y+N5a+556WoXCIsXG4gIFwiQ0FQVFVSRV9QSUNUVVJFXCI6XCLmjZXojrflm77niYdcIixcbiAgXCJTRUxFQ1RfUElDVFVSRVwiOlwi6YCJ5oup5Zu+54mHXCIsXG4gIFwiU0VUX0NVU1RPTV9VUkxcIjpcIuiuvue9ruiHquWumuS5iVVSTFwiLFxuICBcIklOU0VSVF9QSUNUVVJFXCI6XCLmj5LlhaXlm77niYdcIixcbiAgXCJFUlJPUlwiOlwi6ZSZ6K+vXCIsXG4gIFwiVVBMT0FEX0VSUk9SXCI6XCLkuIrkvKDplJnor69cIixcbiAgXCJDQU1FUkFfQ0FOQ0VMTEVEXCI6XCLnm7jmnLrlt7Llj5bmtohcIixcbiAgXCJTRVRfVVJMXCI6XCLorr7nva5VUkxcIixcbiAgXCJESVJFQ1RfTElOS19QSUNUVVJFXCI6XCLlm77niYfnmoTnm7TmjqXnvZHnu5zpk77mjqVcIixcbiAgXCJDT01NRU5UX1NVQk1JVFRFRFwiOlwi6K+E6K665bey5o+Q5LqkXCIsXG4gIFwiREVMRVRFX0NPTU1FTlRcIjpcIuWIoOmZpOivhOiuuuaYr+S4jeWPr+mAhueahC4uLlwiLFxuICBcIkRFTEVURURfQ09NTUVOVFwiOlwi6K+E6K665bey5Yig6ZmkXCIsXG4gIFwiVVBMT0FESU5HX1BJQ1RVUkVcIjpcIuWbvueJh+S4iuS8oOS4rVwiLFxuICBcIlVQTE9BRF9DT01QTEVURURcIjpcIuS4iuS8oOWujOaIkFwiLFxuICBcIlVQTE9BRF9GQUlMRURcIjpcIuS4iuS8oOWksei0pVwiLFxuICBcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOlwi55So5oi35ZCN5oiW5a+G56CB5LiN5a+5XCIsXG4gIFwiSU5GT1wiOlwi5L+h5oGvXCIsXG4gIFwiUVJfVEVYVFwiOlwi6K+35bCG5LqM57u056CB5qGG5YWl5omr5o+P5Yy65Z+fXCIsXG4gIFwiQkFMQU5DRV9URVhUXCI6XCLor7fnoa7orqTkvaDmnInotrPlpJ/nmoTkvZnpop3nlKjkuo7ovazotKbvvIFcIixcbiAgXCJOT05FWElTVF9VU0VSXCI6XCLkvaDovazotKbnmoTnm67moIfnlKjmiLfkuI3lrZjlnKjvvIFcIixcbiAgXCJUUkFOU0ZFUl9URVhUXCI6XCLmmK/lkKbnoa7orqTovazotKbvvJ9cIixcbiAgXCJDT05GSVJNQVRJT05cIjpcIuehruiupFwiLFxuICBcIlRYX0JST0FEQ0FTVEVEXCI6XCLkuqTmmJPlt7Llub/mkq1cIixcbiAgXCJGRUVEXCI6XCLor53pophcIixcbiAgXCJUUkVORElOR1wiOlwi6LaL5ZCRXCIsXG4gIFwiSE9UXCI6XCLng63ngrlcIixcbiAgXCJORVdcIjpcIuaWsOeahFwiLFxuICBcIlBST01PVEVEXCI6XCLmjqjplIBcIixcbiAgXCJWT1RFU1wiOlwi56WoXCIsXG4gIFwiUEFZT1VUXCI6XCLlpZbph5FcIixcbiAgXCJDT01NRU5UU1wiOlwi6K+E6K66XCIsXG4gIFwiVFJFTkRJTkdfMzBcIjpcIjMw5pel6LaL5ZCRXCIsXG4gIFwiU09SVF9QT1NUX0JZXCI6XCLmjpLluo/mjInvvJpcIixcbiAgXCJQQVlPVVRfQ1lDTEVcIjpcIuaUr+S7mOWRqOacn1wiLFxuICBcIlBPVEVOVElBTF9QQVlPVVRcIjpcIua9nOWcqOWllumHkVwiLFxuICBcIlBBU1RfUEFZT1VUXCI6XCLov4fljrvnmoTlpZbph5FcIixcbiAgXCJBVVRIT1JfUEFZT1VUXCI6XCLkvZzogIXlpZbph5FcIixcbiAgXCJDVVJBVElPTl9QQVlPVVRcIjpcIuebkeaKpOS6uuWllumHkVwiLFxuICBcIlBPU1RfU1VCTUlUVEVEXCI6XCLmlofnq6Dlt7Lmj5DkuqTvvIFcIixcbiAgXCJQT1NUX0xBVEVSXCI6XCLmlofnq6DnlZnlvoXku6XlkI7mj5DkuqTvvIFcIixcbiAgXCJTQVZFRFwiOlwi5bey5L+d5a2YXCIsXG4gIFwiQ0xFQVJFRFwiOlwi5bey5riF6ZmkXCIsXG4gIFwiRkxBR0dJTkdfVEVYVFwiOlwi57uZ5paH56ug5oqV5Y+N5a+556Wo5Lya56e76Zmk5pS255uK5bm26ZmN5L2O5p2Q5paZ55qE5Y+v6KeB5oCn44CCPGJyPjxicj7lj43lr7nnpajnlKjkuo7ku6XkuIvlnLrmma/vvJo8dWw+PGxpPuW8hOiZmuS9nOWBh+aIluWJveeqgzwvbGk+PGxpPuS7h+aBqOiogOiuuuaIlue9kee7nOmSk+mxvDwvbGk+PGxpPuaVheaEj+aUvumUmeexu+ebruWGheWuueaIluiAhVNQQU08L2xpPjwvdWw+XCIsXG4gIFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6XCLovr7liLDor7fmsYLpmZDliLbjgILmo4Dmn6Xlhbbku5botovlir8v5qCH562+77yBXCIsXG4gIFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6XCLmlofnq6Dlt7Lku47kuabnrb7lhoXnp7vpmaTvvIFcIixcbiAgXCJQT1NUX0lTX0JPT0tNQVJLXCI6XCLmlofnq6Dlt7Lnu4/liqDlhaXkuabnrb7vvIFcIixcbiAgXCJSRVNFVFwiOlwi6YeN572uXCIsXG4gIFwiTU9ESUZZX1BJQ1RVUkVcIjpcIue8lui+kei1hOaWmeWbvueJh1wiLFxuICBcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6XCLkv67mlLnlsIHpnaLlm77niYdcIixcbiAgXCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjpcIuWmguaenOS9oOmAieS4remrmOe6p+eZu+mZhuaooeW8j++8jOivt+aPkOS+m+a0u+WKqOengemSpe+8gVwiLFxuICBcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOlwi6L+Z5bCG6YeN572u55So5oi36LWE5paZ5Zu+54mHXCIsXG4gIFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6XCLov5nlsIbph43nva7nlKjmiLflsIHpnaLlm77niYdcIixcbiAgXCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOlwi5pyN5Yqh5Zmo5pu05paw6ZyA6KaB6YeN5ZCvXCIsXG4gIFwiU0VUVElOR1NfVVBEQVRFRFwiOlwi6K6+572u5bey5pu05pawXCIsXG4gIFwiTEFOR1VBR0VTXCI6XCLor63oqIBcIixcbiAgXCJMQU5HVUFHRVNfVEVYVFwiOlwi5L2g5Y+v5Lul5Zyo6L+Z5L+u5pS55q2k5bqU55So6K+t6KiA44CCXCIsXG4gIFwiTE9HSU5fVE9fWFwiOlwi5q2k6aG55pON5L2c6KaB5rGC55So5oi35L2/55So5Li75a+G56CB77yM5rS75YqoL+WPkeW4g+WvhumSpeOAguivt+eZu+mZhuW5tumHjeivleOAglwiLFxuICBcIkdBTExFUllcIjpcIuWbvuW6k1wiLFxuICBcIlRSQU5TTEFUSU9OU1wiOlwi57+76K+R6LSh54yu6ICFXCIsXG4gIFwiU0hBUkVcIjpcIuWIhuS6q1wiLFxuICBcIk1BUktFVFBMQUNFXCI6XCLluILlnLpcIixcbiAgXCJFWENIQU5HRVwiOlwi5Lqk5piT5omAXCIsXG4gIFwiRFJBRlRTXCI6XCLojYnnqL9cIixcbiAgXCJQT1NUX0lTX1VORFJBRlRcIjpcIuaWh+eroOW3suS7juiNieeov+WGheenu+mZpO+8gVwiLFxuICBcIlBPU1RfSVNfRFJBRlRcIjpcIuaWh+eroOW3sue7j+WKoOWFpeiNieeov++8gVwiLFxuICBcIlNXSVBFX0xFRlRcIjpcIuWQkeW3pua7keWKqOafpeeci+mAiemhuVwiLFxuICBcIk1BTkFHRVwiOlwi566h55CGXCIsXG4gIFwiSU1BR0VfUkVNT1ZFRFwiOlwi5Zu+5YOP5bey5Yig6ZmkXCIsXG4gIFwiQ09QWVwiOlwi5aSN5Yi2XCIsXG4gIFwiTk9fSU1BR0VcIjpcIuS9oOi/mOayoeacieS4iuS8oOS7u+S9leWbvueJh++8gVwiLFxuICBcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6XCLkuIvmi4nliLfmlrBcIixcbiAgXCJFWFRFUk5BTF9BUFBTXCI6XCLlpJbpg6jlupTnlKhcIixcbiAgXCJQTFVHSU5TXCI6XCLmj5Lku7ZcIixcbiAgXCJTVUdHRVNUXCI6XCLlu7rorq5cIixcbiAgXCJDT01JTkdfU09PTlwiOlwi5Y2z5bCG5Yiw5p2lXCIsXG4gIFwiQ0hBSU5cIjpcIumTvlwiLFxuICBcIkNIQUlOX1RFWFRcIjpcIuWcqOedgOS9oOWPr+S7peS/ruaUueWMuuWdl+mTvuaIlum7mOiupOW5s+WPsFwiLFxuICBcIkNVUlJFTkNZXCI6XCJcIixcbiAgXCJDVVJSRU5DWV9URVhUXCI6XCJcIixcbiAgXCJBQk9VVF8xMVwiOlwiXCIsXG4gIFwiRk9VTkRFUlwiOlwiXCIsXG4gIFwiQUREX0FDQ09VTlRcIjpcIlwiLFxuICBcIlBMQVRGT1JNXCI6XCJcIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJIT01FXCI6XCLpppbpoIFcIixcbiAgXCJMT0dJTlwiOlwi55m75YWlXCIsXG4gIFwiTE9HT1VUXCI6XCLnmbvlh7pcIixcbiAgXCJQUk9GSUxFXCI6XCLpl5zmlrxcIixcbiAgXCJGT0xMT1dcIjpcIui/vei5pFwiLFxuICBcIkJPT0tNQVJLU1wiOlwi5pu457GkXCIsXG4gIFwiVFJBTlNGRVJcIjpcIui9ieW4s1wiLFxuICBcIk1BUktFVFwiOlwi5biC5aC0XCIsXG4gIFwiU0VUVElOR1NcIjpcIuioreWumlwiLFxuICBcIkFCT1VUXCI6XCLpl5zmlrxcIixcbiAgXCJBQk9VVF8xXCI6XCLmiYDmnInkurrnmoTlhaflrrnpg73lj6/ku6XlnKjpgJnoo6HnjbLlvpfnjY7li7VcIixcbiAgXCJBQk9VVF8yXCI6XCLmmK/nlLF7e3BsYXRmb3JtbmFtZX195bmz5Y+w5omA5pSv5oyB44CC5q2kQXBw5LmL6ZaL55m86ICF54K6XCIsXG4gIFwiQUJPVVRfM1wiOlwi5q2k54K66ZaL5rqQ5byP44CB56S+5Y2A6amF5YuV5LmL6KGM5YuV5L2/55So5pa55qGI77yM5o+Q5L6b5L2/55So6ICF5YWn5a656Zax6K6A44CB6KmV6KuW44CB5oqV56Wo44CB5paH56ug55m85biD6IiH5pS25YWl6L2J5biz562J5Yqf6IO944CC5ZCE6aCF5Yqf6IO95piv55Sxe3twbGF0Zm9ybW5hbWV9feS5i+WNgOWhiumPiOS7peWPint7c2l0ZW5hbWV9fee2suermeaJgOaPkOS+m+OAglwiLFxuICBcIkFCT1VUXzRcIjpcIuacrEFwcOS4jeacg+iZleeQhuaIlueuoeaOp+S9v+eUqOiAheS5i+izh+mHkeOAglwiLFxuICBcIkFCT1VUXzVcIjpcIuacrEFwcOaPkOS+m+WuouaItuerr+WuieWFqOS9v+eUqOaooeW8j++8jOS9v+eUqOiAheengemRsOWPquWcqOacrOapn+WFp+mDqOS9v+eUqO+8jOe1leS4jemAgeWHuuWIsOS7u+S9leWklumDqOS8uuacjeWZqOOAglwiLFxuICBcIkFCT1VUXzZcIjpcIuacrEFwcOaPkOS+m+ewoeWWruWlveeUqOS5i+S9v+eUqOiAheS7i+mdouiIh+e2k+mpl+OAglwiLFxuICBcIkFCT1VUXzdcIjpcIuacrEFwcOe1leS4jeacg+WQkeS9v+eUqOiAheimgeaxguaPkOS+m+S7u+S9leWAi+S6uuizh+aWmeOAglwiLFxuICBcIkFCT1VUXzhcIjpcIuaKleelqOaUr+aMgWdvb2Qta2FybWHmiJDngrp3aXRuZXNzXCIsXG4gIFwiQUJPVVRfOVwiOlwi6IGv57WhL+aEj+imi+Wbnumli1wiLFxuICBcIkFCT1VUXzEwXCI6XCLmm7TlpJroqIrmga9cIixcbiAgXCJSRU1PVkVcIjpcIuenu+mZpFwiLFxuICBcIk1BUktFVF9WSUVXXCI6XCLkuqTmmJPluILloLRcIixcbiAgXCJQUklDRVwiOlwi5YO55qC8XCIsXG4gIFwiQU1PVU5UXCI6XCLmlbjph49cIixcbiAgXCJUT1RBTFwiOlwi57i96KiIXCIsXG4gIFwiTk9PUkRFUlNcIjpcIueEoeaOm+WWrlwiLFxuICBcIkRBVEVcIjpcIuaXpeacn1wiLFxuICBcIkJVWVwiOlwi6LK35YWlXCIsXG4gIFwiU0VMTFwiOlwi6LOj5Ye6XCIsXG4gIFwiT1BFTlwiOlwi5o6b5ZauXCIsXG4gIFwiSElTVE9SWVwiOlwi5q235Y+y57SA6YyEXCIsXG4gIFwiRk9MTE9XX0JBQ0tcIjpcIue0jeWFpei/vei5pFwiLFxuICBcIkZPTExPV0VEXCI6XCLmraPooqvov73ouaRcIixcbiAgXCJVTkZPTExPV1wiOlwi5Y+W5raI6L+96LmkXCIsXG4gIFwiRk9MTE9XSU5HXCI6XCLov73ouaTkvaDnmoTlkI3llq5cIixcbiAgXCJGT0xMT1dFUlNcIjpcIuS9oOi/vei5pOeahOWQjeWWrlwiLFxuICBcIlNFQVJDSF9GT0xMT1dFUlNcIjpcIuaQnOWwi+i/vei5pOS9oOeahOWQjeWWrlwiLFxuICBcIlNFQVJDSF9GT0xMT1dJTkdcIjpcIuaQnOWwi+S9oOi/vei5pOeahOWQjeWWrlwiLFxuICBcIkJZXCI6XCLnlLFcIixcbiAgXCJJTlwiOlwi5ZyoXCIsXG4gIFwiTUVOVVwiOlwi6YG45ZauXCIsXG4gIFwiQk9PS01BUktcIjpcIuabuOexpFwiLFxuICBcIlJFQkxPR1wiOlwi6L2J6LK8XCIsXG4gIFwiVVBWT1RFXCI6XCLorppcIixcbiAgXCJET1dOVk9URVwiOlwi5ZmTXCIsXG4gIFwiVU5WT1RFX0RPV05WT1RFRFwiOlwi5Y+W5raI5ZmTXCIsXG4gIFwiVU5WT1RFX1VQVk9URURcIjpcIuWPlua2iOiumlwiLFxuICBcIlJFUExZXCI6XCLlm57opoZcIixcbiAgXCJFRElUXCI6XCLnt6jovK9cIixcbiAgXCJQT1NUXzFcIjpcIuipleirluS4iuWQkeW3pua7keS7pemhr+ekuuWLleS9nOa4heWWrlwiLFxuICBcIlBPU1RfMlwiOlwi6bue5pOK6KmV6KuW5Y+v5bGV6ZaL5LiL5LiA5bGk6KmV6KuWXCIsXG4gIFwiT1BUSU9OU1wiOlwi6YG46aCFXCIsXG4gIFwiUkVTVEVFTUVEX0JZXCI6XCLovYnosrxcIixcbiAgXCJOT1RISU5HX0hFUkVcIjpcIuaWveW3peS4rVwiLFxuICBcIkJBTEFOQ0VTXCI6XCLntZDppJhcIixcbiAgXCJQUk9GSUxFXzFcIjpcInt7cGxhdGZvcm1uYW1lfX0g5piv5Y+v5Lqk5piT55qE6LKo5bmj77yM6Zqo5pmC5Y+v5Lul6YCy6KGM56e76L2J44CCe3twbGF0Zm9ybW5hbWV9fSDlj6/ku6XooqvovYnmj5vmiJAge3twbGF0Zm9ybXBvd2VyfX3vvIzmraTkuIDli5XkvZznqLHngrpwb3dlcmluZyB1cOOAglwiLFxuICBcIlBST0ZJTEVfMlwiOlwie3twbGF0Zm9ybXBvd2VyfX0g5Y+v6KaW54K65YW35pyJ5b2x6Z+/5Yqb55qE6IKh5qyK77yM5oyB5pyJ5Y+v6ZW35pyf5aKe5YC85Lim5bCN5paH56ug5oqV56Wo77yM5oyB5pyJ5pW46YeP6LaK5aSa5bCN5pa85YW25LuW5Lq6542O5Yu15aSn5bCP55qE5b2x6Z+/5Yqb5bCx6LaK5aSn77yM5Lmf5pu06IO95b6e5rqW56K655qE5oqV56Wo6KGM54K65Lit542y5b6X542O5Yu144CCIFwiLFxuICBcIlBST0ZJTEVfM1wiOlwi55uu5YmN5oyB5pyJe3twbGF0Zm9ybXN1bml0fX3nmoR7e3BsYXRmb3JtbmFtZX1944CCXCIsXG4gIFwiRVNUSU1BVEVEX1ZBTFVFXCI6XCLmpoLkvLDlg7nlgLxcIixcbiAgXCJQUk9GSUxFXzRcIjpcIuamguS8sOWDueWAvOaYr+S7pXt7cGxhdGZvcm1uYW1lfX0zLTXlpKnkuYvlubPlnYflg7nngrrln7rnpI5cIixcbiAgXCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6XCLkuqTmmJPmrbflj7LntIDpjIRcIixcbiAgXCJQT1NUSU5HXCI6XCJcIixcbiAgXCJQUk9GSUxFXzVcIjpcIlBvc3Rpbmfnp4HpkbDkvb/nlKjmlrznmbzmlofoiIfmjInorprmtLvli5XkuIrvvIzlhbboiIdBY3RpdmXku6Xlj4pPd25lcuengemRsOWKn+iDveS4jeWQjOOAglwiLFxuICBcIk9XTkVSXCI6XCJcIixcbiAgXCJQUk9GSUxFXzZcIjpcIk93bmVy56eB6ZGw5piv5pys5biz6Jmf5LmL5Li76ZGw77yM5YW35pyJ5pu05pS55YW25LuW56eB6ZGw55qE5qyK5Yqb44CC5a6J5YWo6LW36KaL77yMT3duZXLnp4HpkbDlr4bnorzmh4noqbLlhJjlj6/og73lnLDpm6Lnt5rlhLLlrZjjgIJcIixcbiAgXCJBQ1RJVkVcIjpcIlwiLFxuICBcIlBST0ZJTEVfN1wiOlwiQWN0aXZl56eB6ZGw55So5pa85biz6Jmf6LOH6YeR6JmV55CG5rS75YuV5Lul5Y+K5pa85YWn6YOo5biC5aC05LiL5Zau6LK36LOj5pa56Z2i44CCXCIsXG4gIFwiTUVNT1wiOlwiXCIsXG4gIFwiUFJPRklMRV84XCI6XCJNZW1v56eB6ZGw55So5pa85Ym16YCg6IiH6K6A5Y+WbWVtb+ioiuaBr+OAglwiLFxuICBcIkJMT0dcIjpcIumDqOiQveagvFwiLFxuICBcIlBPU1RTXCI6XCLkvaDnmoToqZXoq5ZcIixcbiAgXCJSRVBMSUVTXCI6XCLlm57mh4noqZXoq5ZcIixcbiAgXCJXQUxMRVRcIjpcIumMouWMhVwiLFxuICBcIlRBR1wiOlwi5qiZ57GkXCIsXG4gIFwiVVNFUlwiOlwi5L2/55So6ICFXCIsXG4gIFwiQ0xPU0VcIjpcIumXnOmWiVwiLFxuICBcIlRPXCI6XCLliLBcIixcbiAgXCJBU1NFVFwiOlwi6LOH55SiXCIsXG4gIFwiU0VORFwiOlwi5YKz6YCBXCIsXG4gIFwiU0VDVVJJVFlcIjpcIuWuieWFqOaAp1wiLFxuICBcIkFWQUlMQUJMRVwiOlwi5Y+v5L2/55SoXCIsXG4gIFwiUFVCTElDX01FTU9cIjpcIuWFrOmWi+ioiuaBr1wiLFxuICBcIlRPX0RFU0NcIjpcIuS9v+eUqOiAhe+8jOS+i+WmgiBnb29kLWthcm1hXCIsXG4gIFwiUElOX0NPREVcIjpcIuWvhueivFwiLFxuICBcIlBJTl9URVhUXCI6XCLoqK3nva7mraTlr4bnorzku6Xkv53orbdBcHDoiIfnlKjmiLbos4fmlpnjgII8YnIvPjxici8+PGI+5rOo5oSP77yaPC9iPuS4gOaXpuWVn+eUqO+8jOS9oOWPquiDveaciTTmrKHop6PpjpbmqZ/mnIPvvIzlpoLmnpzlv5joqJjlr4bnorzmiJbmmK/lhajmlbjnmbvlhaXlpLHmlZfvvIzliYdBcHDmnIPnp7vpmaTnmbvlhaXos4fmlpnjgILkvaDlj6/ku6Xlho3mrKHnmbvlhaXkuKbnubznuozkvb/nlKhBcHDjgIJcIixcbiAgXCJOT1RJRklDQVRJT05TXCI6XCLpgJrnn6VcIixcbiAgXCJWT1RFX1RFWFRcIjpcIuS9oOeahOWFp+WuueeNsuW+l+WIpeS6uuaMieiumuaZguacg+mAmuefpeS9oO+8gTxici8+IDxiPuazqOaEj++8mjwvYj4g6YCa55+l5YWn5a655YyF5ous5oyJ6K6a5qyK6YeN6IiH5o+Q6YaS6KiK5oGv44CC77yI5oyJ6K6a44CB5oyJ5ZmT44CB5Y+W5raI6K6a77yJXCIsXG4gIFwiVk9URVwiOlwi5oqV56WoXCIsXG4gIFwiQ09NTUVOVF9URVhUXCI6XCLku5bkurroqZXoq5bkvaDnmoTmlofnq6DmiJboqZXoq5bmmYLvvIzkvaDmnIPmlLbliLDpgJrnn6XvvIE8YnIvPiA8Yj7ms6jmhI/vvJo8L2I+IOWwjeaWueiLpTxiPumHjeaWsOe3qOi8rzwvYj7oqZXoq5blhaflrrnvvIzkuqbmnIPpgJrnn6XkvaDjgIJcIixcbiAgXCJDT01NRU5UXCI6XCLoqZXoq5ZcIixcbiAgXCJGT0xMT1dfVEVYVFwiOlwi5LuW5Lq66L+96Lmk5oiW5Y+W5raI6L+96Lmk5L2g5pmC77yM5L2g5pyD5pS25Yiw6YCa55+l77yBXCIsXG4gIFwiTUVOVElPTlNcIjpcIuaPkOWPilwiLFxuICBcIk1FTlRJT05TX1RFWFRcIjpcIuS7luS6uuWcqOaWh+eroOaIluipleirluS4reaPkOWPiuS9oOaZgu+8jOS9oOacg+aUtuWIsOmAmuefpe+8gVwiLFxuICBcIlJFU1RFRU1cIjpcIui9ieiyvFwiLFxuICBcIlJFU1RFRU1fVEVYVFwiOlwi5LuW5Lq66L2J6LK85L2g55qE5paH56ug5pmC77yM5L2g5pyD5pS25Yiw6YCa55+l77yBXCIsXG4gIFwiQ09ORklHVVJBVElPTlNcIjpcIue1hOaFi+ioreWumlwiLFxuICBcIlZPVElOR1wiOlwi5oqV56WoXCIsXG4gIFwiVk9USU5HX1RFWFRcIjpcIuaKleelqOasiumHjeacg+W9semfv+aKleelqOiDvemHj+S7peWPiuaKleelqOeNjuWLte+8jOS9oOWPr+S7peS6iOS7peiqv+aVtOOAgjxici8+IDxiPuazqOaEj++8mjwvYj4g5bCN5qyK6YeN5LmL6Kq/5pW05ZCM5qij6YGp55So5pa85oyJ6K6a6IiH5oyJ5ZmT77yM5Lim5oyB57qM5L+d5oyB5q2k5LiA5qyK6YeN44CCXCIsXG4gIFwiU0VSVkVSXCI6XCLkvLrmnI3lmahcIixcbiAgXCJTRVJWRVJfVEVYVFwiOlwi5o6o6JamXCIsXG4gIFwiU0FWRV9DSEFOR0VTXCI6XCLlhLLlrZjorormm7RcIixcbiAgXCJWT1RFUlNfSU5GT1wiOlwi5oqV56Wo6KiK5oGvXCIsXG4gIFwiV0VMQ09NRV9CQUNLXCI6XCLmraHov47lm57kvobvvIFcIixcbiAgXCJMT0dJTl8xXCI6XCLoq4vku6XmgqjnmoTkvb/nlKjogIXluLPomZ/oiIflr4bnorznmbvlhaVcIixcbiAgXCJMT0dJTl8yXCI6XCJQb3N0aW5nIGtleeeUqOaWvOeZvOW4g+aWh+eroOOAgeaKleelqOiIh+i/vei5pOOAglwiLFxuICBcIkxPR0lOXzNcIjpcIkFjdGl2ZSBrZXnnlKjmlrzovYnluLPnm7jpl5zoiIfjgIzpl5zmlrzjgI3kuYvlnJbniYfmm7TmlrDjgIJcIixcbiAgXCJMT0dJTl80XCI6XCLkvb/nlKjogIXnmoToqo3orYnos4foqIrlj6rkv53lrZjlnKjoo53nva7mnKzlnLDnq6/jgILnmbvlh7rlvozoqo3orYnos4foqIrlsIfooqvnp7vpmaTjgIJcIixcbiAgXCJET05UX0hBVkVcIjpcIumChOaykuacieW4s+iZn+WXju+8n1wiLFxuICBcIlNJR05fVVBfTk9XXCI6XCLppqzkuIrljrvoqLvlhopcIixcbiAgXCJDQU5DRUxcIjpcIuWPlua2iFwiLFxuICBcIkFEVkFOQ0VEXCI6XCLpgLLpmo5cIixcbiAgXCJBQ1RJVkVfUFJJS0VZXCI6XCJcIixcbiAgXCJQT1NUSU5HX1BSSUtFWVwiOlwiXCIsXG4gIFwiTUFTVEVSX1BBU1NcIjpcIk1hc3RlcuWvhueivC/kuLvlr4bnorxcIixcbiAgXCJVU0VSTkFNRVwiOlwi5L2/55So6ICF5ZCN56ixXCIsXG4gIFwiQ0FSRF9WSUVXXCI6XCLmraPluLjmqKHlvI9cIixcbiAgXCJDT01QQUNUX1ZJRVdcIjpcIueyvuewoeaooeW8j1wiLFxuICBcIlNFQVJDSFwiOlwi5pCc5bCLXCIsXG4gIFwiU1VCTUlUX0FfU1RPUllcIjpcIuaPkOS6pOaWh+eroFwiLFxuICBcIlJFUExZVE9cIjpcIuWbnuimhlwiLFxuICBcIlBPU1RcIjpcIuiyvOaWh1wiLFxuICBcIlBSRVZJRVdcIjpcIumgkOimvVwiLFxuICBcIkRFRkFVTFRcIjpcIumgkOiorSA1MCUgLyA1MCVcIixcbiAgXCJQT1dFUlVQXCI6XCJcIixcbiAgXCJERUNMSU5FX1BBWU9VVFwiOlwi6Kyd57WVUGF5b3V0XCIsXG4gIFwiU0FWRV9GT1JfTEFURVJcIjpcIumgkOWtmOiNieeov1wiLFxuICBcIkNMRUFSXCI6XCLmuIXpmaRcIixcbiAgXCJQT1NUX0NPTlRFTlRcIjpcIuiyvOaWh+WFp+WuuVwiLFxuICBcIkNPTU1FTlRfQ09OVEVOVFwiOlwi6KmV6KuW5YWn5a65XCIsXG4gIFwiVElUTEVcIjpcIuaomemhjFwiLFxuICBcIlRBR1NcIjpcIuaomeexpFwiLFxuICBcIk5PVF9NQVRDSFwiOlwi5LiN56ymXCIsXG4gIFwiQ09ORklSTV9QSU5cIjpcIueiuuiqjeWvhueivFwiLFxuICBcIklOQ09SUkVDVFwiOlwi5LiN5q2j56K6XCIsXG4gIFwiT1BFTklOR19QT1NUXCI6XCLmiZPplovosrzmlodcIixcbiAgXCJTRVRfUElOXCI6XCLph43oqK3lr4bnorxcIixcbiAgXCJFTlRFUl9QSU5cIjpcIui8uOWFpeWvhueivFwiLFxuICBcIkFSRV9ZT1VfU1VSRVwiOlwi5piv5ZCm56K65a6a77yfXCIsXG4gIFwiUkVCTE9HX1RFWFRcIjpcIui9ieiyvOeEoeazleWPlua2iO+8jOmChOimgee5vOe6jOWXju+8n1wiLFxuICBcIkJST0FEQ0FTVF9FUlJPUlwiOlwi5buj5pKt6Yyv6Kqk77yM6KuL5YaN6Kmm5LiA5qyh77yBXCIsXG4gIFwiU1VDQ0VTU1wiOlwi5oiQ5YqfXCIsXG4gIFwiUkVCTE9HR0VEX1BPU1RcIjpcIui9ieiyvOaWh+eroFwiLFxuICBcIkxPR0lOX0ZBSUxcIjpcIueZu+WFpeWkseaVl++8geiri+eiuuiqjeS9oOaYr+S7pW1hc3RlcuWvhueivOeZu+WFpe+8jOaIluaYr+WcqOmAsumajuaooeW8j+S4i+S7peaPkOS+m+S5i1Bvc3Rpbmfnp4HpkbDnmbvlhaXjgIJcIixcbiAgXCJMT0dJTl9GQUlMX0FcIjpcIueZu+WFpeWkseaVl++8geiri+eiuuiqjeS9oOaYr+S7pW1hc3RlcuWvhueivOeZu+WFpe+8jOaIluaYr+WcqOmAsumajuaooeW8j+S4i+S7peaPkOS+m+S5i0FjdGl2ZeengemRsOeZu+WFpeOAglwiLFxuICBcIldBUk5JTkdcIjpcIuitpuWRilwiLFxuICBcIlZPVEVfRk9SX1dJVE5FU1NcIjpcIuaKleelqOaUr+aMgeimi+itieS6ulwiLFxuICBcIlZPVEVEX0ZPUl9XSVRORVNTXCI6XCLmipXnpajmlK/mjIHngrropovorYnkurpcIixcbiAgXCJBR09cIjpcIuWJjVwiLFxuICBcIkZST01fTk9XXCI6XCLpgoTmnIlcIixcbiAgXCJTRUNTXCI6XCLnp5JcIixcbiAgXCJBX01JTlwiOlwi5LiA5YiG6ZCYXCIsXG4gIFwiTUlOU1wiOlwi5YiG6ZCYXCIsXG4gIFwiQU5fSE9VUlwiOlwi5LiA5bCP5pmCXCIsXG4gIFwiSE9VUlNcIjpcIuWwj+aZglwiLFxuICBcIkFfREFZXCI6XCLkuIDlpKlcIixcbiAgXCJEQVlTXCI6XCLlpKlcIixcbiAgXCJBX01PTlRIXCI6XCLkuIDlgIvmnIhcIixcbiAgXCJNT05USFNcIjpcIuWAi+aciFwiLFxuICBcIkFfWUVBUlwiOlwi5LiA5bm0XCIsXG4gIFwiWUVBUlNcIjpcIuWAi+W5tFwiLFxuICBcIk1JTl9SRUFEXCI6XCLliIbpkJjplrHoroDmmYLplpNcIixcbiAgXCJET1dOVk9URV9GTEFHXCI6XCLmjInlmZNcIixcbiAgXCJDQVBUVVJFX1BJQ1RVUkVcIjpcIueNsuWPluWclueJh1wiLFxuICBcIlNFTEVDVF9QSUNUVVJFXCI6XCLpgbjmk4flnJbniYdcIixcbiAgXCJTRVRfQ1VTVE9NX1VSTFwiOlwi6Kit5a6a5bCI55So6YCj57WQXCIsXG4gIFwiSU5TRVJUX1BJQ1RVUkVcIjpcIuaPkuWFpeWclueJh1wiLFxuICBcIkVSUk9SXCI6XCLpjK/oqqRcIixcbiAgXCJVUExPQURfRVJST1JcIjpcIuS4iuWCs+mMr+iqpFwiLFxuICBcIkNBTUVSQV9DQU5DRUxMRURcIjpcIuWPlua2iOebuOapn1wiLFxuICBcIlNFVF9VUkxcIjpcIuioreWumlVSTFwiLFxuICBcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjpcIuWclueJh+S5i+e2suermemAo+e1kFwiLFxuICBcIkNPTU1FTlRfU1VCTUlUVEVEXCI6XCLoqZXoq5bpgIHlh7pcIixcbiAgXCJERUxFVEVfQ09NTUVOVFwiOlwi5Yiq6Zmk6KmV6KuW5YuV5L2c5piv5LiN5Y+v5oGi5b6p55qEXCIsXG4gIFwiREVMRVRFRF9DT01NRU5UXCI6XCLlt7LliKrpmaTkuYvoqZXoq5ZcIixcbiAgXCJVUExPQURJTkdfUElDVFVSRVwiOlwi5LiK5YKz5ZyW54mHXCIsXG4gIFwiVVBMT0FEX0NPTVBMRVRFRFwiOlwi5LiK5YKz5a6M5oiQXCIsXG4gIFwiVVBMT0FEX0ZBSUxFRFwiOlwi5LiK5YKz5aSx5pWXXCIsXG4gIFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6XCLlr4bnorzmiJbluLPomZ/lkI3nqLHpjK/oqqRcIixcbiAgXCJJTkZPXCI6XCLoqIrmga9cIixcbiAgXCJRUl9URVhUXCI6XCLoq4vlsIdRUiBjb2Rl572u5pa85o6D5o+P5Y2A5Z+f5YWnXCIsXG4gIFwiQkFMQU5DRV9URVhUXCI6XCLoq4vnorroqo3mnInotrPlpKDppJjpoY3lj6/kvpvkuqTmmJPvvIFcIixcbiAgXCJOT05FWElTVF9VU0VSXCI6XCLovYnlhaXluLPomZ/kuI3lrZjlnKhcIixcbiAgXCJUUkFOU0ZFUl9URVhUXCI6XCLnorrlrpropoHpgLLooYzovYnluLPvvJ9cIixcbiAgXCJDT05GSVJNQVRJT05cIjpcIueiuuiqjVwiLFxuICBcIlRYX0JST0FEQ0FTVEVEXCI6XCLkuqTmmJPlt7Llu6Pmkq1cIixcbiAgXCJGRUVEXCI6XCLli5XmhYvmtojmga9cIixcbiAgXCJUUkVORElOR1wiOlwi54Sm6bueXCIsXG4gIFwiSE9UXCI6XCLnhrHploBcIixcbiAgXCJORVdcIjpcIuacgOaWsFwiLFxuICBcIlBST01PVEVEXCI6XCLotIrliqlcIixcbiAgXCJWT1RFU1wiOlwi56Wo5pW4XCIsXG4gIFwiUEFZT1VUXCI6XCLmlLblhaVcIixcbiAgXCJDT01NRU5UU1wiOlwi6KmV6KuWXCIsXG4gIFwiVFJFTkRJTkdfMzBcIjpcIjMw5aSp54Sm6bueXCIsXG4gIFwiU09SVF9QT1NUX0JZXCI6XCLmlofnq6DmjpLluo9cIixcbiAgXCJQQVlPVVRfQ1lDTEVcIjpcIuaUtuWFpemAseacn1wiLFxuICBcIlBPVEVOVElBTF9QQVlPVVRcIjpcIuacquWvpuePvuaUtuWFpVwiLFxuICBcIlBBU1RfUEFZT1VUXCI6XCLlt7LmlK/ku5jmlLblhaVcIixcbiAgXCJBVVRIT1JfUEFZT1VUXCI6XCLkvZzogIXmlLblhaVcIixcbiAgXCJDVVJBVElPTl9QQVlPVVRcIjpcIuaKleelqOaUtuWFpVwiLFxuICBcIlBPU1RfU1VCTUlUVEVEXCI6XCLmlofnq6Dlt7LpgIHlh7pcIixcbiAgXCJQT1NUX0xBVEVSXCI6XCLlvoXnmbzmlofnq6BcIixcbiAgXCJTQVZFRFwiOlwi5bey5YSy5a2YXCIsXG4gIFwiQ0xFQVJFRFwiOlwi5bey5riF6ZmkXCIsXG4gIFwiRkxBR0dJTkdfVEVYVFwiOlwi5bCN5paH56ug5oyJ5ZmT5pyD5b2x6Z+/5YW2542O5Yu177yM5Lim6ZmN5L2O5YW26IO96KaL5bqm44CCPGJyPjxicj4g5oeJ5Zyo5LiL5YiX5oOF5rOB5LiL5oyJ5ZmT77yaPHVsPjxsaT7oqZDmrLrmiJbmioTopbI8L2xpPjxsaT7ku4fmgajmgKfoqIDoq5bmiJbntrLot6/mv6vnlKg8L2xpPjxsaT7lhaflrrnmlYXmhI/liIbpoZ7pjK/oqqTmiJblpKfph4/mlaPluIPlnoPlnL7oqIrmga88L2xpPjwvdWw+XCIsXG4gIFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6XCLlt7LpgZTopoHmsYLpmZDluqbvvIzoq4vmn6XoqaLlhbbku5bnhKbpu57mlofnq6DmiJbmqJnnsaTvvIFcIixcbiAgXCJQT1NUX0lTX1VOQk9PS01BUktcIjpcIuaWh+eroOW3suiHquabuOexpOS4reenu+mZpFwiLFxuICBcIlBPU1RfSVNfQk9PS01BUktcIjpcIuaWh+eroOW3suWKoOWFpeabuOexpFwiLFxuICBcIlJFU0VUXCI6XCLph43nva5cIixcbiAgXCJNT0RJRllfUElDVFVSRVwiOlwi5L+u5pS544CM6Zec5pa844CN55qE5ZyW54mHXCIsXG4gIFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjpcIuS/ruaUueWwgemdouWclueJh1wiLFxuICBcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOlwi6Iul6YG45pOH6YCy6ZqO5qih5byP77yM6KuL5o+Q5L6bQWN0aXZl56eB6ZGw77yBXCIsXG4gIFwiUkVTRVRfUElDVFVSRV9URVhUXCI6XCLmraTli5XkvZzlsIfph43oqK3kvb/nlKjogIXjgIzpl5zmlrzjgI3nmoTlnJbniYdcIixcbiAgXCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjpcIuatpOWLleS9nOWwh+mHjeioreS9v+eUqOiAheWwgemdouWclueJh1wiLFxuICBcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6XCLnlLHmlrzkvLrmnI3lmajmm7TmlrDpnIDopoHph43mlrDllZ/li5XvvIFcIixcbiAgXCJTRVRUSU5HU19VUERBVEVEXCI6XCLoqK3lrprlt7Lmm7TmlrDvvIFcIixcbiAgXCJMQU5HVUFHRVNcIjpcIuiqnuiogFwiLFxuICBcIkxBTkdVQUdFU19URVhUXCI6XCLkvaDlj6/ku6XlnKjmraTmm7TmlLlBUFDnmoTkvb/nlKjoqp7oqIBcIixcbiAgXCJMT0dJTl9UT19YXCI6XCLmraTkuIDli5XkvZzpnIDopoHkvb/nlKjogIXku6XkuLvlr4bnorzjgIFBY3RpdmXnp4HpkbDmiJZQb3N0aW5n56eB6ZGw55m75YWl44CC6KuL55m75YWl5YaN6Kmm5LiA5LiL44CCXCIsXG4gIFwiR0FMTEVSWVwiOlwi6Zmz5YiXXCIsXG4gIFwiVFJBTlNMQVRJT05TXCI6XCLlpJrlnIvoqp7oqIDnv7vora/lt6XkvZzljZTliqnogIVcIixcbiAgXCJTSEFSRVwiOlwi5YiG5LqrXCIsXG4gIFwiTUFSS0VUUExBQ0VcIjpcIuW4guWgtFwiLFxuICBcIkVYQ0hBTkdFXCI6XCLkuqTmmJPmiYBcIixcbiAgXCJEUkFGVFNcIjpcIuiNieeov1wiLFxuICBcIlBPU1RfSVNfVU5EUkFGVFwiOlwi5paH56ug6Ieq6I2J56i/5Lit56e76Zmk77yBXCIsXG4gIFwiUE9TVF9JU19EUkFGVFwiOlwi5paH56ug5Yqg5YWl6I2J56i/77yBXCIsXG4gIFwiU1dJUEVfTEVGVFwiOlwi5ZCR5bem5ruR5YuV5Y+v6ZaL5ZWf5YuV5L2c6YG46aCFXCIsXG4gIFwiTUFOQUdFXCI6XCLnrqHnkIZcIixcbiAgXCJJTUFHRV9SRU1PVkVEXCI6XCLlnJbniYfnp7vpmaRcIixcbiAgXCJDT1BZXCI6XCLopIfoo71cIixcbiAgXCJOT19JTUFHRVwiOlwi5oKo5bCa5pyq5LiK5YKz5Lu75L2V5ZyW54mH77yBXCIsXG4gIFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjpcIuWQkeS4i+aLieWLleWPr+abtOaWsFwiLFxuICBcIkVYVEVSTkFMX0FQUFNcIjpcIuWklumDqEFwcFwiLFxuICBcIlBMVUdJTlNcIjpcIuWkluaOm+eoi+W8j1wiLFxuICBcIlNVR0dFU1RcIjpcIuW7uuitsFwiLFxuICBcIkNPTUlOR19TT09OXCI6XCLljbPlsIfmjqjlh7pcIixcbiAgXCJDSEFJTlwiOlwi6Y+IXCIsXG4gIFwiQ0hBSU5fVEVYVFwiOlwi5oKo5Y+v5Lul5Zyo6YCZ6KOh6K6K5pu05L2/55So55qE5Y2A5aGK6Y+I5oiW5piv6aCQ6Kit55qE5bmz5Y+w44CCXCIsXG4gIFwiQ1VSUkVOQ1lcIjpcIlwiLFxuICBcIkNVUlJFTkNZX1RFWFRcIjpcIlwiLFxuICBcIkFCT1VUXzExXCI6XCJcIixcbiAgXCJGT1VOREVSXCI6XCJcIixcbiAgXCJBRERfQUNDT1VOVFwiOlwiXCIsXG4gIFwiUExBVEZPUk1cIjpcIlwiXG59IiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy9hbmd1bGFyLm1vZHVsZSgnc3RlZW0uc2VydmljZXMnLCBbXSlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCkge1xuXHRhcHAuc2VydmljZSgnQVBJcycsIFsnJGh0dHAnLCAnJHJvb3RTY29wZScsICdBUElfRU5EX1BPSU5UJywgZnVuY3Rpb24gKCRodHRwLCAkcm9vdFNjb3BlLCBBUElfRU5EX1BPSU5UKSB7XG5cdFx0J3VzZSBzdHJpY3QnO1xuXHRcdHJldHVybiB7XG4gICAgICBnZXRDdXJyZW5jeVJhdGU6IGZ1bmN0aW9uKGNvZGVfZnJvbSwgY29kZV90byl7XG4gICAgICAgIGNvbnNvbGUubG9nKGNvZGVfZnJvbSxjb2RlX3RvKTtcbiAgICAgICAgcmV0dXJuICRodHRwLmdldChcImh0dHBzOi8vcXVlcnkueWFob29hcGlzLmNvbS92MS9wdWJsaWMveXFsP3E9c2VsZWN0JTIwKiUyMGZyb20lMjB5YWhvby5maW5hbmNlLnhjaGFuZ2UlMjB3aGVyZSUyMHBhaXIlMjBpbiUyMCglMjJcIitjb2RlX2Zyb20rY29kZV90bytcIiUyMikmZm9ybWF0PWpzb24mZGlhZ25vc3RpY3M9ZmFsc2UmZW52PXN0b3JlJTNBJTJGJTJGZGF0YXRhYmxlcy5vcmclMkZhbGx0YWJsZXN3aXRoa2V5c1wiKTtcbiAgICAgIH0sXG4gICAgICBzYXZlU3Vic2NyaXB0aW9uOiBmdW5jdGlvbihkZXZpY2VpZCwgdXNlcm5hbWUsIHN1YnNjcmlwdGlvbikge1xuICAgICAgICByZXR1cm4gJGh0dHAucG9zdChBUElfRU5EX1BPSU5UK1wiL2FwaS9kZXZpY2VzXCIsIHtkZXZpY2VpZDogZGV2aWNlaWQsIHVzZXJuYW1lOiB1c2VybmFtZSwgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24sIGNoYWluOiAkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWlufSk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlU3Vic2NyaXB0aW9uOiBmdW5jdGlvbihkZXZpY2VpZCwgdXNlcm5hbWUsIHN1YnNjcmlwdGlvbikge1xuICAgICAgICByZXR1cm4gJGh0dHAucHV0KEFQSV9FTkRfUE9JTlQrXCIvYXBpL2RldmljZXNcIiwge2RldmljZWlkOiBkZXZpY2VpZCwgdXNlcm5hbWU6IHVzZXJuYW1lLCBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvbiwgY2hhaW46ICRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW59KTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVUb2tlbjogZnVuY3Rpb24oZGV2aWNlaWQsIG5ld2Rldikge1xuICAgICAgICByZXR1cm4gJGh0dHAucHV0KEFQSV9FTkRfUE9JTlQrXCIvYXBpL2RldmljZS9cIitkZXZpY2VpZCwge25ld2RldjogbmV3ZGV2LCBjaGFpbjogJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbn0pO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZVN1YnNjcmlwdGlvbjogZnVuY3Rpb24oZGV2aWNlaWQpIHtcbiAgICAgICAgcmV0dXJuICRodHRwLmRlbGV0ZShBUElfRU5EX1BPSU5UK1wiL2FwaS9kZXZpY2VzL1wiK2RldmljZWlkKTtcbiAgICAgIH0sXG4gICAgICBnZXRTdWJzY3JpcHRpb25zOiBmdW5jdGlvbihkZXZpY2VpZCkge1xuICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KEFQSV9FTkRfUE9JTlQrXCIvYXBpL2RldmljZXMvXCIrZGV2aWNlaWQpO1xuICAgICAgfSxcblx0XHRcdGFkZEJvb2ttYXJrOiBmdW5jdGlvbih1c2VyLCBib29rbWFyaykge1xuICAgICAgICByZXR1cm4gJGh0dHAucG9zdChBUElfRU5EX1BPSU5UK1wiL2FwaS9ib29rbWFya1wiLCB7dXNlcm5hbWU6IHVzZXIsIGF1dGhvcjogYm9va21hcmsuYXV0aG9yLCBwZXJtbGluazogYm9va21hcmsucGVybWxpbmssIGNoYWluOiAkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWlufSk7XG4gICAgICB9LFxuXHRcdFx0Z2V0Qm9va21hcmtzOiBmdW5jdGlvbih1c2VyKSB7XG4gICAgICAgIHJldHVybiAkaHR0cC5nZXQoQVBJX0VORF9QT0lOVCtcIi9hcGkvYm9va21hcmtzL1wiK3VzZXIpO1xuICAgICAgfSxcblx0XHRcdHJlbW92ZUJvb2ttYXJrOiBmdW5jdGlvbihpZCwgdXNlcikge1xuICAgICAgICByZXR1cm4gJGh0dHAuZGVsZXRlKEFQSV9FTkRfUE9JTlQrXCIvYXBpL2Jvb2ttYXJrcy9cIit1c2VyK1wiL1wiK2lkKTtcbiAgICAgIH0sXG5cdFx0XHRhZGREcmFmdDogZnVuY3Rpb24odXNlciwgZHJhZnQpIHtcbiAgICAgICAgcmV0dXJuICRodHRwLnBvc3QoQVBJX0VORF9QT0lOVCtcIi9hcGkvZHJhZnRcIiwge3VzZXJuYW1lOiB1c2VyLCB0aXRsZTogZHJhZnQudGl0bGUsIGJvZHk6IGRyYWZ0LmJvZHksIHRhZ3M6IGRyYWZ0LnRhZ3MsIHBvc3RfdHlwZTogZHJhZnQucG9zdF90eXBlLCBjaGFpbjogJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbn0pO1xuICAgICAgfSxcblx0XHRcdGdldERyYWZ0czogZnVuY3Rpb24odXNlcikge1xuICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KEFQSV9FTkRfUE9JTlQrXCIvYXBpL2RyYWZ0cy9cIit1c2VyKTtcbiAgICAgIH0sXG5cdFx0XHRyZW1vdmVEcmFmdDogZnVuY3Rpb24oaWQsIHVzZXIpIHtcbiAgICAgICAgcmV0dXJuICRodHRwLmRlbGV0ZShBUElfRU5EX1BPSU5UK1wiL2FwaS9kcmFmdHMvXCIrdXNlcitcIi9cIitpZCk7XG4gICAgICB9LFxuXHRcdFx0cmVtb3ZlSW1hZ2U6IGZ1bmN0aW9uKGlkLCB1c2VyKSB7XG4gICAgICAgIHJldHVybiAkaHR0cC5kZWxldGUoQVBJX0VORF9QT0lOVCtcIi9hcGkvaW1hZ2VzL1wiK3VzZXIrXCIvXCIraWQpO1xuICAgICAgfSxcblx0XHRcdGZldGNoSW1hZ2VzOiBmdW5jdGlvbih1c2VyKSB7XG4gICAgICAgIHJldHVybiAkaHR0cC5nZXQoQVBJX0VORF9QT0lOVCtcIi9hcGkvaW1hZ2VzL1wiK3VzZXIpO1xuICAgICAgfVxuXHRcdH07XG5cdH1dKVxuICBhcHAuZGlyZWN0aXZlKCdiYWNrSW1nJywgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKXtcbiAgICAgICAgdmFyIHVybCA9IGF0dHJzLmJhY2tJbWc7XG4gICAgICAgIGVsZW1lbnQuY3NzKHtcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogJ3VybCgnICsgdXJsICsnKScsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1zaXplJyA6ICdjb3ZlcidcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgfSk7XG4gIGFwcC5kaXJlY3RpdmUoJ3NlbGVjdCcsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIGVsZW1lbnQuYmluZCgnZm9jdXMnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKHdpbmRvdy5jb3Jkb3ZhICYmIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQpIHtcbiAgICAgICAgICAgIC8vICRyb290U2NvcGUubG9nKFwic2hvdyBiYXIgKGhpZGUgPSBmYWxzZSlcIik7XG4gICAgICAgICAgICBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuaGlkZUtleWJvYXJkQWNjZXNzb3J5QmFyKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmJpbmQoJ2JsdXInLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKHdpbmRvdy5jb3Jkb3ZhICYmIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQpIHtcbiAgICAgICAgICAgIC8vICRyb290U2NvcGUubG9nKFwiaGlkZSBiYXIgKGhpZGUgPSB0cnVlKVwiKTtcbiAgICAgICAgICAgIGNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5oaWRlS2V5Ym9hcmRBY2Nlc3NvcnlCYXIodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgYXBwLmRpcmVjdGl2ZSgnbmF2aWdhdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udHJvbGxlciA9IFsnJHNjb3BlJywgJyRyb290U2NvcGUnLCBmdW5jdGlvbiAoJHNjb3BlLCAkcm9vdFNjb3BlKSB7XG4gICAgICAkc2NvcGUuYWRkYWN0aXZlY2xhc3MgPSBmdW5jdGlvbiAobWVudUl0ZW0pIHtcbiAgICAgICAgICAkc2NvcGUuYWN0aXZlTWVudSA9IG1lbnVJdGVtLm5hbWU7XG4gICAgICAgICAgLy8kcm9vdFNjb3BlLmxvZyhtZW51SXRlbSk7XG4gICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSBtZW51SXRlbS5ocmVmO1xuICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICRzY29wZS5jZW50ZXIobWVudUl0ZW0ubmFtZSk7XG4gICAgICAgICAgJHNjb3BlLnNvbWVDdHJsRm4oe21lbnVsaW5rczogbWVudUl0ZW19KTtcbiAgICAgIH07XG5cbiAgICAgICQod2luZG93KS5yZXNpemUoZnVuY3Rpb24oKXtcbiAgICAgICAgJHNjb3BlLmNlbnRlcigpO1xuICAgICAgfSk7XG4gICAgICAkc2NvcGUuY2VudGVyID0gZnVuY3Rpb24obWVudUl0ZW0pIHtcbiAgICAgICAgdmFyIG5hdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibmF2MVwiKTtcbiAgICAgICAgdmFyIG5hdldpZHRoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJuYXYyXCIpLm9mZnNldFdpZHRoO1xuICAgICAgICB2YXIgY3VycmVudEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbbmFtZT1cIicrbWVudUl0ZW0rJ1wiXScpO1xuICAgICAgICBjdXJyZW50RWxlbWVudCA9IG1lbnVJdGVtID8gY3VycmVudEVsZW1lbnRbMF0gOiBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdhY3RpdmUnKVswXTtcbiAgICAgICAgaWYoY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgbWFyZ2luID0gMDtcbiAgICAgICAgICB2YXIgbGVubSA9IG5hdi5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgZm9yKHZhciBpID0wOyBpPGxlbm07IGkrKyl7XG5cbiAgICAgICAgICAgIGlmKGN1cnJlbnRFbGVtZW50ID09IG5hdi5jaGlsZHJlbltpXSl7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICBtYXJnaW4gKz0gbmF2LmNoaWxkcmVuW2ldLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuYXYuc3R5bGUubWFyZ2luTGVmdCA9IChuYXZXaWR0aC8yIC0gbWFyZ2luIC0gY3VycmVudEVsZW1lbnQub2Zmc2V0V2lkdGgvMikgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG5hdi5zdHlsZS5tYXJnaW5MZWZ0ID0gKG5hdldpZHRoLzIgLSAkc2NvcGUuYWN0aXZlTWVudS5sZW5ndGgpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBfbGVuID0gJHNjb3BlLm1lbnVsaW5rcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9sZW47IGkrKykge1xuICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIpIHtcbiAgICAgICAgICBpZiAoJHNjb3BlLm1lbnVsaW5rc1tpXS5ocmVmID09ICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyKSB7XG4gICAgICAgICAgICAkc2NvcGUuYWN0aXZlTWVudSA9ICRzY29wZS5tZW51bGlua3NbaV0ubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHNjb3BlLmFjdGl2ZU1lbnUgPSBcIlRyZW5kaW5nXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8kc2NvcGUuY2VudGVyKCk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuY2VudGVyKCk7XG4gICAgICB9LCA1MCk7XG4gICAgfV07XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6IFwiRVwiLFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIG1lbnVsaW5rczogJz0nLFxuICAgICAgICBzb21lQ3RybEZuOiAnJmNhbGxiYWNrRm4nXG4gICAgICB9LFxuICAgICAgY29udHJvbGxlcjogY29udHJvbGxlcixcbiAgICAgIHRlbXBsYXRlOiBcIjx1bCBpZD0nbmF2MSc+XCIrXG4gICAgICAgICAgICAgIFwiPGxpIG5nLXJlcGVhdD0nbWVudWxpbmtzIGluIG1lbnVsaW5rcycgbmFtZT0ne3ttZW51bGluay5uYW1lfX0nIGNsYXNzPSd0b3Age3ttZW51bGluay5yb2xlfX0nIG5nLWNsYXNzPSd7YWN0aXZlIDogYWN0aXZlTWVudSA9PT0gbWVudWxpbmsubmFtZX0nPlwiK1xuICAgICAgICAgICAgICAgIFwiPGEgb24tdGFwPSdhZGRhY3RpdmVjbGFzcyhtZW51bGluayknPlwiK1xuICAgICAgICAgICAgICAgICAgXCJ7e21lbnVsaW5rLm5hbWV9fVwiXG4gICAgICAgICAgICAgICAgK1wiPC9hPlwiK1xuICAgICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nYXJyb3cnPjwvZGl2PlwiK1xuICAgICAgICAgICAgICAgIFwiPC9saT5cIlxuICAgICAgICAgICAgK1wiPC91bD5cIlxuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIFNpbXBsZVB1YlN1YigpIHtcbiAgICAgIHZhciBldmVudHMgPSB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgb246IGZ1bmN0aW9uKG5hbWVzLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgIG5hbWVzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c1tuYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZXZlbnRzW25hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGV2ZW50c1tuYW1lXSwgZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgfTtcblxuICBhcHAuZGlyZWN0aXZlKCdvbkZpbmlzaFJlbmRlcicsIGZ1bmN0aW9uICgkdGltZW91dCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cikge1xuICAgICAgICAgICAgICBpZiAoc2NvcGUuJGxhc3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzY29wZS4kZW1pdCgnbmdSZXBlYXRGaW5pc2hlZCcpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gIH0pXG4gIGFwcC5kaXJlY3RpdmUoJ2NsaWNrSGFuZGxlcicsIGZ1bmN0aW9uKCR0aW1lb3V0KXtcbiAgICAgIHJldHVybntcbiAgICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsJGF0dHIpe1xuICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICRlbGVtZW50Lm9uKCd0YXAnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGUgZnVuY3Rpb24geW91IHdhbnQgdG8gcGVyZm9ybSBvbiB0YXBcbiAgICAgICAgYWxlcnQoXCJKdXN0IGJlZW4gQ2xpY2tlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgfSlcbiAgYXBwLmRpcmVjdGl2ZSgndGFiU2xpZGVCb3gnLCBbICckdGltZW91dCcsICckd2luZG93JywgJyRpb25pY1NsaWRlQm94RGVsZWdhdGUnLCAnJGlvbmljU2Nyb2xsRGVsZWdhdGUnLCAnJHJvb3RTY29wZScsXG4gICAgZnVuY3Rpb24oJHRpbWVvdXQsICR3aW5kb3csICRpb25pY1NsaWRlQm94RGVsZWdhdGUsICRpb25pY1Njcm9sbERlbGVnYXRlLCAkcm9vdFNjb3BlKSB7XG4gICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3RyaWN0IDogJ0EsIEUsIEMnLFxuICAgICAgICBsaW5rIDogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBuZ01vZGVsKSB7XG5cbiAgICAgICAgICB2YXIgdGEgPSBlbGVtZW50WzBdLCAkdGEgPSBlbGVtZW50O1xuICAgICAgICAgICR0YS5hZGRDbGFzcyhcInRhYmJlZC1zbGlkZWJveFwiKTtcbiAgICAgICAgICBpZihhdHRycy50YWJzUG9zaXRpb24gPT09IFwiYm90dG9tXCIpe1xuICAgICAgICAgICAgJHRhLmFkZENsYXNzKFwiYnRtXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vSGFuZGxlIG11bHRpcGxlIHNsaWRlL3Njcm9sbCBib3hlc1xuICAgICAgICAgIHZhciBoYW5kbGUgPSB0YS5xdWVyeVNlbGVjdG9yKCcuc2xpZGVyJykuZ2V0QXR0cmlidXRlKCdkZWxlZ2F0ZS1oYW5kbGUnKTtcblxuICAgICAgICAgIHZhciBpb25pY1NsaWRlQm94RGVsZWdhdGUgPSAkaW9uaWNTbGlkZUJveERlbGVnYXRlO1xuICAgICAgICAgIGlmKGhhbmRsZSl7XG4gICAgICAgICAgICBpb25pY1NsaWRlQm94RGVsZWdhdGUgPSBpb25pY1NsaWRlQm94RGVsZWdhdGUuJGdldEJ5SGFuZGxlKGhhbmRsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlvbmljU2Nyb2xsRGVsZWdhdGUgPSAkaW9uaWNTY3JvbGxEZWxlZ2F0ZTtcbiAgICAgICAgICBpZihoYW5kbGUpe1xuICAgICAgICAgICAgaW9uaWNTY3JvbGxEZWxlZ2F0ZSA9IGlvbmljU2Nyb2xsRGVsZWdhdGUuJGdldEJ5SGFuZGxlKGhhbmRsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcmVuZGVyU2Nyb2xsYWJsZVRhYnMoKXtcbiAgICAgICAgICAgIHZhciBpY29uc0RpdiA9IGFuZ3VsYXIuZWxlbWVudCh0YS5xdWVyeVNlbGVjdG9yKFwiLnRzYi1pY29uc1wiKSksIGljb25zID0gaWNvbnNEaXYuZmluZChcImFcIiksIHdyYXAgPSBpY29uc0RpdlswXS5xdWVyeVNlbGVjdG9yKFwiLnRzYi1pYy13cnBcIiksIHRvdGFsVGFicyA9IGljb25zLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBzY3JvbGxEaXYgPSB3cmFwLnF1ZXJ5U2VsZWN0b3IoXCIuc2Nyb2xsXCIpO1xuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goaWNvbnMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpe1xuICAgICAgICAgICAgICAgICB2YXIgYSA9IGFuZ3VsYXIuZWxlbWVudCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgIGEub24oJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICBpb25pY1NsaWRlQm94RGVsZWdhdGUuc2xpZGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYoYS5hdHRyKCdpY29uLW9mZicpKSB7XG4gICAgICAgICAgICAgICAgYS5hdHRyKFwiY2xhc3NcIiwgYS5hdHRyKCdpY29uLW9mZicpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBpbml0aWFsSW5kZXggPSBhdHRycy50YWI7XG4gICAgICAgICAgICAvL0luaXRpYWxpemluZyB0aGUgbWlkZGxlIHRhYlxuICAgICAgICAgICAgaWYodHlwZW9mIGF0dHJzLnRhYiA9PT0gJ3VuZGVmaW5lZCcgfHwgKHRvdGFsVGFicyA8PSBpbml0aWFsSW5kZXgpIHx8IGluaXRpYWxJbmRleCA8IDApe1xuICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSBNYXRoLmZsb29yKGljb25zLmxlbmd0aC8yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9JZiBpbml0aWFsIGVsZW1lbnQgaXMgMCwgc2V0IHBvc2l0aW9uIG9mIHRoZSB0YWIgdG8gMHRoIHRhYlxuICAgICAgICAgICAgaWYoaW5pdGlhbEluZGV4ID09IDApe1xuICAgICAgICAgICAgICBzZXRQb3NpdGlvbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vJHJvb3RTY29wZS5sb2coJ2luaXRpYWxJbmRleCAnK2luaXRpYWxJbmRleCk7XG4gICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ2ZlZWQnKSB7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiAwfSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICd0cmVuZGluZycpIHtcbiAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IDB9KTtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ2hvdCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogMX0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAnY3JlYXRlZCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogMn0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAnYWN0aXZlJyl7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiAzfSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICdwcm9tb3RlZCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogNH0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAndHJlbmRpbmczMCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogNX0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gNjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAndm90ZXMnKXtcbiAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IDZ9KTtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ2NoaWxkcmVuJyl7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiA3fSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICdjYXNob3V0Jyl7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiA4fSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSA5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICd0cmVuZGluZycpIHtcbiAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IDB9KTtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ2hvdCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogMX0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAnY3JlYXRlZCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogMn0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAnYWN0aXZlJyl7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiAzfSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICdwcm9tb3RlZCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogNH0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAndHJlbmRpbmczMCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogNX0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAndm90ZXMnKXtcbiAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IDZ9KTtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ2NoaWxkcmVuJyl7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiA3fSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSA3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICdjYXNob3V0Jyl7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiA4fSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlvbmljU2xpZGVCb3hEZWxlZ2F0ZS5zbGlkZShpbml0aWFsSW5kZXgpO1xuICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHNldFBvc2l0aW9uKGluZGV4KXtcbiAgICAgICAgICAgIHZhciBpY29uc0RpdiA9IGFuZ3VsYXIuZWxlbWVudCh0YS5xdWVyeVNlbGVjdG9yKFwiLnRzYi1pY29uc1wiKSksIGljb25zID0gaWNvbnNEaXYuZmluZChcImFcIiksIHdyYXAgPSBpY29uc0RpdlswXS5xdWVyeVNlbGVjdG9yKFwiLnRzYi1pYy13cnBcIiksIHRvdGFsVGFicyA9IGljb25zLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBzY3JvbGxEaXYgPSB3cmFwLnF1ZXJ5U2VsZWN0b3IoXCIuc2Nyb2xsXCIpO1xuXG4gICAgICAgICAgICB2YXIgbWlkZGxlID0gaWNvbnNEaXZbMF0ub2Zmc2V0V2lkdGgvMjtcbiAgICAgICAgICAgIHZhciBjdXJFbCA9IGFuZ3VsYXIuZWxlbWVudChpY29uc1tpbmRleF0pO1xuICAgICAgICAgICAgdmFyIHBydkVsID0gYW5ndWxhci5lbGVtZW50KGljb25zRGl2WzBdLnF1ZXJ5U2VsZWN0b3IoXCIuYWN0aXZlXCIpKTtcbiAgICAgICAgICAgIGlmKGN1ckVsICYmIGN1ckVsLmxlbmd0aCl7XG4gICAgICAgICAgICAgIHZhciBjdXJFbFdpZHRoID0gY3VyRWxbMF0ub2Zmc2V0V2lkdGgsIGN1ckVsTGVmdCA9IGN1ckVsWzBdLm9mZnNldExlZnQ7XG5cbiAgICAgICAgICAgICAgaWYocHJ2RWwuYXR0cignaWNvbi1vZmYnKSkge1xuICAgICAgICAgICAgICAgIHBydkVsLmF0dHIoXCJjbGFzc1wiLCBwcnZFbC5hdHRyKCdpY29uLW9mZicpKTtcbiAgICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICAgIHBydkVsLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKGN1ckVsLmF0dHIoJ2ljb24tb24nKSkge1xuICAgICAgICAgICAgICAgIGN1ckVsLmF0dHIoXCJjbGFzc1wiLCBjdXJFbC5hdHRyKCdpY29uLW9uJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1ckVsLmFkZENsYXNzKFwiYWN0aXZlXCIpO1xuXG4gICAgICAgICAgICAgIHZhciBsZWZ0U3RyID0gKG1pZGRsZSAgLSAoY3VyRWxMZWZ0KSAtICBjdXJFbFdpZHRoLzIgKyA1KTtcbiAgICAgICAgICAgICAgLy9JZiB0YWJzIGFyZSBub3Qgc2Nyb2xsYWJsZVxuICAgICAgICAgICAgICBpZighc2Nyb2xsRGl2KXtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFN0ciA9IChtaWRkbGUgIC0gKGN1ckVsTGVmdCkgLSAgY3VyRWxXaWR0aC8yICsgNSkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgd3JhcC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAgXCJ0cmFuc2xhdGUzZChcIitsZWZ0U3RyK1wiLDAsMClcIiA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9JZiBzY3JvbGxhYmxlIHRhYnNcbiAgICAgICAgICAgICAgICB2YXIgd3JhcFdpZHRoID0gd3JhcC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFggPSBNYXRoLmFicyhnZXRYKHNjcm9sbERpdi5zdHlsZS53ZWJraXRUcmFuc2Zvcm0pKTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdE9mZnNldCA9IDEwMDtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudE9mZnNldCA9IDU0O1xuICAgICAgICAgICAgICAgIC8vSWYgdGFicyBhcmUgcmVhY2hpbmcgcmlnaHQgZW5kIG9yIGxlZnQgZW5kXG4gICAgICAgICAgICAgICAgaWYoKChjdXJyZW50WCArIHdyYXBXaWR0aCkgPCAoY3VyRWxMZWZ0ICsgY3VyRWxXaWR0aCArIGVsZW1lbnRPZmZzZXQpKSB8fCAoY3VycmVudFggPiAoY3VyRWxMZWZ0IC0gbGVmdE9mZnNldCkpKXtcbiAgICAgICAgICAgICAgICAgIGlmKGxlZnRTdHIgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgbGVmdFN0ciA9IDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvL1VzZSB0aGlzIHNjcm9sbFRvLCBzbyB3aGVuIHNjcm9sbGluZyB0YWIgbWFudWFsbHkgd2lsbCBub3QgZmxpY2tlclxuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaW9uaWNTY3JvbGxEZWxlZ2F0ZS5zY3JvbGxUbyhNYXRoLmFicyhsZWZ0U3RyKSwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB9LCAxMCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYobGVmdFN0ciA+IDApe1xuICAgICAgICAgICAgICAgICAgICBsZWZ0U3RyID0gMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlvbmljU2Nyb2xsRGVsZWdhdGUuc2Nyb2xsVG8oTWF0aC5hYnMobGVmdFN0ciksIDAsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgZnVuY3Rpb24gZ2V0WChtYXRyaXgpIHtcblxuICAgICAgICAgICAgbWF0cml4ID0gbWF0cml4LnJlcGxhY2UoXCJ0cmFuc2xhdGUzZChcIixcIlwiKTtcbiAgICAgICAgICAgIG1hdHJpeCA9IG1hdHJpeC5yZXBsYWNlKFwidHJhbnNsYXRlKFwiLFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIChwYXJzZUludChtYXRyaXgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGV2ZW50cyA9IHNjb3BlLmV2ZW50cztcbiAgICAgICAgICBldmVudHMub24oJ3NsaWRlQ2hhbmdlJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZXRQb3NpdGlvbihkYXRhLmluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBldmVudHMub24oJ25nUmVwZWF0RmluaXNoZWQnLCBmdW5jdGlvbihuZ1JlcGVhdEZpbmlzaGVkRXZlbnQpIHtcbiAgICAgICAgICAgIHJlbmRlclNjcm9sbGFibGVUYWJzKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlbmRlclNjcm9sbGFibGVUYWJzKCk7XG4gICAgICAgICAgfSwgMTApO1xuXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRyb2xsZXIgOiBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgJGVsZW1lbnQsICRyb290U2NvcGUpIHtcbiAgICAgICAgICAkc2NvcGUuZXZlbnRzID0gbmV3IFNpbXBsZVB1YlN1YigpO1xuICAgICAgICAgICRzY29wZS5zbGlkZUhhc0NoYW5nZWQgPSBmdW5jdGlvbihpbmRleCl7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcIlNsaWRlQ2hhbmdlZCBcIitpbmRleCk7XG4gICAgICAgICAgICAkc2NvcGUuY3VycmVudFNsaWRlID0gaW5kZXg7XG4gICAgICAgICAgICAkc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogaW5kZXh9KTtcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGlmKCRzY29wZS5vblNsaWRlTW92ZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5vblNsaWRlTW92ZSh7XCJpbmRleFwiIDogZXZhbChpbmRleCl9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ2ZlZWQnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAndHJlbmRpbmcnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAnaG90JztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ2NyZWF0ZWQnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAnYWN0aXZlJztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ3Byb21vdGVkJztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDYpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ3RyZW5kaW5nMzAnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gNykge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAndm90ZXMnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAnY2hpbGRyZW4nO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAnY2FzaG91dCc7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICd0cmVuZGluZyc7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICdob3QnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAnY3JlYXRlZCc7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICdhY3RpdmUnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAncHJvbW90ZWQnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAndHJlbmRpbmczMCc7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSA2KSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICd2b3Rlcyc7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSA3KSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICdjaGlsZHJlbic7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICdjYXNob3V0JztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAkc2NvcGUuJG9uKCduZ1JlcGVhdEZpbmlzaGVkJywgZnVuY3Rpb24obmdSZXBlYXRGaW5pc2hlZEV2ZW50KSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnbmdSZXBlYXRGaW5pc2hlZCcpO1xuICAgICAgICAgICAgJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwibmdSZXBlYXRGaW5pc2hlZFwiLCB7XCJldmVudFwiIDogbmdSZXBlYXRGaW5pc2hlZEV2ZW50fSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICB9XG4gIF0pO1xuXG5cdGFwcC5maWx0ZXIoJ3RpbWVhZ28nLCBmdW5jdGlvbigkZmlsdGVyLCAkdHJhbnNsYXRlLCAkcm9vdFNjb3BlKSB7XG5cbiAgICAgIGZ1bmN0aW9uIFRpbWVBZ28oaW5wdXQsIHBfYWxsb3dGdXR1cmUpIHtcbiAgICAgICAgdmFyIHN1YnN0aXR1dGUgPSBmdW5jdGlvbiAoc3RyaW5nT3JGdW5jdGlvbiwgbnVtYmVyLCBzdHJpbmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IGFuZ3VsYXIuaXNGdW5jdGlvbihzdHJpbmdPckZ1bmN0aW9uKSA/IHN0cmluZ09yRnVuY3Rpb24obnVtYmVyLCBkYXRlRGlmZmVyZW5jZSkgOiBzdHJpbmdPckZ1bmN0aW9uO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IChzdHJpbmdzLm51bWJlcnMgJiYgc3RyaW5ncy5udW1iZXJzW251bWJlcl0pIHx8IG51bWJlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyVkL2ksIHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub3dUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSxcbiAgICAgICAgICAgIGRhdGUgPSAobmV3IERhdGUoaW5wdXQpKS5nZXRUaW1lKCksXG4gICAgICAgICAgICAvL3JlZnJlc2hNaWxsaXM9IDZlNCwgLy9BIG1pbnV0ZVxuICAgICAgICAgICAgYWxsb3dGdXR1cmUgPSBwX2FsbG93RnV0dXJlIHx8IGZhbHNlLFxuICAgICAgICAgICAgc3RyaW5ncz0ge1xuICAgICAgICAgICAgICAgIHByZWZpeEFnbzogJycsXG4gICAgICAgICAgICAgICAgcHJlZml4RnJvbU5vdzogJycsXG4gICAgICAgICAgICAgICAgc3VmZml4QWdvOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQUdPJyksXG4gICAgICAgICAgICAgICAgc3VmZml4RnJvbU5vdzogJGZpbHRlcigndHJhbnNsYXRlJykoJ0ZST01fTk9XJyksXG4gICAgICAgICAgICAgICAgc2Vjb25kczogJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFQ1MnKSxcbiAgICAgICAgICAgICAgICBtaW51dGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBX01JTicpLFxuICAgICAgICAgICAgICAgIG1pbnV0ZXM6IFwiJWQgXCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ01JTlMnKSxcbiAgICAgICAgICAgICAgICBob3VyOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQU5fSE9VUicpLFxuICAgICAgICAgICAgICAgIGhvdXJzOiBcIiVkIFwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdIT1VSUycpLFxuICAgICAgICAgICAgICAgIGRheTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FfREFZJyksXG4gICAgICAgICAgICAgICAgZGF5czogXCIlZCBcIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnREFZUycpLFxuICAgICAgICAgICAgICAgIG1vbnRoOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQV9NT05USCcpLFxuICAgICAgICAgICAgICAgIG1vbnRoczogXCIlZCBcIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnTU9OVEhTJyksXG4gICAgICAgICAgICAgICAgeWVhcjogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FfWUVBUicpLFxuICAgICAgICAgICAgICAgIHllYXJzOiBcIiVkIFwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdZRUFSUycpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0ZURpZmZlcmVuY2UgPSBub3dUaW1lIC0gZGF0ZSxcbiAgICAgICAgICAgIHdvcmRzLFxuICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGguYWJzKGRhdGVEaWZmZXJlbmNlKSAvIDEwMDAsXG4gICAgICAgICAgICBtaW51dGVzID0gc2Vjb25kcyAvIDYwLFxuICAgICAgICAgICAgaG91cnMgPSBtaW51dGVzIC8gNjAsXG4gICAgICAgICAgICBkYXlzID0gaG91cnMgLyAyNCxcbiAgICAgICAgICAgIHllYXJzID0gZGF5cyAvIDM2NSxcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IHN0cmluZ3Mud29yZFNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gIFwiIFwiIDogc3RyaW5ncy53b3JkU2VwYXJhdG9yLFxuXG5cbiAgICAgICAgICAgIHByZWZpeCA9IHN0cmluZ3MucHJlZml4QWdvLFxuICAgICAgICAgICAgc3VmZml4ID0gc3RyaW5ncy5zdWZmaXhBZ287XG5cbiAgICAgICAgaWYgKGFsbG93RnV0dXJlKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZURpZmZlcmVuY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gc3RyaW5ncy5wcmVmaXhGcm9tTm93O1xuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHN0cmluZ3Muc3VmZml4RnJvbU5vdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdvcmRzID0gc2Vjb25kcyA8IDQ1ICYmIHN1YnN0aXR1dGUoc3RyaW5ncy5zZWNvbmRzLCBNYXRoLnJvdW5kKHNlY29uZHMpLCBzdHJpbmdzKSB8fFxuICAgICAgICBzZWNvbmRzIDwgOTAgJiYgc3Vic3RpdHV0ZShzdHJpbmdzLm1pbnV0ZSwgMSwgc3RyaW5ncykgfHxcbiAgICAgICAgbWludXRlcyA8IDQ1ICYmIHN1YnN0aXR1dGUoc3RyaW5ncy5taW51dGVzLCBNYXRoLnJvdW5kKG1pbnV0ZXMpLCBzdHJpbmdzKSB8fFxuICAgICAgICBtaW51dGVzIDwgOTAgJiYgc3Vic3RpdHV0ZShzdHJpbmdzLmhvdXIsIDEsIHN0cmluZ3MpIHx8XG4gICAgICAgIGhvdXJzIDwgMjQgJiYgc3Vic3RpdHV0ZShzdHJpbmdzLmhvdXJzLCBNYXRoLnJvdW5kKGhvdXJzKSwgc3RyaW5ncykgfHxcbiAgICAgICAgaG91cnMgPCA0MiAmJiBzdWJzdGl0dXRlKHN0cmluZ3MuZGF5LCAxLCBzdHJpbmdzKSB8fFxuICAgICAgICBkYXlzIDwgMzAgJiYgc3Vic3RpdHV0ZShzdHJpbmdzLmRheXMsIE1hdGgucm91bmQoZGF5cyksIHN0cmluZ3MpIHx8XG4gICAgICAgIGRheXMgPCA0NSAmJiBzdWJzdGl0dXRlKHN0cmluZ3MubW9udGgsIDEsIHN0cmluZ3MpIHx8XG4gICAgICAgIGRheXMgPCAzNjUgJiYgc3Vic3RpdHV0ZShzdHJpbmdzLm1vbnRocywgTWF0aC5yb3VuZChkYXlzIC8gMzApLCBzdHJpbmdzKSB8fFxuICAgICAgICB5ZWFycyA8IDEuNSAmJiBzdWJzdGl0dXRlKHN0cmluZ3MueWVhciwgMSwgc3RyaW5ncykgfHxcbiAgICAgICAgc3Vic3RpdHV0ZShzdHJpbmdzLnllYXJzLCBNYXRoLnJvdW5kKHllYXJzKSwgc3RyaW5ncyk7XG4gICAgICAgIC8vJHJvb3RTY29wZS5sb2cocHJlZml4K3dvcmRzK3N1ZmZpeCtzZXBhcmF0b3IpO1xuICAgICAgICBwcmVmaXgucmVwbGFjZSgvIC9nLCAnJylcbiAgICAgICAgd29yZHMucmVwbGFjZSgvIC9nLCAnJylcbiAgICAgICAgc3VmZml4LnJlcGxhY2UoLyAvZywgJycpXG4gICAgICAgIHJldHVybiAocHJlZml4KycgJyt3b3JkcysnICcrc3VmZml4KycgJytzZXBhcmF0b3IpO1xuXG4gICAgICB9O1xuXG4gICAgICBUaW1lQWdvLiRzdGF0ZWZ1bCA9IHRydWU7XG4gICAgICByZXR1cm4gVGltZUFnbztcbiAgICB9KTtcblxuICAgIGFwcC5maWx0ZXIoJ3BhcnNlVXJsJywgZnVuY3Rpb24oJHNjZSkge1xuXHQgICAgdmFyIHVybHMgPSAvKFxcYihodHRwcz98ZnRwKTpcXC9cXC9bQS1aMC05KyZAI1xcLyU/PX5ffCE6LC47LV0qWy1BLVowLTkrJkAjXFwvJT1+X3xdKS9naW07XG5cdCAgICB2YXIgZW1haWxzID0gLyhcXHcrQFthLXpBLVpfXSs/XFwuW2EtekEtWl17Miw2fSkvZ2ltO1xuICBcdCBcdHZhciBpbWdzID0gLyhodHRwcz86XFwvXFwvLipcXC4oPzpwbmd8anBnfGpwZWd8Z2lmKSkvZ2ltO1xuICBcdFx0dmFyIHlvdXR1YmUgPSAvXi4qKCh5b3V0dS5iZVxcLyl8KHZcXC8pfChcXC91XFwvXFx3XFwvKXwoZW1iZWRcXC8pfCh3YXRjaFxcPykpXFw/P3Y/PT8oW14jXFwmXFw/XSopLiovO1xuICBcdFx0dmFyIHlvdXR1YmVpZCA9IC8oPzooPzp5b3V0dWJlLmNvbVxcL3dhdGNoXFw/dj0pfCg/OnlvdXR1LmJlXFwvKSkoW0EtWmEtejAtOVxcX1xcLV0rKS9pO1xuXG5cdCAgICByZXR1cm4gZnVuY3Rpb24odGV4dHUsIHN1YnBhcnQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIFx0Z2ZtOiB0cnVlLFxuXHRcdFx0ICAgIHRhYmxlczogdHJ1ZSxcbiAgICAgICAgICBzbWFydExpc3RzOiB0cnVlLFxuXHRcdFx0ICAgIGJyZWFrczogdHJ1ZSxcblx0XHRcdCAgICBwZWRhbnRpYzogZmFsc2UsXG5cdFx0XHQgICAgc2FuaXRpemU6IGZhbHNlLFxuXHRcdFx0ICAgIHNtYXJ0TGlzdHM6IHRydWUsXG5cdFx0XHQgICAgc21hcnR5cGFudHM6IGZhbHNlXG5cdFx0XHQgIH07XG4gICAgICAgIGlmICh0ZXh0dSkge1xuICAgICAgICAgIHZhciB0ZXh0dSA9IG1hcmtlZCh0ZXh0dSwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKHN1YnBhcnQpIHtcbiAgICAgICAgICAgIHZhciBzID0gJHNjZS50cnVzdEFzSHRtbCh0ZXh0dSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gcy5zdWJzdHJpbmcocy5pbmRleE9mKFwiPHA+XCIpLCBzLmluZGV4T2YoXCI8L3A+XCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJHNjZS50cnVzdEFzSHRtbCh0ZXh0dSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cdCAgICB9O1xuXHR9KTtcblxuICAgIGFwcC5maWx0ZXIoJ21ldGFkYXRhJywgZnVuY3Rpb24oJHNjZSkge1xuICAgICAgICB2YXIgdXJscyA9IC8oXFxiKGh0dHBzP3xmdHApOlxcL1xcL1tBLVowLTkrJkAjXFwvJT89fl98ITosLjstXSpbLUEtWjAtOSsmQCNcXC8lPX5ffF0pL2dpbTtcbiAgICAgICAgdmFyIHVzZXJzID0gLyhefFxccykoQFthLXpdWy1cXC5hLXpcXGRdK1thLXpcXGRdKS9naW07XG4gICAgICAgIHZhciBpbWdzID0gLyhodHRwcz86XFwvXFwvLipcXC4oPzpwbmd8anBnfGpwZWd8Z2lmKSkvZ2ltO1xuICAgICAgICB2YXIgeW91dHViZSA9IC9eLiooKHlvdXR1LmJlXFwvKXwodlxcLyl8KFxcL3VcXC9cXHdcXC8pfChlbWJlZFxcLyl8KHdhdGNoXFw/KSlcXD8/dj89PyhbXiNcXCZcXD9dKikuKi87XG4gICAgICAgIHZhciB5b3V0dWJlaWQgPSAvKD86KD86eW91dHViZS5jb21cXC93YXRjaFxcP3Y9KXwoPzp5b3V0dS5iZVxcLykpKFtBLVphLXowLTlcXF9cXC1dKykvaTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odGV4dHUpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSB7fTtcbiAgICAgICAgICAgIHZhciBtdXJscyA9IHRleHR1Lm1hdGNoKHVybHMpO1xuICAgICAgICAgICAgdmFyIG11c2VycyA9IHRleHR1Lm1hdGNoKHVzZXJzKTtcbiAgICAgICAgICAgIHZhciBtaW1ncyA9IFtdO1xuICAgICAgICAgICAgdmFyIG1saW5rcyA9IFtdO1xuICAgICAgICAgICAgaWYgKG11cmxzKSB7XG4gICAgICAgICAgICAgIHZhciBfbGVuID0gbXVybHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmQgPSBtdXJsc1tpXS5tYXRjaChpbWdzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWltZ3MucHVzaChtdXJsc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtbGlua3MucHVzaChtdXJsc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1saW5rcykge1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLm1lcmdlKG91dCwge2xpbmtzOiBtbGlua3N9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1pbWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIubWVyZ2Uob3V0LCB7aW1hZ2U6IG1pbWdzfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG11c2Vycykge1xuICAgICAgICAgICAgICB2YXIgX2xlbiA9IG11c2Vycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbXVzZXJzW2ldID0gbXVzZXJzW2ldLnRyaW0oKS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtdXNlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5tZXJnZShvdXQsIHt1c2VyczogbXVzZXJzfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGFwcC5maWx0ZXIoJ21ldGFkYXRhVXNlcnMnLCBmdW5jdGlvbigkc2NlKSB7XG4gICAgICAgIHZhciB1c2VycyA9IC8oXnxcXHMpKEBbYS16XVstXFwuYS16XFxkXStbYS16XFxkXSkvZ2ltO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odGV4dHUpIHtcbiAgICAgICAgICBpZiAodGV4dHUpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSB7fTtcbiAgICAgICAgICAgIHZhciBtdXNlcnMgPSB0ZXh0dS5tYXRjaCh1c2Vycyk7XG5cbiAgICAgICAgICAgICRyb290U2NvcGUubG9nKGFuZ3VsYXIudG9Kc29uKG11c2VycykpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGV4dHU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgIGFwcC5maWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJywgZnVuY3Rpb24oJGZpbHRlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRleHQuc3BsaXQoJy0nKVsxXSk7XG4gICAgICAgICAgICAvL3ZhciB4ID0gdGV4dC5zcGxpdCgnLScpWzFdO1xuICAgICAgICAgICAgLy92YXIgdHQgPSAkZmlsdGVyKCd1cHBlcmNhc2UnKSh4KTtcbiAgICAgICAgICAgIHZhciB0ZXh0dSA9IHdpbmRvdy5nZXRTeW1ib2wodGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dHU9PVwiP1wiP3RleHQ6dGV4dHU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gIGZ1bmN0aW9uIGFuc2lXb3JkQm91bmQoYykge1xuICAgIHJldHVybiAoXG4gICAgICAoJyAnID09PSBjKSB8fFxuICAgICAgKCdcXG4nID09PSBjKSB8fFxuICAgICAgKCdcXHInID09PSBjKSB8fFxuICAgICAgKCdcXHQnID09PSBjKVxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRpbmdUaW1lKHRleHQsIG9wdGlvbnMpIHtcbiAgICB2YXIgd29yZHMgPSAwLCBzdGFydCA9IDAsIGVuZCA9IHRleHQubGVuZ3RoIC0gMSwgd29yZEJvdW5kLCBpXG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgLy8gdXNlIGRlZmF1bHQgdmFsdWVzIGlmIG5lY2Vzc2FyeVxuICAgIG9wdGlvbnMud29yZHNQZXJNaW51dGUgPSBvcHRpb25zLndvcmRzUGVyTWludXRlIHx8IDIwMFxuXG4gICAgLy8gdXNlIHByb3ZpZGVkIGZ1bmN0aW9uIGlmIGF2YWlsYWJsZVxuICAgIHdvcmRCb3VuZCA9IG9wdGlvbnMud29yZEJvdW5kIHx8IGFuc2lXb3JkQm91bmRcblxuICAgIC8vIGZldGNoIGJvdW5kc1xuICAgIHdoaWxlICh3b3JkQm91bmQodGV4dFtzdGFydF0pKSBzdGFydCsrXG4gICAgd2hpbGUgKHdvcmRCb3VuZCh0ZXh0W2VuZF0pKSBlbmQtLVxuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBudW1iZXIgb2Ygd29yZHNcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8PSBlbmQ7KSB7XG4gICAgICBmb3IgKDsgaSA8PSBlbmQgJiYgIXdvcmRCb3VuZCh0ZXh0W2ldKTsgaSsrKSA7XG4gICAgICB3b3JkcysrXG4gICAgICBmb3IgKDsgaSA8PSBlbmQgJiYgd29yZEJvdW5kKHRleHRbaV0pOyBpKyspIDtcbiAgICB9XG5cbiAgICAvLyByZWFkaW5nIHRpbWUgc3RhdHNcbiAgICB2YXIgbWludXRlcyA9IHdvcmRzIC8gb3B0aW9ucy53b3Jkc1Blck1pbnV0ZVxuICAgIHZhciB0aW1lID0gbWludXRlcyAqIDYwICogMTAwMFxuICAgIHZhciBkaXNwbGF5ZWQgPSBNYXRoLmNlaWwobWludXRlcy50b0ZpeGVkKDIpKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IGRpc3BsYXllZCArICcgbWluIHJlYWQnLFxuICAgICAgbWludXRlczogTWF0aC5jZWlsKG1pbnV0ZXMudG9GaXhlZCgyKSksXG4gICAgICB0aW1lOiB0aW1lLFxuICAgICAgd29yZHM6IHdvcmRzXG4gICAgfVxuICB9XG5cbiAgYXBwLmZpbHRlcigncmVhZGluZ3RpbWUnLCBmdW5jdGlvbigkc2NlLCAkcm9vdFNjb3BlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgIHJldHVybiByZWFkaW5nVGltZSh0ZXh0KS5taW51dGVzO1xuICAgICAgICB9XG4gICAgICB9O1xuICB9KVxuXG5cdGFwcC5maWx0ZXIoJ3NwJywgZnVuY3Rpb24oJHNjZSwgJHJvb3RTY29wZSkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcblx0ICAgIFx0aWYgKHRleHQpIHtcblx0ICAgIFx0XHRyZXR1cm4gKE51bWJlcih0ZXh0LnNwbGl0KFwiIFwiKVswXSkvMWU2KiRyb290U2NvcGUuJHN0b3JhZ2Uuc3RlZW1fcGVyX212ZXN0cykudG9GaXhlZCgzKTtcblx0ICAgIFx0fVxuXHQgICAgfTtcblx0fSlcblx0YXBwLmZpbHRlcignc2QnLCBmdW5jdGlvbigkc2NlLCAkcm9vdFNjb3BlKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24odGV4dCwgYmFsYW5jZSwgc2JkKSB7XG5cdCAgICBcdGlmICh0ZXh0KSB7XG5cdCAgICBcdFx0cmV0dXJuICgoTnVtYmVyKHRleHQuc3BsaXQoXCIgXCIpWzBdKS8xZTYqJHJvb3RTY29wZS4kc3RvcmFnZS5zdGVlbV9wZXJfbXZlc3RzKiRyb290U2NvcGUuJHN0b3JhZ2UuYmFzZSArIE51bWJlcihiYWxhbmNlLnNwbGl0KFwiIFwiKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5iYXNlICsgTnVtYmVyKHNiZC5zcGxpdChcIiBcIilbMF0pKS50b0ZpeGVkKDMpKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcblx0ICAgIFx0fVxuXHQgICAgfTtcblx0fSlcblx0YXBwLmZpbHRlcignc2JkJywgZnVuY3Rpb24oJHNjZSwgJHJvb3RTY29wZSkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcblx0ICAgIFx0aWYgKHRleHQpIHtcblx0ICAgIFx0XHRyZXR1cm4gKE51bWJlcih0ZXh0LnNwbGl0KFwiIFwiKVswXSkudG9GaXhlZCgzKSk7XG5cdCAgICBcdH1cblx0ICAgIH07XG5cdH0pXG5cdGFwcC5maWx0ZXIoJ3N0JywgZnVuY3Rpb24oJHNjZSwgJHJvb3RTY29wZSkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcblx0ICAgIFx0aWYgKHRleHQpIHtcblx0ICAgIFx0XHRyZXR1cm4gKE51bWJlcih0ZXh0LnNwbGl0KFwiIFwiKVswXSkudG9GaXhlZCgzKSk7XG5cdCAgICBcdH1cblx0ICAgIH07XG5cdH0pXG5cdGFwcC5maWx0ZXIoJ3JlcHV0YXRpb24nLCBmdW5jdGlvbigpe1xuXHRcdHJldHVybiBmdW5jdGlvbih2YWx1ZSwgYm9vbCkge1xuXHRcdFx0cmVwdXRhdGlvbl9sZXZlbCA9IDE7XG5cdFx0XHRuZWcgPSBmYWxzZTtcblxuXHRcdFx0aWYgKHZhbHVlIDwgMClcblx0XHRcdFx0bmVnID0gdHJ1ZTtcblxuXHRcdFx0aWYgKHZhbHVlICE9IDApIHtcblx0XHRcdFx0cmVwdXRhdGlvbl9sZXZlbCA9IE1hdGgubG9nMTAoTWF0aC5hYnModmFsdWUpKTtcblx0XHRcdFx0cmVwdXRhdGlvbl9sZXZlbCA9IE1hdGgubWF4KHJlcHV0YXRpb25fbGV2ZWwgLSA5LCAwKTtcblxuXHRcdFx0XHRpZiAocmVwdXRhdGlvbl9sZXZlbCA8IDApXG5cdFx0XHRcdFx0cmVwdXRhdGlvbl9sZXZlbCA9IDA7XG5cdFx0XHRcdGlmIChuZWcpXG5cdFx0XHRcdFx0cmVwdXRhdGlvbl9sZXZlbCAqPSAtMTtcblxuXHRcdFx0XHRyZXB1dGF0aW9uX2xldmVsID0gKHJlcHV0YXRpb25fbGV2ZWwqOSkgKyAyNTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYm9vbD9yZXB1dGF0aW9uX2xldmVsOk1hdGguZmxvb3IocmVwdXRhdGlvbl9sZXZlbCk7XG5cdFx0fVxuXHR9KVxuXG4gIGFwcC5maWx0ZXIoXCJzdW1Qb3N0VG90YWxcIiwgZnVuY3Rpb24oJHJvb3RTY29wZSl7XG4gICAgZnVuY3Rpb24gU3VtUG9zdFRvdGFsKHZhbHVlLCByYXRlKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKHZhbHVlLCByYXRlKTtcbiAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5wZW5kaW5nX3BheW91dF92YWx1ZSkge1xuICAgICAgICAvL3ZhbHVlLnRvdGFsX3BheW91dF92YWx1ZS5zcGxpdChcIiBcIilbMF0pK3BhcnNlRmxvYXQodmFsdWUudG90YWxfcGVuZGluZ19wYXlvdXRfdmFsdWUuc3BsaXQoXCIgXCIpWzBdKVxuICAgICAgICByZXR1cm4gKHBhcnNlRmxvYXQodmFsdWUucGVuZGluZ19wYXlvdXRfdmFsdWUuc3BsaXQoXCIgXCIpWzBdKSpyYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy9TdW1Qb3N0VG90YWwuJHN0YXRlZnVsID0gdHJ1ZTtcblxuICAgIHJldHVybiBTdW1Qb3N0VG90YWw7XG4gIH0pO1xuXG4gIGFwcC5maWx0ZXIoXCJyYXRlXCIsIGZ1bmN0aW9uKCRyb290U2NvcGUpe1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAocGFyc2VGbG9hdCh2YWx1ZSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7ICBcblxuICBhcHAuZmlsdGVyKCdocmVmVG9KUycsIGZ1bmN0aW9uICgkc2NlLCAkc2FuaXRpemUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgIHZhciByZWdleCA9IC9ocmVmPVwiKFtcXFNdKylcIi9nO1xuICAgICAgICAgIHZhciBuZXdTdHJpbmcgPSAkc2FuaXRpemUodGV4dCkucmVwbGFjZShyZWdleCwgXCJocmVmIG9uQ2xpY2s9XFxcIndpbmRvdy5vcGVuKCckMScsICdfYmxhbmsnLCAnbG9jYXRpb249eWVzJyk7cmV0dXJuIGZhbHNlO1xcXCJcIik7XG4gICAgICAgICAgcmV0dXJuICRzY2UudHJ1c3RBc0h0bWwobmV3U3RyaW5nKTtcbiAgICAgIH1cbiAgfSk7XG5cbiAgYXBwLmRpcmVjdGl2ZSgnYXV0b2ZvY3VzJywgWyckdGltZW91dCcsXG4gICAgZnVuY3Rpb24gKCR0aW1lb3V0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoJHNjb3BlLCAkZWxlbWVudCkge1xuICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRlbGVtZW50WzBdLmZvY3VzKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfV0pO1xuXG5cdGFwcC5kaXJlY3RpdmUoJ3FyY29kZScsIGZ1bmN0aW9uKCRpbnRlcnBvbGF0ZSkge1xuXHRcdHJldHVybiB7XG5cdFx0ICAgIHJlc3RyaWN0OiAnRScsXG5cdFx0ICAgIGxpbms6IGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycykge1xuXG5cdFx0ICAgICAgdmFyIG9wdGlvbnMgPSB7XG5cdFx0ICAgICAgICB0ZXh0OiAnJyxcblx0XHQgICAgICAgIHdpZHRoOiAxMjgsXG5cdFx0ICAgICAgICBoZWlnaHQ6IDEyOCxcblx0XHQgICAgICAgIGNvbG9yRGFyazogJyMwMDAwMDAnLFxuXHRcdCAgICAgICAgY29sb3JMaWdodDogJyNmZmZmZmYnLFxuXHRcdCAgICAgICAgY29ycmVjdExldmVsOiAnSCdcblx0XHQgICAgICB9O1xuXG5cdFx0ICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHQgICAgICAgIG9wdGlvbnNba2V5XSA9ICRpbnRlcnBvbGF0ZSgkYXR0cnNba2V5XSB8fCAnJykoJHNjb3BlKSB8fCBvcHRpb25zW2tleV07XG5cdFx0ICAgICAgfSk7XG5cblx0XHQgICAgICBvcHRpb25zLmNvcnJlY3RMZXZlbCA9IFFSQ29kZS5Db3JyZWN0TGV2ZWxbb3B0aW9ucy5jb3JyZWN0TGV2ZWxdO1xuXG5cdFx0ICAgICAgbmV3IFFSQ29kZSgkZWxlbWVudFswXSwgb3B0aW9ucyk7XG5cblx0XHQgICAgfVxuXHRcdH1cblx0fSk7XG5cblxuICAgIGFwcC5kaXJlY3RpdmUoJ2lvbkNvbW1lbnQnLCBpb25Db21tZW50KVxuICAgIGFwcC5kaXJlY3RpdmUoJ2lvblRocmVhZCcsIGlvblRocmVhZCk7XG5cbiAgICBmdW5jdGlvbiBpb25Db21tZW50KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICAgICAgY29tbWVudDogJz0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8aW9uLWl0ZW0gbmctaWY9XCJjb21tZW50LmF1dGhvclwiIGNsYXNzPVwiaW9uLWNvbW1lbnQgaXRlbVwiPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW9uLWNvbW1lbnQtLWF1dGhvclwiPjxpbWcgY2xhc3M9XCJyb3VuZC1hdmF0YXJcIiBzcmM9XCJpbWcvdXNlcl9wcm9maWxlLnBuZ1wiIG5nLXNyYz1cInt7JHJvb3QuJHN0b3JhZ2UucGFjY291bnRzW2NvbW1lbnQuYXV0aG9yXS5qc29uX21ldGFkYXRhLnVzZXJfaW1hZ2V8fCRyb290LiRzdG9yYWdlLnBhY2NvdW50c1tjb21tZW50LmF1dGhvcl0uanNvbl9tZXRhZGF0YS5wcm9maWxlLnByb2ZpbGVfaW1hZ2V9fVwiIG9uZXJyb3I9XCJ0aGlzLnNyYz1cXCdpbWcvdXNlcl9wcm9maWxlLnBuZ1xcJ1wiIG9uYWJvcnQ9XCJ0aGlzLnNyYz1cXCdpbWcvdXNlcl9wcm9maWxlLnBuZ1xcJ1wiIC8+PGI+PGEgaHJlZj1cIiMvYXBwL3Byb2ZpbGUve3tjb21tZW50LmF1dGhvcn19XCI+e3tjb21tZW50LmF1dGhvcn19PC9hPjwvYj4mbmJzcDs8ZGl2IGNsYXNzPVwicmVwdXRhdGlvblwiPnt7Y29tbWVudC5hdXRob3JfcmVwdXRhdGlvbnxyZXB1dGF0aW9ufG51bWJlcjowfX08L2Rpdj4mbWlkZG90O3t7Y29tbWVudC5jcmVhdGVkfHRpbWVhZ299fTwvZGl2PlxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW9uLWNvbW1lbnQtLXNjb3JlXCI+PHNwYW4gb24tdGFwPVwib3BlblRvb2x0aXAoJGV2ZW50LGNvbW1lbnQpXCI+PGI+e3skcm9vdC4kc3RvcmFnZS5jdXJyZW5jeXxnZXRDdXJyZW5jeVN5bWJvbH19PC9iPiB7e2NvbW1lbnQudG90YWxfcGVuZGluZ19wYXlvdXRfdmFsdWUuc3BsaXQoXCIgXCIpWzBdfHJhdGV8bnVtYmVyfX0gPC9zcGFuPiB8IDxzcGFuIG9uLXRhcD1cImRvd252b3RlUG9zdChjb21tZW50KVwiPjxzcGFuIGNsYXNzPVwiZmEgZmEtZmxhZ1wiIG5nLWNsYXNzPVwie1xcJ2Fzc2VydGl2ZVxcJzpjb21tZW50LmRvd252b3RlZH1cIj48L3NwYW4+PC9zcGFuPjwvZGl2PlxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW9uLWNvbW1lbnQtLXRleHQgYm9keXRleHQgc2VsZWN0YWJsZVwiIG5nLWJpbmQtaHRtbD1cImNvbW1lbnQuYm9keSB8IHBhcnNlVXJsIFwiPjwvZGl2PlxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW9uLWNvbW1lbnQtLXJlcGxpZXNcIj48c3BhbiBvbi10YXA9XCJ1cHZvdGVQb3N0KGNvbW1lbnQpXCIgb24taG9sZD1cIm9wZW5TbGlkZXJyKCRldmVudClcIj48c3BhbiBjbGFzcz1cImZhIGZhLWNoZXZyb24tY2lyY2xlLXVwXCIgbmctY2xhc3M9XCJ7XFwncG9zaXRpdmVcXCc6Y29tbWVudC51cHZvdGVkfVwiPjwvc3Bhbj4ge3tcIlVQVk9URVwifHRyYW5zbGF0ZX19PC9zcGFuPiB8IDxzcGFuIG9uLXRhcD1cIiRyb290Lm9wZW5JbmZvKGNvbW1lbnQpXCI+e3tjb21tZW50Lm5ldF92b3RlcyB8fCAwfX0ge3tcIlZPVEVTXCJ8dHJhbnNsYXRlfX08L3NwYW4+IHwgPHNwYW4gb24tdGFwPVwidG9nZ2xlQ29tbWVudChjb21tZW50KVwiPnt7Y29tbWVudC5jaGlsZHJlbiB8fCAwfX0ge3tcIlJFUExJRVNcInx0cmFuc2xhdGV9fTwvc3Bhbj4gfCA8c3BhbiBvbi10YXA9XCJyZXBseVRvQ29tbWVudChjb21tZW50KVwiPjxzcGFuIGNsYXNzPVwiZmEgZmEtcmVwbHlcIj48L3NwYW4+IHt7XCJSRVBMWVwifHRyYW5zbGF0ZX19PC9zcGFuPiA8c3BhbiBuZy1pZj1cImNvbW1lbnQuYXV0aG9yID09ICRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgJiYgY29tcGF0ZURhdGUoY29tbWVudClcIiBvbi10YXA9XCJlZGl0Q29tbWVudChjb21tZW50KVwiPiB8IDxzcGFuIGNsYXNzPVwiaW9uLWlvcy1jb21wb3NlLW91dGxpbmVcIj48L3NwYW4+IHt7XFwnRURJVFxcJ3x0cmFuc2xhdGV9fTwvc3Bhbj4gPHNwYW4gbmctaWY9XCJjb21tZW50LmF1dGhvciA9PSAkcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lXCIgb24tdGFwPVwiZGVsZXRlQ29tbWVudChjb21tZW50KVwiPiB8IDxzcGFuIGNsYXNzPVwiaW9uLWlvcy10cmFzaC1vdXRsaW5lXCI+PC9zcGFuPiB7e1xcJ1JFTU9WRVxcJ3x0cmFuc2xhdGV9fTwvc3Bhbj48L2Rpdj5cXFxuICAgICAgICAgICAgICAgICAgICA8L2lvbi1pdGVtPicsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBmdW5jdGlvbigkc2NvcGUsICRyb290U2NvcGUsICRzdGF0ZSwgJGlvbmljTW9kYWwsICRpb25pY1BvcG92ZXIsICRpb25pY1BvcHVwLCAkaW9uaWNBY3Rpb25TaGVldCwgJGNvcmRvdmFDYW1lcmEsICRmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICRpb25pY1BvcG92ZXIuZnJvbVRlbXBsYXRlVXJsKCdwb3BvdmVyVHIuaHRtbCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJHNjb3BlXG4gICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihwb3BvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnRvb2x0aXAgPSBwb3BvdmVyO1xuICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgdmFyIGZvcm1hdFRvUGVyY2VudGFnZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgKyAnJSc7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgJHNjb3BlLnBzbGlkZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQvMTAwLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgZmxvb3I6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgY2VpbDogMTAwLFxuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZTogZm9ybWF0VG9QZXJjZW50YWdlLFxuICAgICAgICAgICAgICAgICAgICAgIHNob3dTZWxlY3Rpb25CYXI6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICRpb25pY1BvcG92ZXIuZnJvbVRlbXBsYXRlVXJsKCdwb3BvdmVyU2xpZGVyci5odG1sJywge1xuICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAkc2NvcGVcbiAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocG9wb3Zlcikge1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS50b29sdGlwU2xpZGVyciA9IHBvcG92ZXI7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgJHNjb3BlLm9wZW5TbGlkZXJyID0gZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5wc2xpZGVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQvMTAwLFxuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb29yOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VpbDogMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlOiBmb3JtYXRUb1BlcmNlbnRhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93U2VsZWN0aW9uQmFyOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudG9vbHRpcFNsaWRlcnIuc2hvdygkZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlU2xpZGVyciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudG9vbHRpcFNsaWRlcnIuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLiR3YXRjaCgncHNsaWRlcicsIGZ1bmN0aW9uKG5ld1ZhbHVlLCBvbGRWYWx1ZSl7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cobmV3VmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQgPSBuZXdWYWx1ZS52YWx1ZSoxMDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgJHNjb3BlLm9wZW5Ub29sdGlwID0gZnVuY3Rpb24oJGV2ZW50LCBkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cHB2ID0gTnVtYmVyKGQudG90YWxfcGVuZGluZ19wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gTnVtYmVyKGQucHJvbW90ZWQuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cHYgPSBOdW1iZXIoZC50b3RhbF9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhciA9IE51bWJlcihkLnRvdGFsX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdLWQuY3VyYXRvcl9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjcnAgPSBOdW1iZXIoZC5jdXJhdG9yX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRoID0gXCI8ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ1BBWU9VVF9DWUNMRScpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrZC5tb2RlLnJlcGxhY2UoJ18nLCcgJykrXCI8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ1BPVEVOVElBTF9QQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykodHBwdiwgMykrXCI8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ1BBU1RfUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCdnZXRDdXJyZW5jeVN5bWJvbCcpKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kpKyRmaWx0ZXIoJ251bWJlcicpKHRwdiwzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCd0aW1lYWdvJykoZC5jYXNob3V0X3RpbWUsIHRydWUpK1wiPC9kaXY+PC9kaXY+XCI7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS50b29sdGlwVGV4dCA9IHRleHRoO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudG9vbHRpcC5zaG93KCRldmVudCk7XG4gICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICRzY29wZS5jbG9zZVRvb2x0aXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUudG9vbHRpcC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgIC8vQ2xlYW51cCB0aGUgcG9wb3ZlciB3aGVuIHdlJ3JlIGRvbmUgd2l0aCBpdCFcbiAgICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS50b29sdGlwLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgICAgICAgICRzY29wZS5jb21wYXRlRGF0ZSA9IGZ1bmN0aW9uKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQubGFzdF9wYXlvdXQgPT0gXCIxOTcwLTAxLTAxVDAwOjAwOjAwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50Lm1vZGUgPT0gXCJmaXJzdF9wYXlvdXRcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICRzY29wZS50b2dnbGVDb21tZW50ID0gZnVuY3Rpb24oY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCd0b2dnbGVDb21tZW50Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5zaG93Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudC5zaG93Q2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LnNob3dDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgJHNjb3BlLnVwdm90ZVBvc3QgPSBmdW5jdGlvbihwb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUudm90ZVBvc3QocG9zdCwgJ3Vwdm90ZScsICd1cGRhdGU6Y29udGVudCcpO1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmRvd252b3RlUG9zdCA9IGZ1bmN0aW9uKHBvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpcm1Qb3B1cCA9ICRpb25pY1BvcHVwLmNvbmZpcm0oe1xuICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQVJFX1lPVV9TVVJFJyksXG4gICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdET1dOVk9URV9GTEFHJylcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpcm1Qb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgc3VyZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS52b3RlUG9zdChwb3N0LCAnZG93bnZvdGUnLCAndXBkYXRlOmNvbnRlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgbm90IHN1cmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLnVudm90ZVBvc3QgPSBmdW5jdGlvbihwb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUudm90ZVBvc3QocG9zdCwgJ3Vudm90ZScsICd1cGRhdGU6Y29udGVudCcpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhPXt9O1xuICAgICAgICAgICAgICAgICAgJGlvbmljTW9kYWwuZnJvbVRlbXBsYXRlVXJsKCd0ZW1wbGF0ZXMvcmVwbHkuaHRtbCcsIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICRzY29wZSAgfSkudGhlbihmdW5jdGlvbihtb2RhbCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY21vZGFsID0gbW9kYWw7XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLm9wZW5Nb2RhbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNtb2RhbC5zaG93KCk7XG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VNb2RhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUucmVwbHlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNtb2RhbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAkc2NvcGUuaXNyZXBseWluZyA9IGZ1bmN0aW9uKGNobywgeHgpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnJlcGx5aW5nID0geHg7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5wb3N0ID0gY2hvO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5lZGl0YyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmVkaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLmNvbW1lbnQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5vcGVuTW9kYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5lZGl0YyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZWRpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5jb21tZW50ID0gJHNjb3BlLnBvc3QuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5wYXRjaGJvZHkgPSAkc2NvcGUucG9zdC5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm9wZW5Nb2RhbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAkc2NvcGUuc2hvd0ltZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgIHZhciBoaWRlU2hlZXQgPSAkaW9uaWNBY3Rpb25TaGVldC5zaG93KHtcbiAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FQVFVSRV9QSUNUVVJFJykgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VMRUNUX1BJQ1RVUkUnKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICB7IHRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRfQ1VTVE9NX1VSTCcpIH0sXG4gICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgdGl0bGVUZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnSU5TRVJUX1BJQ1RVUkUnKSxcbiAgICAgICAgICAgICAgICAgICAgIGNhbmNlbFRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDQU5DRUwnKSxcbiAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgY2FuY2VsIGNvZGUuLlxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICBidXR0b25DbGlja2VkOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmluc2VydEltYWdlQyhpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICRzY29wZS5pbnNlcnRJbWFnZUMgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IDAgfHwgdHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YWxpdHk6IDUwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25UeXBlOiBDYW1lcmEuRGVzdGluYXRpb25UeXBlLkZJTEVfVVJJLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVHlwZTogKHR5cGU9PT0wKT9DYW1lcmEuUGljdHVyZVNvdXJjZVR5cGUuQ0FNRVJBOkNhbWVyYS5QaWN0dXJlU291cmNlVHlwZS5QSE9UT0xJQlJBUlksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0VkaXQ6ICh0eXBlPT09MCk/dHJ1ZTpmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nVHlwZTogQ2FtZXJhLkVuY29kaW5nVHlwZS5KUEVHLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9wb3Zlck9wdGlvbnM6IENhbWVyYVBvcG92ZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZVRvUGhvdG9BbGJ1bTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29ycmVjdE9yaWVudGF0aW9uOnRydWVcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICRjb3Jkb3ZhQ2FtZXJhLmdldFBpY3R1cmUob3B0aW9ucykudGhlbihmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIEltYWdlVXBsb2FkU2VydmljZS51cGxvYWRJbWFnZShpbWFnZURhdGEpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgdXJsID0gcmVzdWx0LnNlY3VyZV91cmwgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IHJlc3VsdC5pbWFnZVVybCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWwgPSBcIiAhW2ltYWdlXShcIiArIHVybCArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKGZpbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLmRhdGEuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuY29tbWVudCArPSBmaW5hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuY29tbWVudCA9IGZpbmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpIHx8ICFpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY29yZG92YUNhbWVyYS5jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1VQTE9BRF9FUlJPUicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpIHx8ICFpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY29yZG92YUNhbWVyYS5jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FNRVJBX0NBTkNFTExFRCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAkaW9uaWNQb3B1cC5wcm9tcHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRfVVJMJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0RJUkVDVF9MSU5LX1BJQ1RVUkUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRQbGFjZWhvbGRlcjogJ2h0dHA6Ly9leGFtcGxlLmNvbS9pbWFnZS5qcGcnXG4gICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3VyIHVybCBpcycgKyByZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gcmVzLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsID0gXCIgIVtpbWFnZV0oXCIgKyB1cmwgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coZmluYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLmRhdGEuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLmNvbW1lbnQgKz0gZmluYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuY29tbWVudCA9IGZpbmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgIHZhciBkbXAgPSBuZXcgd2luZG93LmRpZmZfbWF0Y2hfcGF0Y2goKTtcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGNoKHRleHQxLCB0ZXh0Mikge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghdGV4dDEgJiYgdGV4dDEgPT09ICcnKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRjaGVzID0gZG1wLnBhdGNoX21ha2UodGV4dDEsIHRleHQyKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0Y2ggPSBkbXAucGF0Y2hfdG9UZXh0KHBhdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRjaDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICRzY29wZS5yZXBseSA9IGZ1bmN0aW9uICh4eCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISRzY29wZS5lZGl0Yykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93WyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4rXCJKU1wiXS5Mb2dpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbi5zZXRSb2xlcyhbXCJwb3N0aW5nXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRzY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZVBvc3RpbmdLZXkgfHwgbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3dbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIkpTXCJdLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZWZvcm1hdCA9IHQuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpKyh0LmdldE1vbnRoKCkrMSkudG9TdHJpbmcoKSt0LmdldERhdGUoKS50b1N0cmluZygpK1widFwiK3QuZ2V0SG91cnMoKS50b1N0cmluZygpK3QuZ2V0TWludXRlcygpLnRvU3RyaW5nKCkrdC5nZXRTZWNvbmRzKCkudG9TdHJpbmcoKSt0LmdldE1pbGxpc2Vjb25kcygpLnRvU3RyaW5nKCkrXCJ6XCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIganNvbiA9IHt0YWdzOiBhbmd1bGFyLmZyb21Kc29uKCRzY29wZS5wb3N0Lmpzb25fbWV0YWRhdGEpLnRhZ3NbMF0gfHwgXCJcIiwgYXBwOiAnZXN0ZWVtLycrJHJvb3RTY29wZS4kc3RvcmFnZS5hcHB2ZXJzaW9uLCBmb3JtYXQ6ICdtYXJrZG93bitodG1sJyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImNvbW1lbnRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50X2F1dGhvcjogJHNjb3BlLnBvc3QuYXV0aG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50X3Blcm1saW5rOiAkc2NvcGUucG9zdC5wZXJtbGluayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcjogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVybWxpbms6IFwicmUtXCIrJHNjb3BlLnBvc3QuYXV0aG9yK1wiLVwiKyRzY29wZS5wb3N0LnBlcm1saW5rK1wiLVwiK3RpbWVmb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICRzY29wZS5kYXRhLmNvbW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uX21ldGFkYXRhOiBhbmd1bGFyLnRvSnNvbihqc29uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vJHJvb3RTY29wZS5sb2cobXlfcHVia2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5yZXBseWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlTW9kYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuY29tbWVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0NPTU1FTlRfU1VCTUlUVEVEJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoXCJ1cGRhdGU6Y29udGVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX1RPX1gnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoKCRzY29wZS5wYXRjaGJvZHksICRzY29wZS5kYXRhLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXR0aW5nIGJvZHkgaW50byBidWZmZXIgd2lsbCBleHBhbmQgVW5pY29kZSBjaGFyYWN0ZXJzIGludG8gdGhlaXIgdHJ1ZSBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRjaCAmJiBwYXRjaC5sZW5ndGggPCBuZXcgQnVmZmVyKCRzY29wZS5kYXRhLmNvbW1lbnQsICd1dGYtOCcpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5jb21tZW50MiA9IHBhdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyRyb290U2NvcGUubG9nKHBhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93WyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4rXCJKU1wiXS5Mb2dpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbi5zZXRSb2xlcyhbXCJwb3N0aW5nXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRzY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZVBvc3RpbmdLZXkgfHwgbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3dbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIkpTXCJdLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGpzb24gPSB7dGFnczogYW5ndWxhci5mcm9tSnNvbigkc2NvcGUucG9zdC5qc29uX21ldGFkYXRhKS50YWdzWzBdIHx8IFwiXCIsIGFwcDogJ2VzdGVlbS8nKyRyb290U2NvcGUuJHN0b3JhZ2UuYXBwdmVyc2lvbiwgZm9ybWF0OiAnbWFya2Rvd24raHRtbCcgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJjb21tZW50XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudF9hdXRob3I6ICRzY29wZS5wb3N0LnBhcmVudF9hdXRob3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRfcGVybWxpbms6ICRzY29wZS5wb3N0LnBhcmVudF9wZXJtbGluayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcjogJHNjb3BlLnBvc3QuYXV0aG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVybWxpbms6ICRzY29wZS5wb3N0LnBlcm1saW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAkc2NvcGUuZGF0YS5jb21tZW50MiB8fCAkc2NvcGUuZGF0YS5jb21tZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbl9tZXRhZGF0YTogJHNjb3BlLnBvc3QuanNvbl9tZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vJHJvb3RTY29wZS5sb2cobXlfcHVia2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5jbG9zZU1vZGFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnJlcGx5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0JST0FEQ0FTVF9FUlJPUicpK1wiIFwiK2xvY2FsU3RvcmFnZS5lcnJvcm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5jb21tZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ09NTUVOVF9TVUJNSVRURUQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdChcInVwZGF0ZTpjb250ZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHNjb3BlLnJlcGx5VG9Db21tZW50ID0gZnVuY3Rpb24oY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygncmVwbHkgdG8gY29tbWVudCcpXG4gICAgICAgICAgICAgICAgICAgIC8vJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbSA9IGNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5pc3JlcGx5aW5nKGNvbW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkc2NvcGUuZWRpdENvbW1lbnQgPSBmdW5jdGlvbihjb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdlZGl0IHRvIGNvbW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAvLyRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0gPSBjb21tZW50O1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaXNyZXBseWluZyhjb21tZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRzY29wZS5kZWxldGVDb21tZW50ID0gZnVuY3Rpb24oY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnZGVsZXRlIHRvIGNvbW1lbnQgJysgYW5ndWxhci50b0pzb24oY29tbWVudCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmlybVBvcHVwID0gJGlvbmljUG9wdXAuY29uZmlybSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FSRV9ZT1VfU1VSRScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdERUxFVEVfQ09NTUVOVCcpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25maXJtUG9wdXAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIHN1cmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5teWxvZ2luID0gbmV3IHdpbmRvd1skcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluK1wiSlNcIl0uTG9naW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5teWxvZ2luLnNldFJvbGVzKFtcInBvc3RpbmdcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRzY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdGluZzogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBvc3Rpbmcua2V5X2F1dGhzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZVBvc3RpbmdLZXkgfHwgbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHIgPSBuZXcgd2luZG93WyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4rXCJKU1wiXS5UcmFuc2FjdGlvbkJ1aWxkZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJkZWxldGVfY29tbWVudFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aG9yOiBjb21tZW50LmF1dGhvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJtbGluazogY29tbWVudC5wZXJtbGlua1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8kcm9vdFNjb3BlLmxvZyhteV9wdWJrZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIucHJvY2Vzc190cmFuc2FjdGlvbigkc2NvcGUubXlsb2dpbiwgbnVsbCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnREVMRVRFRF9DT01NRU5UJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KFwidXBkYXRlOmNvbnRlbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9UT19YJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIG5vdCBzdXJlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlvblRocmVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgICAgIGNvbW1lbnRzOiAnPSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvL1JlcGxhY2UgbmctaWY9XCIhY29tbWVudC5zaG93Q2hpbGRyZW5cIiB3aXRoIG5nLWlmPVwiY29tbWVudC5zaG93Q2hpbGRyZW5cIiB0byBoaWRlIGFsbCBjaGlsZCBjb21tZW50cyBieSBkZWZhdWx0XG4gICAgICAgICAgICAvL1JlcGxhY2UgY29tbWVudC5kYXRhLnJlcGxpZXMuZGF0YS5jaGlsZHJlbiBhY2NvcmRpbmcgdG8gdGhlIEFQSSB5b3UgYXJlIHVzaW5nIHwgb3JkZXJCeTpcXCctbmV0X3ZvdGVzXFwnXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxzY3JpcHQgdHlwZT1cInRleHQvbmctdGVtcGxhdGVcIiBpZD1cIm5vZGUuaHRtbFwiPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlvbi1jb21tZW50IGNvbW1lbnQ9XCJjb21tZW50XCI+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2lvbi1jb21tZW50PlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJlZGRpdC1wb3N0LS1jb21tZW50LS1jb250YWluZXJcIj5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIG5nLWlmPVwiIWNvbW1lbnQuc2hvd0NoaWxkcmVuXCIgY2xhc3M9XCJhbmltYXRlLWlmIGlvbi1jb21tZW50LS1jaGlsZHJlblwiPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgbmctcmVwZWF0PVwiY29tbWVudCBpbiBjb21tZW50LmNvbW1lbnRzIHwgb3JkZXJCeTpcXCctbmV0X3ZvdGVzXFwnIHRyYWNrIGJ5ICRpbmRleCBcIj5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1pbmNsdWRlIHNyYz1cIlxcJ25vZGUuaHRtbFxcJ1wiLz5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc2NyaXB0PlxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW9uLWxpc3QgbmctaWY9XCJjb21tZW50cyAmJiBjb21tZW50cy5sZW5ndGggPiAwXCI+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIG5nLXJlcGVhdD1cImNvbW1lbnQgaW4gY29tbWVudHMgfCBvcmRlckJ5OlxcJy1uZXRfdm90ZXNcXCcgdHJhY2sgYnkgJGluZGV4XCI+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWluY2x1ZGUgc3JjPVwiXFwnbm9kZS5odG1sXFwnXCIvPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2lvbi1saXN0PicsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBmdW5jdGlvbigkc2NvcGUsICRyb290U2NvcGUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUudG9nZ2xlQ29tbWVudCA9IGZ1bmN0aW9uKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCd0b2dnbGVDb21tZW50Jyk7XG4gICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5zaG93Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LnNob3dDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LnNob3dDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl1cygkcSwgJGlvbmljTG9hZGluZywgJGNvcmRvdmFGaWxlVHJhbnNmZXIsICRpb25pY1BsYXRmb3JtLCAkZmlsdGVyLCAkcm9vdFNjb3BlKSB7XG4gICAgICAgIHZhciBzZXJ2aWNlID0ge307XG4gICAgICAgIHNlcnZpY2UudXBsb2FkSW1hZ2UgPSB1cGxvYWRJbWFnZTtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2U7XG4gICAgICAgIGZ1bmN0aW9uIHVwbG9hZEltYWdlKGltYWdlVVJJKSB7XG4gICAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICB2YXIgZmlsZVNpemU7XG4gICAgICAgICAgdmFyIHBlcmNlbnRhZ2U7XG4gICAgICAgICAgLyppZiAoaW9uaWMuUGxhdGZvcm0uaXNBbmRyb2lkKCkpIHtcbiAgICAgICAgICAgIGlmIChpbWFnZVVSSS5pbmRleE9mKCdmaWxlOi8vJyk9PT0tMSkge1xuICAgICAgICAgICAgICBpbWFnZVVSST1cImZpbGU6Ly9cIitpbWFnZVVSSTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9Ki9cbiAgICAgICAgICAvLyBGaW5kIG91dCBob3cgYmlnIHRoZSBvcmlnaW5hbCBmaWxlIGlzXG4gICAgICAgICAgd2luZG93LnJlc29sdmVMb2NhbEZpbGVTeXN0ZW1VUkwoaW1hZ2VVUkksIGZ1bmN0aW9uKGZpbGVFbnRyeSkge1xuICAgICAgICAgICAgZmlsZUVudHJ5LmZpbGUoZnVuY3Rpb24oZmlsZU9iaikge1xuICAgICAgICAgICAgICBmaWxlU2l6ZSA9IGZpbGVPYmouc2l6ZTtcbiAgICAgICAgICAgICAgLy8gRGlzcGxheSBhIGxvYWRpbmcgaW5kaWNhdG9yIHJlcG9ydGluZyB0aGUgc3RhcnQgb2YgdGhlIHVwbG9hZFxuICAgICAgICAgICAgICAkaW9uaWNMb2FkaW5nLnNob3coe3RlbXBsYXRlIDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1VQTE9BRElOR19QSUNUVVJFJykgKyAwICsgJyUnfSk7XG4gICAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIHVwbG9hZFxuICAgICAgICAgICAgICB1cGxvYWRGaWxlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmdW5jdGlvbiB1cGxvYWRGaWxlKCkge1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBDbG91ZGluYXJ5IFwidXBsb2FkIHByZXNldFwiIG5hbWUgdG8gdGhlIGhlYWRlcnNcbiAgICAgICAgICAgIC8vIFwiaHR0cHM6Ly9hcGkuY2xvdWRpbmFyeS5jb20vdjFfMS9lc3RlZW0vaW1hZ2UvdXBsb2FkXCJcbiAgICAgICAgICAgIHZhciB1cGxvYWRPcHRpb25zID0ge1xuICAgICAgICAgICAgICBwYXJhbXMgOiB7ICd1c2VybmFtZSc6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZX1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAkaW9uaWNQbGF0Zm9ybS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkY29yZG92YUZpbGVUcmFuc2Zlci51cGxvYWQoXCJodHRwOi8vMTkyLjE1OC4yOS4xOjgwODAvYXBpL3VwbG9hZFwiLCBpbWFnZVVSSSwgdXBsb2FkT3B0aW9ucykudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGV0IHRoZSB1c2VyIGtub3cgdGhlIHVwbG9hZCBpcyBjb21wbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgJGlvbmljTG9hZGluZy5zaG93KHt0ZW1wbGF0ZSA6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdVUExPQURfQ09NUExFVEVEJyksIGR1cmF0aW9uOiAxMDAwfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3VsdCBoYXMgYSBcInJlc3BvbnNlXCIgcHJvcGVydHkgdGhhdCBpcyBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIEZZSTogVGhlIHJlc3VsdCB3aWxsIGFsc28gaGF2ZSBVUkxzIGZvciBhbnkgbmV3IGltYWdlcyBnZW5lcmF0ZWQgd2l0aFxuICAgICAgICAgICAgICAgICAgICAvLyBlYWdlciB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gSlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQocmVzdWx0LnJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVoIG9oIVxuICAgICAgICAgICAgICAgICAgICAkaW9uaWNMb2FkaW5nLnNob3coe3RlbXBsYXRlIDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1VQTE9BRF9GQUlMRUQnKSwgZHVyYXRpb246IDIwMDB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHVwbG9hZCBwbHVnaW4gZ2l2ZXMgeW91IGluZm9ybWF0aW9uIGFib3V0IGhvdyBtdWNoIGRhdGEgaGFzIGJlZW4gdHJhbnNmZXJyZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gc29tZSBpbnRlcnZhbC4gIFVzZSB0aGlzIHdpdGggdGhlIG9yaWdpbmFsIGZpbGUgc2l6ZSB0byBzaG93IGEgcHJvZ3Jlc3MgaW5kaWNhdG9yLlxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50YWdlID0gTWF0aC5mbG9vcigocHJvZ3Jlc3MubG9hZGVkIC8gZmlsZVNpemUpICogMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgJGlvbmljTG9hZGluZy5zaG93KHt0ZW1wbGF0ZSA6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdVUExPQURJTkdfUElDVFVSRScpICsgcGVyY2VudGFnZSArICclJ30pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhcHAuZmFjdG9yeSgnSW1hZ2VVcGxvYWRTZXJ2aWNlJywgaXVzKTtcblxuICAgIGFwcC5jb25zdGFudCgnZGVmYXVsdFNldHRpbmdzJywge1xuICAgICAgICBhbHBoYWJldGNvbG9yczogW1wiIzVBODc3MFwiLCBcIiNCMkI3QkJcIiwgXCIjNkZBOUFCXCIsIFwiI0Y1QUYyOVwiLCBcIiMwMDg4QjlcIiwgXCIjRjE4NjM2XCIsIFwiI0Q5M0EzN1wiLCBcIiNBNkIxMkVcIiwgXCIjNUM5QkJDXCIsIFwiI0Y1ODg4RFwiLCBcIiM5QTg5QjVcIiwgXCIjNDA3ODg3XCIsIFwiIzlBODlCNVwiLCBcIiM1QTg3NzBcIiwgXCIjRDMzRjMzXCIsIFwiI0EyQjAxRlwiLCBcIiNGMEIxMjZcIiwgXCIjMDA4N0JGXCIsIFwiI0YxODYzNlwiLCBcIiMwMDg3QkZcIiwgXCIjQjJCN0JCXCIsIFwiIzcyQUNBRVwiLCBcIiM5QzhBQjRcIiwgXCIjNUE4NzcwXCIsIFwiI0VFQjQyNFwiLCBcIiM0MDc4ODdcIl0sXG4gICAgICAgIHRleHRDb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICBkZWZhdWx0Qm9yZGVyOiAnYm9yZGVyOjVweCBzb2xpZCB3aGl0ZScsXG4gICAgICAgIHRyaWFuZ2xldXA6ICd3aWR0aDogMDtoZWlnaHQ6IDA7Ym9yZGVyLWxlZnQ6IDUwcHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OiA1MHB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1ib3R0b206IDEwMHB4IHNvbGlkOycsXG4gICAgICAgIGZvbnRzaXplOiAzMCwgLy8gdW5pdCBpbiBwaXhlbHNcbiAgICAgICAgaGVpZ2h0OiA1MCwgLy8gdW5pdCBpbiBwaXhlbHNcbiAgICAgICAgd2lkdGg6IDUwLCAvLyB1bml0IGluIHBpeGVsc1xuICAgICAgICBmb250V2VpZ2h0OiA0MDAsIC8vXG4gICAgICAgIGNoYXJDb3VudDogMSxcbiAgICAgICAgZm9udEZhbWlseTogJ0hlbHZldGljYU5ldWUtTGlnaHQsSGVsdmV0aWNhIE5ldWUgTGlnaHQsSGVsdmV0aWNhIE5ldWUsSGVsdmV0aWNhLCBBcmlhbCxMdWNpZGEgR3JhbmRlLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgYmFzZTogJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJyxcbiAgICAgICAgcmFkaXVzOiAnYm9yZGVyLXJhZGl1czo1MCU7JyxcbiAgICAgICAgY3VzdG9tYmdjb2xvcjogJycsXG4gICAgICAgIGR5bmFtaWM6ICdmYWxzZScsXG4gICAgICAgIHJvdGF0ZWRlZzogJzAnXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBkaXJlY3RpdmUgdG8gY3JlYXRlIHRoZSBhdmF0YXJcbiAgICAgKiBAcGFyYW0ge3R5cGV9IHBhcmFtMVxuICAgICAqIEBwYXJhbSB7dHlwZX0gcGFyYW0yXG4gICAgICovXG4gICAgYXBwLmRpcmVjdGl2ZSgnbmdMZXR0ZXJBdmF0YXInLCBbJ2RlZmF1bHRTZXR0aW5ncycsIGZ1bmN0aW9uIChkZWZhdWx0U2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnQUUnLFxuICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICAgICAgYWxwaGFiZXRjb2xvcnM6ICc9YWxwaGFiZXRjb2xvcnMnLFxuICAgICAgICAgICAgICAgIGRhdGE6ICdAJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFBvcHVsYXRlIHRoZSBhdHRyaWJ1dGUgdmFsdWVzIHRvIHBhcmFtcyBvYmplY3RcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB0eXBlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvdW50OiBhdHRycy5jaGFyY291bnQgfHwgZGVmYXVsdFNldHRpbmdzLmNoYXJDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYXR0cnMuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dENvbG9yOiBkZWZhdWx0U2V0dGluZ3MudGV4dENvbG9yLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGF0dHJzLmhlaWdodCB8fCBkZWZhdWx0U2V0dGluZ3MuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogYXR0cnMud2lkdGggfHwgZGVmYXVsdFNldHRpbmdzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBmb250c2l6ZTogYXR0cnMuZm9udHNpemUgfHwgZGVmYXVsdFNldHRpbmdzLmZvbnRzaXplLFxuICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBhdHRycy5mb250d2VpZ2h0IHx8IGRlZmF1bHRTZXR0aW5ncy5mb250V2VpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBhdHRycy5mb250ZmFtaWx5IHx8IGRlZmF1bHRTZXR0aW5ncy5mb250RmFtaWx5LFxuICAgICAgICAgICAgICAgICAgICBhdmF0YXJCb3JkZXJTdHlsZTogYXR0cnMuYXZhdGFyY3VzdG9tYm9yZGVyLFxuICAgICAgICAgICAgICAgICAgICBhdmF0YXJkZWZhdWx0Qm9yZGVyOiBhdHRycy5hdmF0YXJib3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRCb3JkZXI6IGRlZmF1bHRTZXR0aW5ncy5kZWZhdWx0Qm9yZGVyLFxuICAgICAgICAgICAgICAgICAgICBzaGFwZTogYXR0cnMuc2hhcGUsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhYmV0Y29sb3JzOiBzY29wZS5hbHBoYWJldGNvbG9ycyB8fCBkZWZhdWx0U2V0dGluZ3MuYWxwaGFiZXRjb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgIGF2YXRhckN1c3RvbUJHQ29sb3I6IGF0dHJzLmF2YXRhcmN1c3RvbWJnY29sb3IgfHwgZGVmYXVsdFNldHRpbmdzLmN1c3RvbWJnY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWM6IGF0dHJzLmR5bmFtaWMgfHwgZGVmYXVsdFNldHRpbmdzLmR5bmFtaWMsXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZWRlZzogYXR0cnMucm90YXRlZGVnIHx8IGRlZmF1bHRTZXR0aW5ncy5yb3RhdGVkZWdcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogdG8gZ2VuZXJhdGUgdGhlIGF2YXRhciBkeW5hbWljYWxseSBvbiBkYXRhIGNoYW5nZSwgZW5hYmxlIHRoZSBiZWxvdyBmdW5jdGlvbiB0byB3YXRjaCB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmR5bmFtaWMgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2VuZXJhdGVMZXR0ZXJBdmF0YXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX2dlbmVyYXRlTGV0dGVyQXZhdGFyKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gX2dlbmVyYXRlTGV0dGVyQXZhdGFyKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmNoYXJDb3VudCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2RhdGEgPSBnZXRGaXJzdEFuZExhc3ROYW1lKHNjb3BlLmRhdGEudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gX2RhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBzY29wZS5kYXRhLnN1YnN0cigwLCBwYXJhbXMuY2hhckNvdW50KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHNjb3BlLmRhdGEuc3Vic3RyKDAsIHBhcmFtcy5jaGFyQ291bnQpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvYmogPSBnZXRDaGFyYWN0ZXJPYmplY3QoYywgcGFyYW1zLnRleHRDb2xvciwgcGFyYW1zLmZvbnRGYW1pbHksIHBhcmFtcy5mb250V2VpZ2h0LCBwYXJhbXMuZm9udHNpemUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3JJbmRleCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSAnJztcblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogUG9wdWxhdGUgdGhlIGNvbG9ycyBhY2NvcmRpbmcgdG8gYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuY2hhckNvZGVBdCgwKSA8IDY1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGdldFJhbmRvbUNvbG9ycygpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JJbmRleCA9IE1hdGguZmxvb3IoKGMuY2hhckNvZGVBdCgwKSAtIDY1KSAlIHBhcmFtcy5hbHBoYWJldGNvbG9ycy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBwYXJhbXMuYWxwaGFiZXRjb2xvcnNbY29sb3JJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmF2YXRhckN1c3RvbUJHQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gcGFyYW1zLmF2YXRhckN1c3RvbUJHQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ZnID0gZ2V0SW1nVGFnKHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCwgY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBzdmcuYXBwZW5kKGNvYmopO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbHZjb21wb25lbnQgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXY+JykuYXBwZW5kKHN2Zy5jbG9uZSgpKS5odG1sKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdmdIdG1sID0gd2luZG93LmJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGx2Y29tcG9uZW50KSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IGRlZmF1bHRTZXR0aW5ncy5iYXNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0eWxlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYXZhdGFyQm9yZGVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHlsZSA9IHBhcmFtcy5hdmF0YXJCb3JkZXJTdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuYXZhdGFyZGVmYXVsdEJvcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0eWxlID0gcGFyYW1zLmRlZmF1bHRCb3JkZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnJvdGF0ZWRlZyAhPSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHlsZSA9ICctbXMtdHJhbnNmb3JtOiByb3RhdGUoJyArIHBhcmFtcy5yb3RhdGVkZWcgKyAnZGVnKTsgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgnICsgcGFyYW1zLnJvdGF0ZWRlZyArICdkZWcpOyB0cmFuc2Zvcm06IHJvdGF0ZSgnICsgcGFyYW1zLnJvdGF0ZWRlZyArICdkZWcpJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuc2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuc2hhcGUgPT09ICdyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm91bmRfc3R5bGUgPSBkZWZhdWx0U2V0dGluZ3MucmFkaXVzICsgX3N0eWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5kYXRhLmluZGV4T2YoJ2h0dHAnKSA+IC0xIHx8IHNjb3BlLmRhdGEuaW5kZXhPZignZGF0YTppbWFnZScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltZ19zaXplID0gJ3dpZHRoOicgKyBwYXJhbXMud2lkdGggKyAncHg7aGVpZ2h0OicgKyBwYXJhbXMuaGVpZ2h0ICsgJ3B4Oyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IFwiPGltZyBzcmM9XCIgKyBzY29wZS5kYXRhICsgXCIgc3R5bGU9J1wiICsgaW1nX3NpemUgKyByb3VuZF9zdHlsZSArIFwiJyAgLz5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBcIjxpbWcgc3JjPVwiICsgYmFzZSArIHN2Z0h0bWwgKyBcIiBzdHlsZT0nXCIgKyByb3VuZF9zdHlsZSArIFwiJyB0aXRsZT0nXCIgKyBzY29wZS5kYXRhICsgXCInIC8+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLmRhdGEuaW5kZXhPZignaHR0cCcpID4gLTEgfHwgc2NvcGUuZGF0YS5pbmRleE9mKCdkYXRhOmltYWdlJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWdfc2l6ZSA9ICd3aWR0aDonICsgcGFyYW1zLndpZHRoICsgJ3B4O2hlaWdodDonICsgcGFyYW1zLmhlaWdodCArICdweDsnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IFwiPGltZyBzcmM9XCIgKyBzY29wZS5kYXRhICsgXCIgc3R5bGU9J1wiICsgaW1nX3NpemUgKyBfc3R5bGUgKyBcIicgIC8+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IFwiPGltZyBzcmM9XCIgKyBiYXNlICsgc3ZnSHRtbCArIFwiIHN0eWxlPSdcIiArIF9zdHlsZSArIFwiJyB0aXRsZT0nXCIgKyBzY29wZS5kYXRhICsgXCInIC8+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmR5bmFtaWMgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmQoY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVwbGFjZVdpdGgoY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XSk7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByYW5kb20gY29sb3JzXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRSYW5kb21Db2xvcnMoKSB7XG4gICAgICAgIHZhciBsZXR0ZXJzID0gJzAxMjM0NTY3ODlBQkNERUYnLnNwbGl0KCcnKTtcbiAgICAgICAgdmFyIF9jb2xvciA9ICcjJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIF9jb2xvciArPSBsZXR0ZXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2KV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9jb2xvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBmaXJzdCBuYW1lIGFuZCBsYXN0IG5hbWUgZmlyc3QgbGV0dGVycyBhbmQgY29tYmluZWQgYW5kIGZvcm0gdGhlIGxldHRlciBhdmF0YXJcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7dW5yZXNvbHZlZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGaXJzdEFuZExhc3ROYW1lKGRhdGEpIHtcbiAgICAgICAgdmFyIG5hbWVzID0gZGF0YS5zcGxpdChcIiBcIik7XG4gICAgICAgIGlmIChuYW1lcyAmJiBuYW1lcy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgdmFyIGZpcnN0TmFtZSA9IG5hbWVzWzBdO1xuICAgICAgICAgICAgdmFyIGxhc3ROYW1lID0gbmFtZXNbMV07XG4gICAgICAgICAgICBpZiAoZmlyc3ROYW1lICYmIGxhc3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaXJzdE5hbWUuc3Vic3RyKDAsIDEpICsgbGFzdE5hbWUuc3Vic3RyKDAsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5zdWJzdHIoMCwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb3B1bGF0ZSB0aGUgc3ZnIHRhZyB3aGljaCB3aWxsIHVzZWQgZm9yIHRoZSBhdmF0YXIgZ2VuZXJhdGlvblxuICAgICAqIEBwYXJhbSB7dHlwZX0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7dHlwZX0gY29sb3JcbiAgICAgKiBAcmV0dXJucyB7dW5yZXNvbHZlZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJbWdUYWcod2lkdGgsIGhlaWdodCwgY29sb3IpIHtcblxuICAgICAgICB2YXIgc3ZnVGFnID0gYW5ndWxhci5lbGVtZW50KCc8c3ZnPjwvc3ZnPicpXG4gICAgICAgICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAneG1sbnMnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICAgICAgICAgICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICd3aWR0aCc6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JzogaGVpZ2h0XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogd2lkdGggKyAncHgnLFxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JzogaGVpZ2h0ICsgJ3B4J1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdmdUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEdlbmVyYXRlIHRoZSBMZXR0ZXIgdGFnIGJ5IHVzaW5nIHRoZSBzdmcgdGV4dCBlbGVtZW50XG4gICAgICogQHBhcmFtIHt0eXBlfSBjaGFyYWN0ZXJcbiAgICAgKiBAcGFyYW0ge3R5cGV9IHRleHRDb2xvclxuICAgICAqIEBwYXJhbSB7dHlwZX0gZm9udEZhbWlseVxuICAgICAqIEBwYXJhbSB7dHlwZX0gZm9udFdlaWdodFxuICAgICAqIEBwYXJhbSB7dHlwZX0gZm9udHNpemVcbiAgICAgKiBAcmV0dXJucyB7dW5yZXNvbHZlZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDaGFyYWN0ZXJPYmplY3QoY2hhcmFjdGVyLCB0ZXh0Q29sb3IsIGZvbnRGYW1pbHksIGZvbnRXZWlnaHQsIGZvbnRzaXplKSB7XG4gICAgICAgIHZhciB0ZXh0VGFnID0gYW5ndWxhci5lbGVtZW50KCc8dGV4dCB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPjwvdGV4dD4nKVxuICAgICAgICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgJ3knOiAnNTAlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3gnOiAnNTAlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2R5JzogJzAuMzVlbScsXG4gICAgICAgICAgICAgICAgICAgIC8vJ3N0cm9rZSc6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ2F1dG8nLFxuICAgICAgICAgICAgICAgICAgICAnZmlsbCc6IHRleHRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtZmFtaWx5JzogZm9udEZhbWlseVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmh0bWwoY2hhcmFjdGVyKVxuICAgICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAnZm9udC13ZWlnaHQnOiBmb250V2VpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAnZm9udC1zaXplJzogZm9udHNpemUgKyAncHgnLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0ZXh0VGFnO1xuICAgIH1cblxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL3Bvc3RzL3NlcnZpY2VzLmpzXCIsXCIvcG9zdHNcIikiXX0=
